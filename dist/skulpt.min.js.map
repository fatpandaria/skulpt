{"version":3,"sources":["webpack:/// [synthetic:base] ","webpack:/// [synthetic:es6/util/arrayiterator] ","webpack:/// [synthetic:util/defines] ","webpack:/// [synthetic:util/defineproperty] ","webpack:/// [synthetic:util/global] ","webpack:/// [synthetic:es6/symbol] ","webpack:/// [synthetic:es6/util/iteratorfromarray] ","webpack:/// [synthetic:util/polyfill] ","webpack:/// [synthetic:es6/array/values] ","webpack:///skulpt.min.js","webpack:///webpack/bootstrap","webpack:///(webpack)/buildin/global.js","webpack:///./src/main.js","webpack:///./src/util.js","webpack:///./node_modules/strftime/strftime.js","webpack:///./support/time-helpers/strptime.js","webpack:///./node_modules/setimmediate/setImmediate.js","webpack:///./node_modules/process/browser.js","webpack:///./src/assert-prod.js","webpack:///./src/env.js","webpack:///./src/type.js","webpack:///./src/abstract.js","webpack:///./src/object.js","webpack:///./src/function.js","webpack:///./src/builtin.js","webpack:///./src/fromcodepoint.js","webpack:///./src/errors.js","webpack:///./src/method.js","webpack:///./src/misceval.js","webpack:///./src/seqtype.js","webpack:///./src/list.js","webpack:///./src/str.js","webpack:///./src/formatting.js","webpack:///./src/tuple.js","webpack:///./src/dict.js","webpack:///./src/numtype.js","webpack:///./src/biginteger.js","webpack:///./src/int.js","webpack:///./src/bool.js","webpack:///./src/float.js","webpack:///./src/number.js","webpack:///./src/long.js","webpack:///./src/complex.js","webpack:///./src/slice.js","webpack:///./src/set.js","webpack:///./src/print.js","webpack:///./src/module.js","webpack:///./src/structseq.js","webpack:///./src/generator.js","webpack:///./src/file.js","webpack:///./src/ffi.js","webpack:///./src/iterator.js","webpack:///./src/enumerate.js","webpack:///./src/token.js","webpack:///./src/tokenize.js","webpack:///./gen/parse_tables.js","webpack:///./src/parser.js","webpack:///./gen/astnodes.js","webpack:///./src/ast.js","webpack:///./src/symtable.js","webpack:///./src/compile.js","webpack:///./src/import.js","webpack:///./src/timsort.js","webpack:///./src/sorted.js","webpack:///./src/typeobject.js","webpack:///./src/builtindict.js","webpack:///./src/constants.js","webpack:///./src/internalpython.js"],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","i","l","call","m","c","d","__webpack_require__.d","name","getter","o","Object","defineProperty","enumerable","get","r","__webpack_require__.r","Symbol","toStringTag","value","t","__webpack_require__.t","mode","__esModule","ns","create","key","bind","n","__webpack_require__.n","getDefault","getModuleExports","__webpack_require__.o","object","property","prototype","hasOwnProperty","p","s","g","Function","e","window","Sk","global","githash","date","self","exportSymbol","Sk.exportSymbol","parts","split","curobj","idx","length","part","isArrayLike","Sk.isArrayLike","Array","js_beautify","Sk.js_beautify","x","build","Strftime","locale","customTimezoneOffset","useUtcTimezone","_processFormat","format","timestamp","resultString","padding","isInScope","extendedTZ","currentCharCode","charCodeAt","warn","days","getDay","months","getMonth","padTill2","Math","floor","getFullYear","formats","D","F","getHours","hours12","padTill3","getMinutes","am","pm","R","getSeconds","T","weekNumber","X","_useUtcBasedDate","_customTimezoneOffset","tzString","toString","match","shortDays","shortMonths","getDate","y","Date","day","ceil","getTime","ordinalSuffixes","String","ordinal","AM","PM","v","slice","off","getTimezoneOffset","sep","mins","abs","sign","hours","_locale","DefaultLocale","_cachedDateTimestamp","_cachedDate","strftime","_strftime","utcOffset","newUTCOffset","currentTimestamp","now","localize","strftime.localize","localizeByIdentifier","strftime.localizeByIdentifier","localeIdentifier","Locales","timezone","strftime.timezone","useUtcBasedDate","timezoneType","parseInt","minutes","utc","strftime.utc","numberToPad","paddingChar","hour","firstWeekday","weekday","firstDayOfYearUtc","UTC","dateUtc","yday","number","ii","message","console","de_DE","en_CA","en_US","es_MX","fr_FR","it_IT","nl_NL","pt_BR","ru_RU","tr_TR","zh_CN","defaultStrftime","namespace","eval","Date.now","strptime","str","local","parse","version","formatTransform","_","spec","mod","numPad","pos","replace","specifiers","genitive","indexOf","test","substr","Error","make","push","reg","toLetterCaseReverse","toUpperCase","toLowerCase","inArray","el","strRegStr","data","gen","bg","b","setUTCMonth","Bg","B","fg","f","strRegNum2","getUTCFullYear","setUTCFullYear","setUTCDate","setUTCHours","getUTCHours","setUTCMinutes","P","setUTCSeconds","offset","setTime","Date_dBY_year_in_HM","Date_dBY_year","Date_dBY","Date_dBA","Date_AdBY","Date_df_in_HM","Date_dfY","Date_dB_in_HM","Date_df","strptime.parse","loop","RegExp","process","undefined","clearImmediate","handle","tasksByHandle","runIfPresent","currentlyRunningATask","setTimeout","task","callback","args","apply","installNextTickImplementation","registerImmediate","nextTick","canUsePostMessage","postMessage","importScripts","postMessageIsAsynchronous","oldOnMessage","onmessage","global.onmessage","installPostMessageImplementation","messagePrefix","random","onGlobalMessage","event","source","addEventListener","attachEvent","installMessageChannelImplementation","channel","MessageChannel","port1","channel.port1.onmessage","port2","installReadyStateChangeImplementation","html","doc","documentElement","script","createElement","onreadystatechange","script.onreadystatechange","removeChild","appendChild","installSetTimeoutImplementation","setImmediate","nextHandle","document","attachTo","getPrototypeOf","arguments","defaultSetTimout","defaultClearTimeout","runTimeout","fun","cachedSetTimeout","runClearTimeout","marker","cachedClearTimeout","clearTimeout","cleanUpNextTick","draining","currentQueue","queue","concat","queueIndex","drainQueue","timeout","len","run","Item","array","noop","process.nextTick","Item.prototype.run","title","browser","env","argv","versions","on","addListener","once","removeListener","removeAllListeners","emit","prependListener","prependOnceListener","listeners","process.listeners","binding","process.binding","cwd","process.cwd","chdir","process.chdir","dir","umask","process.umask","asserts","assert","Sk.asserts.assert","condition","fail","Sk.asserts.fail","bool_check","Sk.bool_check","variable","python2","print_function","division","absolute_import","unicode_literals","python3","set_repr","class_repr","inherit_from_object","super_args","octal_number_literal","bankers_rounding","python_version","dunder_next","dunder_round","list_clear","exceptions","no_long_type","ceil_floor_int","l_suffix","silent_octal_literal","configure","Sk.configure","options","output","debugout","uncaughtException","read","nonreadopen","fileopen","filewrite","timeoutMsg","sysargv","__future__","imageProxy","inputfun","inputfunTakesPrompt","turtle_textinput","retainGlobals","debugging","killableWhile","killableFor","signals","handler","removeEventListener","index","splice","signal","breakpoints","Sk.setTimeout","func","delay","execLimit","yieldLimit","syspath","realsyspath","sysmodules","builtin","dict","misceval","softspace_","switch_version","lng","tp$name","Sk.uncaughtException","err","Sk.timeoutMsg","Number","POSITIVE_INFINITY","Sk.output","Sk.read","getSysArgv","Sk.getSysArgv","inBrowser","Sk.debugout","Sk.inputfun","prompt","Sk.turtle_textinput","Promise","resolve","cover","id","style","position","width","height","top","left","background","display","alignItems","justifyContent","zIndex","body","inputModal","border","modal_header","titleDom","innerHTML","closeBtn","paddingLeft","paddingRight","lineHeight","modal_body","textAlign","marginBottom","content","marginTop","input","type","modal_footer","cancelBtn","fontWeight","primaryBtn","marginLeft","text_input","onclick","cancelBtn.onclick","closeBtn.onclick","primaryBtn.onclick","turtle_numinput","Sk.turtle_numinput","defaultVal","minval","maxval","errorDom","getElementById","errorText","fontSize","color","setup_method_mappings","Sk.setup_method_mappings","float_","int_","nmber","list","dict_iter_","list_iter_","set_iter_","str_iter_","tuple_iter_","generator","enumerate","iterator","Sk.switch_version","method_to_map","mapping","mappings","newmeth","oldmeth","classes","klass","dunderToSkulpt","Sk.builtin.type","bases","ob$type","TypeError","abstr","typeName","checkString","kws","tp$base","sk$klass","args_copy","unshift","superConstructor","mp$ass_subscript","_name","ffi","remapToJs","inheritsBuiltin","tp$call","klass.tp$call","newf","typeLookup","$new","newargs","applyOrSuspend","chain","init","$init","none","none$","setUpInheritance","firstAncestor","builtin_bases","it","tp$iter","parent","tp$iternext","inherits","makeIntoTypeObj","module_lk","mp$lookup","globals","k","mp$subscript","reprf","tp$getattr","$repr","im_func","cname","tp$setattr","klass.prototype.tp$setattr","pyName","canSuspend","setf","GenericGetAttr","$setattr","callsimOrSuspendArray","retryOptionalSuspensionOrThrow","GenericSetAttr","klass.prototype.tp$getattr","getf","descr","$getattribute","tp$descr_get","GenericPythonGetAttr","tryCatch","AttributeError","tp$str","klass.prototype.tp$str","strf","$str","tp$length","klass.prototype.tp$length","gattr","$len","lenf","klass.prototype.tp$call","kw","$call","callf","klass.prototype.tp$iter","iterf","$iter","callsimArray","klass.prototype.tp$iternext","next","$next3","$next2","iternextf","StopIteration","tp$getitem","klass.prototype.tp$getitem","$getitem","tp$setitem","klass.prototype.tp$setitem","$setitem","basesStr_","mro","buildMRO","mroStr_","tp$mro","shortcutDunder","skulpt_name","magic_name","magic_func","canSuspendIdx","j","dunder","makeTypeObj","Sk.builtin.type.makeTypeObj","newedInstanceOfType","Sk.builtin.type.makeIntoTypeObj","__module__","ctype","tp$richcompare","sk$type","Sk.builtin.type.prototype.tp$getattr","res","tp","Sk.builtin.type.prototype.tp$setattr","$jsstr","jsName","Sk.builtin.type.typeLookup","base","mroMerge_","Sk.builtin.type.mroMerge_","seqs","seq","sseq","cand","cands","buildMRO_","Sk.builtin.type.buildMRO_","all","kbases","Sk.builtin.type.buildMRO","tuple","Sk.builtin.type.prototype.tp$richcompare","other","op","r1","r2","format_spec","pyCheckArgsLen","pythonFunctions","Sk.abstr.typeName","vtypename","binop_type_error","Sk.abstr.binop_type_error","w","wtypename","unop_type_error","Sk.abstr.unop_type_error","uop","boNameToSlotFuncLhs_","Sk.abstr.boNameToSlotFuncLhs_","obj","nb$add","nb$subtract","nb$multiply","nb$divide","nb$floor_divide","nb$remainder","nb$divmod","nb$power","nb$lshift","nb$rshift","nb$and","nb$xor","nb$or","boNameToSlotFuncRhs_","Sk.abstr.boNameToSlotFuncRhs_","nb$reflected_add","nb$reflected_subtract","nb$reflected_multiply","nb$reflected_divide","nb$reflected_floor_divide","nb$reflected_remainder","nb$reflected_divmod","nb$reflected_power","nb$reflected_lshift","nb$reflected_rshift","nb$reflected_and","nb$reflected_xor","nb$reflected_or","iboNameToSlotFunc_","Sk.abstr.iboNameToSlotFunc_","nb$inplace_add","nb$inplace_subtract","nb$inplace_multiply","nb$inplace_divide","nb$inplace_floor_divide","nb$inplace_remainder","nb$inplace_power","nb$inplace_lshift","nb$inplace_rshift","nb$inplace_and","nb$inplace_or","nb$inplace_xor","uoNameToSlotFunc_","Sk.abstr.uoNameToSlotFunc_","nb$negative","nb$positive","nb$invert","binary_op_","Sk.abstr.binary_op_","opname","w_is_subclass","constructor","wop","ret","NotImplemented","NotImplemented$","vop","binary_iop_","Sk.abstr.binary_iop_","unary_op_","Sk.abstr.unary_op_","numOpAndPromote","Sk.abstr.numOpAndPromote","a","opfn","ans","threshold$","fromInt$","NameError","complex","tmp","assk$","boNumPromote_","Add","Sub","Mult","Mod","ZeroDivisionError","Div","FloorDiv","pow","BitAnd","BitOr","BitXor","LShift","ValueError","RShift","numberBinOp","Sk.abstr.numberBinOp","numPromoteFunc","numberInplaceBinOp","Sk.abstr.numberInplaceBinOp","numberUnaryOp","Sk.abstr.numberUnaryOp","isTrue","bool","false$","true$","asnum$","fixSeqIndex_","Sk.abstr.fixSeqIndex_","sq$length","sequenceContains","Sk.abstr.sequenceContains","ob","sq$contains","special","lookupSpecial","$contains","checkIterable","seqtypename","iterFor","iter","richCompareBool","Break","sequenceConcat","Sk.abstr.sequenceConcat","seq1","seq2","sq$concat","seq1typename","sequenceGetIndexOf","Sk.abstr.sequenceGetIndexOf","sequenceGetCountOf","Sk.abstr.sequenceGetCountOf","count","sequenceGetItem","Sk.abstr.sequenceGetItem","sequenceSetItem","Sk.abstr.sequenceSetItem","sequenceDelItem","Sk.abstr.sequenceDelItem","sq$del_item","sequenceRepeat","Sk.abstr.sequenceRepeat","asIndex","ntypename","sequenceGetSlice","Sk.abstr.sequenceGetSlice","i1","i2","sq$slice","sequenceDelSlice","Sk.abstr.sequenceDelSlice","sq$del_slice","sequenceSetSlice","Sk.abstr.sequenceSetSlice","sq$ass_slice","sequenceUnpack","Sk.abstr.sequenceUnpack","mappingUnpackIntoKeywordArray","Sk.abstr.mappingUnpackIntoKeywordArray","jsArray","pyMapping","pyCodeObject","itemfn","callsimOrSuspend","items","item","objectFormat","Sk.abstr.objectFormat","meth","$format","result","objectAdd","Sk.abstr.objectAdd","atypename","btypename","objectNegative","Sk.abstr.objectNegative","obj_asnum","objtypename","objectPositive","Sk.abstr.objectPositive","objectDelItem","Sk.abstr.objectDelItem","mp$del_subscript","sq$ass_item","keyValue","keytypename","otypename","objectGetItem","Sk.abstr.objectGetItem","isIndex","sq$item","objectSetItem","Sk.abstr.objectSetItem","Sk.abstr.gattr","objname","sattr","Sk.abstr.sattr","iternext","Sk.abstr.iternext","Sk.abstr.iter","seqIter","myobj","getitem","this.tp$iternext","remapToPy","IndexError","getit","Sk.abstr.lookupSpecial","obtp","markUnhashable","Sk.abstr.markUnhashable","thisClass","proto","__hash__","tp$hash","Sk.abstr.inherits","childCtor","parentCtor","tempCtor","superClass_","Sk.abstr.setUpInheritance","childName","child","Sk.abstr.superConstructor","argumentsForConstructor","Sk.builtin.object","__init__","Sk.builtin.object.prototype.__init__","co_kwargs","_tryGetSubscript","Sk.builtin._tryGetSubscript","Sk.builtin.object.prototype.GenericGetAttr","$getattr","Sk.builtin.object.prototype.GenericPythonGetAttr","Sk.builtin.object.prototype.GenericSetAttr","tp$descr_set","unfixReserved","GenericPythonSetAttr","Sk.builtin.object.prototype.GenericPythonSetAttr","HashNotImplemented","Sk.builtin.object.prototype.HashNotImplemented","cls","formatstr","NotImplementedError","ob$eq","ob$ne","ob$lt","ob$le","ob$gt","ob$ge","hashCount","idCount","Sk.builtin.object.prototype.tp$hash","$savedHash_","Sk.builtin.object.prototype.ob$eq","Sk.builtin.object.prototype.ob$ne","Sk.builtin.object.prototype.ob$lt","Sk.builtin.object.prototype.ob$le","Sk.builtin.object.prototype.ob$gt","Sk.builtin.object.prototype.ob$ge","Sk.builtin.none","Sk.builtin.none.prototype.tp$hash","Sk.builtin.NotImplemented","pyCheckArgs","Sk.builtin.pyCheckArgs","minargs","maxargs","kwargs","free","nargs","Infinity","msg","Sk.builtin.pyCheckArgsLen","pyCheckType","Sk.builtin.pyCheckType","exptype","check","checkSequence","Sk.builtin.checkSequence","arg","Sk.builtin.checkIterable","checkCallable","Sk.builtin.checkCallable","method","checkNumber","Sk.builtin.checkNumber","checkComplex","Sk.builtin.checkComplex","_complex_check","checkInt","Sk.builtin.checkInt","checkFloat","Sk.builtin.checkFloat","Sk.builtin.checkString","__class__","checkClass","Sk.builtin.checkClass","checkBool","Sk.builtin.checkBool","checkNone","Sk.builtin.checkNone","checkFunction","Sk.builtin.checkFunction","Sk.builtin.func","code","closure","closure2","func_code","func_globals","func_closure","Sk.builtin.func.prototype.tp$descr_get","objtype","__get__","Sk.builtin.func.prototype.__get__","instance","owner","tp$getname","Sk.builtin.func.prototype.tp$getname","Sk.builtin.func.prototype.tp$call","posargs","co_argcount","co_varnames","varnames","co_kwonlyargcount","totalArgs","nposargs","co_varargs","vararg","defaults","$defaults","missing","missingUnnamed","defaultStart","join","kwdefs","$kwdefs","builtins","range","Sk.builtin.range","start","stop","step","Sk.builtin.asnum$","cantBeInt","str$","toInt$","biginteger","trueCompare","intValue","Sk.builtin.assk$","asnum$nofloat","Sk.builtin.asnum$nofloat","expon","mantissa","decimal","round","Sk.builtin.round","ndigits","round$","$round","Sk.builtin.len","intcheck","mp$length","min","Sk.builtin.min","arrayFromArguments","lowest","max","Sk.builtin.max","highest","any","Sk.builtin.any","Sk.builtin.all","sum","Sk.builtin.sum","tot","has_float","intermed","zip","Sk.builtin.zip","done","iters","tup","Sk.builtin.abs","__abs__","$abs","fabs","Sk.builtin.fabs","ord","Sk.builtin.ord","chr","Sk.builtin.chr","fromCharCode","unichr","Sk.builtin.unichr","fromCodePoint","RangeError","int2str_","Sk.builtin.int2str_","radix","prefix","suffix","nb$isnegative","hex","Sk.builtin.hex","oct","Sk.builtin.oct","bin","Sk.builtin.bin","Sk.builtin.dir","getName","internal","slotNameToRichName","charAt","names","$dir","_seq","prop","sort","filter","last","Sk.builtin.dir.slotNameToRichName","repr","Sk.builtin.repr","objectRepr","open","Sk.builtin.open","filename","bufsize","file","isinstance","Sk.builtin.isinstance","issubclass","hash","Sk.builtin.hash","__hash","getattr","Sk.builtin.getattr","default_","mangledName","fixReservedWords","setattr","Sk.builtin.setattr","raw_input","Sk.builtin.raw_input","lprompt","importModule","sys","$readline","jseval","Sk.builtin.jseval","evalcode","AssertionError","jsmillis","Sk.builtin.jsmillis","valueOf","eval_","Sk.builtin.eval_","map","Sk.builtin.map","retval","nones","combined","iterables","argnum","reduce","Sk.builtin.reduce","initializer","accum_value","Sk.builtin.filter","iterable","ctor","add","hasattr","Sk.builtin.hasattr","attr","Sk.builtin.pow","a_num","b_num","c_num","right","quit","Sk.builtin.quit","SystemExit","Sk.builtin.issubclass","c1","c2","issubclass_internal","Sk.builtin.globals","divmod","Sk.builtin.divmod","Sk.builtin.format","$emptystr","reversed","Sk.builtin.reversed","$reversed","reverseIter","this.tp$iter","Sk.builtin.id","__id","bytearray","Sk.builtin.bytearray","callable","Sk.builtin.callable","delattr","Sk.builtin.delattr","try1","try2","execfile","Sk.builtin.execfile","frozenset","Sk.builtin.frozenset","help","Sk.builtin.help","Sk.builtin.iter","sentinel","locals","Sk.builtin.locals","memoryview","Sk.builtin.memoryview","next_","Sk.builtin.next_","nxt","reload","Sk.builtin.reload","vars","Sk.builtin.vars","xrange","apply_","Sk.builtin.apply_","buffer","Sk.builtin.buffer","coerce","Sk.builtin.coerce","intern","Sk.builtin.intern","$defineProperty","error","stringFromCharCode","codeUnits","codePoint","isFinite","highSurrogate","lowSurrogate","MAX_SIZE","BaseException","Sk.builtin.BaseException","traceback","lineno","Sk.builtin.BaseException.prototype.tp$str","Sk.builtin.BaseException.prototype.toString","clstype","Exception","Sk.builtin.Exception","StandardError","Sk.builtin.StandardError","Sk.builtin.AssertionError","Sk.builtin.AttributeError","ImportError","Sk.builtin.ImportError","IndentationError","Sk.builtin.IndentationError","Sk.builtin.IndexError","KeyError","Sk.builtin.KeyError","Sk.builtin.NameError","UnboundLocalError","Sk.builtin.UnboundLocalError","OverflowError","Sk.builtin.OverflowError","SyntaxError","Sk.builtin.SyntaxError","RuntimeError","Sk.builtin.RuntimeError","SuspensionError","Sk.builtin.SuspensionError","Sk.builtin.SystemExit","Sk.builtin.TypeError","Sk.builtin.ValueError","Sk.builtin.ZeroDivisionError","TimeLimitError","Sk.builtin.TimeLimitError","IOError","Sk.builtin.IOError","Sk.builtin.NotImplementedError","NegativePowerError","Sk.builtin.NegativePowerError","ExternalError","Sk.builtin.ExternalError","nativeError","OperationError","Sk.builtin.OperationError","SystemError","Sk.builtin.SystemError","Sk.builtin.StopIteration","getExcInfo","Sk.builtin.getExcInfo","Sk.builtin.method","im_self","im_class","im_builtin","Sk.builtin.method.prototype.ob$eq","Sk.builtin.method.prototype.ob$ne","Sk.builtin.method.prototype.tp$hash","selfhash","funchash","Sk.builtin.method.prototype.tp$call","getMessage","reason","Sk.builtin.method.prototype.tp$descr_get","Sk.builtin.method.prototype.__get__","Suspension","Sk.misceval.Suspension","resume","$isSuspension","this.resume","optional","Sk.misceval.retryOptionalSuspensionOrThrow","susp","Sk.misceval.isIndex","$index","Sk.misceval.asIndex","idxfn","tp$index","applySlice","Sk.misceval.applySlice","u","ilow","ihigh","assignSlice","Sk.misceval.assignSlice","Sk.misceval.arrayFromArguments","set","$obj","swappedOp_","Sk.misceval.richCompareBool","v_type","w_type","numeric_types","sequence_types","v_num_type","v_seq_type","w_num_type","w_seq_type","numberCompare","longCompare","op2shortcut","shortcut","v_has_shortcut","swapped_shortcut","w_has_shortcut","op2method_","swapped_method","vcmp","$cmp","wcmp","vname","wname","Sk.misceval.objectRepr","opAllowsEquality","Sk.misceval.opAllowsEquality","Sk.misceval.isTrue","nb$nonzero","print_","Sk.misceval.print_","loadname","Sk.misceval.loadname","bi","Sk.misceval.call","kwdict","varargseq","callAsync","Sk.misceval.callAsync","suspensionHandlers","applyAsync","callOrSuspend","Sk.misceval.callOrSuspend","callsim","Sk.misceval.callsim","Sk.misceval.callsimArray","argarray","callsimAsync","Sk.misceval.callsimAsync","Sk.misceval.callsimOrSuspend","Sk.misceval.callsimOrSuspendArray","Sk.misceval.apply","asyncToPromise","Sk.misceval.asyncToPromise","suspendablefn","suspHandlers","reject","handleResponse","resumeWithData","resumeWithError","ex","handlerPromise","then","Sk.misceval.applyAsync","Sk.misceval.chain","initialValue","chainedFns","fs","nextStep","Sk.misceval.tryCatch","tryFn","catchFn","susp.resume","Sk.misceval.iterFor","forFn","prevValue","breakOrIterNext","brValue","Sk.misceval.Break","Sk.misceval.applyOrSuspend","fcall","__call__","promiseToSuspension","Sk.misceval.promiseToSuspension","promise","suspension","suspension.resume","buildClass","Sk.misceval.buildClass","cell","meta","l_cell","_bases","_locals","seqtype","Sk.builtin.seqtype","sk$abstract","sq$repeat","Sk.builtin.list","L","thisList","list_concat_","Sk.builtin.list.prototype.list_concat_","list_extend_","Sk.builtin.list.prototype.list_extend_","newb","list_del_item_","Sk.builtin.list.prototype.list_del_item_","list_del_slice_","Sk.builtin.list.prototype.list_del_slice_","list_ass_item_","Sk.builtin.list.prototype.list_ass_item_","list_ass_slice_","Sk.builtin.list.prototype.list_ass_slice_","Sk.builtin.list.prototype.tp$richcompare","vl","wl","__iter__","Sk.builtin.list.prototype.tp$iter","Sk.builtin.list.prototype.sq$length","Sk.builtin.list.prototype.sq$repeat","Sk.builtin.list.prototype.nb$inplace_multiply","Sk.builtin.list.prototype.sq$contains","__contains__","list_subscript_","Sk.builtin.list.prototype.list_subscript_","sssiter$","wrt","list_ass_subscript_","Sk.builtin.list.prototype.list_ass_subscript_","indices","slice_indices_","tosub","list_del_subscript_","Sk.builtin.list.prototype.list_del_subscript_","dec","offdir","__getitem__","__setitem__","val","__delitem__","list_sort_","Sk.builtin.list.prototype.list_sort_","cmp","reverse","has_key","has_cmp","rev","timsort","timSort","zero","lt","timsort.lt","listlength","keyvalue","list_reverse_","mucked","Sk.builtin.list.prototype.list_reverse_","old","newarr","clear$","Sk.builtin.list.prototype.clear$","Sk.builtin.list_iter_","lst","$r","this.$r","next$","Sk.builtin.list_iter_.prototype.next$","interned","Sk.builtin.str","Sk.builtin.str.prototype.$jsstr","Sk.builtin.str.prototype.mp$subscript","Sk.builtin.str.prototype.sq$length","Sk.builtin.str.prototype.sq$concat","Sk.builtin.str.prototype.sq$repeat","Sk.builtin.str.prototype.sq$item","Sk.builtin.str.prototype.sq$slice","Sk.builtin.str.prototype.sq$contains","Sk.builtin.str.prototype.tp$iter","Sk.builtin.str.prototype.tp$richcompare","quote","ashex","re_escape_","Sk.builtin.str.re_escape_","re","orig","cap","arrOfStrs","howmany","regex","splits","exec","lastIndex","substring","chars","pattern","sepStr","lastIndexOf","pat","end","normaltext","ctl","fillchar","newstr","newstr1","tgt","oldS","newS","patt","replacer","pad","zeroes","tabsize","spaces","expanded","lc","keepends","selflen","strs_w","sol","ch","eol","cased","previous_is_cased","Sk.builtin.str.prototype.nb$remainder","rhs","replFunc","mappingKey","conversionFlags","fieldWidth","precision","precbody","conversionType","precedeWithSign","blankBeforePositive","leftAdjust","zeroPad","alternateForm","formatNumber","neg","precZeroPadded","handleWidth","totLen","mk","convValue","isNaN","convName","Sk.builtin.str_iter_","Sk.builtin.str_iter_.prototype.next$","kwa","arg_dict","size","kwItems","field_name","arg_name","attr_name","attribute_name","element_index","conversion","fill_char","fill_align","zero_pad","sign_aware","comma","str_whole","percent","container","return_str","formatFormat","toFixed","toLocaleString","Sk.builtin.tuple","bits","Sk.builtin.tuple.prototype.mp$subscript","Sk.builtin.tuple.prototype.tp$hash","mult","Sk.builtin.tuple.prototype.sq$repeat","Sk.builtin.tuple.prototype.tp$iter","Sk.builtin.tuple.prototype.tp$richcompare","Sk.builtin.tuple.prototype.sq$concat","Sk.builtin.tuple.prototype.sq$contains","Sk.builtin.tuple.prototype.sq$length","Sk.builtin.tuple_iter_","Sk.builtin.tuple_iter_.prototype.next$","Sk.builtin.dict","buckets","Sk.builtin.dict.tp$call","kf","key$lookup","Sk.builtin.dict.prototype.key$lookup","bucket","eq","lhs","key$pop","Sk.builtin.dict.prototype.key$pop","Sk.builtin.dict.prototype.mp$lookup","Sk.builtin.dict.prototype.mp$subscript","Sk.builtin.dict.prototype.sq$contains","Sk.builtin.dict.prototype.mp$ass_subscript","$hash","Sk.builtin.dict.prototype.mp$del_subscript","Sk.builtin.dict.prototype.mp$length","dict_merge","Sk.builtin.dict.prototype.dict_merge","keys","update_f","seq_i","k_iter","k_key","k_value","kwargs_dict","update","__cmp__","__len__","__getattribute__","Sk.builtin.dict.prototype.tp$iter","__repr__","Sk.builtin.dict.prototype.ob$eq","otherv","Sk.builtin.dict.prototype.ob$ne","isEqual","newCopy","$fromkeys","Sk.builtin.dict.$fromkeys","Sk.builtin.dict_iter_","allkeys","$keys","Sk.builtin.dict_iter_.prototype.next$","numtype","Sk.builtin.numtype","nb$abs","nb$int_","nb$lng","nb$float_","Sk.builtin.numtype.prototype.nb$add","Sk.builtin.numtype.prototype.nb$reflected_add","Sk.builtin.numtype.prototype.nb$inplace_add","Sk.builtin.numtype.prototype.nb$subtract","Sk.builtin.numtype.prototype.nb$reflected_subtract","Sk.builtin.numtype.prototype.nb$inplace_subtract","Sk.builtin.numtype.prototype.nb$multiply","Sk.builtin.numtype.prototype.nb$reflected_multiply","Sk.builtin.numtype.prototype.nb$inplace_multiply","Sk.builtin.numtype.prototype.nb$divide","Sk.builtin.numtype.prototype.nb$reflected_divide","Sk.builtin.numtype.prototype.nb$inplace_divide","Sk.builtin.numtype.prototype.nb$floor_divide","Sk.builtin.numtype.prototype.nb$reflected_floor_divide","Sk.builtin.numtype.prototype.nb$inplace_floor_divide","Sk.builtin.numtype.prototype.nb$remainder","Sk.builtin.numtype.prototype.nb$reflected_remainder","Sk.builtin.numtype.prototype.nb$inplace_remainder","Sk.builtin.numtype.prototype.nb$divmod","Sk.builtin.numtype.prototype.nb$reflected_divmod","Sk.builtin.numtype.prototype.nb$power","Sk.builtin.numtype.prototype.nb$reflected_power","Sk.builtin.numtype.prototype.nb$inplace_power","Sk.builtin.numtype.prototype.nb$abs","Sk.builtin.numtype.prototype.nb$negative","Sk.builtin.numtype.prototype.nb$positive","Sk.builtin.numtype.prototype.nb$nonzero","Sk.builtin.numtype.prototype.nb$isnegative","nb$ispositive","Sk.builtin.numtype.prototype.nb$ispositive","Sk.builtin.biginteger","fromNumber","fromString","canary","j_lm","nbi","Sk.builtin.biginteger.nbi","am1","Sk.builtin.biginteger.prototype.am1","am2","Sk.builtin.biginteger.prototype.am2","h","xl","xh","am3","Sk.builtin.biginteger.prototype.am3","dbits","DB","DM","DV","BI_FP","FV","F1","F2","BI_RM","BI_RC","rr","vv","int2char","Sk.builtin.biginteger.int2char","intAt","Sk.builtin.biginteger.intAt","bnpCopyTo","Sk.builtin.biginteger.prototype.bnpCopyTo","bnpFromInt","Sk.builtin.biginteger.prototype.bnpFromInt","nbv","Sk.builtin.biginteger.nbv","bnpFromString","Sk.builtin.biginteger.prototype.bnpFromString","sh","fromRadix","mi","clamp","ZERO","subTo","bnpClamp","Sk.builtin.biginteger.prototype.bnpClamp","bnToString","Sk.builtin.biginteger.prototype.bnToString","negate","toRadix","km","bnNegate","Sk.builtin.biginteger.prototype.bnNegate","bnAbs","Sk.builtin.biginteger.prototype.bnAbs","bnCompareTo","Sk.builtin.biginteger.prototype.bnCompareTo","nbits","Sk.builtin.biginteger.nbits","bnBitLength","Sk.builtin.biginteger.prototype.bnBitLength","bnpDLShiftTo","Sk.builtin.biginteger.prototype.bnpDLShiftTo","bnpDRShiftTo","Sk.builtin.biginteger.prototype.bnpDRShiftTo","bnpLShiftTo","Sk.builtin.biginteger.prototype.bnpLShiftTo","bs","cbs","bm","ds","bnpRShiftTo","Sk.builtin.biginteger.prototype.bnpRShiftTo","bnpSubTo","Sk.builtin.biginteger.prototype.bnpSubTo","bnpMultiplyTo","Sk.builtin.biginteger.prototype.bnpMultiplyTo","bnpSquareTo","Sk.builtin.biginteger.prototype.bnpSquareTo","bnpDivRemTo","Sk.builtin.biginteger.prototype.bnpDivRemTo","q","pt","fromInt","copyTo","ts","ms","nsh","lShiftTo","ys","y0","yt","d1","d2","dlShiftTo","compareTo","ONE","qd","drShiftTo","rShiftTo","bnMod","Sk.builtin.biginteger.prototype.bnMod","divRemTo","Classic","Sk.builtin.biginteger.Classic","cConvert","Sk.builtin.biginteger.prototype.cConvert","cRevert","Sk.builtin.biginteger.prototype.cRevert","cReduce","Sk.builtin.biginteger.prototype.cReduce","cMulTo","Sk.builtin.biginteger.prototype.cMulTo","multiplyTo","cSqrTo","Sk.builtin.biginteger.prototype.cSqrTo","squareTo","convert","revert","mulTo","sqrTo","bnpInvDigit","Sk.builtin.biginteger.prototype.bnpInvDigit","Montgomery","Sk.builtin.biginteger.Montgomery","mp","invDigit","mpl","mph","um","mt2","montConvert","Sk.builtin.biginteger.prototype.montConvert","montRevert","Sk.builtin.biginteger.prototype.montRevert","montReduce","Sk.builtin.biginteger.prototype.montReduce","u0","montSqrTo","Sk.builtin.biginteger.prototype.montSqrTo","montMulTo","Sk.builtin.biginteger.prototype.montMulTo","bnpIsEven","Sk.builtin.biginteger.prototype.bnpIsEven","bnpExp","Sk.builtin.biginteger.prototype.bnpExp","z","bnModPowInt","Sk.builtin.biginteger.prototype.bnModPowInt","isEven","exp","bitLength","modPowInt","bnClone","Sk.builtin.biginteger.prototype.bnClone","bnIntValue","Sk.builtin.biginteger.prototype.bnIntValue","bnByteValue","Sk.builtin.biginteger.prototype.bnByteValue","bnShortValue","Sk.builtin.biginteger.prototype.bnShortValue","bnpChunkSize","Sk.builtin.biginteger.prototype.bnpChunkSize","LN2","log","bnSigNum","Sk.builtin.biginteger.prototype.bnSigNum","bnpToRadix","Sk.builtin.biginteger.prototype.bnpToRadix","signum","cs","chunkSize","bnpFromRadix","Sk.builtin.biginteger.prototype.bnpFromRadix","dMultiply","dAddOffset","bnpFromNumber","Sk.builtin.biginteger.prototype.bnpFromNumber","testBit","bitwiseTo","shiftLeft","op_or","isProbablePrime","bnToByteArray","Sk.builtin.biginteger.prototype.bnToByteArray","bnEquals","Sk.builtin.biginteger.prototype.bnEquals","bnMin","Sk.builtin.biginteger.prototype.bnMin","bnMax","Sk.builtin.biginteger.prototype.bnMax","bnpBitwiseTo","Sk.builtin.biginteger.prototype.bnpBitwiseTo","op_and","Sk.builtin.biginteger.op_and","bnAnd","Sk.builtin.biginteger.prototype.bnAnd","Sk.builtin.biginteger.op_or","bnOr","Sk.builtin.biginteger.prototype.bnOr","op_xor","Sk.builtin.biginteger.op_xor","bnXor","Sk.builtin.biginteger.prototype.bnXor","op_andnot","Sk.builtin.biginteger.op_andnot","bnAndNot","Sk.builtin.biginteger.prototype.bnAndNot","bnNot","Sk.builtin.biginteger.prototype.bnNot","bnShiftLeft","Sk.builtin.biginteger.prototype.bnShiftLeft","bnShiftRight","Sk.builtin.biginteger.prototype.bnShiftRight","lbit","Sk.builtin.biginteger.lbit","bnGetLowestSetBit","Sk.builtin.biginteger.prototype.bnGetLowestSetBit","cbit","Sk.builtin.biginteger.cbit","bnBitCount","Sk.builtin.biginteger.prototype.bnBitCount","bnTestBit","Sk.builtin.biginteger.prototype.bnTestBit","bnpChangeBit","Sk.builtin.biginteger.prototype.bnpChangeBit","bnSetBit","Sk.builtin.biginteger.prototype.bnSetBit","changeBit","bnClearBit","Sk.builtin.biginteger.prototype.bnClearBit","bnFlipBit","Sk.builtin.biginteger.prototype.bnFlipBit","bnpAddTo","Sk.builtin.biginteger.prototype.bnpAddTo","bnAdd","Sk.builtin.biginteger.prototype.bnAdd","addTo","bnSubtract","Sk.builtin.biginteger.prototype.bnSubtract","bnMultiply","Sk.builtin.biginteger.prototype.bnMultiply","bnDivide","Sk.builtin.biginteger.prototype.bnDivide","bnRemainder","Sk.builtin.biginteger.prototype.bnRemainder","bnDivideAndRemainder","Sk.builtin.biginteger.prototype.bnDivideAndRemainder","bnpDMultiply","Sk.builtin.biginteger.prototype.bnpDMultiply","bnpDAddOffset","Sk.builtin.biginteger.prototype.bnpDAddOffset","NullExp","Sk.builtin.biginteger.NullExp","nNop","Sk.builtin.biginteger.prototype.nNop","nMulTo","Sk.builtin.biginteger.prototype.nMulTo","nSqrTo","Sk.builtin.biginteger.prototype.nSqrTo","bnPow","Sk.builtin.biginteger.prototype.bnPow","bnpMultiplyLowerTo","Sk.builtin.biginteger.prototype.bnpMultiplyLowerTo","bnpMultiplyUpperTo","Sk.builtin.biginteger.prototype.bnpMultiplyUpperTo","Barrett","Sk.builtin.biginteger.Barrett","q3","mu","divide","barrettConvert","Sk.builtin.biginteger.prototype.barrettConvert","barrettRevert","Sk.builtin.biginteger.prototype.barrettRevert","barrettReduce","Sk.builtin.biginteger.prototype.barrettReduce","multiplyUpperTo","multiplyLowerTo","barrettSqrTo","Sk.builtin.biginteger.prototype.barrettSqrTo","barrettMulTo","Sk.builtin.biginteger.prototype.barrettMulTo","bnModPow","Sk.builtin.biginteger.prototype.bnModPow","k1","g2","is1","bnGCD","Sk.builtin.biginteger.prototype.bnGCD","clone","getLowestSetBit","bnpModInt","Sk.builtin.biginteger.prototype.bnpModInt","bnModInverse","Sk.builtin.biginteger.prototype.bnModInverse","ac","subtract","lowprimes","lplim","bnIsProbablePrime","Sk.builtin.biginteger.prototype.bnIsProbablePrime","modInt","millerRabin","bnpMillerRabin","Sk.builtin.biginteger.prototype.bnpMillerRabin","n1","shiftRight","modPow","isnegative","Sk.builtin.biginteger.prototype.isnegative","ispositive","Sk.builtin.biginteger.prototype.ispositive","Sk.builtin.biginteger.prototype.trueCompare","compare","byteValue","shortValue","toByteArray","equals","and","or","xor","andNot","not","bitCount","setBit","clearBit","flipBit","multiply","remainder","divideAndRemainder","modInverse","gcd","Sk.builtin.int_","__index__","__int__","str2number","$int_","magicName","$trunc","__trunc__","$shiftconsts","Sk.builtin.int_.prototype.nb$int_","Sk.builtin.int_.prototype.nb$float_","Sk.builtin.int_.prototype.nb$lng","__complex__","Sk.builtin.int_.prototype.tp$index","Sk.builtin.int_.prototype.tp$hash","Sk.builtin.int_.prototype.clone","Sk.builtin.int_.prototype.nb$add","thisAsLong","thisAsFloat","Sk.builtin.int_.prototype.nb$reflected_add","Sk.builtin.int_.prototype.nb$subtract","Sk.builtin.int_.prototype.nb$reflected_subtract","negative_this","Sk.builtin.int_.prototype.nb$multiply","product","Sk.builtin.int_.prototype.nb$reflected_multiply","Sk.builtin.int_.prototype.nb$divide","Sk.builtin.int_.prototype.nb$reflected_divide","Sk.builtin.int_.prototype.nb$floor_divide","Sk.builtin.int_.prototype.nb$reflected_floor_divide","Sk.builtin.int_.prototype.nb$remainder","divResult","Sk.builtin.int_.prototype.nb$reflected_remainder","Sk.builtin.int_.prototype.nb$divmod","Sk.builtin.int_.prototype.nb$reflected_divmod","Sk.builtin.int_.prototype.nb$power","power","Sk.builtin.int_.prototype.nb$reflected_power","Sk.builtin.int_.prototype.nb$abs","Sk.builtin.int_.prototype.nb$and","Sk.builtin.int_.prototype.nb$or","Sk.builtin.int_.prototype.nb$xor","Sk.builtin.int_.prototype.nb$lshift","shift","Sk.builtin.int_.prototype.nb$reflected_lshift","Sk.builtin.int_.prototype.nb$rshift","Sk.builtin.int_.prototype.nb$reflected_rshift","Sk.builtin.int_.prototype.nb$invert","Sk.builtin.int_.prototype.nb$negative","Sk.builtin.int_.prototype.nb$positive","Sk.builtin.int_.prototype.nb$nonzero","Sk.builtin.int_.prototype.nb$isnegative","Sk.builtin.int_.prototype.nb$ispositive","Sk.builtin.int_.prototype.numberCompare","Sk.builtin.int_.prototype.ob$eq","Sk.builtin.int_.prototype.ob$ne","Sk.builtin.int_.prototype.ob$lt","Sk.builtin.int_.prototype.ob$le","Sk.builtin.int_.prototype.ob$gt","Sk.builtin.int_.prototype.ob$ge","Sk.builtin.int_.prototype.round$","ndigs","rounded","num10","bankRound","multiplier","__format__","Sk.builtin.int_.prototype.__format__","conjugate","Sk.builtin.int_.prototype.tp$str","Sk.builtin.int_.prototype.str$","work","Sk.str2number","parser","negater","fname","origs","Sk.builtin.bool","Sk.builtin.bool.prototype.tp$hash","__float__","Sk.builtin.float_","_str_to_float","parseFloat","$float_","Sk.builtin._str_to_float","NaN","Sk.builtin.float_.prototype.nb$int_","Sk.builtin.float_.prototype.nb$float_","Sk.builtin.float_.prototype.nb$lng","PyFloat_Check","Sk.builtin.float_.PyFloat_Check","PyFloat_Check_Exact","Sk.builtin.float_.PyFloat_Check_Exact","PyFloat_AsDouble","Sk.builtin.float_.PyFloat_AsDouble","fo","Sk.builtin.float_.prototype.tp$index","Sk.builtin.float_.prototype.tp$hash","Sk.builtin.float_.prototype.clone","Sk.builtin.float_.prototype.toFixed","Sk.builtin.float_.prototype.nb$add","Sk.builtin.float_.prototype.nb$reflected_add","Sk.builtin.float_.prototype.nb$subtract","Sk.builtin.float_.prototype.nb$reflected_subtract","Sk.builtin.float_.prototype.nb$multiply","Sk.builtin.float_.prototype.nb$reflected_multiply","Sk.builtin.float_.prototype.nb$divide","Sk.builtin.float_.prototype.nb$reflected_divide","Sk.builtin.float_.prototype.nb$floor_divide","Sk.builtin.float_.prototype.nb$reflected_floor_divide","Sk.builtin.float_.prototype.nb$remainder","op2","Sk.builtin.float_.prototype.nb$reflected_remainder","Sk.builtin.float_.prototype.nb$divmod","Sk.builtin.float_.prototype.nb$reflected_divmod","Sk.builtin.float_.prototype.nb$power","Sk.builtin.float_.prototype.nb$reflected_power","Sk.builtin.float_.prototype.nb$abs","Sk.builtin.float_.prototype.nb$negative","Sk.builtin.float_.prototype.nb$positive","Sk.builtin.float_.prototype.nb$nonzero","Sk.builtin.float_.prototype.nb$isnegative","Sk.builtin.float_.prototype.nb$ispositive","Sk.builtin.float_.prototype.numberCompare","diff","Sk.builtin.float_.prototype.ob$eq","Sk.builtin.float_.prototype.ob$ne","Sk.builtin.float_.prototype.ob$lt","Sk.builtin.float_.prototype.ob$le","Sk.builtin.float_.prototype.ob$gt","Sk.builtin.float_.prototype.ob$ge","Sk.builtin.float_.prototype.round$","Sk.builtin.float_.prototype.__format__","Sk.builtin.float_.prototype.tp$str","Sk.builtin.float_.prototype.str$","toPrecision","pre","post","toExponential","deprecatedError","Sk.builtin.nmber","skType","Sk.builtin.nmber.prototype.tp$index","Sk.builtin.nmber.prototype.tp$hash","Sk.builtin.nmber.fromInt$","ival","Sk.builtin.nmber.prototype.clone","Sk.builtin.nmber.prototype.toFixed","Sk.builtin.nmber.prototype.nb$add","Sk.builtin.nmber.prototype.nb$subtract","Sk.builtin.nmber.prototype.nb$multiply","Sk.builtin.nmber.prototype.nb$divide","Sk.builtin.nmber.prototype.nb$floor_divide","Sk.builtin.nmber.prototype.nb$remainder","Sk.builtin.nmber.prototype.nb$divmod","Sk.builtin.nmber.prototype.nb$power","Sk.builtin.nmber.prototype.nb$and","Sk.builtin.nmber.prototype.nb$or","Sk.builtin.nmber.prototype.nb$xor","Sk.builtin.nmber.prototype.nb$lshift","Sk.builtin.nmber.prototype.nb$rshift","Sk.builtin.nmber.prototype.nb$negative","Sk.builtin.nmber.prototype.nb$positive","Sk.builtin.nmber.prototype.nb$nonzero","Sk.builtin.nmber.prototype.nb$isnegative","Sk.builtin.nmber.prototype.nb$ispositive","Sk.builtin.nmber.prototype.numberCompare","__eq__","Sk.builtin.nmber.prototype.__eq__","me","__ne__","Sk.builtin.nmber.prototype.__ne__","__lt__","Sk.builtin.nmber.prototype.__lt__","__le__","Sk.builtin.nmber.prototype.__le__","__gt__","Sk.builtin.nmber.prototype.__gt__","__ge__","Sk.builtin.nmber.prototype.__ge__","Sk.builtin.nmber.prototype.round$","Sk.builtin.nmber.prototype.tp$str","Sk.builtin.nmber.prototype.str$","Sk.builtin.lng","longFromStr","Sk.builtin.lng.prototype.tp$index","Sk.builtin.lng.prototype.tp$hash","Sk.builtin.lng.prototype.nb$int_","Sk.builtin.lng.prototype.__format__","Sk.builtin.lng.prototype.round$","nb$lng_","Sk.builtin.lng.prototype.nb$lng_","Sk.builtin.lng.prototype.nb$float_","MAX_INT$","MIN_INT$","Sk.builtin.lng.prototype.cantBeInt","Sk.builtin.lng.fromInt$","Sk.longFromStr","Sk.builtin.lng.prototype.toInt$","Sk.builtin.lng.prototype.clone","Sk.builtin.lng.prototype.nb$add","Sk.builtin.lng.prototype.nb$reflected_add","Sk.builtin.lng.prototype.nb$subtract","Sk.builtin.lng.prototype.nb$reflected_subtract","Sk.builtin.lng.prototype.nb$multiply","Sk.builtin.lng.prototype.nb$reflected_multiply","Sk.builtin.lng.prototype.nb$divide","thisneg","otherneg","Sk.builtin.lng.prototype.nb$reflected_divide","Sk.builtin.lng.prototype.nb$floor_divide","Sk.builtin.lng.prototype.nb$divmod","Sk.builtin.lng.prototype.nb$reflected_divmod","Sk.builtin.lng.prototype.nb$remainder","Sk.builtin.lng.prototype.nb$reflected_remainder","Sk.builtin.lng.prototype.nb$power","Sk.builtin.lng.prototype.nb$reflected_power","Sk.builtin.lng.prototype.nb$abs","Sk.builtin.lng.prototype.nb$lshift","Sk.builtin.lng.prototype.nb$reflected_lshift","Sk.builtin.lng.prototype.nb$rshift","Sk.builtin.lng.prototype.nb$reflected_rshift","Sk.builtin.lng.prototype.nb$and","Sk.builtin.lng.prototype.nb$or","Sk.builtin.lng.prototype.nb$xor","Sk.builtin.lng.prototype.nb$negative","Sk.builtin.lng.prototype.nb$invert","Sk.builtin.lng.prototype.nb$positive","Sk.builtin.lng.prototype.nb$nonzero","Sk.builtin.lng.prototype.nb$isnegative","Sk.builtin.lng.prototype.nb$ispositive","Sk.builtin.lng.prototype.longCompare","otherAsLong","Sk.builtin.lng.prototype.ob$eq","Sk.builtin.lng.prototype.ob$ne","Sk.builtin.lng.prototype.ob$lt","Sk.builtin.lng.prototype.ob$le","Sk.builtin.lng.prototype.ob$gt","Sk.builtin.lng.prototype.ob$ge","Sk.builtin.lng.prototype.$r","Sk.builtin.lng.prototype.tp$str","Sk.builtin.lng.prototype.str$","hypot","sqrt","Sk.builtin.complex","real","imag","cr_is_complex","ci_is_complex","complex_subtype_from_string","try_complex_special_method","nbr","nb_float","_isNegativeZero","Sk.builtin.complex.prototype.nb$int_","Sk.builtin.complex.prototype.nb$float_","Sk.builtin.complex.prototype.nb$lng","__doc__","Sk.builtin.complex._isNegativeZero","Sk.builtin.complex.try_complex_special_method","$complex","check_number_or_complex","Sk.builtin.complex.check_number_or_complex","Sk.builtin.complex.complex_subtype_from_string","got_bracket","float_regex2","val_wws","Sk.builtin.complex.prototype.tp$hash","$imag","$real","Sk.builtin.complex.prototype.nb$add","_c_diff","Sk.builtin.complex._c_diff","Sk.builtin.complex.prototype.nb$subtract","Sk.builtin.complex.prototype.nb$multiply","Sk.builtin.complex.prototype.nb$divide","breal","bimag","areal","aimag","abs_breal","abs_bimag","ratio","denom","Sk.builtin.complex.prototype.nb$floor_divide","Sk.builtin.complex.prototype.nb$remainder","Sk.builtin.complex.prototype.nb$power","int_exponent","c_powi","c_pow","Sk.builtin.complex.c_pow","vabs","at","atan2","phase","cos","sin","Sk.builtin.complex.c_powi","cn","c_powu","Sk.builtin.complex.c_powu","mask","Sk.builtin.complex.prototype.nb$negative","Sk.builtin.complex.prototype.nb$positive","Sk.builtin.complex._complex_check","Sk.builtin.complex.prototype.tp$richcompare","_real","_imag","equal","w_real","w_imag","Sk.builtin.complex.prototype.__eq__","Sk.builtin.complex.prototype.__ne__","Sk.builtin.complex.prototype.__lt__","Sk.builtin.complex.prototype.__le__","Sk.builtin.complex.prototype.__gt__","Sk.builtin.complex.prototype.__ge__","Sk.builtin.complex.prototype.__float__","Sk.builtin.complex.prototype.__int__","_internalGenericGetAttr","Sk.builtin.complex.prototype.tp$getattr","Sk.builtin.complex.prototype.tp$setattr","complex_format","Sk.builtin.complex.complex_format","format_code","lead","tail","im","PyOS_double_to_string","Py_DTSF_SIGN","Sk.builtin.complex.prototype.tp$str","int$format","Sk.builtin.complex.prototype.int$format","_PyComplex_FormatAdvanced","co_name","Sk.builtin.complex._PyComplex_FormatAdvanced","_is_finite","Sk.builtin.complex._is_finite","_is_infinity","Sk.builtin.complex._is_infinity","int$abs","Sk.builtin.complex.prototype.int$abs","int$bool","Sk.builtin.complex.prototype.int$bool","__bool__","int$truediv","Sk.builtin.complex.prototype.int$truediv","__truediv__","int$hash","Sk.builtin.complex.prototype.int$hash","int$add","Sk.builtin.complex.prototype.int$add","__add__","int$repr","Sk.builtin.complex.prototype.int$repr","int$str","Sk.builtin.complex.prototype.int$str","__str__","int$sub","Sk.builtin.complex.prototype.int$sub","__sub__","int$mul","Sk.builtin.complex.prototype.int$mul","__mul__","int$div","Sk.builtin.complex.prototype.int$div","__div__","int$floordiv","Sk.builtin.complex.prototype.int$floordiv","__floordiv__","int$mod","Sk.builtin.complex.prototype.int$mod","__mod__","int$pow","Sk.builtin.complex.prototype.int$pow","__pow__","int$neg","Sk.builtin.complex.prototype.int$neg","__neg__","int$pos","Sk.builtin.complex.prototype.int$pos","__pos__","int$conjugate","Sk.builtin.complex.prototype.int$conjugate","int$divmod","Sk.builtin.complex.prototype.int$divmod","div","__divmod__","int$getnewargs","Sk.builtin.complex.prototype.int$getnewargs","__getnewargs__","int$nonzero","Sk.builtin.complex.prototype.int$nonzero","__nonzero__","Sk.builtin.complex.PyOS_double_to_string","flags","upper","buf","Py_DTSF_ADD_DOT_0","format_str","Py_DTSF_ALT","Py_DTST_FINITE","Py_DTST_INFINITE","Py_DTST_NAN","Sk.builtin.slice","slice$start","slice$stop","slice$step","Sk.builtin.slice.prototype.tp$richcompare","t1","t2","Sk.builtin.slice.prototype.slice_indices_","sss","Sk.builtin.slice.prototype.sssiter$","wrtv","Sk.builtin.set","S","set_reset_","S_list","Sk.builtin.set.prototype.set_reset_","Sk.builtin.set.prototype.ob$eq","Sk.builtin.set.prototype.ob$ne","Sk.builtin.set.prototype.ob$lt","Sk.builtin.set.prototype.ob$le","Sk.builtin.set.prototype.ob$gt","Sk.builtin.set.prototype.ob$ge","Sk.builtin.set.prototype.nb$and","Sk.builtin.set.prototype.nb$or","Sk.builtin.set.prototype.nb$xor","Sk.builtin.set.prototype.nb$subtract","Sk.builtin.set.prototype.tp$iter","Sk.builtin.set.prototype.sq$length","Sk.builtin.set.prototype.sq$contains","isIn","selfLength","otherLength","new_args","sd","Sk.builtin.set_iter_","Sk.builtin.set_iter_.prototype.next$","print_f","kw_list","remap_val","is_none","write","print","Sk.builtin.module","structseq_types","make_structseq","Sk.builtin.make_structseq","fields","nm","flds","docs","cons","isArray","__reduce__","cons.prototype.tp$setattr","cons.prototype.tp$getattr","Sk.builtin.generator","Sk.builtin.generator.prototype.tp$iter","Sk.builtin.generator.prototype.tp$iternext","yielded","finishIteration","Sk.builtin.generator.prototype.next$","makeGenerator","Sk.builtin.makeGenerator","Sk.builtin.file","buffering","closed","data$","fileno","elem","nodeName","textContent","lineList","currentLine","pos$","__enter__","__exit__","Sk.builtin.file.prototype.tp$iter","$lines","close","flush","isatty","l_size","Sk.builtin.file.$readline","line","readline","readlines","sizehint","arr","seek","whence","l_offset","tell","truncate","Sk.ffi.remapToPy","kvs","Sk.ffi.remapToJs","kAsJs","Sk.ffi.callback","fn","stdwrap","Sk.ffi.stdwrap","towrap","inst","basicwrap","Sk.ffi.basicwrap","unwrapo","Sk.ffi.unwrapo","unwrapn","Sk.ffi.unwrapn","Sk.builtin.iterator","objit","flag","Sk.builtin.iterator.prototype.tp$iter","Sk.builtin.iterator.prototype.tp$iternext","checkSentinel","Sk.builtin.iterator.prototype.next$","Sk.builtin.enumerate","Sk.builtin.enumerate.prototype.next$","tokens","T_ENDMARKER","T_NAME","T_NUMBER","T_STRING","T_NEWLINE","T_INDENT","T_DEDENT","T_LPAR","T_RPAR","T_LSQB","T_RSQB","T_COLON","T_COMMA","T_SEMI","T_PLUS","T_MINUS","T_STAR","T_SLASH","T_VBAR","T_AMPER","T_LESS","T_GREATER","T_EQUAL","T_DOT","T_PERCENT","T_LBRACE","T_RBRACE","T_EQEQUAL","T_NOTEQUAL","T_LESSEQUAL","T_GREATEREQUAL","T_TILDE","T_CIRCUMFLEX","T_LEFTSHIFT","T_RIGHTSHIFT","T_DOUBLESTAR","T_PLUSEQUAL","T_MINEQUAL","T_STAREQUAL","T_SLASHEQUAL","T_PERCENTEQUAL","T_AMPEREQUAL","T_VBAREQUAL","T_CIRCUMFLEXEQUAL","T_LEFTSHIFTEQUAL","T_RIGHTSHIFTEQUAL","T_DOUBLESTAREQUAL","T_DOUBLESLASH","T_DOUBLESLASHEQUAL","T_AT","T_ATEQUAL","T_RARROW","T_ELLIPSIS","T_OP","T_AWAIT","T_ASYNC","T_ERRORTOKEN","T_NT_OFFSET","T_N_TOKENS","T_COMMENT","T_NL","T_ENCODING","EXACT_TOKEN_TYPES","NOTEQUAL","PERCENT","PERCENTEQUAL","AMPER","AMPEREQUAL","LPAR","RPAR","STAR","DOUBLESTAR","DOUBLESTAREQUAL","STAREQUAL","PLUS","PLUSEQUAL","COMMA","MINUS","MINEQUAL","RARROW","DOT","ELLIPSIS","SLASH","DOUBLESLASH","DOUBLESLASHEQUAL","SLASHEQUAL","COLON","COLONEQUAL","SEMI","LESS","LEFTSHIFT","LEFTSHIFTEQUAL","LESSEQUAL","EQUAL","EQEQUAL","GREATER","GREATEREQUAL","RIGHTSHIFT","RIGHTSHIFTEQUAL","AT","ATEQUAL","LSQB","RSQB","CIRCUMFLEX","CIRCUMFLEXEQUAL","LBRACE","VBAR","VBAREQUAL","RBRACE","TILDE","tok_name","__all__","token","ISTERMINAL","ISNONTERMINAL","ISEOF","TokenInfo","string","group","maybe","contains","_all_string_prefixes","TokenError","exact_type","TokenInfo.prototype.exact_type","reRegExpChar","reHasRegExpChar","Comment_","Pointfloat","Exponent","Floatnumber","Expfloat","Imagnumber","StringPrefix","Triple","EXACT_TOKENS_SORTED","Special","Funny","ContStr","PseudoExtras","endpats","prefixes","_prefix","Single","Double","Single3","Double3","single_quoted","triple_quoted","_tokenize","encoding","yield_","LSuffix","Intnumber","Number_","PseudoToken","Whitespace","Name","lnum","parenlev","continued","contstr","needcont","contline","indents","capos","endprog","strstart","last_line","endmatch","column","what","comment_token","pseudomatch","spos","epos","initial","numchars","normalized","normalize","id_start","Lu","Ll","Lt","Lm","Lo","Nl","the_underscore","Other_ID_Start","id_continue","Mn","Mc","Nd","Pc","Other_ID_Continue","unicode","OpMap","T_BACKQUOTE","ParseTables","sym","and_expr","and_test","annassign","arglist","argument","arith_expr","assert_stmt","async_funcdef","async_stmt","atom","atom_expr","augassign","break_stmt","classdef","comp_for","comp_if","comp_iter","comp_op","comparison","compound_stmt","continue_stmt","debugger_stmt","decorated","decorator","decorators","del_stmt","dictorsetmaker","dotted_as_name","dotted_as_names","dotted_name","encoding_decl","eval_input","except_clause","expr","expr_stmt","exprlist","factor","file_input","flow_stmt","for_stmt","funcdef","global_stmt","if_stmt","import_as_name","import_as_names","import_from","import_name","import_stmt","lambdef","lambdef_nocond","nonlocal_stmt","not_test","or_test","parameters","pass_stmt","print_stmt","raise_stmt","return_stmt","shift_expr","simple_stmt","single_input","sliceop","small_stmt","star_expr","stmt","subscript","subscriptlist","suite","term","test_nocond","testlist","testlist_comp","testlist_star_expr","tfpdef","trailer","try_stmt","typedargslist","varargslist","vfpdef","while_stmt","with_item","with_stmt","xor_expr","yield_arg","yield_expr","yield_stmt","number2symbol","dfas","states","labels","keywords","Parser","grammar","p_flags","makeParser","setup","FUTURE_PRINT_FUNCTION","FUTURE_UNICODE_LITERALS","FUTURE_DIVISION","FUTURE_ABSOLUTE_IMPORT","FUTURE_WITH_STATEMENT","FUTURE_NESTED_SCOPES","FUTURE_GENERATORS","CO_FUTURE_PRINT_FUNCTION","CO_FUTURE_UNICODE_LITERALS","CO_FUTURE_DIVISON","CO_FUTURE_ABSOLUTE_IMPORT","CO_FUTURE_WITH_STATEMENT","Parser.prototype.setup","stack","stackentry","dfa","state","node","newnode","context","children","used_names","addtoken","Parser.prototype.addtoken","ilabel","classify","arcs","newstate","pop","itsdfa","itsfirst","errline","Parser.prototype.classify","Parser.prototype.shift","col_offset","Parser.prototype.push","newdfa","Parser.prototype.pop","rootnode","Sk.parse","endmarker_seen","lines","tokenInfo","parseTreeDump","Sk.parseTreeDump","indent","astnodes","Load","Sk.astnodes.Load","Store","Sk.astnodes.Store","Del","Sk.astnodes.Del","AugLoad","Sk.astnodes.AugLoad","AugStore","Sk.astnodes.AugStore","Param","Sk.astnodes.Param","And","Sk.astnodes.And","Or","Sk.astnodes.Or","Sk.astnodes.Add","Sk.astnodes.Sub","Sk.astnodes.Mult","MatMult","Sk.astnodes.MatMult","Sk.astnodes.Div","Sk.astnodes.Mod","Pow","Sk.astnodes.Pow","Sk.astnodes.LShift","Sk.astnodes.RShift","Sk.astnodes.BitOr","Sk.astnodes.BitXor","Sk.astnodes.BitAnd","Sk.astnodes.FloorDiv","Invert","Sk.astnodes.Invert","Not","Sk.astnodes.Not","UAdd","Sk.astnodes.UAdd","USub","Sk.astnodes.USub","Eq","Sk.astnodes.Eq","NotEq","Sk.astnodes.NotEq","Sk.astnodes.Lt","LtE","Sk.astnodes.LtE","Gt","Sk.astnodes.Gt","GtE","Sk.astnodes.GtE","Is","Sk.astnodes.Is","IsNot","Sk.astnodes.IsNot","In","Sk.astnodes.In","NotIn","Sk.astnodes.NotIn","Module","Sk.astnodes.Module","docstring","Interactive","Sk.astnodes.Interactive","Expression","Sk.astnodes.Expression","Suite","Sk.astnodes.Suite","FunctionDef","Sk.astnodes.FunctionDef","decorator_list","returns","AsyncFunctionDef","Sk.astnodes.AsyncFunctionDef","ClassDef","Sk.astnodes.ClassDef","Return","Sk.astnodes.Return","Delete","Sk.astnodes.Delete","targets","Assign","Sk.astnodes.Assign","AugAssign","Sk.astnodes.AugAssign","target","AnnAssign","Sk.astnodes.AnnAssign","annotation","simple","For","Sk.astnodes.For","orelse","AsyncFor","Sk.astnodes.AsyncFor","While","Sk.astnodes.While","If","Sk.astnodes.If","With","Sk.astnodes.With","AsyncWith","Sk.astnodes.AsyncWith","Raise","Sk.astnodes.Raise","exc","cause","tback","Try","Sk.astnodes.Try","handlers","finalbody","Assert","Sk.astnodes.Assert","Import","Sk.astnodes.Import","ImportFrom","Sk.astnodes.ImportFrom","level","Global","Sk.astnodes.Global","Nonlocal","Sk.astnodes.Nonlocal","Expr","Sk.astnodes.Expr","Pass","Sk.astnodes.Pass","Sk.astnodes.Break","Continue","Sk.astnodes.Continue","Print","Sk.astnodes.Print","dest","values","nl","Debugger","Sk.astnodes.Debugger","BoolOp","Sk.astnodes.BoolOp","BinOp","Sk.astnodes.BinOp","UnaryOp","Sk.astnodes.UnaryOp","operand","Lambda","Sk.astnodes.Lambda","IfExp","Sk.astnodes.IfExp","Dict","Sk.astnodes.Dict","Set","Sk.astnodes.Set","elts","ListComp","Sk.astnodes.ListComp","elt","generators","SetComp","Sk.astnodes.SetComp","DictComp","Sk.astnodes.DictComp","GeneratorExp","Sk.astnodes.GeneratorExp","Await","Sk.astnodes.Await","Yield","Sk.astnodes.Yield","YieldFrom","Sk.astnodes.YieldFrom","Compare","Sk.astnodes.Compare","ops","comparators","Call","Sk.astnodes.Call","Num","Sk.astnodes.Num","Str","Sk.astnodes.Str","FormattedValue","Sk.astnodes.FormattedValue","JoinedStr","Sk.astnodes.JoinedStr","Bytes","Sk.astnodes.Bytes","NameConstant","Sk.astnodes.NameConstant","Ellipsis","Sk.astnodes.Ellipsis","Constant","Sk.astnodes.Constant","Attribute","Sk.astnodes.Attribute","ctx","Subscript","Sk.astnodes.Subscript","Starred","Sk.astnodes.Starred","Sk.astnodes.Name","List","Sk.astnodes.List","Tuple","Sk.astnodes.Tuple","Slice","Sk.astnodes.Slice","lower","ExtSlice","Sk.astnodes.ExtSlice","dims","Index","Sk.astnodes.Index","comprehension","Sk.astnodes.comprehension","ifs","is_async","ExceptHandler","Sk.astnodes.ExceptHandler","arguments_","Sk.astnodes.arguments_","kwonlyargs","kw_defaults","kwarg","Sk.astnodes.arg","keyword","Sk.astnodes.keyword","alias","Sk.astnodes.alias","asname","withitem","Sk.astnodes.withitem","context_expr","optional_vars","_astname","_fields","_isenum","Compiling","c_flags","c_encoding","c_filename","NCH","CHILD","REQ","ast_error","strobj","numStmts","cnt","SYM","TOK","forbiddenCheck","setContext","exprName","Repr","getOperator","operatorMap","new_identifier","astForCompOp","copy_location","end_lineno","end_col_offset","seq_for_testlist","listmaker","testlist_safe","testlist1","old_test","ast_for_expr","astForSuite","astForStmt","num","ast_for_exprlist","aliasForImportName","ast_for_genexp","ast_for_itercomp","COMP_GENEXP","astForFactor","pfactor","ppower","patom","pnum","ast_for_atom","expression","ast_for_call","allowgen","nkeywords","ndoublestars","chch","NULL","starred","ast_for_trailer","left_expr","attr_id","slc","astForSlice","slices","kind","_slice_kind","Index_kind","ast_for_flow_stmt","ast_for_testlist","astForArg","handleKeywordonlyArgs","kwdefaults","argname","astForArguments","posdefaults","foundDefault","ast_for_funcdef_impl","n0","decorator_seq","name_i","type_comment","c_feature_version","T_TYPE_COMMENT","T_NEW_TYPE_COMMENT","tc","astForClassdef","decoratorSeq","classname","dummy_name","dummy","astForComprehension","countCompIfs","nifs","nfors","countCompFors","comps","forch","comp","ast_for_comprehension","n_fors","for_ch","first","n_ifs","COMP_LISTCOMP","COMP_SETCOMP","astForAugassign","parsestr","rawmode","unescape","encodeURIComponent","d0","d3","parsenumber","n2","is_dict","astForAtomExpr","nch","cmps","nops","nextOper","newoperator","is_from","an","en","expr1","varName","expr2","aliases","ndots","nchildren","modname","decider","nElif","hasElse","nodeTarget","_target","nc","nexcept","finally_","thing","nameExpr","Slice_kind","ExtSlice_kind","astFromParse","Sk.astFromParse","stmts","astDump","Sk.astDump","_format","fieldstr","namelen","fieldlen","attrs","field","elems","elemsstr","Symbol_","namespaces","__name","__flags","__scope","SCOPE_OFF","SCOPE_MASK","__namespaces","SymbolTableScope","table","ast","symFlags","blockType","returnsValue","varkeywords","varargs","childHasFree","hasFree","isNested","cur","nested","FunctionBlock","scopeId","astScopeCounter","stss","symbols","SymbolTable","curClass","tmpname","VISIT_SEQ","visitFunc","_dictUpdate","kb","SYMTAB_CONSTS","DEF_GLOBAL","DEF_LOCAL","DEF_PARAM","USE","DEF_STAR","DEF_DOUBLESTAR","DEF_INTUPLE","DEF_FREE","DEF_FREE_GLOBAL","DEF_FREE_CLASS","DEF_IMPORT","DEF_BOUND","LOCAL","GLOBAL_EXPLICIT","GLOBAL_IMPLICIT","FREE","CELL","OPT_IMPORT_STAR","OPT_EXEC","OPT_BARE_EXEC","OPT_TOPLEVEL","GENERATOR","GENERATOR_EXPRESSION","ModuleBlock","ClassBlock","get_name","Symbol_.prototype.get_name","is_referenced","Symbol_.prototype.is_referenced","is_parameter","Symbol_.prototype.is_parameter","is_global","Symbol_.prototype.is_global","is_declared_global","Symbol_.prototype.is_declared_global","is_local","Symbol_.prototype.is_local","is_free","Symbol_.prototype.is_free","is_imported","Symbol_.prototype.is_imported","is_assigned","Symbol_.prototype.is_assigned","is_namespace","Symbol_.prototype.is_namespace","get_namespaces","Symbol_.prototype.get_namespaces","get_type","SymbolTableScope.prototype.get_type","SymbolTableScope.prototype.get_name","get_lineno","SymbolTableScope.prototype.get_lineno","is_nested","SymbolTableScope.prototype.is_nested","has_children","SymbolTableScope.prototype.has_children","get_identifiers","SymbolTableScope.prototype.get_identifiers","_identsMatching","lookup","SymbolTableScope.prototype.lookup","__check_children","SymbolTableScope.prototype.__check_children","SymbolTableScope.prototype._identsMatching","get_parameters","SymbolTableScope.prototype.get_parameters","_funcParams","get_locals","SymbolTableScope.prototype.get_locals","_funcLocals","get_globals","SymbolTableScope.prototype.get_globals","_funcGlobals","masked","get_frees","SymbolTableScope.prototype.get_frees","_funcFrees","get_methods","SymbolTableScope.prototype.get_methods","_classMethods","getScope","SymbolTableScope.prototype.getScope","getStsForAst","SymbolTable.prototype.getStsForAst","SEQStmt","SymbolTable.prototype.SEQStmt","nodes","visitStmt","SEQExpr","SymbolTable.prototype.SEQExpr","visitExpr","enterBlock","SymbolTable.prototype.enterBlock","fixReservedNames","prev","exitBlock","SymbolTable.prototype.exitBlock","visitParams","SymbolTable.prototype.visitParams","toplevel","addDef","visitArguments","SymbolTable.prototype.visitArguments","newTmpname","SymbolTable.prototype.newTmpname","SymbolTable.prototype.addDef","mangled","mangleName","fromGlobal","visitSlice","SymbolTable.prototype.visitSlice","SymbolTable.prototype.visitStmt","visitAlias","nameslen","visit_withitem","visitExcepthandlers","SymbolTable.prototype.visit_withitem","SymbolTable.prototype.visitExpr","visitComprehension","visitGenexp","SymbolTable.prototype.visitComprehension","lcs","startAt","SymbolTable.prototype.visitAlias","storename","dot","SymbolTable.prototype.visitGenexp","outermost","SymbolTable.prototype.visitExcepthandlers","eh","analyzeBlock","SymbolTable.prototype.analyzeBlock","ste","bound","scope","newglobal","newbound","newfree","analyzeName","allfree","childlen","analyzeChildBlock","analyzeCells","updateSymbols","SymbolTable.prototype.analyzeChildBlock","entry","childFree","tempBound","tempFree","tempGlobal","SymbolTable.prototype.analyzeCells","SymbolTable.prototype.updateSymbols","classflag","freeValue","SymbolTable.prototype.analyzeName","analyze","SymbolTable.prototype.analyze","symboltable","Sk.symboltable","dumpSymtab","Sk.dumpSymtab","st","pyBoolStr","pyList","getIdents","objidents","objidentslen","info","nss","nsslen","sub","Compiler","sourceCodeForAnnotation","interactive","nestlevel","allUnits","CompilerUnit","doesSuspend","private_","firstlineno","linenoSet","localnames","localtemps","tempsToSave","blocknum","blocks","curblock","consts","scopename","suffixCode","switchCode","varDeclsCode","prefixCode","breakBlocks","continueBlocks","exceptBlocks","finallyBlocks","reservedWords_","reservedNames_","priv","ident","strpriv","out","gensymcount","activateScope","CompilerUnit.prototype.activateScope","_next","getSourceLine","Compiler.prototype.getSourceLine","annotateSource","Compiler.prototype.annotateSource","gensym","Compiler.prototype.gensym","hint","niceName","Compiler.prototype.niceName","roughName","makeConstant","Compiler.prototype.makeConstant","rest","constant","cval","_gr","Compiler.prototype._gr","outputInterruptTest","Compiler.prototype.outputInterruptTest","_jumpfalse","Compiler.prototype._jumpfalse","block","cond","_jumpundef","Compiler.prototype._jumpundef","_jumpnotundef","Compiler.prototype._jumpnotundef","_jumptrue","Compiler.prototype._jumptrue","_jump","Compiler.prototype._jump","_checkSuspension","Compiler.prototype._checkSuspension","retblk","newBlock","setBlock","cunpackstarstoarray","Compiler.prototype.cunpackstarstoarray","permitEndOnly","hasStars","vexpr","ctuplelistorset","Compiler.prototype.ctuplelistorset","tuporlist","allconsts","cdict","Compiler.prototype.cdict","clistcomp","Compiler.prototype.clistcomp","ccompgen","cdictcomp","Compiler.prototype.cdictcomp","csetcomp","Compiler.prototype.csetcomp","Compiler.prototype.ccompgen","genIndex","skip","anchor","toiter","nexti","ifres","lvalue","lkey","cyield","Compiler.prototype.cyield","nextBlock","ccompare","Compiler.prototype.ccompare","fres","ccall","Compiler.prototype.ccall","positionalArgs","keywordArgs","kwarray","cslice","Compiler.prototype.cslice","low","high","eslice","Compiler.prototype.eslice","dimSubs","vslicesub","Compiler.prototype.vslicesub","subs","vslice","Compiler.prototype.vslice","dataToStore","chandlesubscr","Compiler.prototype.chandlesubscr","cboolop","Compiler.prototype.cboolop","jtype","expres","Compiler.prototype.vexpr","augvar","augsubs","clambda","cifexp","cgenexp","nStr","real_val","imag_val","mname","nameop","vseqexpr","Compiler.prototype.vseqexpr","exprs","caugassign","Compiler.prototype.caugassign","to","auge","aug","augsub","exprConstant","Compiler.prototype.exprConstant","Compiler.prototype.newBlock","Compiler.prototype.setBlock","pushBreakBlock","Compiler.prototype.pushBreakBlock","popBreakBlock","Compiler.prototype.popBreakBlock","pushContinueBlock","Compiler.prototype.pushContinueBlock","popContinueBlock","Compiler.prototype.popContinueBlock","pushExceptBlock","Compiler.prototype.pushExceptBlock","popExceptBlock","Compiler.prototype.popExceptBlock","pushFinallyBlock","Compiler.prototype.pushFinallyBlock","blk","breakDepth","popFinallyBlock","Compiler.prototype.popFinallyBlock","peekFinallyBlock","Compiler.prototype.peekFinallyBlock","setupExcept","Compiler.prototype.setupExcept","eb","endExcept","Compiler.prototype.endExcept","outputLocals","Compiler.prototype.outputLocals","unit","have","argnames","outputSuspensionHelpers","Compiler.prototype.outputSuspensionHelpers","localSaveCode","localsToSave","seenTemps","hasCell","outputAllUnits","Compiler.prototype.outputAllUnits","generatedBlocks","cif","Compiler.prototype.cif","vseqstmt","cwhile","Compiler.prototype.cwhile","debugBlock","cfor","Compiler.prototype.cfor","cleanup","craise","Compiler.prototype.craise","instantiatedException","isClass","outputFinallyCascade","Compiler.prototype.outputFinallyCascade","thisFinally","nextFinally","ctry","Compiler.prototype.ctry","finalBody","finalExceptionHandler","finalExceptionToReRaise","unhandled","handlertype","cwith","Compiler.prototype.cwith","itemIdx","exceptionHandler","tidyUp","carryOn","mgr","exit","thisFinallyBlock","cassert","Compiler.prototype.cassert","cimportas","Compiler.prototype.cimportas","src","dotLoc","cimport","Compiler.prototype.cimport","lastDot","cfromimport","Compiler.prototype.cfromimport","aliasOut","got","storeName","buildcodeobj","Compiler.prototype.buildcodeobj","coname","class_for_super","argnamesarr","cells","decos","enterScope","isGenerator","entryBlock","funcArgs","isCell","exitScope","frees","containingHasFree","cfunction","Compiler.prototype.cfunction","funcorgen","Compiler.prototype.clambda","Compiler.prototype.cifexp","cgenexpgen","Compiler.prototype.cgenexpgen","ge","velt","Compiler.prototype.cgenexp","gener","cclass","Compiler.prototype.cclass","cbody","wrapped","ccontinue","Compiler.prototype.ccontinue","gotoBlock","cbreak","Compiler.prototype.cbreak","vstmt","Compiler.prototype.vstmt","cprint","JSON","stringify","Compiler.prototype.vseqstmt","Compiler.prototype.isCell","Compiler.prototype.nameop","optype","OP_NAME","OP_DEREF","OP_FAST","OP_GLOBAL","mangledNoPre","Compiler.prototype.enterScope","scopeName","Compiler.prototype.exitScope","Compiler.prototype.cbody","Compiler.prototype.cprint","cmod","Compiler.prototype.cmod","modf","compile","Sk.compile","savedFlags","cst","cf_flags","funcname","resetCompiler","Sk.resetCompiler","importSearchPathForName","Sk.importSearchPathForName","ext","searchPath","nameAsPath","tryPathAndBreakOnSuccess","packagePath","pathStr","doOneTimeInitialization","Sk.doOneTimeInitialization","typesWithFunctionsToWrap","builtin_type","internalPy","files","fileWithoutExtension","importBuiltinWithBody","importSetUpPath","Sk.importSetUpPath","paths","importModuleInternal_","Sk.importModuleInternal_","dumpJS","suppliedPyBody","relativeToPackage","returnUndefinedOnTopLevelNotFound","parentModule","topLevelModuleToReturn","relativePackageName","$name","absolutePackagePrefix","$path","modNameSplit","parentModName","topLevelModuleToReturn_","searchFileName","co","onBeforeImport","codeAndPath","codeAndPath_","finalcode","$js","dateSet","withLineNumbers","beaut","modscope","modlocs","onAfterImport","Sk.importModule","importMain","Sk.importMain","filesLoaded","importMainWithBody","Sk.importMainWithBody","Sk.importBuiltinWithBody","__import__","Sk.builtin.__import__","fromlist","saveSk","relativeToPackageName","relativeToPackageNames","dottedName","importChain","leafModule","fromName","importStar","Sk.importStar","loc","props","Sk.builtin.timSort","MIN_GALLOP","Sk.builtin.timSort.prototype.lt","le","Sk.builtin.timSort.prototype.le","setitem","Sk.builtin.timSort.prototype.setitem","binary_sort","Sk.builtin.timSort.prototype.binary_sort","sorted","pivot","count_run","Sk.builtin.timSort.prototype.count_run","descending","listSlice","Sk.builtin.timSort.prototype.sort","minrun","remaining","merge_init","merge_compute_minrun","cr","advance","pending","merge_collapse","merge_force_collapse","gallop","Sk.builtin.timSort.prototype.gallop","rightmost","maxofs","lastofs","ofs","hintminlastofs","Sk.builtin.timSort.prototype.merge_init","min_gallop","merge_lo","Sk.builtin.timSort.prototype.merge_lo","acount","bcount","copyitems","popleft","merge_hi","Sk.builtin.timSort.prototype.merge_hi","popright","nexta","nextb","merge_at","Sk.builtin.timSort.prototype.merge_at","Sk.builtin.timSort.prototype.merge_collapse","Sk.builtin.timSort.prototype.merge_force_collapse","Sk.builtin.timSort.prototype.merge_compute_minrun","Sk.builtin.listSlice","Sk.builtin.listSlice.prototype.copyitems","Sk.builtin.listSlice.prototype.advance","Sk.builtin.listSlice.prototype.getitem","Sk.builtin.listSlice.prototype.setitem","Sk.builtin.listSlice.prototype.popleft","Sk.builtin.listSlice.prototype.popright","Sk.builtin.listSlice.prototype.reverse","list_hi","list_lo","lo","hi","Sk.builtin.sorted","compare_func","type_is_subtype_base_chain","Sk.builtin.type_is_subtype_base_chain","PyType_IsSubtype","Sk.builtin.PyType_IsSubtype","super_","Sk.builtin.super_","a_type","other_self","obj_type","Sk.builtin.super_.prototype.tp$getattr","$empty","$default_factory","$copy","$dict","$enter","$eq","$exit","$ge","$gt","$le","$lt","$ne","$write","builtinNames"],"mappings":"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","file":"skulpt.min.js","sourcesContent":["","","","","","","","","","/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// define __esModule on exports\n/******/ \t__webpack_require__.r = function(exports) {\n/******/ \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n/******/ \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n/******/ \t\t}\n/******/ \t\tObject.defineProperty(exports, '__esModule', { value: true });\n/******/ \t};\n/******/\n/******/ \t// create a fake namespace object\n/******/ \t// mode & 1: value is a module id, require it\n/******/ \t// mode & 2: merge all properties of value into the ns\n/******/ \t// mode & 4: return value when already ns object\n/******/ \t// mode & 8|1: behave like require\n/******/ \t__webpack_require__.t = function(value, mode) {\n/******/ \t\tif(mode & 1) value = __webpack_require__(value);\n/******/ \t\tif(mode & 8) return value;\n/******/ \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n/******/ \t\tvar ns = Object.create(null);\n/******/ \t\t__webpack_require__.r(ns);\n/******/ \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n/******/ \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n/******/ \t\treturn ns;\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 1);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports) {\n\nvar g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function(\"return this\")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/* jshint ignore:start */\n\n// This file list is only used for testing.\n// It should be kept in sync with ../skulpt.py.\n// Order is important!\n\n__webpack_require__(2);\n\n// Global support functions\nSk.global[\"strftime\"] = __webpack_require__(3);\nSk.global[\"strptime\"] = __webpack_require__(4);\n__webpack_require__(5);\n\n// Skulpt\n__webpack_require__(7);\n__webpack_require__(8);\n__webpack_require__(9);\n__webpack_require__(10);\n__webpack_require__(11);\n__webpack_require__(12);\n__webpack_require__(13);\n__webpack_require__(14);\n__webpack_require__(15);\n__webpack_require__(16);\n__webpack_require__(17);\n__webpack_require__(18);\n__webpack_require__(19);\n__webpack_require__(20);\n__webpack_require__(21);\n__webpack_require__(22);\n__webpack_require__(23);\n__webpack_require__(24);\n__webpack_require__(25);\n__webpack_require__(26);\n__webpack_require__(27);\n__webpack_require__(28);\n__webpack_require__(29);\n__webpack_require__(30);\n__webpack_require__(31);\n__webpack_require__(32);\n__webpack_require__(33);\n__webpack_require__(34);\n__webpack_require__(35);\n__webpack_require__(36);\n__webpack_require__(37);\n__webpack_require__(38);\n__webpack_require__(39);\n__webpack_require__(40);\n__webpack_require__(41);\n__webpack_require__(42);\n__webpack_require__(43);\n__webpack_require__(44);\n__webpack_require__(45);\n__webpack_require__(46);\n__webpack_require__(47);\n__webpack_require__(48);\n__webpack_require__(49);\n__webpack_require__(50);\n__webpack_require__(51);\n__webpack_require__(52);\n__webpack_require__(53);\n__webpack_require__(54);\n__webpack_require__(55);\n__webpack_require__(56);\n\n/* jshint ignore:end */\n\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/* WEBPACK VAR INJECTION */(function(global) {// Global Sk object\nvar Sk = {}; // jshint ignore:line\n\nSk.build = {\n    githash: \"2ec316720f367dba1e6a3498f584ed315fa9c005\",\n    date: \"2019-07-09T12:05:40.590Z\"\n};\n\n/**\n * Global object no matter where we're running\n */\nSk.global =\n    typeof global !== \"undefined\" ? global : // jshint ignore:line\n    typeof self !== \"undefined\" ? self : // jshint ignore:line\n    typeof window !== \"undefined\" ? window : // jshint ignore:line\n    {};\n\n/**\n * Export \"object\" to global namespace as \"name\".\n *\n * @param {string} name name to export the object to\n * @param {*} object object to export\n */\nSk.exportSymbol = function (name, object) {\n    var parts = name.split(\".\");\n    var curobj = Sk.global;\n    var part, idx;\n\n    for (idx = 0; idx < (parts.length - 1); idx++) {\n        part = parts[idx];\n\n        if (curobj.hasOwnProperty(part)) {\n            curobj = curobj[part];\n        } else {\n            curobj = curobj[part] = {};\n        }\n    }\n\n    if (typeof object !== \"undefined\") {\n        part = parts[idx];\n        curobj[part] = object;\n    }\n};\n\nSk.isArrayLike = function (object) {\n    if ((object instanceof Array) || (object && object.length && (typeof object.length == \"number\"))) {\n        return true;\n    }\n    return false;\n};\n\nSk.js_beautify = function (x) {\n    return x;\n};\n\nSk.exportSymbol(\"Sk\", Sk);\nSk.exportSymbol(\"Sk.global\", Sk.global);\nSk.exportSymbol(\"Sk.build\", Sk.build);\nSk.exportSymbol(\"Sk.exportSymbol\", Sk.exportSymbol);\nSk.exportSymbol(\"Sk.isArrayLike\", Sk.isArrayLike);\nSk.exportSymbol(\"Sk.js_beautify\", Sk.js_beautify);\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(0)))\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports) {\n\n//\n// strftime\n// github.com/samsonjs/strftime\n// @_sjs\n//\n// Copyright 2010 - 2016 Sami Samhuri <sami@samhuri.net>\n//\n// MIT License\n// http://sjs.mit-license.org\n//\n\n;(function() {\n\n    var Locales = {\n        de_DE: {\n            days: ['Sonntag', 'Montag', 'Dienstag', 'Mittwoch', 'Donnerstag', 'Freitag', 'Samstag'],\n            shortDays: ['So', 'Mo', 'Di', 'Mi', 'Do', 'Fr', 'Sa'],\n            months: ['Januar', 'Februar', 'Mrz', 'April', 'Mai', 'Juni', 'Juli', 'August', 'September', 'Oktober', 'November', 'Dezember'],\n            shortMonths: ['Jan', 'Feb', 'Mr', 'Apr', 'Mai', 'Jun', 'Jul', 'Aug', 'Sep', 'Okt', 'Nov', 'Dez'],\n            AM: 'AM',\n            PM: 'PM',\n            am: 'am',\n            pm: 'pm',\n            formats: {\n                c: '%a %d %b %Y %X %Z',\n                D: '%d.%m.%Y',\n                F: '%Y-%m-%d',\n                R: '%H:%M',\n                r: '%I:%M:%S %p',\n                T: '%H:%M:%S',\n                v: '%e-%b-%Y',\n                X: '%T',\n                x: '%D'\n            }\n        },\n\n        en_CA: {\n            days: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday' ],\n            shortDays: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],\n            months: ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'],\n            shortMonths: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],\n            ordinalSuffixes: [\n                'st', 'nd', 'rd', 'th', 'th', 'th', 'th', 'th', 'th', 'th',\n                'th', 'th', 'th', 'th', 'th', 'th', 'th', 'th', 'th', 'th',\n                'st', 'nd', 'rd', 'th', 'th', 'th', 'th', 'th', 'th', 'th',\n                'st'\n            ],\n            AM: 'AM',\n            PM: 'PM',\n            am: 'am',\n            pm: 'pm',\n            formats: {\n                c: '%a %d %b %Y %X %Z',\n                D: '%d/%m/%y',\n                F: '%Y-%m-%d',\n                R: '%H:%M',\n                r: '%I:%M:%S %p',\n                T: '%H:%M:%S',\n                v: '%e-%b-%Y',\n                X: '%r',\n                x: '%D'\n            }\n        },\n\n        en_US: {\n            days: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday' ],\n            shortDays: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],\n            months: ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'],\n            shortMonths: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],\n            ordinalSuffixes: [\n                'st', 'nd', 'rd', 'th', 'th', 'th', 'th', 'th', 'th', 'th',\n                'th', 'th', 'th', 'th', 'th', 'th', 'th', 'th', 'th', 'th',\n                'st', 'nd', 'rd', 'th', 'th', 'th', 'th', 'th', 'th', 'th',\n                'st'\n            ],\n            AM: 'AM',\n            PM: 'PM',\n            am: 'am',\n            pm: 'pm',\n            formats: {\n                c: '%a %d %b %Y %X %Z',\n                D: '%m/%d/%y',\n                F: '%Y-%m-%d',\n                R: '%H:%M',\n                r: '%I:%M:%S %p',\n                T: '%H:%M:%S',\n                v: '%e-%b-%Y',\n                X: '%r',\n                x: '%D'\n            }\n        },\n\n        es_MX: {\n            days: ['domingo', 'lunes', 'martes', 'mircoles', 'jueves', 'viernes', 'sbado'],\n            shortDays: ['dom', 'lun', 'mar', 'mi', 'jue', 'vie', 'sb'],\n            months: ['enero', 'febrero', 'marzo', 'abril', 'mayo', 'junio', 'julio', 'agosto', 'septiembre', 'octubre', 'noviembre',' diciembre'],\n            shortMonths: ['ene', 'feb', 'mar', 'abr', 'may', 'jun', 'jul', 'ago', 'sep', 'oct', 'nov', 'dic'],\n            AM: 'AM',\n            PM: 'PM',\n            am: 'am',\n            pm: 'pm',\n            formats: {\n                c: '%a %d %b %Y %X %Z',\n                D: '%d/%m/%Y',\n                F: '%Y-%m-%d',\n                R: '%H:%M',\n                r: '%I:%M:%S %p',\n                T: '%H:%M:%S',\n                v: '%e-%b-%Y',\n                X: '%T',\n                x: '%D'\n            }\n        },\n\n        fr_FR: {\n            days: ['dimanche', 'lundi', 'mardi', 'mercredi', 'jeudi', 'vendredi', 'samedi'],\n            shortDays: ['dim.', 'lun.', 'mar.', 'mer.', 'jeu.', 'ven.', 'sam.'],\n            months: ['janvier', 'fvrier', 'mars', 'avril', 'mai', 'juin', 'juillet', 'aot', 'septembre', 'octobre', 'novembre', 'dcembre'],\n            shortMonths: ['janv.', 'fvr.', 'mars', 'avril', 'mai', 'juin', 'juil.', 'aot', 'sept.', 'oct.', 'nov.', 'dc.'],\n            AM: 'AM',\n            PM: 'PM',\n            am: 'am',\n            pm: 'pm',\n            formats: {\n                c: '%a %d %b %Y %X %Z',\n                D: '%d/%m/%Y',\n                F: '%Y-%m-%d',\n                R: '%H:%M',\n                r: '%I:%M:%S %p',\n                T: '%H:%M:%S',\n                v: '%e-%b-%Y',\n                X: '%T',\n                x: '%D'\n            }\n        },\n\n        it_IT: {\n            days: ['domenica', 'luned', 'marted', 'mercoled', 'gioved', 'venerd', 'sabato'],\n            shortDays: ['dom', 'lun', 'mar', 'mer', 'gio', 'ven', 'sab'],\n            months: ['gennaio', 'febbraio', 'marzo', 'aprile', 'maggio', 'giugno', 'luglio', 'agosto', 'settembre', 'ottobre', 'novembre', 'dicembre'],\n            shortMonths: ['pr', 'mag', 'giu', 'lug', 'ago', 'set', 'ott', 'nov', 'dic'],\n            AM: 'AM',\n            PM: 'PM',\n            am: 'am',\n            pm: 'pm',\n            formats: {\n                c: '%a %d %b %Y %X %Z',\n                D: '%d/%m/%Y',\n                F: '%Y-%m-%d',\n                R: '%H:%M',\n                r: '%I:%M:%S %p',\n                T: '%H:%M:%S',\n                v: '%e-%b-%Y',\n                X: '%T',\n                x: '%D'\n            }\n        },\n\n        nl_NL: {\n            days: ['zondag', 'maandag', 'dinsdag', 'woensdag', 'donderdag', 'vrijdag', 'zaterdag'],\n            shortDays: ['zo', 'ma', 'di', 'wo', 'do', 'vr', 'za'],\n            months: ['januari', 'februari', 'maart', 'april', 'mei', 'juni', 'juli', 'augustus', 'september', 'oktober', 'november', 'december'],\n            shortMonths: ['jan', 'feb', 'mrt', 'apr', 'mei', 'jun', 'jul', 'aug', 'sep', 'okt', 'nov', 'dec'],\n            AM: 'AM',\n            PM: 'PM',\n            am: 'am',\n            pm: 'pm',\n            formats: {\n                c: '%a %d %b %Y %X %Z',\n                D: '%d-%m-%y',\n                F: '%Y-%m-%d',\n                R: '%H:%M',\n                r: '%I:%M:%S %p',\n                T: '%H:%M:%S',\n                v: '%e-%b-%Y',\n                X: '%T',\n                x: '%D'\n            }\n        },\n\n        pt_BR: {\n            days: ['domingo', 'segunda', 'tera', 'quarta', 'quinta', 'sexta', 'sbado'],\n            shortDays: ['Dom', 'Seg', 'Ter', 'Qua', 'Qui', 'Sex', 'Sb'],\n            months: ['janeiro', 'fevereiro', 'maro', 'abril', 'maio', 'junho', 'julho', 'agosto', 'setembro', 'outubro', 'novembro', 'dezembro'],\n            shortMonths: ['Jan', 'Fev', 'Mar', 'Abr', 'Mai', 'Jun', 'Jul', 'Ago', 'Set', 'Out', 'Nov', 'Dez'],\n            AM: 'AM',\n            PM: 'PM',\n            am: 'am',\n            pm: 'pm',\n            formats: {\n                c: '%a %d %b %Y %X %Z',\n                D: '%d-%m-%Y',\n                F: '%Y-%m-%d',\n                R: '%H:%M',\n                r: '%I:%M:%S %p',\n                T: '%H:%M:%S',\n                v: '%e-%b-%Y',\n                X: '%T',\n                x: '%D'\n            }\n        },\n\n        ru_RU: {\n            days: ['', '', '', '', '', '', ''],\n            shortDays: ['', '', '', '', '', '', ''],\n            months: ['', '', '', '', '', '', '', '', '', '', '', ''],\n            shortMonths: ['', '', '', '', '', '', '', '', '', '', '', ''],\n            AM: 'AM',\n            PM: 'PM',\n            am: 'am',\n            pm: 'pm',\n            formats: {\n                c: '%a %d %b %Y %X',\n                D: '%d.%m.%y',\n                F: '%Y-%m-%d',\n                R: '%H:%M',\n                r: '%I:%M:%S %p',\n                T: '%H:%M:%S',\n                v: '%e-%b-%Y',\n                X: '%T',\n                x: '%D'\n            }\n        },\n\n        tr_TR: {\n            days: ['Pazar', 'Pazartesi', 'Sal','aramba', 'Perembe', 'Cuma', 'Cumartesi'],\n            shortDays: ['Paz', 'Pzt', 'Sal', 'r', 'Pr', 'Cum', 'Cts'],\n            months: ['Ocak', 'ubat', 'Mart', 'Nisan', 'Mays', 'Haziran', 'Temmuz', 'Austos', 'Eyll', 'Ekim', 'Kasm', 'Aralk'],\n            shortMonths: ['Oca', 'ub', 'Mar', 'Nis', 'May', 'Haz', 'Tem', 'Au', 'Eyl', 'Eki', 'Kas', 'Ara'],\n            AM: '',\n            PM: 'S',\n            am: '',\n            pm: 'S',\n            formats: {\n                c: '%a %d %b %Y %X %Z',\n                D: '%d-%m-%Y',\n                F: '%Y-%m-%d',\n                R: '%H:%M',\n                r: '%I:%M:%S %p',\n                T: '%H:%M:%S',\n                v: '%e-%b-%Y',\n                X: '%T',\n                x: '%D'\n            }\n        },\n\n        // By michaeljayt<michaeljayt@gmail.com>\n        // https://github.com/michaeljayt/strftime/commit/bcb4c12743811d51e568175aa7bff3fd2a77cef3\n        zh_CN: {\n            days: ['', '', '', '', '', '', ''],\n            shortDays: ['', '', '', '', '', '', ''],\n            months: ['', '', '', '', '', '', '', '', '', '', '', ''],\n            shortMonths: ['', '', '', '', '', '', '', '', '', '', '', ''],\n            AM: '',\n            PM: '',\n            am: '',\n            pm: '',\n            formats: {\n                c: '%a %d %b %Y %X %Z',\n                D: '%d/%m/%y',\n                F: '%Y-%m-%d',\n                R: '%H:%M',\n                r: '%I:%M:%S %p',\n                T: '%H:%M:%S',\n                v: '%e-%b-%Y',\n                X: '%r',\n                x: '%D'\n            }\n        }\n    };\n\n    var DefaultLocale = Locales['en_US'],\n        defaultStrftime = new Strftime(DefaultLocale, 0, false),\n        isCommonJS = typeof module !== 'undefined',\n        namespace;\n\n    // CommonJS / Node module\n    if (isCommonJS) {\n        namespace = module.exports = defaultStrftime;\n    }\n    // Browsers and other environments\n    else {\n        // Get the global object. Works in ES3, ES5, and ES5 strict mode.\n        namespace = (function() { return this || (1,eval)('this'); }());\n        namespace.strftime = defaultStrftime;\n    }\n\n    // Polyfill Date.now for old browsers.\n    if (typeof Date.now !== 'function') {\n        Date.now = function() {\n          return +new Date();\n        };\n    }\n\n    function Strftime(locale, customTimezoneOffset, useUtcTimezone) {\n        var _locale = locale || DefaultLocale,\n            _customTimezoneOffset = customTimezoneOffset || 0,\n            _useUtcBasedDate = useUtcTimezone || false,\n\n            // we store unix timestamp value here to not create new Date() each iteration (each millisecond)\n            // Date.now() is 2 times faster than new Date()\n            // while millisecond precise is enough here\n            // this could be very helpful when strftime triggered a lot of times one by one\n            _cachedDateTimestamp = 0,\n            _cachedDate;\n\n        function _strftime(format, date) {\n            var timestamp;\n\n            if (!date) {\n                var currentTimestamp = Date.now();\n                if (currentTimestamp > _cachedDateTimestamp) {\n                    _cachedDateTimestamp = currentTimestamp;\n                    _cachedDate = new Date(_cachedDateTimestamp);\n\n                    timestamp = _cachedDateTimestamp;\n\n                    if (_useUtcBasedDate) {\n                        // how to avoid duplication of date instantiation for utc here?\n                        // we tied to getTimezoneOffset of the current date\n                        _cachedDate = new Date(_cachedDateTimestamp + getTimestampToUtcOffsetFor(_cachedDate) + _customTimezoneOffset);\n                    }\n                }\n                else {\n                  timestamp = _cachedDateTimestamp;\n                }\n                date = _cachedDate;\n            }\n            else {\n                timestamp = date.getTime();\n\n                if (_useUtcBasedDate) {\n                    var utcOffset = getTimestampToUtcOffsetFor(date);\n                    date = new Date(timestamp + utcOffset + _customTimezoneOffset);\n                    // If we've crossed a DST boundary with this calculation we need to\n                    // adjust the new date accordingly or it will be off by an hour in UTC.\n                    if (getTimestampToUtcOffsetFor(date) !== utcOffset) {\n                        var newUTCOffset = getTimestampToUtcOffsetFor(date);\n                        date = new Date(timestamp + newUTCOffset + _customTimezoneOffset);\n                    }\n                }\n            }\n\n            return _processFormat(format, date, _locale, timestamp);\n        }\n\n        function _processFormat(format, date, locale, timestamp) {\n            var resultString = '',\n                padding = null,\n                isInScope = false,\n                length = format.length,\n                extendedTZ = false;\n\n            for (var i = 0; i < length; i++) {\n\n                var currentCharCode = format.charCodeAt(i);\n\n                if (isInScope === true) {\n                    // '-'\n                    if (currentCharCode === 45) {\n                        padding = '';\n                        continue;\n                    }\n                    // '_'\n                    else if (currentCharCode === 95) {\n                        padding = ' ';\n                        continue;\n                    }\n                    // '0'\n                    else if (currentCharCode === 48) {\n                        padding = '0';\n                        continue;\n                    }\n                    // ':'\n                    else if (currentCharCode === 58) {\n                      if (extendedTZ) {\n                          warn(\"[WARNING] detected use of unsupported %:: or %::: modifiers to strftime\");\n                      }\n                      extendedTZ = true;\n                      continue;\n                    }\n\n                    switch (currentCharCode) {\n\n                        // Examples for new Date(0) in GMT\n\n                        // '%'\n                        // case '%':\n                        case 37:\n                            resultString += '%';\n                            break;\n\n                        // 'Thursday'\n                        // case 'A':\n                        case 65:\n                            resultString += locale.days[date.getDay()];\n                            break;\n\n                        // 'January'\n                        // case 'B':\n                        case 66:\n                            resultString += locale.months[date.getMonth()];\n                            break;\n\n                        // '19'\n                        // case 'C':\n                        case 67:\n                            resultString += padTill2(Math.floor(date.getFullYear() / 100), padding);\n                            break;\n\n                        // '01/01/70'\n                        // case 'D':\n                        case 68:\n                            resultString += _processFormat(locale.formats.D, date, locale, timestamp);\n                            break;\n\n                        // '1970-01-01'\n                        // case 'F':\n                        case 70:\n                            resultString += _processFormat(locale.formats.F, date, locale, timestamp);\n                            break;\n\n                        // '00'\n                        // case 'H':\n                        case 72:\n                            resultString += padTill2(date.getHours(), padding);\n                            break;\n\n                        // '12'\n                        // case 'I':\n                        case 73:\n                            resultString += padTill2(hours12(date.getHours()), padding);\n                            break;\n\n                        // '000'\n                        // case 'L':\n                        case 76:\n                            resultString += padTill3(Math.floor(timestamp % 1000));\n                            break;\n\n                        // '00'\n                        // case 'M':\n                        case 77:\n                            resultString += padTill2(date.getMinutes(), padding);\n                            break;\n\n                        // 'am'\n                        // case 'P':\n                        case 80:\n                            resultString += date.getHours() < 12 ? locale.am : locale.pm;\n                            break;\n\n                        // '00:00'\n                        // case 'R':\n                        case 82:\n                            resultString += _processFormat(locale.formats.R, date, locale, timestamp);\n                            break;\n\n                        // '00'\n                        // case 'S':\n                        case 83:\n                            resultString += padTill2(date.getSeconds(), padding);\n                            break;\n\n                        // '00:00:00'\n                        // case 'T':\n                        case 84:\n                            resultString += _processFormat(locale.formats.T, date, locale, timestamp);\n                            break;\n\n                        // '00'\n                        // case 'U':\n                        case 85:\n                            resultString += padTill2(weekNumber(date, 'sunday'), padding);\n                            break;\n\n                        // '00'\n                        // case 'W':\n                        case 87:\n                            resultString += padTill2(weekNumber(date, 'monday'), padding);\n                            break;\n\n                        // '16:00:00'\n                        // case 'X':\n                        case 88:\n                            resultString += _processFormat(locale.formats.X, date, locale, timestamp);\n                            break;\n\n                        // '1970'\n                        // case 'Y':\n                        case 89:\n                            resultString += date.getFullYear();\n                            break;\n\n                        // 'GMT'\n                        // case 'Z':\n                        case 90:\n                            if (_useUtcBasedDate && _customTimezoneOffset === 0) {\n                                resultString += \"GMT\";\n                            }\n                            else {\n                                // fixme optimize\n                                var tzString = date.toString().match(/\\(([\\w\\s]+)\\)/);\n                                resultString += tzString && tzString[1] || '';\n                            }\n                            break;\n\n                        // 'Thu'\n                        // case 'a':\n                        case 97:\n                            resultString += locale.shortDays[date.getDay()];\n                            break;\n\n                        // 'Jan'\n                        // case 'b':\n                        case 98:\n                            resultString += locale.shortMonths[date.getMonth()];\n                            break;\n\n                        // ''\n                        // case 'c':\n                        case 99:\n                            resultString += _processFormat(locale.formats.c, date, locale, timestamp);\n                            break;\n\n                        // '01'\n                        // case 'd':\n                        case 100:\n                            resultString += padTill2(date.getDate(), padding);\n                            break;\n\n                        // ' 1'\n                        // case 'e':\n                        case 101:\n                            resultString += padTill2(date.getDate(), padding == null ? ' ' : padding);\n                            break;\n\n                        // 'Jan'\n                        // case 'h':\n                        case 104:\n                            resultString += locale.shortMonths[date.getMonth()];\n                            break;\n\n                        // '000'\n                        // case 'j':\n                        case 106:\n                            var y = new Date(date.getFullYear(), 0, 1);\n                            var day = Math.ceil((date.getTime() - y.getTime()) / (1000 * 60 * 60 * 24));\n                            resultString += padTill3(day);\n                            break;\n\n                        // ' 0'\n                        // case 'k':\n                        case 107:\n                            resultString += padTill2(date.getHours(), padding == null ? ' ' : padding);\n                            break;\n\n                        // '12'\n                        // case 'l':\n                        case 108:\n                            resultString += padTill2(hours12(date.getHours()), padding == null ? ' ' : padding);\n                            break;\n\n                        // '01'\n                        // case 'm':\n                        case 109:\n                            resultString += padTill2(date.getMonth() + 1, padding);\n                            break;\n\n                        // '\\n'\n                        // case 'n':\n                        case 110:\n                            resultString += '\\n';\n                            break;\n\n                        // '1st'\n                        // case 'o':\n                        case 111:\n                            // Try to use an ordinal suffix from the locale, but fall back to using the old\n                            // function for compatibility with old locales that lack them.\n                            var day = date.getDate();\n                            if (locale.ordinalSuffixes) {\n                                resultString += String(day) + (locale.ordinalSuffixes[day - 1] || ordinal(day));\n                            }\n                            else {\n                                resultString += String(day) + ordinal(day);\n                            }\n                            break;\n\n                        // 'AM'\n                        // case 'p':\n                        case 112:\n                            resultString += date.getHours() < 12 ? locale.AM : locale.PM;\n                            break;\n\n                        // '12:00:00 AM'\n                        // case 'r':\n                        case 114:\n                            resultString += _processFormat(locale.formats.r, date, locale, timestamp);\n                            break;\n\n                        // '0'\n                        // case 's':\n                        case 115:\n                            resultString += Math.floor(timestamp / 1000);\n                            break;\n\n                        // '\\t'\n                        // case 't':\n                        case 116:\n                            resultString += '\\t';\n                            break;\n\n                        // '4'\n                        // case 'u':\n                        case 117:\n                            var day = date.getDay();\n                            resultString += day === 0 ? 7 : day;\n                            break; // 1 - 7, Monday is first day of the week\n\n                        // ' 1-Jan-1970'\n                        // case 'v':\n                        case 118:\n                            resultString += _processFormat(locale.formats.v, date, locale, timestamp);\n                            break;\n\n                        // '4'\n                        // case 'w':\n                        case 119:\n                            resultString += date.getDay();\n                            break; // 0 - 6, Sunday is first day of the week\n\n                        // '12/31/69'\n                        // case 'x':\n                        case 120:\n                            resultString += _processFormat(locale.formats.x, date, locale, timestamp);\n                            break;\n\n                        // '70'\n                        // case 'y':\n                        case 121:\n                            resultString += ('' + date.getFullYear()).slice(2);\n                            break;\n\n                        // '+0000'\n                        // case 'z':\n                        case 122:\n                            if (_useUtcBasedDate && _customTimezoneOffset === 0) {\n                                resultString += extendedTZ ? \"+00:00\" : \"+0000\";\n                            }\n                            else {\n                                var off;\n                                if (_customTimezoneOffset !== 0) {\n                                    off = _customTimezoneOffset / (60 * 1000);\n                                }\n                                else {\n                                    off = -date.getTimezoneOffset();\n                                }\n                                var sign = off < 0 ? '-' : '+';\n                                var sep = extendedTZ ? ':' : '';\n                                var hours = Math.floor(Math.abs(off / 60));\n                                var mins = Math.abs(off % 60);\n                                resultString += sign + padTill2(hours) + sep + padTill2(mins);\n                            }\n                            break;\n\n                        default:\n                            if (isInScope) {\n                                resultString += '%';\n                            }\n                            resultString += format[i];\n                            break;\n                    }\n\n                    padding = null;\n                    isInScope = false;\n                    continue;\n                }\n\n                // '%'\n                if (currentCharCode === 37) {\n                    isInScope = true;\n                    continue;\n                }\n\n                resultString += format[i];\n            }\n\n            return resultString;\n        }\n\n        var strftime = _strftime;\n\n        strftime.localize = function(locale) {\n            return new Strftime(locale || _locale, _customTimezoneOffset, _useUtcBasedDate);\n        };\n\n        strftime.localizeByIdentifier = function(localeIdentifier) {\n            var locale = Locales[localeIdentifier];\n            if (!locale) {\n                warn('[WARNING] No locale found with identifier \"' + localeIdentifier + '\".');\n                return strftime;\n            }\n            return strftime.localize(locale);\n        };\n\n        strftime.timezone = function(timezone) {\n            var customTimezoneOffset = _customTimezoneOffset;\n            var useUtcBasedDate = _useUtcBasedDate;\n\n            var timezoneType = typeof timezone;\n            if (timezoneType === 'number' || timezoneType === 'string') {\n                useUtcBasedDate = true;\n\n                // ISO 8601 format timezone string, [-+]HHMM\n                if (timezoneType === 'string') {\n                    var sign = timezone[0] === '-' ? -1 : 1,\n                        hours = parseInt(timezone.slice(1, 3), 10),\n                        minutes = parseInt(timezone.slice(3, 5), 10);\n\n                    customTimezoneOffset = sign * ((60 * hours) + minutes) * 60 * 1000;\n                    // in minutes: 420\n                }\n                else if (timezoneType === 'number') {\n                    customTimezoneOffset = timezone * 60 * 1000;\n                }\n            }\n\n            return new Strftime(_locale, customTimezoneOffset, useUtcBasedDate);\n        };\n\n        strftime.utc = function() {\n            return new Strftime(_locale, _customTimezoneOffset, true);\n        };\n\n        return strftime;\n    }\n\n    function padTill2(numberToPad, paddingChar) {\n        if (paddingChar === '' || numberToPad > 9) {\n            return numberToPad;\n        }\n        if (paddingChar == null) {\n            paddingChar = '0';\n        }\n        return paddingChar + numberToPad;\n    }\n\n    function padTill3(numberToPad) {\n        if (numberToPad > 99) {\n            return numberToPad;\n        }\n        if (numberToPad > 9) {\n            return '0' + numberToPad;\n        }\n        return '00' + numberToPad;\n    }\n\n    function hours12(hour) {\n        if (hour === 0) {\n            return 12;\n        }\n        else if (hour > 12) {\n            return hour - 12;\n        }\n        return hour;\n    }\n\n    // firstWeekday: 'sunday' or 'monday', default is 'sunday'\n    //\n    // Pilfered & ported from Ruby's strftime implementation.\n    function weekNumber(date, firstWeekday) {\n        firstWeekday = firstWeekday || 'sunday';\n\n        // This works by shifting the weekday back by one day if we\n        // are treating Monday as the first day of the week.\n        var weekday = date.getDay();\n        if (firstWeekday === 'monday') {\n            if (weekday === 0) // Sunday\n                weekday = 6;\n            else\n                weekday--;\n        }\n\n        var firstDayOfYearUtc = Date.UTC(date.getFullYear(), 0, 1),\n            dateUtc = Date.UTC(date.getFullYear(), date.getMonth(), date.getDate()),\n            yday = Math.floor((dateUtc - firstDayOfYearUtc) / 86400000),\n            weekNum = (yday + 7 - weekday) / 7;\n\n        return Math.floor(weekNum);\n    }\n\n    // Get the ordinal suffix for a number: st, nd, rd, or th\n    function ordinal(number) {\n        var i = number % 10;\n        var ii = number % 100;\n\n        if ((ii >= 11 && ii <= 13) || i === 0 || i >= 4) {\n            return 'th';\n        }\n        switch (i) {\n            case 1: return 'st';\n            case 2: return 'nd';\n            case 3: return 'rd';\n        }\n    }\n\n    function getTimestampToUtcOffsetFor(date) {\n        return (date.getTimezoneOffset() || 0) * 60000;\n    }\n\n    function warn(message) {\n        if (typeof console !== 'undefined' && typeof console.warn == 'function') {\n            console.warn(message)\n        }\n    }\n\n}());\n\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/* jshint -W067 */\n(function() {\n    'use strict';\n\n    /**\n * User: rikishi\n * Date: 07.07.13\n * Time: 19:17\n *\n */\n\n/**\n * @param {String} str\n * @param {String} format\n * @param {Boolean} [local]\n * @returns {Date|Null}\n */\n/*jshint -W079 */\nvar strptime = function(str, format, local) {\n    return strptime.parse(str, format, local);\n};\n\n\n    strptime.version = '0.0.1';\n\n    var namespace;\n\n    if (true) {\n        namespace = module.exports = strptime;\n    } else {}\n\n    namespace.strptime = strptime;\n\n    (function(strptime) {\n\n    strptime.locale = {\n        'a': ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],\n        'A': ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'],\n        'b': ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],\n        'B': ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'],\n        'f': ['Jan.', 'Feb.', 'Mar.', 'Apr.', 'May', 'Jun.', 'Jul.', 'Aug.', 'Sep.', 'Oct.', 'Nov.', 'Dec.'],\n        'c': '%Y-%m-%d %H:%M:%S',\n        'P': ['am', 'pm'],\n        'r': '%I:%M:%S %p',\n        'x': '%m/%d/%y',\n        'X': '%H:%M:%S',\n        'day': ['Yesterday', 'Today', 'Tomorrow'],\n\n        //      \n        'bg': ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],\n        'Bg': ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'],\n        'fg': ['Jan.', 'Feb.', 'Mar.', 'Apr.', 'May', 'Jun.', 'Jul.', 'Aug.', 'Sep.', 'Oct.', 'Nov.', 'Dec.'],\n\n        'Date_dBY_year_in_HM': '%#B %-d, %Y at %-H:%M',\n        'Date_dBY_year': '%#B %-d, %Y',\n        'Date_dBY': '%#B %-d, %Y',\n        'Date_AdBY': '%A, %#B %-d, %Y',\n        'Date_dBA': '%#B %-d, %A',\n        'Date_df_in_HM': '%#f, %-d at %-H:%M',\n        'Date_dfY': '%-d %#f %Y',\n        'Date_dB_in_HM': '%#B %-d at %-H:%M',\n        'Date_df': '%-d %#f'\n    };\n\n}(strptime));\n\n\n    (function(strptime) {\n\n    var inArray = Array.prototype.indexOf || function(el) {\n        var l = this.length;\n        var i = 0;\n        while (i < l) {\n            if (el == this[i]) {\n                return i;\n            }\n            i++;\n        }\n        return -1;\n    };\n\n    var locale = strptime.locale;\n\n    var strRegNum2 = '[\\\\d\\\\s]?\\\\d';\n    var strRegStr = '\\\\S+';\n\n    var specifiers = {\n        '%': '\\\\%',\n        //    ,     \n        'a': strRegStr,\n        //    ,     \n        'A': strRegStr,\n        //   ,     \n        'b': {\n            'reg': strRegStr,\n            'make': function(date, data, mod, gen) {\n                data = inArray.call(gen ? locale.bg : locale.b, toLetterCaseReverse(data, mod));\n                if (data === -1) {\n                    return false;\n                }\n\n                date.setUTCMonth(data);\n                return true;\n            }\n        },\n        //   ,      ( %b)\n        'h': {\n            'reg': strRegStr,\n            'make': function(date, data, mod, gen) {\n                data = inArray.call(gen ? locale.bg : locale.b, toLetterCaseReverse(data, mod));\n                if (data === -1) {\n                    return false;\n                }\n\n                date.setUTCMonth(data);\n                return true;\n            }\n        },\n        //   ,     \n        'B': {\n            'reg': strRegStr,\n            'make': function(date, data, mod, gen) {\n                data = inArray.call(gen ? locale.Bg : locale.B, toLetterCaseReverse(data, mod));\n                if (data === -1) {\n                    return false;\n                }\n\n                date.setUTCMonth(data);\n                return true;\n            }\n        },\n        //     ,     \n        'f': {\n            'reg': strRegStr,\n            'make': function(date, data, mod, gen) {\n                data = inArray.call(gen ? locale.fg : locale.f, toLetterCaseReverse(data, mod));\n                if (data === -1) {\n                    return false;\n                }\n\n                date.setUTCMonth(data);\n                return true;\n            }\n        },\n\n\n        //        ISO-8601:1988\n        'g': {\n            'reg': strRegNum2,\n            'make': function(date, data) {\n                data = parseInt(data, 10);\n                if (data < 0 || data > 99) {\n                    return false;\n                }\n\n                data = data + 100 * parseInt((new Date()).getUTCFullYear() / 100, 10);\n                date.setUTCFullYear(data);\n                return true;\n            }\n        },\n        //    %g\n        'G': {\n            'reg': '\\\\d{4}',\n            'make': function(date, data) {\n                data = parseInt(data, 10);\n                date.setUTCFullYear(data);\n                return true;\n            }\n        },\n        //     (  )\n        'd': {\n            'reg': strRegNum2,\n            'make': function(date, data) {\n                data = parseInt(data, 10);\n                if (data < 1 || data > 31) {\n                    return false;\n                }\n                date.setUTCDate(data);\n                return true;\n            }\n        },\n        //  ,   ,      \n        'e': {\n            'reg': strRegNum2,\n            'make': function(date, data) {\n                data = parseInt(data, 10);\n                if (data < 1 || data > 31) {\n                    return false;\n                }\n                date.setUTCDate(data);\n                return true;\n            }\n        },\n\n        //     24- \n        'H': {\n            'reg': strRegNum2,\n            'make': function(date, data) {\n                data = parseInt(data, 10);\n                if (data < 0 || data > 23) {\n                    return false;\n                }\n                date.setUTCHours(data);\n                return true;\n            }\n        },\n        //     12- \n        'I': {\n            'reg': strRegNum2,\n            'make': function(date, data) {\n                data = parseInt(data, 10);\n                if (data < 1 || data > 12) {\n                    return false;\n                }\n\n                date.setUTCHours(date.getUTCHours() + data);\n                return true;\n            }\n        },\n        //     (  )\n        'm': {\n            'reg': strRegNum2,\n            'make': function(date, data) {\n                data = parseInt(data, 10);\n                if (data < 1 || data > 12) {\n                    return false;\n                }\n                date.setUTCMonth(data - 1);\n                return true;\n            }\n        },\n        //    (  )\n        'M': {\n            'reg': strRegNum2,\n            'make': function(date, data) {\n                data = parseInt(data, 10);\n                if (data < 0 || data > 59) {\n                    return false;\n                }\n                date.setUTCMinutes(data);\n                return true;\n            }\n        },\n        'n': '\\\\n',\n        // 'AM'  'PM'   ,     \n        'p': {\n            'reg': strRegStr,\n            'make': function(date, data) {\n                data = inArray.call(locale.P, data.toLowerCase());\n                if (data === -1) {\n                    return false;\n                }\n\n                if (data === 1) {\n                    date.setUTCHours(date.getUTCHours() + 12);\n                }\n\n                return true;\n            }\n        },\n        // 'am'  'pm'     \n        'P': {\n            'reg': strRegStr,\n            'make': function(date, data) {\n                data = inArray.call(locale.P, data.toLowerCase());\n                if (data === -1) {\n                    return false;\n                }\n\n                if (data === 1) {\n                    date.setUTCHours(date.getUTCHours() + 12);\n                }\n\n                return true;\n            }\n        },\n\n        //    (  )\n        'S': {\n            'reg': strRegNum2,\n            'make': function(date, data) {\n                data = parseInt(data, 10);\n                if (data < 0 || data > 60) {\n                    return false;\n                }\n                date.setUTCSeconds(data);\n                return true;\n            }\n        },\n        't': '\\\\t',\n        'u': '\\\\d',\n        'U': strRegNum2,\n        'w': '\\\\d',\n        'W': strRegNum2,\n        //  2  \n        'y': {\n            'reg': strRegNum2,\n            'make': function(date, data) {\n                data = parseInt(data, 10);\n                if (data < 0 || data > 99) {\n                    return false;\n                }\n\n                data = data + 100 * parseInt((new Date()).getUTCFullYear() / 100, 10);\n                date.setUTCFullYear(data);\n                return true;\n            }\n        },\n        // \n        'Y': {\n            'reg': '\\\\d{4}',\n            'make': function(date, data) {\n                data = parseInt(data, 10);\n                date.setUTCFullYear(data);\n                return true;\n            }\n        },\n        'z': {\n            'reg': '[+\\\\-]\\\\d{4}',\n            'make': function(date, data) {\n                var m = data.match(/^([+\\-])(\\d{2})(\\d{2})$/);\n                if (!m) {\n                    return false;\n                }\n\n                var offset = (parseInt(m[2], 10) * 60 + parseInt(m[3], 10)) * 60000;\n                if (m[1] === '+') {\n                    offset = -offset;\n                }\n\n                date.setTime(date.getTime() + offset);\n\n                return true;\n            }\n        },\n        'l': {\n            'reg': strRegNum2,\n            'make': function(date, data) {\n                data = parseInt(data, 10);\n                if (data < 1 || data > 12) {\n                    return false;\n                }\n\n                date.setUTCHours(date.getUTCHours() + data);\n                return true;\n            }\n        },\n        //    Unix\n        's': {\n            'reg': '\\\\d+',\n            'make': function(date, data) {\n                data = parseInt(data, 10);\n                date.setTime(data * 1000);\n                return true;\n            }\n        },\n\n\n\n        'c': locale.c,\n        'r': locale.r,\n        'R': '%H:%M',\n        'T': '%H:%M:%S',\n        'x': locale.x,\n        'X': locale.X,\n        'D': '%m/%d/%y',\n        'F': '%Y-%m-%d',\n\n\n        'Date_iso': '%Y-%m-%dT%H:%M:%S',\n        'Date_dBY_year_in_HM': locale.Date_dBY_year_in_HM,\n        'Date_dBY_year': locale.Date_dBY_year,\n        'Date_dBY': locale.Date_dBY,\n        'Date_dBA': locale.Date_dBA,\n        'Date_AdBY': locale.Date_AdBY,\n        'Date_df_in_HM': locale.Date_df_in_HM,\n        'Date_dfY': locale.Date_dfY,\n        'Date_dB_in_HM': locale.Date_dB_in_HM,\n        'Date_dmY__dot': '%d.%m.%Y',\n        'Date_df': locale.Date_df,\n        'Date_FT': '%F %T',\n        'Date_dmY__minus': '%d-%m-%Y'\n    };\n\n    strptime.parse = function(str, format, local) {\n        str = String(str);\n        format = String(format);\n\n        var loop = 5;\n        while (/%(Date_[a-zA-Z0-9_]+|[cDFrRTxX])/g.test(format) && loop) {\n            format = format.replace(/%(Date_[a-zA-Z0-9_]+|[cDFrRTxX])/, formatTransform);\n            loop--;\n        }\n\n        formatTransform.make = [];\n        var reg = format.replace(/%(([#\\^!~]{0,2})[aAbBfh]|([0\\-_]?)[degHImMSVWyl]|[GnpPtuUwYzZs%])/g, formatTransform);\n\n        var match = str.match(new RegExp(reg));\n\n        if (!match || !formatTransform.make.length) {\n            return null;\n        }\n\n        var date = new Date(Date.UTC(0, 0));\n\n        for (var i = 0, l = formatTransform.make.length; i < l; i++) {\n            var build = formatTransform.make[i];\n            if (!build[0](date, match[i + 1], build[1], build[2])) {\n                return null;\n            }\n        }\n\n        if (local) {\n            date.setTime(date.getTime() + date.getTimezoneOffset() * 60000);\n        }\n\n        return date;\n    };\n\n    function formatTransform(_, spec, mod, numPad, pos, str) {\n        spec = String(spec);\n        mod = String(mod);\n        spec = spec.replace(/^[#_0\\^\\-!~]+/, '');\n\n        var s = specifiers[spec];\n\n        if (!s) {\n            return _;\n        }\n\n        var genitive = false;\n        if (mod.indexOf('!') === -1 && spec.length === 1 && (mod.indexOf('~') > -1 || ('bBf'.indexOf(spec) > -1 && /%[0\\-_]?d[\\s]+$/.test(str.substr(0, pos))))) {\n\n            genitive = true;\n        }\n\n        if ((spec === 'I' || spec === 'l') && !/%[pP]/.test(str)) {\n            throw new Error('Undefined AM/PM');\n        }\n\n        // TODO    \n\n        switch (typeof(s)) {\n        case 'function':\n            return s();\n        case 'string':\n            return s;\n        case 'object':\n            formatTransform.make.push([s.make, mod, genitive]);\n            return '(' + s.reg + ')';\n        default:\n            return _;\n        }\n    }\n\n    /**\n     * @param {String} str\n     * @param {String} [mode]\n     * @returns {String}\n     */\n    function toLetterCaseReverse(str, mode) {\n        str = String(str);\n        mode = String(mode);\n\n        if (mode.indexOf('#') !== -1) {\n            return str.substr(0, 1).toUpperCase() + str.substr(1);\n        }\n\n        if (mode.indexOf('^') !== -1) {\n            return str.substr(0, 1) + str.substr(1).toLowerCase();\n        }\n\n        return str;\n    }\n\n}(strptime));\n\n\n}());\n\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/* WEBPACK VAR INJECTION */(function(global, process) {(function (global, undefined) {\n    \"use strict\";\n\n    if (global.setImmediate) {\n        return;\n    }\n\n    var nextHandle = 1; // Spec says greater than zero\n    var tasksByHandle = {};\n    var currentlyRunningATask = false;\n    var doc = global.document;\n    var registerImmediate;\n\n    function setImmediate(callback) {\n      // Callback can either be a function or a string\n      if (typeof callback !== \"function\") {\n        callback = new Function(\"\" + callback);\n      }\n      // Copy function arguments\n      var args = new Array(arguments.length - 1);\n      for (var i = 0; i < args.length; i++) {\n          args[i] = arguments[i + 1];\n      }\n      // Store and register the task\n      var task = { callback: callback, args: args };\n      tasksByHandle[nextHandle] = task;\n      registerImmediate(nextHandle);\n      return nextHandle++;\n    }\n\n    function clearImmediate(handle) {\n        delete tasksByHandle[handle];\n    }\n\n    function run(task) {\n        var callback = task.callback;\n        var args = task.args;\n        switch (args.length) {\n        case 0:\n            callback();\n            break;\n        case 1:\n            callback(args[0]);\n            break;\n        case 2:\n            callback(args[0], args[1]);\n            break;\n        case 3:\n            callback(args[0], args[1], args[2]);\n            break;\n        default:\n            callback.apply(undefined, args);\n            break;\n        }\n    }\n\n    function runIfPresent(handle) {\n        // From the spec: \"Wait until any invocations of this algorithm started before this one have completed.\"\n        // So if we're currently running a task, we'll need to delay this invocation.\n        if (currentlyRunningATask) {\n            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a\n            // \"too much recursion\" error.\n            setTimeout(runIfPresent, 0, handle);\n        } else {\n            var task = tasksByHandle[handle];\n            if (task) {\n                currentlyRunningATask = true;\n                try {\n                    run(task);\n                } finally {\n                    clearImmediate(handle);\n                    currentlyRunningATask = false;\n                }\n            }\n        }\n    }\n\n    function installNextTickImplementation() {\n        registerImmediate = function(handle) {\n            process.nextTick(function () { runIfPresent(handle); });\n        };\n    }\n\n    function canUsePostMessage() {\n        // The test against `importScripts` prevents this implementation from being installed inside a web worker,\n        // where `global.postMessage` means something completely different and can't be used for this purpose.\n        if (global.postMessage && !global.importScripts) {\n            var postMessageIsAsynchronous = true;\n            var oldOnMessage = global.onmessage;\n            global.onmessage = function() {\n                postMessageIsAsynchronous = false;\n            };\n            global.postMessage(\"\", \"*\");\n            global.onmessage = oldOnMessage;\n            return postMessageIsAsynchronous;\n        }\n    }\n\n    function installPostMessageImplementation() {\n        // Installs an event handler on `global` for the `message` event: see\n        // * https://developer.mozilla.org/en/DOM/window.postMessage\n        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages\n\n        var messagePrefix = \"setImmediate$\" + Math.random() + \"$\";\n        var onGlobalMessage = function(event) {\n            if (event.source === global &&\n                typeof event.data === \"string\" &&\n                event.data.indexOf(messagePrefix) === 0) {\n                runIfPresent(+event.data.slice(messagePrefix.length));\n            }\n        };\n\n        if (global.addEventListener) {\n            global.addEventListener(\"message\", onGlobalMessage, false);\n        } else {\n            global.attachEvent(\"onmessage\", onGlobalMessage);\n        }\n\n        registerImmediate = function(handle) {\n            global.postMessage(messagePrefix + handle, \"*\");\n        };\n    }\n\n    function installMessageChannelImplementation() {\n        var channel = new MessageChannel();\n        channel.port1.onmessage = function(event) {\n            var handle = event.data;\n            runIfPresent(handle);\n        };\n\n        registerImmediate = function(handle) {\n            channel.port2.postMessage(handle);\n        };\n    }\n\n    function installReadyStateChangeImplementation() {\n        var html = doc.documentElement;\n        registerImmediate = function(handle) {\n            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted\n            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.\n            var script = doc.createElement(\"script\");\n            script.onreadystatechange = function () {\n                runIfPresent(handle);\n                script.onreadystatechange = null;\n                html.removeChild(script);\n                script = null;\n            };\n            html.appendChild(script);\n        };\n    }\n\n    function installSetTimeoutImplementation() {\n        registerImmediate = function(handle) {\n            setTimeout(runIfPresent, 0, handle);\n        };\n    }\n\n    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.\n    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);\n    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;\n\n    // Don't get fooled by e.g. browserify environments.\n    if ({}.toString.call(global.process) === \"[object process]\") {\n        // For Node.js before 0.9\n        installNextTickImplementation();\n\n    } else if (canUsePostMessage()) {\n        // For non-IE10 modern browsers\n        installPostMessageImplementation();\n\n    } else if (global.MessageChannel) {\n        // For web workers, where supported\n        installMessageChannelImplementation();\n\n    } else if (doc && \"onreadystatechange\" in doc.createElement(\"script\")) {\n        // For IE 68\n        installReadyStateChangeImplementation();\n\n    } else {\n        // For older browsers\n        installSetTimeoutImplementation();\n    }\n\n    attachTo.setImmediate = setImmediate;\n    attachTo.clearImmediate = clearImmediate;\n}(typeof self === \"undefined\" ? typeof global === \"undefined\" ? this : global : self));\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(0), __webpack_require__(6)))\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports) {\n\n// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n\n/***/ }),\n/* 7 */\n/***/ (function(module, exports) {\n\nSk.asserts = {};\n\n/**\n * Cause assertion failure when condition is false.\n * \n * @param {*} condition condition to check\n * @param {string=} message error message\n */\nSk.asserts.assert = function (condition, message) {\n    return condition;\n};\nSk.exportSymbol(\"Sk.asserts.assert\", Sk.asserts.assert);\n\n/**\n * Cause assertion failure.\n * \n * @param {string=} message error message\n */\nSk.asserts.fail = function (message) {\n};\nSk.exportSymbol(\"Sk.asserts.fail\", Sk.asserts.fail);\n\n\n/***/ }),\n/* 8 */\n/***/ (function(module, exports) {\n\n/**\n * Base namespace for Skulpt. This is the only symbol that Skulpt adds to the\n * global namespace. Other user accessible symbols are noted and described\n * below.\n */\n\n/**\n *\n * Set various customizable parts of Skulpt.\n *\n * output: Replacable output redirection (called from print, etc.).\n * read: Replacable function to load modules with (called via import, etc.)\n * sysargv: Setable to emulate arguments to the script. Should be an array of JS\n * strings.\n * syspath: Setable to emulate PYTHONPATH environment variable (for finding\n * modules). Should be an array of JS strings.\n * nonreadopen: Boolean - set to true to allow non-read file operations\n * fileopen: Optional function to call any time a file is opened\n * filewrite: Optional function to call when writing to a file\n *\n * Any variables that aren't set will be left alone.\n */\n\nSk.bool_check = function(variable, name) {\n    if (variable === undefined || variable === null || typeof variable !== \"boolean\") {\n        throw new Error(\"must specify \" + name + \" and it must be a boolean\");\n    }\n};\n\nSk.python2 = {\n    print_function: false,\n    division: false,\n    absolute_import: null,\n    unicode_literals: false,\n    // skulpt specific\n    python3: false,\n    set_repr: false,\n    class_repr: false,\n    inherit_from_object: false,\n    super_args: false,\n    octal_number_literal: false,\n    bankers_rounding: false,\n    python_version: false,\n    dunder_next: false,\n    dunder_round: false,    \n    list_clear: false,\n    exceptions: false,\n    no_long_type: false,\n    ceil_floor_int: false,\n    l_suffix: true,\n    silent_octal_literal: true\n};\n\nSk.python3 = {\n    print_function: true,\n    division: true,\n    absolute_import: null,\n    unicode_literals: true,\n    // skulpt specific\n    python3: true,\n    set_repr: true,\n    class_repr: true,\n    inherit_from_object: true,\n    super_args: true,\n    octal_number_literal: true,\n    bankers_rounding: true,\n    python_version: true,\n    dunder_next: true,\n    dunder_round: true,\n    list_clear: true,\n    exceptions: true,\n    no_long_type: true,\n    ceil_floor_int: true,\n    l_suffix: false,\n    silent_octal_literal: false\n};\n\nSk.configure = function (options) {\n    \"use strict\";\n    Sk.output = options[\"output\"] || Sk.output;\n    Sk.asserts.assert(typeof Sk.output === \"function\");\n\n    Sk.debugout = options[\"debugout\"] || Sk.debugout;\n    Sk.asserts.assert(typeof Sk.debugout === \"function\");\n\n    Sk.uncaughtException = options[\"uncaughtException\"] || Sk.uncaughtException;\n    Sk.asserts.assert(typeof Sk.uncaughtException === \"function\");\n\n    Sk.read = options[\"read\"] || Sk.read;\n    Sk.asserts.assert(typeof Sk.read === \"function\");\n\n    Sk.nonreadopen = options[\"nonreadopen\"] || false;\n    Sk.asserts.assert(typeof Sk.nonreadopen === \"boolean\");\n\n    Sk.fileopen = options[\"fileopen\"] || undefined;\n    Sk.asserts.assert(typeof Sk.fileopen === \"function\" || typeof Sk.fileopen === \"undefined\");\n\n    Sk.filewrite = options[\"filewrite\"] || undefined;\n    Sk.asserts.assert(typeof Sk.filewrite === \"function\" || typeof Sk.filewrite === \"undefined\");\n\n    Sk.timeoutMsg = options[\"timeoutMsg\"] || Sk.timeoutMsg;\n    Sk.asserts.assert(typeof Sk.timeoutMsg === \"function\");\n    Sk.exportSymbol(\"Sk.timeoutMsg\", Sk.timeoutMsg);\n\n    Sk.sysargv = options[\"sysargv\"] || Sk.sysargv;\n    Sk.asserts.assert(Sk.isArrayLike(Sk.sysargv));\n\n    Sk.__future__ = options[\"__future__\"] || Sk.python2;\n\n    Sk.bool_check(Sk.__future__.print_function, \"Sk.__future__.print_function\");\n    Sk.bool_check(Sk.__future__.division, \"Sk.__future__.division\");\n    Sk.bool_check(Sk.__future__.unicode_literals, \"Sk.__future__.unicode_literals\");\n    Sk.bool_check(Sk.__future__.set_repr, \"Sk.__future__.set_repr\");\n    Sk.bool_check(Sk.__future__.class_repr, \"Sk.__future__.class_repr\");\n    Sk.bool_check(Sk.__future__.inherit_from_object, \"Sk.__future__.inherit_from_object\");\n    Sk.bool_check(Sk.__future__.super_args, \"Sk.__future__.super_args\");\n    Sk.bool_check(Sk.__future__.octal_number_literal, \"Sk.__future__.octal_number_literal\");\n    Sk.bool_check(Sk.__future__.bankers_rounding, \"Sk.__future__.bankers_rounding\");\n    Sk.bool_check(Sk.__future__.python_version, \"Sk.__future__.python_version\");\n    Sk.bool_check(Sk.__future__.dunder_next, \"Sk.__future__.dunder_next\");\n    Sk.bool_check(Sk.__future__.dunder_round, \"Sk.__future__.dunder_round\");\n    Sk.bool_check(Sk.__future__.list_clear, \"Sk.__future__.list_clear\");\n    Sk.bool_check(Sk.__future__.exceptions, \"Sk.__future__.exceptions\");\n    Sk.bool_check(Sk.__future__.no_long_type, \"Sk.__future__.no_long_type\");\n    Sk.bool_check(Sk.__future__.ceil_floor_int, \"Sk.__future__.ceil_floor_int\");\n    Sk.bool_check(Sk.__future__.silent_octal_literal, \"Sk.__future__.silent_octal_literal\");\n    Sk.bool_check(Sk.__future__.l_suffix, \"Sk.__future__.l_suffix\");\n\n    // in __future__ add checks for absolute_import\n\n    Sk.imageProxy = options[\"imageProxy\"] || \"http://localhost:8080/320x\";\n    Sk.asserts.assert(typeof Sk.imageProxy === \"string\" || typeof Sk.imageProxy === \"function\");\n\n    Sk.inputfun = options[\"inputfun\"] || Sk.inputfun;\n    Sk.asserts.assert(typeof Sk.inputfun === \"function\");\n\n    Sk.inputfunTakesPrompt = options[\"inputfunTakesPrompt\"] || false;\n    Sk.asserts.assert(typeof Sk.inputfunTakesPrompt === \"boolean\");\n\n    //add turtle_input\n    Sk.turtle_textinput = options[\"turtle_textinput\"] || Sk.turtle_textinput;\n    Sk.asserts.assert(typeof Sk.turtle_textinput === \"function\");\n\n    Sk.retainGlobals = options[\"retainglobals\"] || false;\n    Sk.asserts.assert(typeof Sk.retainGlobals === \"boolean\");\n\n    Sk.debugging = options[\"debugging\"] || false;\n    Sk.asserts.assert(typeof Sk.debugging === \"boolean\");\n\n    Sk.killableWhile = options[\"killableWhile\"] || false;\n    Sk.asserts.assert(typeof Sk.killableWhile === \"boolean\");\n\n    Sk.killableFor = options[\"killableFor\"] || false;\n    Sk.asserts.assert(typeof Sk.killableFor === \"boolean\");\n\n    Sk.signals = typeof options[\"signals\"] !== undefined ? options[\"signals\"] : null;\n    if (Sk.signals === true) {\n        Sk.signals = {\n            listeners: [],\n            addEventListener: function (handler) {\n                Sk.signals.listeners.push(handler);\n            },\n            removeEventListener: function (handler) {\n                var index = Sk.signals.listeners.indexOf(handler);\n                if (index >= 0) {\n                    Sk.signals.listeners.splice(index, 1); // Remove items\n                }\n            },\n            signal: function (signal, data) {\n                for (var i = 0; i < Sk.signals.listeners.length; i++) {\n                    Sk.signals.listeners[i].call(null, signal, data);\n                }\n            }\n        };\n    } else {\n        Sk.signals = null;\n    }\n    Sk.asserts.assert(typeof Sk.signals === \"object\");\n\n    Sk.breakpoints = options[\"breakpoints\"] || function() { return true; };\n    Sk.asserts.assert(typeof Sk.breakpoints === \"function\");\n\n    Sk.setTimeout = options[\"setTimeout\"];\n    if (Sk.setTimeout === undefined) {\n        if (typeof setTimeout === \"function\") {\n            Sk.setTimeout = function(func, delay) { setTimeout(func, delay); };\n        } else {\n            Sk.setTimeout = function(func, delay) { func(); };\n        }\n    }\n    Sk.asserts.assert(typeof Sk.setTimeout === \"function\");\n\n    if (\"execLimit\" in options) {\n        Sk.execLimit = options[\"execLimit\"];\n    }\n\n    if (\"yieldLimit\" in options) {\n        Sk.yieldLimit = options[\"yieldLimit\"];\n    }\n\n    if (options[\"syspath\"]) {\n        Sk.syspath = options[\"syspath\"];\n        Sk.asserts.assert(Sk.isArrayLike(Sk.syspath));\n        // assume that if we're changing syspath we want to force reimports.\n        // not sure how valid this is, perhaps a separate api for that.\n        Sk.realsyspath = undefined;\n        Sk.sysmodules = new Sk.builtin.dict([]);\n    }\n\n    Sk.misceval.softspace_ = false;\n\n    Sk.switch_version(\"round$\", Sk.__future__.dunder_round);\n    Sk.switch_version(\"next$\", Sk.__future__.dunder_next);\n    Sk.switch_version(\"clear$\", Sk.__future__.list_clear);\n\n    Sk.builtin.lng.tp$name = Sk.__future__.no_long_type ? \"int\" : \"long\";\n};\n\nSk.exportSymbol(\"Sk.configure\", Sk.configure);\n\n/*\n* Replaceable handler for uncaught exceptions\n*/\nSk.uncaughtException = function(err) {\n    throw err;\n};\n\n/*\n * Replaceable handler for uncaught exceptions\n */\nSk.uncaughtException = function(err) {\n    throw err;\n};\nSk.exportSymbol(\"Sk.uncaughtException\", Sk.uncaughtException);\n\n/*\n *      Replaceable message for message timeouts\n */\nSk.timeoutMsg = function () {\n    return \"Program exceeded run time limit.\";\n};\nSk.exportSymbol(\"Sk.timeoutMsg\", Sk.timeoutMsg);\n\n/*\n *  Hard execution timeout, throws an error. Set to null to disable\n */\nSk.execLimit = Number.POSITIVE_INFINITY;\n\n/*\n *  Soft execution timeout, returns a Suspension. Set to null to disable\n */\nSk.yieldLimit = Number.POSITIVE_INFINITY;\n\n/*\n * Replacable output redirection (called from print, etc).\n */\nSk.output = function (x) {\n};\n\n/*\n * Replacable function to load modules with (called via import, etc.)\n * todo; this should be an async api\n */\nSk.read = function (x) {\n    throw \"Sk.read has not been implemented\";\n};\n\n/*\n * Setable to emulate arguments to the script. Should be array of JS strings.\n */\nSk.sysargv = [];\n\n// lame function for sys module\nSk.getSysArgv = function () {\n    return Sk.sysargv;\n};\nSk.exportSymbol(\"Sk.getSysArgv\", Sk.getSysArgv);\n\n\n/**\n * Setable to emulate PYTHONPATH environment variable (for finding modules).\n * Should be an array of JS strings.\n */\nSk.syspath = [];\n\nSk.inBrowser = Sk.global[\"document\"] !== undefined;\n\n/**\n * Internal function used for debug output.\n * @param {...} args\n */\nSk.debugout = function (args) {\n};\n\n(function () {\n    // set up some sane defaults based on availability\n    if (Sk.global[\"write\"] !== undefined) {\n        Sk.output = Sk.global[\"write\"];\n    } else if (Sk.global[\"console\"] !== undefined && Sk.global[\"console\"][\"log\"] !== undefined) {\n        Sk.output = function (x) {\n            Sk.global[\"console\"][\"log\"](x);\n        };\n    } else if (Sk.global[\"print\"] !== undefined) {\n        Sk.output = Sk.global[\"print\"];\n    }\n    if (Sk.global[\"console\"] !== undefined && Sk.global[\"console\"][\"log\"] !== undefined) {\n        Sk.debugout = function (x) {\n            Sk.global[\"console\"][\"log\"](x);\n        };\n    } else if (Sk.global[\"print\"] !== undefined) {\n        Sk.debugout = Sk.global[\"print\"];\n    }\n}());\n\nSk.inputfun = function (args) {\n    return window.prompt(args);\n};\n// Sk add function\nSk.turtle_textinput = function(title, prompt){\n    return new Promise(function(resolve){\n        var cover = document.createElement(\"div\");\n        cover.id = \"cover\";\n        cover.style.position = \"fixed\";\n        cover.style.width = \"100%\";\n        cover.style.height = \"100%\";\n        cover.style.top = \"0px\";\n        cover.style.left = \"0px\";\n        cover.style.background = \"rgba(0,0,0,0.4)\";\n        cover.style.display = \"flex\";\n        cover.style.alignItems = \"center\";\n        cover.style.justifyContent = \"center\";\n        cover.style.zIndex = \"99\";\n        document.body.appendChild(cover);\n        var inputModal = document.createElement(\"div\");\n        inputModal.style.width = \"400px\";\n        inputModal.style.height = \"200px\";\n        inputModal.style.border=\"1px solid #666\";\n        inputModal.style.zIndex = \"1000\";\n        inputModal.style.background=\"#fff\";\n        cover.appendChild(inputModal);\n        var modal_header = document.createElement(\"div\");\n        var titleDom = document.createElement(\"span\");\n        titleDom.innerHTML = title;\n        var closeBtn = document.createElement(\"button\");\n        closeBtn.innerHTML = \"X\";\n        closeBtn.style.border = \"none\";\n        closeBtn.style.background = \"#cee2ff\";\n        modal_header.style.display=\"flex\";\n        modal_header.style.alignItems=\"center\";\n        modal_header.style.justifyContent=\"space-between\";\n        modal_header.style.paddingLeft = \"10px\";\n        modal_header.style.paddingRight = \"10px\";\n        modal_header.style.background = \"#cee2ff\";\n        modal_header.style.lineHeight = \"40px\";\n        modal_header.appendChild(titleDom);\n        modal_header.appendChild(closeBtn);\n        inputModal.appendChild(modal_header);\n        var modal_body = document.createElement(\"div\");\n        modal_body.style.textAlign=\"center\";\n        modal_body.style.marginBottom=\"20px\";\n        var content = document.createElement(\"span\");\n        content.innerHTML = prompt;\n        content.style.display=\"block\";\n        content.style.marginBottom=\"10px\";\n        content.style.marginTop=\"10px\";\n        modal_body.appendChild(content);\n        var input = document.createElement(\"input\");\n        input.type = \"text\";\n        input.id=\"text_input\";\n        input.style.width=\"180px\";\n        input.style.height=\"25px\";\n        input.style.border=\"1px solid #cee2ff\";\n        modal_body.appendChild(input);\n        inputModal.appendChild(modal_body);\n        var modal_footer = document.createElement(\"div\");\n        modal_footer.style.textAlign=\"center\";\n        var cancelBtn = document.createElement(\"button\");\n        cancelBtn.type=\"button\";\n        cancelBtn.id = \"cancel\";\n        cancelBtn.style.border=\"1px solid #898989\";\n        cancelBtn.style.width=\"60px\";\n        cancelBtn.style.height = \"30px\";\n        cancelBtn.style.fontWeight=\"bold\";\n        cancelBtn.innerHTML = \"\";\n        var primaryBtn = document.createElement(\"button\");\n        primaryBtn.type = \"button\";\n        primaryBtn.id = \"confirm\";\n        primaryBtn.innerHTML = \"\";\n        primaryBtn.style.marginLeft=\"40px\";\n        primaryBtn.style.width=\"60px\";\n        primaryBtn.style.height=\"30px\";\n        primaryBtn.style.background=\"#4d97ff\";\n        primaryBtn.style.fontWeight=\"bold\";\n        modal_footer.appendChild(cancelBtn);\n        modal_footer.appendChild(primaryBtn);\n        inputModal.appendChild(modal_footer);\n        var text_input = 0;\n        cancelBtn.onclick = function(){\n            document.body.removeChild(cover);\n            resolve(text_input);\n        };\n        closeBtn.onclick = function(){\n            document.body.removeChild(cover);\n            resolve(text_input);\n        };\n        primaryBtn.onclick = function(){\n            text_input = input.value;\n            document.body.removeChild(cover);\n            resolve(text_input);\n        };\n    });\n};\n\nSk.turtle_numinput = function(title, prompt, defaultVal, minval, maxval){\n    return new Promise(function(resolve){\n        var cover = document.createElement(\"div\");\n        cover.id = \"cover\";\n        cover.style.position = \"fixed\";\n        cover.style.width = \"100%\";\n        cover.style.height = \"100%\";\n        cover.style.top = \"0px\";\n        cover.style.left = \"0px\";\n        cover.style.background = \"rgba(0,0,0,0.4)\";\n        cover.style.display = \"flex\";\n        cover.style.alignItems = \"center\";\n        cover.style.justifyContent = \"center\";\n        cover.style.zIndex = \"99\";\n        document.body.appendChild(cover);\n        var inputModal = document.createElement(\"div\");\n        inputModal.style.width = \"400px\";\n        inputModal.style.height = \"200px\";\n        inputModal.style.border=\"1px solid #666\";\n        inputModal.style.zIndex = \"1000\";\n        inputModal.style.background=\"#fff\";\n        cover.appendChild(inputModal);\n        var modal_header = document.createElement(\"div\");\n        var titleDom = document.createElement(\"span\");\n        titleDom.innerHTML = title;\n        var closeBtn = document.createElement(\"button\");\n        closeBtn.innerHTML = \"X\";\n        closeBtn.style.border = \"none\";\n        closeBtn.style.background = \"#cee2ff\";\n        modal_header.style.display=\"flex\";\n        modal_header.style.alignItems=\"center\";\n        modal_header.style.justifyContent=\"space-between\";\n        modal_header.style.paddingLeft = \"10px\";\n        modal_header.style.paddingRight = \"10px\";\n        modal_header.style.background = \"#cee2ff\";\n        modal_header.style.lineHeight = \"40px\";\n        modal_header.appendChild(titleDom);\n        modal_header.appendChild(closeBtn);\n        inputModal.appendChild(modal_header);\n        var modal_body = document.createElement(\"div\");\n        modal_body.style.textAlign=\"center\";\n        modal_body.style.marginBottom=\"10px\";\n        var content = document.createElement(\"span\");\n        content.innerHTML = prompt;\n        content.style.display=\"block\";\n        content.style.marginBottom=\"10px\";\n        content.style.marginTop=\"10px\";\n        modal_body.appendChild(content);\n        var input = document.createElement(\"input\");\n        input.type = \"number\";\n        input.id=\"text_input\";\n        input.style.width=\"180px\";\n        input.style.height=\"25px\";\n        input.style.border=\"1px solid #cee2ff\";\n        input.value = defaultVal;\n        modal_body.appendChild(input);\n        inputModal.appendChild(modal_body);\n        var modal_footer = document.createElement(\"div\");\n        modal_footer.style.textAlign=\"center\";\n        var cancelBtn = document.createElement(\"button\");\n        cancelBtn.type=\"button\";\n        cancelBtn.id = \"cancel\";\n        cancelBtn.style.border=\"1px solid #898989\";\n        cancelBtn.style.width=\"60px\";\n        cancelBtn.style.height = \"30px\";\n        cancelBtn.style.fontWeight=\"bold\";\n        cancelBtn.innerHTML = \"\";\n        var primaryBtn = document.createElement(\"button\");\n        primaryBtn.type = \"button\";\n        primaryBtn.id = \"confirm\";\n        primaryBtn.innerHTML = \"\";\n        primaryBtn.style.marginLeft=\"40px\";\n        primaryBtn.style.width=\"60px\";\n        primaryBtn.style.height=\"30px\";\n        primaryBtn.style.background=\"#4d97ff\";\n        primaryBtn.style.fontWeight=\"bold\";\n        modal_footer.appendChild(cancelBtn);\n        modal_footer.appendChild(primaryBtn);\n        inputModal.appendChild(modal_footer);\n        var text_input = 0;\n        cancelBtn.onclick = function(){\n            document.body.removeChild(cover);\n            resolve(text_input);\n        };\n        closeBtn.onclick = function(){\n            document.body.removeChild(cover);\n            resolve(text_input);\n        };\n        primaryBtn.onclick = function(){\n            text_input = input.value;\n            var errorDom = document.getElementById(\"tip\");\n            if ((text_input < minval || text_input > maxval)){\n                if(!errorDom){\n                    var errorText = document.createElement(\"span\");\n                    errorText.id = \"tip\";\n                    errorText.innerHTML = \"\"+minval+\"~\"+maxval+\"\";\n                    errorText.style.fontSize=\"14px\";\n                    errorText.style.color=\"red\";\n                    errorText.style.display = \"block\";\n                    errorText.style.marginTop=\"5px\";\n                    modal_body.appendChild(errorText);\n                }\n                return;\n            } else if(text_input > minval && text_input < maxval && errorDom){\n                modal_body.removeChild(errorDom);\n            }\n            document.body.removeChild(cover);\n            resolve(text_input);\n        };\n    });\n};\n\n\n\n// Information about method names and their internal functions for\n// methods that differ (in visibility or name) between Python 2 and 3.\n//\n// Format:\n//   internal function: {\n//     \"classes\" : <array of affected classes>,\n//     2 : <visible Python 2 method name> or null if none\n//     3 : <visible Python 3 method name> or null if none\n//   },\n//   ...\n\nSk.setup_method_mappings = function () {\n    return {\n        \"round$\": {\n            \"classes\": [Sk.builtin.float_,\n                        Sk.builtin.int_,\n                        Sk.builtin.nmber],\n            2: null,\n            3: \"__round__\"\n        },\n        \"clear$\": {\n            \"classes\": [Sk.builtin.list],\n            2: null,\n            3: \"clear\"\n        },\n        \"next$\": {\n            \"classes\": [Sk.builtin.dict_iter_,\n                        Sk.builtin.list_iter_,\n                        Sk.builtin.set_iter_,\n                        Sk.builtin.str_iter_,\n                        Sk.builtin.tuple_iter_,\n                        Sk.builtin.generator,\n                        Sk.builtin.enumerate,\n                        Sk.builtin.iterator],\n            2: \"next\",\n            3: \"__next__\"\n        }\n    };\n};\n\nSk.switch_version = function (method_to_map, python3) {\n    var mapping, klass, classes, idx, len, newmeth, oldmeth, mappings;\n\n    mappings = Sk.setup_method_mappings();\n\n    mapping = mappings[method_to_map];\n\n    if (python3) {\n        newmeth = mapping[3];\n        oldmeth = mapping[2];\n    } else {\n        newmeth = mapping[2];\n        oldmeth = mapping[3];\n    }\n\n    classes = mapping[\"classes\"];\n    len = classes.length;\n    for (idx = 0; idx < len; idx++) {\n        klass = classes[idx];\n        if (oldmeth && klass.prototype.hasOwnProperty(oldmeth)) {\n            delete klass.prototype[oldmeth];\n        }\n        if (newmeth) {\n            klass.prototype[newmeth] = new Sk.builtin.func(klass.prototype[method_to_map]);\n        }\n    }\n};\n\nSk.exportSymbol(\"Sk.python3\", Sk.python3);\nSk.exportSymbol(\"Sk.inputfun\", Sk.inputfun);\nSk.exportSymbol(\"Sk.turtle_textinput\", Sk.turtle_textinput);\n\nSk.exportSymbol(\"Sk.__future__\", Sk.__future__);\nSk.exportSymbol(\"Sk.inputfun\", Sk.inputfun);\n\n\n/***/ }),\n/* 9 */\n/***/ (function(module, exports) {\n\nif(Sk.builtin === undefined) {\n    Sk.builtin = {};\n}\n\n/**\n * Maps Python dunder names to the Skulpt Javascript function names that\n * implement them.\n *\n * Note: __add__, __mul__, and __rmul__ can be used for either numeric or\n * sequence types. Here, they default to the numeric versions (i.e. nb$add,\n * nb$multiply, and nb$reflected_multiply). This works because Sk.abstr.binary_op_\n * checks for the numeric shortcuts and not the sequence shortcuts when computing\n * a binary operation.\n *\n * Because many of these functions are used in contexts in which Skulpt does not\n * [yet] handle suspensions, the assumption is that they must not suspend. However,\n * some of these built-in functions are acquiring 'canSuspend' arguments to signal\n * where this is not the case. These need to be spliced out of the argument list before\n * it is passed to python. Array values in this map contain [dunderName, argumentIdx],\n * where argumentIdx specifies the index of the 'canSuspend' boolean argument.\n *\n * @type {Object}\n */\nSk.dunderToSkulpt = {\n    \"__eq__\": \"ob$eq\",\n    \"__ne__\": \"ob$ne\",\n    \"__lt__\": \"ob$lt\",\n    \"__le__\": \"ob$le\",\n    \"__gt__\": \"ob$gt\",\n    \"__ge__\": \"ob$ge\",\n    \"__hash__\": \"tp$hash\",\n    \"__abs__\": \"nb$abs\",\n    \"__neg__\": \"nb$negative\",\n    \"__pos__\": \"nb$positive\",\n    \"__int__\": \"nb$int_\",\n    \"__long__\": \"nb$lng\",\n    \"__float__\": \"nb$float_\",\n    \"__add__\": \"nb$add\",\n    \"__radd__\": \"nb$reflected_add\",\n    \"__sub__\": \"nb$subtract\",\n    \"__rsub__\": \"nb$reflected_subtract\",\n    \"__mul__\": \"nb$multiply\",\n    \"__rmul__\": \"nb$reflected_multiply\",\n    \"__div__\": \"nb$divide\",\n    \"__rdiv__\": \"nb$reflected_divide\",\n    \"__floordiv__\": \"nb$floor_divide\",\n    \"__rfloordiv__\": \"nb$reflected_floor_divide\",\n    \"__mod__\": \"nb$remainder\",\n    \"__rmod__\": \"nb$reflected_remainder\",\n    \"__divmod__\": \"nb$divmod\",\n    \"__rdivmod__\": \"nb$reflected_divmod\",\n    \"__pow__\": \"nb$power\",\n    \"__rpow__\": \"nb$reflected_power\",\n    \"__contains__\": \"sq$contains\",\n    \"__len__\": [\"sq$length\", 1],\n    \"__get__\": [\"tp$descr_get\", 3],\n    \"__set__\": [\"tp$descr_set\", 3]\n};\n\n/**\n *\n * @constructor\n *\n * @param {*} name name or object to get type of, if only one arg\n *\n * @param {Sk.builtin.tuple=} bases\n *\n * @param {Object=} dict\n *\n *\n * This type represents the type of `type'. *Calling* an instance of\n * this builtin type named \"type\" creates class objects. The resulting\n * class objects will have various tp$xyz attributes on them that allow\n * for the various operations on that object.\n *\n * calling the type or calling an instance of the type? or both?\n */\nSk.builtin.type = function (name, bases, dict) {\n    var mro;\n    var obj;\n    var klass;\n    var v;\n    if (bases === undefined && dict === undefined) {\n        // 1 arg version of type()\n        // the argument is an object, not a name and returns a type object\n        obj = name;\n        return obj.ob$type;\n    } else {\n\n        // argument dict must be of type dict\n        if(dict.tp$name !== \"dict\") {\n            throw new Sk.builtin.TypeError(\"type() argument 3 must be dict, not \" + Sk.abstr.typeName(dict));\n        }\n\n        // checks if name must be string\n        if(!Sk.builtin.checkString(name)) {\n            throw new Sk.builtin.TypeError(\"type() argument 1 must be str, not \" + Sk.abstr.typeName(name));\n        }\n\n        // argument bases must be of type tuple\n        if(bases.tp$name !== \"tuple\") {\n            throw new Sk.builtin.TypeError(\"type() argument 2 must be tuple, not \" + Sk.abstr.typeName(bases));\n        }\n\n        // type building version of type\n\n        // dict is the result of running the classes code object\n        // (basically the dict of functions). those become the prototype\n        // object of the class).\n\n        /**\n        * The constructor is a stub, that gets called from object.__new__\n        * @constructor\n        */\n        klass = function (args, kws) {\n            var args_copy;\n\n            // Call up through the chain in case there's a built-in object\n            // whose constructor we need to initialise\n            if (klass.prototype.tp$base !== undefined) {\n                if (klass.prototype.tp$base.sk$klass) {\n                    klass.prototype.tp$base.call(this, args, kws);\n                } else {\n                    // Call super constructor if subclass of a builtin\n                    args_copy = args.slice();\n                    args_copy.unshift(klass, this);\n                    Sk.abstr.superConstructor.apply(undefined, args_copy);\n                }\n            }\n\n            this[\"$d\"] = new Sk.builtin.dict([]);\n            this[\"$d\"].mp$ass_subscript(new Sk.builtin.str(\"__dict__\"), this[\"$d\"]);\n        };\n\n        var _name = Sk.ffi.remapToJs(name); // unwrap name string to js for latter use\n\n        var inheritsBuiltin = false;\n\n        // Invoking the class object calls __new__() to generate a new instance,\n        // then __init__() to initialise it\n        klass.tp$call = function(args, kws) {\n            var newf = Sk.builtin.type.typeLookup(klass, Sk.builtin.str.$new), newargs;\n            var self;\n\n            args = args || [];\n            kws = kws || [];\n\n            if (newf === undefined || newf === Sk.builtin.object.prototype[\"__new__\"]) {\n                // No override -> just call the constructor\n                self = new klass(args, kws);\n                newf = undefined;\n            } else {\n                newargs = args.slice();\n                newargs.unshift(klass);\n                self = Sk.misceval.applyOrSuspend(newf, undefined, undefined, kws, newargs);\n            }\n\n            return Sk.misceval.chain(self, function(s) {\n                var init = Sk.builtin.type.typeLookup(s.ob$type, Sk.builtin.str.$init);\n\n                self = s; // in case __new__ suspended\n\n                if (init !== undefined) {\n                    args.unshift(self);\n                    return Sk.misceval.applyOrSuspend(init, undefined, undefined, kws, args);\n                } else if (newf === undefined && (args.length !== 0 || kws.length !== 0) && !inheritsBuiltin) {\n                    // We complain about spurious constructor arguments if neither __new__\n                    // nor __init__ were overridden\n                    throw new Sk.builtin.TypeError(\"__init__() got unexpected argument(s)\");\n                }\n            }, function(r) {\n                if (r !== Sk.builtin.none.none$ && r !== undefined) {\n                    throw new Sk.builtin.TypeError(\"__init__() should return None, not \" + Sk.abstr.typeName(r));\n                } else {\n                    return self;\n                }\n            });\n        };\n\n        if (bases.v.length === 0 && Sk.__future__.inherit_from_object) {\n            // new style class, inherits from object by default\n            bases.v.push(Sk.builtin.object);\n            Sk.abstr.setUpInheritance(_name, klass, Sk.builtin.object);\n        }\n\n        var parent, it, firstAncestor, builtin_bases = [];\n        // Set up inheritance from any builtins\n        for (it = bases.tp$iter(), parent = it.tp$iternext(); parent !== undefined; parent = it.tp$iternext()) {\n            if (firstAncestor === undefined) {\n                firstAncestor = parent;\n            }\n\n            while (parent.sk$klass && parent.prototype.tp$base) {\n                parent = parent.prototype.tp$base;\n            }\n\n            if (!parent.sk$klass && builtin_bases.indexOf(parent) < 0) {\n                builtin_bases.push(parent);\n                inheritsBuiltin = true;\n            }\n        }\n\n        if (builtin_bases.length > 1) {\n            throw new Sk.builtin.TypeError(\"Multiple inheritance with more than one builtin type is unsupported\");\n        }\n\n        // Javascript does not support multiple inheritance, so only the first\n        // base (if any) will directly inherit in Javascript\n        if (firstAncestor !== undefined) {\n            Sk.abstr.inherits(klass, firstAncestor);\n\n            if (firstAncestor.prototype instanceof Sk.builtin.object || firstAncestor === Sk.builtin.object) {\n                klass.prototype.tp$base = firstAncestor;\n            }\n        }\n\n        klass.prototype.tp$name = _name;\n        klass.prototype.ob$type = Sk.builtin.type.makeIntoTypeObj(_name, klass);\n\n        // set __module__ if not present (required by direct type(name, bases, dict) calls)\n        var module_lk = new Sk.builtin.str(\"__module__\");\n        if(dict.mp$lookup(module_lk) === undefined) {\n            dict.mp$ass_subscript(module_lk, Sk.globals[\"__name__\"]);\n        }\n\n        // copy properties into our klass object\n        // uses python iter methods\n        var k;\n        for (it = dict.tp$iter(), k = it.tp$iternext(); k !== undefined; k = it.tp$iternext()) {\n            v = dict.mp$subscript(k);\n            if (v === undefined) {\n                v = null;\n            }\n            klass.prototype[k.v] = v;\n            klass[k.v] = v;\n        }\n\n        klass[\"__class__\"] = klass;\n        klass[\"__name__\"] = name;\n        klass.sk$klass = true;\n        klass.prototype[\"$r\"] = function () {\n            var cname;\n            var mod;\n            var reprf = this.tp$getattr(Sk.builtin.str.$repr);\n            if (reprf !== undefined && reprf.im_func !== Sk.builtin.object.prototype[\"__repr__\"]) {\n                return Sk.misceval.apply(reprf, undefined, undefined, undefined, []);\n            }\n\n            if ((klass.prototype.tp$base !== undefined) &&\n                (klass.prototype.tp$base !== Sk.builtin.object) &&\n                (klass.prototype.tp$base.prototype[\"$r\"] !== undefined)) {\n                // If subclass of a builtin which is not object, use that class' repr\n                return klass.prototype.tp$base.prototype[\"$r\"].call(this);\n            } else {\n                // Else, use default repr for a user-defined class instance\n                mod = dict.mp$subscript(module_lk); // lookup __module__\n                cname = \"\";\n                if (mod) {\n                    cname = mod.v + \".\";\n                }\n                return new Sk.builtin.str(\"<\" + cname + _name + \" object>\");\n            }\n        };\n\n        klass.prototype.tp$setattr = function(pyName, data, canSuspend) {\n            var r, setf = Sk.builtin.object.prototype.GenericGetAttr.call(this, Sk.builtin.str.$setattr);\n            if (setf !== undefined) {\n                var f = /** @type {?} */ (setf);\n                r = Sk.misceval.callsimOrSuspendArray(f, [pyName, data]);\n                return canSuspend ? r : Sk.misceval.retryOptionalSuspensionOrThrow(r);\n            }\n\n            return Sk.builtin.object.prototype.GenericSetAttr.call(this, pyName, data, canSuspend);\n        };\n\n        klass.prototype.tp$getattr = function(pyName, canSuspend) {\n            var r, descr, /** @type {(Object|undefined)} */ getf;\n            // Find __getattribute__ on this type if we can\n            descr = Sk.builtin.type.typeLookup(klass, Sk.builtin.str.$getattribute);\n\n            if (descr !== undefined && descr !== null && descr.tp$descr_get !== undefined) {\n                getf = descr.tp$descr_get.call(descr, this, klass);\n            }\n\n            if (getf === undefined) {\n                getf = Sk.builtin.object.prototype.GenericPythonGetAttr.bind(null, this);\n            }\n\n            // Convert AttributeErrors back into 'undefined' returns to match the tp$getattr\n            // convention\n            r = Sk.misceval.tryCatch(function() {\n                return Sk.misceval.callsimOrSuspendArray(/** @type {Object} */ (getf), [pyName]);\n            }, function (e) {\n                if (e instanceof Sk.builtin.AttributeError) {\n                    return undefined;\n                } else {\n                    throw e;\n                }\n            });\n\n            return canSuspend ? r : Sk.misceval.retryOptionalSuspensionOrThrow(r);\n        };\n\n        klass.prototype.tp$str = function () {\n            var strf = this.tp$getattr(Sk.builtin.str.$str);\n            if (strf !== undefined && strf.im_func !== Sk.builtin.object.prototype[\"__str__\"]) {\n                return Sk.misceval.apply(strf, undefined, undefined, undefined, []);\n            }\n            if ((klass.prototype.tp$base !== undefined) &&\n                (klass.prototype.tp$base !== Sk.builtin.object) &&\n                (klass.prototype.tp$base.prototype.tp$str !== undefined)) {\n                // If subclass of a builtin which is not object, use that class' repr\n                return klass.prototype.tp$base.prototype.tp$str.call(this);\n            }\n            return this[\"$r\"]();\n        };\n        klass.prototype.tp$length = function (canSuspend) {\n            var r = Sk.misceval.chain(Sk.abstr.gattr(this, Sk.builtin.str.$len, canSuspend), function(lenf) {\n                return Sk.misceval.applyOrSuspend(lenf, undefined, undefined, undefined, []);\n            });\n            return canSuspend ? r : Sk.misceval.retryOptionalSuspensionOrThrow(r);\n        };\n        klass.prototype.tp$call = function (args, kw) {\n            return Sk.misceval.chain(this.tp$getattr(Sk.builtin.str.$call, true), function(callf) {\n                if (callf === undefined) {\n                    throw new Sk.builtin.TypeError(\"'\" + Sk.abstr.typeName(this) + \"' object is not callable\");\n                }\n                return Sk.misceval.applyOrSuspend(callf, undefined, undefined, kw, args);\n            });\n        };\n        klass.prototype.tp$iter = function () {\n            var iterf = this.tp$getattr(Sk.builtin.str.$iter);\n            if (iterf === undefined) {\n                throw new Sk.builtin.TypeError(\"'\" + Sk.abstr.typeName(this) + \"' object is not iterable\");\n            }\n            return Sk.misceval.callsimArray(iterf);\n        };\n        klass.prototype.tp$iternext = function (canSuspend) {\n            var self = this;\n            var next;\n\n            if (Sk.__future__.dunder_next) {\n                next = Sk.builtin.str.$next3;\n            } else {\n                next = Sk.builtin.str.$next2;\n            }\n            var r = Sk.misceval.chain(self.tp$getattr(next, canSuspend), function(iternextf) {\n                if (iternextf === undefined) {\n                    throw new Sk.builtin.TypeError(\"'\" + Sk.abstr.typeName(self) + \"' object is not iterable\");\n                }\n\n                return Sk.misceval.tryCatch(function() {\n                    return Sk.misceval.callsimOrSuspendArray(iternextf);\n                }, function(e) {\n                    if (e instanceof Sk.builtin.StopIteration) {\n                        return undefined;\n                    } else {\n                        throw e;\n                    }\n                });\n            });\n\n            return canSuspend ? r : Sk.misceval.retryOptionalSuspensionOrThrow(r);\n        };\n\n        klass.prototype.tp$getitem = function (key, canSuspend) {\n            var getf = this.tp$getattr(Sk.builtin.str.$getitem, canSuspend), r;\n            if (getf !== undefined) {\n                r = Sk.misceval.applyOrSuspend(getf, undefined, undefined, undefined, [key]);\n                return canSuspend ? r : Sk.misceval.retryOptionalSuspensionOrThrow(r);\n            }\n            throw new Sk.builtin.TypeError(\"'\" + Sk.abstr.typeName(this) + \"' object does not support indexing\");\n        };\n        klass.prototype.tp$setitem = function (key, value, canSuspend) {\n            var setf = this.tp$getattr(Sk.builtin.str.$setitem, canSuspend), r;\n            if (setf !== undefined) {\n                r = Sk.misceval.applyOrSuspend(setf, undefined, undefined, undefined, [key, value]);\n                return canSuspend ? r : Sk.misceval.retryOptionalSuspensionOrThrow(r);\n            }\n            throw new Sk.builtin.TypeError(\"'\" + Sk.abstr.typeName(this) + \"' object does not support item assignment\");\n        };\n\n        if (bases) {\n            //print(\"building mro for\", name);\n            //for (var i = 0; i < bases.length; ++i)\n            //print(\"base[\" + i + \"]=\" + bases[i].tp$name);\n            klass[\"$d\"] = new Sk.builtin.dict([]);\n            klass[\"$d\"].mp$ass_subscript(Sk.builtin.type.basesStr_, bases);\n            mro = Sk.builtin.type.buildMRO(klass);\n            klass[\"$d\"].mp$ass_subscript(Sk.builtin.type.mroStr_, mro);\n            klass.tp$mro = mro;\n            //print(\"mro result\", Sk.builtin.repr(mro).v);\n        }\n\n        // fix for class attributes\n        klass.tp$setattr = Sk.builtin.type.prototype.tp$setattr;\n\n        var shortcutDunder = function (skulpt_name, magic_name, magic_func, canSuspendIdx) {\n            klass.prototype[skulpt_name] = function () {\n                var canSuspend = false;\n                var len = arguments.length;\n                var args, i, j;\n                if ((canSuspendIdx !== null) && (canSuspendIdx <= len)) {\n                    args = new Array(len);\n                } else {\n                    args = new Array(len+1);\n                }\n\n                args[0] = this;\n                j = 1;\n                for (i = 0; i < len; i++) {\n                    if (i === (canSuspendIdx-1)) {\n                        canSuspend = arguments[i];\n                    } else {\n                        args[j] = arguments[i];\n                        j += 1;\n                    }\n                }\n\n                if (canSuspend) {\n                    return Sk.misceval.callsimOrSuspendArray(magic_func, args);\n                } else {\n                    return Sk.misceval.callsimArray(magic_func, args);\n                }\n            };\n        };\n\n        // Register skulpt shortcuts to magic methods defined by this class.\n        // Dynamically deflined methods (eg those returned by __getattr__())\n        // cannot be used by these magic functions; this is consistent with\n        // how CPython handles \"new-style\" classes:\n        // https://docs.python.org/2/reference/datamodel.html#special-method-lookup-for-old-style-classes\n        var dunder, skulpt_name, canSuspendIdx;\n        for (dunder in Sk.dunderToSkulpt) {\n            skulpt_name = Sk.dunderToSkulpt[dunder];\n            if (typeof(skulpt_name) === \"string\") {\n                canSuspendIdx = null;\n            } else {\n                canSuspendIdx = skulpt_name[1];\n                skulpt_name = skulpt_name[0];\n            }\n\n            if (klass[dunder]) {\n                // scope workaround\n                shortcutDunder(skulpt_name, dunder, klass[dunder], canSuspendIdx);\n            }\n        }\n\n        return klass;\n    }\n\n};\n\n/**\n *\n */\nSk.builtin.type.makeTypeObj = function (name, newedInstanceOfType) {\n    Sk.builtin.type.makeIntoTypeObj(name, newedInstanceOfType);\n    return newedInstanceOfType;\n};\n\nSk.builtin.type.makeIntoTypeObj = function (name, t) {\n    Sk.asserts.assert(name !== undefined);\n    Sk.asserts.assert(t !== undefined);\n    t.ob$type = Sk.builtin.type;\n    t.tp$name = name;\n    t[\"$r\"] = function () {\n        var ctype;\n        var mod = t.__module__;\n        var cname = \"\";\n        if (mod) {\n            cname = mod.v + \".\";\n        }\n        ctype = \"class\";\n        if (!mod && !t.sk$klass && !Sk.__future__.class_repr) {\n            ctype = \"type\";\n        }\n        return new Sk.builtin.str(\"<\" + ctype + \" '\" + cname + t.tp$name + \"'>\");\n    };\n    t.tp$str = undefined;\n    t.tp$getattr = Sk.builtin.type.prototype.tp$getattr;\n    t.tp$setattr = Sk.builtin.object.prototype.GenericSetAttr;\n    t.tp$richcompare = Sk.builtin.type.prototype.tp$richcompare;\n    t.sk$type = true;\n\n    return t;\n};\n\nSk.builtin.type.ob$type = Sk.builtin.type;\nSk.builtin.type.tp$name = \"type\";\nSk.builtin.type.sk$type = true;\nSk.builtin.type[\"$r\"] = function () {\n    if(Sk.__future__.class_repr) {\n        return new Sk.builtin.str(\"<class 'type'>\");\n    } else {\n        return new Sk.builtin.str(\"<type 'type'>\");\n    }\n};\n\n//Sk.builtin.type.prototype.tp$descr_get = function() { print(\"in type descr_get\"); };\n\n//Sk.builtin.type.prototype.tp$name = \"type\";\n\n// basically the same as GenericGetAttr except looks in the proto instead\nSk.builtin.type.prototype.tp$getattr = function (pyName, canSuspend) {\n    var res;\n    var tp = this;\n    var descr;\n    var f;\n\n    if (this[\"$d\"]) {\n        res = this[\"$d\"].mp$lookup(pyName);\n        if (res !== undefined) {\n            return res;\n        }\n    }\n\n    descr = Sk.builtin.type.typeLookup(tp, pyName);\n\n    //print(\"type.tpgetattr descr\", descr, descr.tp$name, descr.func_code, name);\n    if (descr !== undefined && descr !== null && descr.ob$type !== undefined) {\n        f = descr.tp$descr_get;\n        // todo;if (f && descr.tp$descr_set) // is a data descriptor if it has a set\n        // return f.call(descr, this, this.ob$type);\n    }\n\n    if (f) {\n        // non-data descriptor\n        return f.call(descr, Sk.builtin.none.none$, tp, canSuspend);\n    }\n\n    if (descr !== undefined) {\n        return descr;\n    }\n\n    return undefined;\n};\n\nSk.builtin.type.prototype.tp$setattr = function (pyName, value) {\n    // class attributes are direct properties of the object\n    var jsName = pyName.$jsstr();\n    this[jsName] = value;\n};\n\nSk.builtin.type.typeLookup = function (type, pyName) {\n    var mro = type.tp$mro;\n    var base;\n    var res;\n    var i;\n    var jsName = pyName.$jsstr();\n\n    // todo; probably should fix this, used for builtin types to get stuff\n    // from prototype\n    if (!mro) {\n        if (type.prototype) {\n            return type.prototype[jsName];\n        }\n        return undefined;\n    }\n\n    for (i = 0; i < mro.v.length; ++i) {\n        base = mro.v[i];\n        if (base.hasOwnProperty(jsName)) {\n            return base[jsName];\n        }\n        res = base[\"$d\"].mp$lookup(pyName);\n        if (res !== undefined) {\n            return res;\n        }\n        if (base.prototype && base.prototype[jsName] !== undefined) {\n            return base.prototype[jsName];\n        }\n    }\n\n    return undefined;\n};\n\nSk.builtin.type.mroMerge_ = function (seqs) {\n    /*\n     var tmp = [];\n     for (var i = 0; i < seqs.length; ++i)\n     {\n     tmp.push(new Sk.builtin.list(seqs[i]));\n     }\n     print(Sk.builtin.repr(new Sk.builtin.list(tmp)).v);\n     */\n    var seq;\n    var i;\n    var next;\n    var k;\n    var sseq;\n    var j;\n    var cand;\n    var cands;\n    var res = [];\n    for (; ;) {\n        for (i = 0; i < seqs.length; ++i) {\n            seq = seqs[i];\n            if (seq.length !== 0) {\n                break;\n            }\n        }\n        if (i === seqs.length) { // all empty\n            return res;\n        }\n        cands = [];\n        for (i = 0; i < seqs.length; ++i) {\n            seq = seqs[i];\n            //print(\"XXX\", Sk.builtin.repr(new Sk.builtin.list(seq)).v);\n            if (seq.length !== 0) {\n                cand = seq[0];\n                //print(\"CAND\", Sk.builtin.repr(cand).v);\n\n                /* eslint-disable */\n                OUTER:\n                    for (j = 0; j < seqs.length; ++j) {\n                        sseq = seqs[j];\n                        for (k = 1; k < sseq.length; ++k) {\n                            if (sseq[k] === cand) {\n                                break OUTER;\n                            }\n                        }\n                    }\n                /* eslint-enable */\n\n                // cand is not in any sequences' tail -> constraint-free\n                if (j === seqs.length) {\n                    cands.push(cand);\n                }\n            }\n        }\n\n        if (cands.length === 0) {\n            throw new Sk.builtin.TypeError(\"Inconsistent precedences in type hierarchy\");\n        }\n\n        next = cands[0];\n        // append next to result and remove from sequences\n        res.push(next);\n        for (i = 0; i < seqs.length; ++i) {\n            seq = seqs[i];\n            if (seq.length > 0 && seq[0] === next) {\n                seq.splice(0, 1);\n            }\n        }\n    }\n};\n\nSk.builtin.type.buildMRO_ = function (klass) {\n    // MERGE(klass + mro(bases) + bases)\n    var i;\n    var bases;\n    var all = [\n        [klass]\n    ];\n\n    //Sk.debugout(\"buildMRO for\", klass.tp$name);\n\n    var kbases = klass[\"$d\"].mp$subscript(Sk.builtin.type.basesStr_);\n    for (i = 0; i < kbases.v.length; ++i) {\n        all.push(Sk.builtin.type.buildMRO_(kbases.v[i]));\n    }\n\n    bases = [];\n    for (i = 0; i < kbases.v.length; ++i) {\n        bases.push(kbases.v[i]);\n    }\n    all.push(bases);\n\n    return Sk.builtin.type.mroMerge_(all);\n};\n\n/*\n * C3 MRO (aka CPL) linearization. Figures out which order to search through\n * base classes to determine what should override what. C3 does the \"right\n * thing\", and it's what Python has used since 2.3.\n *\n * Kind of complicated to explain, but not really that complicated in\n * implementation. Explanations:\n *\n * http://people.csail.mit.edu/jrb/goo/manual.43/goomanual_55.html\n * http://www.python.org/download/releases/2.3/mro/\n * http://192.220.96.201/dylan/linearization-oopsla96.html\n *\n * This implementation is based on a post by Samuele Pedroni on python-dev\n * (http://mail.python.org/pipermail/python-dev/2002-October/029176.html) when\n * discussing its addition to Python.\n */\nSk.builtin.type.buildMRO = function (klass) {\n    return new Sk.builtin.tuple(Sk.builtin.type.buildMRO_(klass));\n};\n\nSk.builtin.type.prototype.tp$richcompare = function (other, op) {\n    var r2;\n    var r1;\n    if (other.ob$type != Sk.builtin.type) {\n        return undefined;\n    }\n    if (!this[\"$r\"] || !other[\"$r\"]) {\n        return undefined;\n    }\n\n    r1 = this[\"$r\"]();\n    r2 = other[\"$r\"]();\n\n    return r1.tp$richcompare(r2, op);\n};\n\nSk.builtin.type.prototype[\"__format__\"] = function(self, format_spec) {\n    Sk.builtin.pyCheckArgsLen(\"__format__\", arguments.length, 1, 2);\n    return new Sk.builtin.str(self);\n};\n\nSk.builtin.type.pythonFunctions = [\"__format__\"];\n\n\n/***/ }),\n/* 10 */\n/***/ (function(module, exports) {\n\n/**\n * @namespace Sk.abstr\n *\n */\nSk.abstr = {};\n\n//\n// Number\n//\n\nSk.abstr.typeName = function (v) {\n    var vtypename;\n    if (v.tp$name !== undefined) {\n        vtypename = v.tp$name;\n    } else {\n        vtypename = \"<invalid type>\";\n    }\n    return vtypename;\n};\n\nSk.abstr.binop_type_error = function (v, w, name) {\n    var vtypename = Sk.abstr.typeName(v),\n        wtypename = Sk.abstr.typeName(w);\n\n    throw new Sk.builtin.TypeError(\"unsupported operand type(s) for \" + name + \": '\" + vtypename + \"' and '\" + wtypename + \"'\");\n};\n\nSk.abstr.unop_type_error = function (v, name) {\n    var vtypename = Sk.abstr.typeName(v),\n        uop = {\n            \"UAdd\"  : \"+\",\n            \"USub\"  : \"-\",\n            \"Invert\": \"~\"\n        }[name];\n\n    throw new Sk.builtin.TypeError(\"bad operand type for unary \" + uop + \": '\" + vtypename + \"'\");\n};\n\n/**\n * lookup and return the LHS object slot function method.  This coudl be either a builtin slot function or a dunder method defined by the user.\n * @param obj\n * @param name\n * @returns {Object|null|undefined}\n * @private\n */\nSk.abstr.boNameToSlotFuncLhs_ = function (obj, name) {\n    if (obj === null) {\n        return undefined;\n    }\n\n    switch (name) {\n        case \"Add\":\n            return obj.nb$add ? obj.nb$add : obj[\"__add__\"];\n        case \"Sub\":\n            return obj.nb$subtract ? obj.nb$subtract : obj[\"__sub__\"];\n        case \"Mult\":\n            return obj.nb$multiply ? obj.nb$multiply : obj[\"__mul__\"];\n        case \"Div\":\n            return obj.nb$divide ? obj.nb$divide : obj[\"__div__\"];\n        case \"FloorDiv\":\n            return obj.nb$floor_divide ? obj.nb$floor_divide : obj[\"__floordiv__\"];\n        case \"Mod\":\n            return obj.nb$remainder ? obj.nb$remainder : obj[\"__mod__\"];\n        case \"DivMod\":\n            return obj.nb$divmod ? obj.nb$divmod : obj[\"__divmod__\"];\n        case \"Pow\":\n            return obj.nb$power ? obj.nb$power : obj[\"__pow__\"];\n        case \"LShift\":\n            return obj.nb$lshift ? obj.nb$lshift : obj[\"__lshift__\"];\n        case \"RShift\":\n            return obj.nb$rshift ? obj.nb$rshift : obj[\"__rshift__\"];\n        case \"BitAnd\":\n            return obj.nb$and ? obj.nb$and : obj[\"__and__\"];\n        case \"BitXor\":\n            return obj.nb$xor ? obj.nb$xor : obj[\"__xor__\"];\n        case \"BitOr\":\n            return obj.nb$or ? obj.nb$or : obj[\"__or__\"];\n    }\n};\n\nSk.abstr.boNameToSlotFuncRhs_ = function (obj, name) {\n    if (obj === null) {\n        return undefined;\n    }\n\n    switch (name) {\n        case \"Add\":\n            return obj.nb$reflected_add ? obj.nb$reflected_add : obj[\"__radd__\"];\n        case \"Sub\":\n            return obj.nb$reflected_subtract ? obj.nb$reflected_subtract : obj[\"__rsub__\"];\n        case \"Mult\":\n            return obj.nb$reflected_multiply ? obj.nb$reflected_multiply : obj[\"__rmul__\"];\n        case \"Div\":\n            return obj.nb$reflected_divide ? obj.nb$reflected_divide : obj[\"__rdiv__\"];\n        case \"FloorDiv\":\n            return obj.nb$reflected_floor_divide ? obj.nb$reflected_floor_divide : obj[\"__rfloordiv__\"];\n        case \"Mod\":\n            return obj.nb$reflected_remainder ? obj.nb$reflected_remainder : obj[\"__rmod__\"];\n        case \"DivMod\":\n            return obj.nb$reflected_divmod ? obj.nb$reflected_divmod : obj[\"__rdivmod__\"];\n        case \"Pow\":\n            return obj.nb$reflected_power ? obj.nb$reflected_power : obj[\"__rpow__\"];\n        case \"LShift\":\n            return obj.nb$reflected_lshift ? obj.nb$reflected_lshift : obj[\"__rlshift__\"];\n        case \"RShift\":\n            return obj.nb$reflected_rshift ? obj.nb$reflected_rshift : obj[\"__rrshift__\"];\n        case \"BitAnd\":\n            return obj.nb$reflected_and ? obj.nb$reflected_and : obj[\"__rand__\"];\n        case \"BitXor\":\n            return obj.nb$reflected_xor ? obj.nb$reflected_xor : obj[\"__rxor__\"];\n        case \"BitOr\":\n            return obj.nb$reflected_or ? obj.nb$reflected_or : obj[\"__ror__\"];\n    }\n};\n\nSk.abstr.iboNameToSlotFunc_ = function (obj, name) {\n    switch (name) {\n        case \"Add\":\n            return obj.nb$inplace_add ? obj.nb$inplace_add : obj[\"__iadd__\"];\n        case \"Sub\":\n            return obj.nb$inplace_subtract ? obj.nb$inplace_subtract : obj[\"__isub__\"];\n        case \"Mult\":\n            return obj.nb$inplace_multiply ? obj.nb$inplace_multiply : obj[\"__imul__\"];\n        case \"Div\":\n            return obj.nb$inplace_divide ? obj.nb$inplace_divide : obj[\"__idiv__\"];\n        case \"FloorDiv\":\n            return obj.nb$inplace_floor_divide ? obj.nb$inplace_floor_divide : obj[\"__ifloordiv__\"];\n        case \"Mod\":\n            return obj.nb$inplace_remainder;\n        case \"Pow\":\n            return obj.nb$inplace_power;\n        case \"LShift\":\n            return obj.nb$inplace_lshift ? obj.nb$inplace_lshift : obj[\"__ilshift__\"];\n        case \"RShift\":\n            return obj.nb$inplace_rshift ? obj.nb$inplace_rshift : obj[\"__irshift__\"];\n        case \"BitAnd\":\n            return obj.nb$inplace_and;\n        case \"BitOr\":\n            return obj.nb$inplace_or;\n        case \"BitXor\":\n            return obj.nb$inplace_xor ? obj.nb$inplace_xor : obj[\"__ixor__\"];\n    }\n};\nSk.abstr.uoNameToSlotFunc_ = function (obj, name) {\n    if (obj === null) {\n        return undefined;\n    }\n    switch (name) {\n        case \"USub\":\n            return obj.nb$negative ? obj.nb$negative : obj[\"__neg__\"];\n        case \"UAdd\":\n            return obj.nb$positive ? obj.nb$positive : obj[\"__pos__\"];\n        case \"Invert\":\n            return obj.nb$invert ? obj.nb$invert : obj[\"__invert__\"];\n    }\n};\n\nSk.abstr.binary_op_ = function (v, w, opname) {\n    var wop;\n    var ret;\n    var vop;\n\n    // All Python inheritance is now enforced with Javascript inheritance\n    // (see Sk.abstr.setUpInheritance). This checks if w's type is a strict\n    // subclass of v's type\n    var w_is_subclass = w.constructor.prototype instanceof v.constructor;\n\n    // From the Python 2.7 docs:\n    //\n    // \"If the right operands type is a subclass of the left operands type and\n    // that subclass provides the reflected method for the operation, this\n    // method will be called before the left operands non-reflected method.\n    // This behavior allows subclasses to override their ancestors operations.\"\n    //\n    // -- https://docs.python.org/2/reference/datamodel.html#index-92\n\n    if (w_is_subclass) {\n        wop = Sk.abstr.boNameToSlotFuncRhs_(w, opname);\n        if (wop !== undefined) {\n            if (wop.call) {\n                ret = wop.call(w, v);\n            } else {\n                ret = Sk.misceval.callsimArray(wop, [w, v]);\n            }\n            if (ret !== undefined && ret !== Sk.builtin.NotImplemented.NotImplemented$) {\n                return ret;\n            }\n        }\n    }\n\n    vop = Sk.abstr.boNameToSlotFuncLhs_(v, opname);\n    if (vop !== undefined) {\n        if (vop.call) {\n            ret = vop.call(v, w);\n        } else {\n            ret = Sk.misceval.callsimArray(vop, [v, w]);\n        }\n        if (ret !== undefined && ret !== Sk.builtin.NotImplemented.NotImplemented$) {\n            return ret;\n        }\n    }\n    // Don't retry RHS if failed above\n    if (!w_is_subclass) {\n        wop = Sk.abstr.boNameToSlotFuncRhs_(w, opname);\n        if (wop !== undefined) {\n            if (wop.call) {\n                ret = wop.call(w, v);\n            } else {\n                ret = Sk.misceval.callsimArray(wop, [w, v]);\n            }\n            if (ret !== undefined && ret !== Sk.builtin.NotImplemented.NotImplemented$) {\n                return ret;\n            }\n        }\n    }\n    Sk.abstr.binop_type_error(v, w, opname);\n};\n\nSk.abstr.binary_iop_ = function (v, w, opname) {\n    var wop;\n    var ret;\n    var vop = Sk.abstr.iboNameToSlotFunc_(v, opname);\n    if (vop !== undefined) {\n        if (vop.call) {\n            ret = vop.call(v, w);\n        } else {  // assume that vop is an __xxx__ type method\n            ret = Sk.misceval.callsimArray(vop, [v, w]);\n        }\n        if (ret !== undefined && ret !== Sk.builtin.NotImplemented.NotImplemented$) {\n            return ret;\n        }\n    }\n    // If there wasn't an in-place operation, fall back to the binop\n    return Sk.abstr.binary_op_(v, w, opname);\n};\nSk.abstr.unary_op_ = function (v, opname) {\n    var ret;\n    var vop = Sk.abstr.uoNameToSlotFunc_(v, opname);\n    if (vop !== undefined) {\n        if (vop.call) {\n            ret = vop.call(v);\n        } else {  // assume that vop is an __xxx__ type method\n            ret = Sk.misceval.callsimArray(vop, [v]); //  added to be like not-in-place... is this okay?\n        }\n        if (ret !== undefined) {\n            return ret;\n        }\n    }\n    Sk.abstr.unop_type_error(v, opname);\n};\n\n//\n// handle upconverting a/b from number to long if op causes too big/small a\n// result, or if either of the ops are already longs\nSk.abstr.numOpAndPromote = function (a, b, opfn) {\n    var tmp;\n    var ans;\n    if (a === null || b === null) {\n        return undefined;\n    }\n\n    if (typeof a === \"number\" && typeof b === \"number\") {\n        ans = opfn(a, b);\n        // todo; handle float   Removed RNL (bugs in lng, and it should be a question of precision, not magnitude -- this was just wrong)\n        if ((ans > Sk.builtin.int_.threshold$ || ans < -Sk.builtin.int_.threshold$) && Math.floor(ans) === ans) {\n            return [Sk.builtin.lng.fromInt$(a), Sk.builtin.lng.fromInt$(b)];\n        } else {\n            return ans;\n        }\n    } else if (a === undefined || b === undefined) {\n        throw new Sk.builtin.NameError(\"Undefined variable in expression\");\n    }\n\n    if (a.constructor === Sk.builtin.lng) {\n        return [a, b];\n    } else if ((a.constructor === Sk.builtin.int_ ||\n                a.constructor === Sk.builtin.float_) &&\n                b.constructor === Sk.builtin.complex) {\n        // special case of upconverting nmber and complex\n        // can we use here the Sk.builtin.checkComplex() method?\n        tmp = new Sk.builtin.complex(a);\n        return [tmp, b];\n    } else if (a.constructor === Sk.builtin.int_ ||\n               a.constructor === Sk.builtin.float_) {\n        return [a, b];\n    } else if (typeof a === \"number\") {\n        tmp = Sk.builtin.assk$(a);\n        return [tmp, b];\n    } else {\n        return undefined;\n    }\n};\n\nSk.abstr.boNumPromote_ = {\n    \"Add\"     : function (a, b) {\n        return a + b;\n    },\n    \"Sub\"     : function (a, b) {\n        return a - b;\n    },\n    \"Mult\"    : function (a, b) {\n        return a * b;\n    },\n    \"Mod\"     : function (a, b) {\n        var m;\n        if (b === 0) {\n            throw new Sk.builtin.ZeroDivisionError(\"division or modulo by zero\");\n        }\n        m = a % b;\n        return ((m * b) < 0 ? (m + b) : m);\n    },\n    \"Div\"     : function (a, b) {\n        if (b === 0) {\n            throw new Sk.builtin.ZeroDivisionError(\"division or modulo by zero\");\n        } else {\n            return a / b;\n        }\n    },\n    \"FloorDiv\": function (a, b) {\n        if (b === 0) {\n            throw new Sk.builtin.ZeroDivisionError(\"division or modulo by zero\");\n        } else {\n            return Math.floor(a / b);\n        } // todo; wrong? neg?\n    },\n    \"Pow\"     : Math.pow,\n    \"BitAnd\"  : function (a, b) {\n        var m = a & b;\n        if (m < 0) {\n            m = m + 4294967296; // convert back to unsigned\n        }\n        return m;\n    },\n    \"BitOr\"   : function (a, b) {\n        var m = a | b;\n        if (m < 0) {\n            m = m + 4294967296; // convert back to unsigned\n        }\n        return m;\n    },\n    \"BitXor\"  : function (a, b) {\n        var m = a ^ b;\n        if (m < 0) {\n            m = m + 4294967296; // convert back to unsigned\n        }\n        return m;\n    },\n    \"LShift\"  : function (a, b) {\n        var m;\n        if (b < 0) {\n            throw new Sk.builtin.ValueError(\"negative shift count\");\n        }\n        m = a << b;\n        if (m > a) {\n            return m;\n        } else {\n            // Fail, this will get recomputed with longs\n            return a * Math.pow(2, b);\n        }\n    },\n    \"RShift\"  : function (a, b) {\n        var m;\n        if (b < 0) {\n            throw new Sk.builtin.ValueError(\"negative shift count\");\n        }\n        m = a >> b;\n        if ((a > 0) && (m < 0)) {\n            // fix incorrect sign extension\n            m = m & (Math.pow(2, 32 - b) - 1);\n        }\n        return m;\n    }\n};\n\nSk.abstr.numberBinOp = function (v, w, op) {\n    var tmp;\n    var numPromoteFunc = Sk.abstr.boNumPromote_[op];\n    if (numPromoteFunc !== undefined) {\n        tmp = Sk.abstr.numOpAndPromote(v, w, numPromoteFunc);\n        if (typeof tmp === \"number\") {\n            return tmp;\n        } else if (tmp !== undefined && tmp.constructor === Sk.builtin.int_) {\n            return tmp;\n        } else if (tmp !== undefined && tmp.constructor === Sk.builtin.float_) {\n            return tmp;\n        } else if (tmp !== undefined && tmp.constructor === Sk.builtin.lng) {\n            return tmp;\n        } else if (tmp !== undefined) {\n            v = tmp[0];\n            w = tmp[1];\n        }\n    }\n\n    return Sk.abstr.binary_op_(v, w, op);\n};\nSk.exportSymbol(\"Sk.abstr.numberBinOp\", Sk.abstr.numberBinOp);\n\nSk.abstr.numberInplaceBinOp = function (v, w, op) {\n    var tmp;\n    var numPromoteFunc = Sk.abstr.boNumPromote_[op];\n    if (numPromoteFunc !== undefined) {\n        tmp = Sk.abstr.numOpAndPromote(v, w, numPromoteFunc);\n        if (typeof tmp === \"number\") {\n            return tmp;\n        } else if (tmp !== undefined && tmp.constructor === Sk.builtin.int_) {\n            return tmp;\n        } else if (tmp !== undefined && tmp.constructor === Sk.builtin.float_) {\n            return tmp;\n        } else if (tmp !== undefined && tmp.constructor === Sk.builtin.lng) {\n            return tmp;\n        } else if (tmp !== undefined) {\n            v = tmp[0];\n            w = tmp[1];\n        }\n    }\n\n    return Sk.abstr.binary_iop_(v, w, op);\n};\nSk.exportSymbol(\"Sk.abstr.numberInplaceBinOp\", Sk.abstr.numberInplaceBinOp);\n\nSk.abstr.numberUnaryOp = function (v, op) {\n    var value;\n    if (op === \"Not\") {\n        return Sk.misceval.isTrue(v) ? Sk.builtin.bool.false$ : Sk.builtin.bool.true$;\n    } else if (v instanceof Sk.builtin.bool) {\n        value = Sk.builtin.asnum$(v);\n        if (op === \"USub\") {\n            return new Sk.builtin.int_(-value);\n        }\n        if (op === \"UAdd\") {\n            return new Sk.builtin.int_(value);\n        }\n        if (op === \"Invert\") {\n            return new Sk.builtin.int_(~value);\n        }\n    } else {\n        if (op === \"USub\" && v.nb$negative) {\n            return v.nb$negative();\n        }\n        if (op === \"UAdd\" && v.nb$positive) {\n            return v.nb$positive();\n        }\n        if (op === \"Invert\" && v.nb$invert) {\n            return v.nb$invert();\n        }\n    }\n\n    return Sk.abstr.unary_op_(v, op);\n};\nSk.exportSymbol(\"Sk.abstr.numberUnaryOp\", Sk.abstr.numberUnaryOp);\n\n//\n// Sequence\n//\n\nSk.abstr.fixSeqIndex_ = function (seq, i) {\n    i = Sk.builtin.asnum$(i);\n    if (i < 0 && seq.sq$length) {\n        i += seq.sq$length();\n    }\n    return i;\n};\n\n/**\n * @param {*} seq\n * @param {*} ob\n * @param {boolean=} canSuspend\n */\nSk.abstr.sequenceContains = function (seq, ob, canSuspend) {\n    var seqtypename;\n    var special;\n    var r;\n\n    if (seq.sq$contains) {\n        return seq.sq$contains(ob);\n    }\n\n    /**\n     *  Look for special method and call it, we have to distinguish between built-ins and\n     *  python objects\n     */\n    special = Sk.abstr.lookupSpecial(seq, Sk.builtin.str.$contains);\n    if (special != null) {\n        // method on builtin, provide this arg\n        return Sk.misceval.isTrue(Sk.misceval.callsimArray(special, [seq, ob]));\n    }\n\n    if (!Sk.builtin.checkIterable(seq)) {\n        seqtypename = Sk.abstr.typeName(seq);\n        throw new Sk.builtin.TypeError(\"argument of type '\" + seqtypename + \"' is not iterable\");\n    }\n\n    r = Sk.misceval.iterFor(Sk.abstr.iter(seq), function(i) {\n        if (Sk.misceval.richCompareBool(i, ob, \"Eq\")) {\n            return new Sk.misceval.Break(true);\n        } else {\n            return false;\n        }\n    }, false);\n\n    return canSuspend ? r : Sk.misceval.retryOptionalSuspensionOrThrow(r);\n};\n\nSk.abstr.sequenceConcat = function (seq1, seq2) {\n    var seq1typename;\n    if (seq1.sq$concat) {\n        return seq1.sq$concat(seq2);\n    }\n    seq1typename = Sk.abstr.typeName(seq1);\n    throw new Sk.builtin.TypeError(\"'\" + seq1typename + \"' object can't be concatenated\");\n};\n\nSk.abstr.sequenceGetIndexOf = function (seq, ob) {\n    var seqtypename;\n    var i, it;\n    var index;\n    if (seq.index) {\n        return Sk.misceval.callsimArray(seq.index, [seq, ob]);\n    }\n    if (Sk.builtin.checkIterable(seq)) {\n        index = 0;\n        for (it = Sk.abstr.iter(seq), i = it.tp$iternext();\n            i !== undefined; i = it.tp$iternext()) {\n            if (Sk.misceval.richCompareBool(ob, i, \"Eq\")) {\n                return new Sk.builtin.int_(index);\n            }\n            index += 1;\n        }\n        throw new Sk.builtin.ValueError(\"sequence.index(x): x not in sequence\");\n    }\n\n    seqtypename = Sk.abstr.typeName(seq);\n    throw new Sk.builtin.TypeError(\"argument of type '\" + seqtypename + \"' is not iterable\");\n};\n\nSk.abstr.sequenceGetCountOf = function (seq, ob) {\n    var seqtypename;\n    var i, it;\n    var count;\n    if (seq.count) {\n        return Sk.misceval.callsimArray(seq.count, [seq, ob]);\n    }\n    if (Sk.builtin.checkIterable(seq)) {\n        count = 0;\n        for (it = Sk.abstr.iter(seq), i = it.tp$iternext();\n            i !== undefined; i = it.tp$iternext()) {\n            if (Sk.misceval.richCompareBool(ob, i, \"Eq\")) {\n                count += 1;\n            }\n        }\n        return new Sk.builtin.int_(count);\n    }\n\n    seqtypename = Sk.abstr.typeName(seq);\n    throw new Sk.builtin.TypeError(\"argument of type '\" + seqtypename + \"' is not iterable\");\n};\n\nSk.abstr.sequenceGetItem = function (seq, i, canSuspend) {\n    var seqtypename;\n    if (seq.mp$subscript) {\n        return seq.mp$subscript(i);\n    }\n\n    seqtypename = Sk.abstr.typeName(seq);\n    throw new Sk.builtin.TypeError(\"'\" + seqtypename + \"' object is unsubscriptable\");\n};\n\nSk.abstr.sequenceSetItem = function (seq, i, x, canSuspend) {\n    var seqtypename;\n    if (seq.mp$ass_subscript) {\n        return seq.mp$ass_subscript(i, x);\n    }\n\n    seqtypename = Sk.abstr.typeName(seq);\n    throw new Sk.builtin.TypeError(\"'\" + seqtypename + \"' object does not support item assignment\");\n};\n\nSk.abstr.sequenceDelItem = function (seq, i) {\n    var seqtypename;\n    if (seq.sq$del_item) {\n        i = Sk.abstr.fixSeqIndex_(seq, i);\n        seq.sq$del_item(i);\n        return;\n    }\n\n    seqtypename = Sk.abstr.typeName(seq);\n    throw new Sk.builtin.TypeError(\"'\" + seqtypename + \"' object does not support item deletion\");\n};\n\nSk.abstr.sequenceRepeat = function (f, seq, n) {\n    var ntypename;\n    var count;\n    n = Sk.builtin.asnum$(n);\n    count = Sk.misceval.asIndex(n);\n    if (count === undefined) {\n        ntypename = Sk.abstr.typeName(n);\n        throw new Sk.builtin.TypeError(\"can't multiply sequence by non-int of type '\" + ntypename + \"'\");\n    }\n    return f.call(seq, n);\n};\n\nSk.abstr.sequenceGetSlice = function (seq, i1, i2) {\n    var seqtypename;\n    if (seq.sq$slice) {\n        i1 = Sk.abstr.fixSeqIndex_(seq, i1);\n        i2 = Sk.abstr.fixSeqIndex_(seq, i2);\n        return seq.sq$slice(i1, i2);\n    } else if (seq.mp$subscript) {\n        return seq.mp$subscript(new Sk.builtin.slice(i1, i2));\n    }\n\n    seqtypename = Sk.abstr.typeName(seq);\n    throw new Sk.builtin.TypeError(\"'\" + seqtypename + \"' object is unsliceable\");\n};\n\nSk.abstr.sequenceDelSlice = function (seq, i1, i2) {\n    var seqtypename;\n    if (seq.sq$del_slice) {\n        i1 = Sk.abstr.fixSeqIndex_(seq, i1);\n        i2 = Sk.abstr.fixSeqIndex_(seq, i2);\n        seq.sq$del_slice(i1, i2);\n        return;\n    }\n\n    seqtypename = Sk.abstr.typeName(seq);\n    throw new Sk.builtin.TypeError(\"'\" + seqtypename + \"' doesn't support slice deletion\");\n};\n\nSk.abstr.sequenceSetSlice = function (seq, i1, i2, x) {\n    var seqtypename;\n    if (seq.sq$ass_slice) {\n        i1 = Sk.abstr.fixSeqIndex_(seq, i1);\n        i2 = Sk.abstr.fixSeqIndex_(seq, i2);\n        seq.sq$ass_slice(i1, i2, x);\n    } else if (seq.mp$ass_subscript) {\n        seq.mp$ass_subscript(new Sk.builtin.slice(i1, i2), x);\n    } else {\n        seqtypename = Sk.abstr.typeName(seq);\n        throw new Sk.builtin.TypeError(\"'\" + seqtypename + \"' object doesn't support slice assignment\");\n    }\n};\n\n// seq - Python object to unpack\n// n   - JavaScript number of items to unpack\nSk.abstr.sequenceUnpack = function (seq, n) {\n    var res = [];\n    var it, i;\n\n    if (!Sk.builtin.checkIterable(seq)) {\n        throw new Sk.builtin.TypeError(\"'\" + Sk.abstr.typeName(seq) + \"' object is not iterable\");\n    }\n\n    for (it = Sk.abstr.iter(seq), i = it.tp$iternext();\n        (i !== undefined) && (res.length < n);\n        i = it.tp$iternext()) {\n        res.push(i);\n    }\n\n    if (res.length < n) {\n        throw new Sk.builtin.ValueError(\"need more than \" + res.length + \" values to unpack\");\n    }\n    if (i !== undefined) {\n        throw new Sk.builtin.ValueError(\"too many values to unpack\");\n    }\n\n    // Return Javascript array of items\n    return res;\n};\n\n// Unpack mapping into a JS array of alternating keys/values, possibly suspending\n// Skulpt uses a slightly grungy format for keyword args\n// into misceval.apply() and friends (alternating JS strings and Python values).\n// We should probably migrate that interface to using Python strings\n// at some point, but in the meantime we have this function to\n// unpack keyword dictionaries into our special format\nSk.abstr.mappingUnpackIntoKeywordArray = function(jsArray, pyMapping, pyCodeObject) {\n    return Sk.misceval.chain(pyMapping.tp$getattr(new Sk.builtin.str(\"items\")), function(itemfn) {\n        if (!itemfn) { throw new Sk.builtin.TypeError(\"Object is not a mapping\"); }\n        return Sk.misceval.callsimOrSuspend(itemfn);\n    }, function(items) {\n        return Sk.misceval.iterFor(Sk.abstr.iter(items), function(item) {\n            if (!item || !item.v) { throw new Sk.builtin.TypeError(\"Object is not a mapping; items() does not return tuples\"); }\n            if (!(item.v[0] instanceof Sk.builtin.str)) {\n                throw new Sk.builtin.TypeError((pyCodeObject.tp$name ? pyCodeObject.tp$name +\":\" : \"\") + \"keywords must be strings\");\n            }\n            jsArray.push(item.v[0].v, item.v[1]);\n        });\n    });\n};\n\n//\n// Object\n//\n\nSk.abstr.objectFormat = function (obj, format_spec) {\n    var meth; // PyObject\n    var result; // PyObject\n\n    // Find the (unbound!) __format__ method (a borrowed reference)\n    meth = Sk.abstr.lookupSpecial(obj, Sk.builtin.str.$format);\n    if (meth == null) {\n        throw new Sk.builtin.TypeError(\"Type \" + Sk.abstr.typeName(obj) + \" doesn't define __format__\");\n    }\n\n    // And call it\n    result = Sk.misceval.callsimArray(meth, [obj, format_spec]);\n    if (!Sk.builtin.checkString(result)) {\n        throw new Sk.builtin.TypeError(\"__format__ must return a str, not \" + Sk.abstr.typeName(result));\n    }\n\n    return result;\n};\n\nSk.abstr.objectAdd = function (a, b) {\n    var btypename;\n    var atypename;\n    if (a.nb$add) {\n        return a.nb$add(b);\n    }\n\n    atypename = Sk.abstr.typeName(a);\n    btypename = Sk.abstr.typeName(b);\n    throw new Sk.builtin.TypeError(\"unsupported operand type(s) for +: '\" + atypename + \"' and '\" + btypename + \"'\");\n};\n\n// in Python 2.6, this behaviour seems to be defined for numbers and bools (converts bool to int)\nSk.abstr.objectNegative = function (obj) {\n    var objtypename;\n    var obj_asnum = Sk.builtin.asnum$(obj); // this will also convert bool type to int\n\n    if (obj instanceof Sk.builtin.bool) {\n        obj = new Sk.builtin.int_(obj_asnum);\n    }\n\n    if (obj.nb$negative) {\n        return obj.nb$negative();\n    }\n\n    objtypename = Sk.abstr.typeName(obj);\n    throw new Sk.builtin.TypeError(\"bad operand type for unary -: '\" + objtypename + \"'\");\n};\n\n// in Python 2.6, this behaviour seems to be defined for numbers and bools (converts bool to int)\nSk.abstr.objectPositive = function (obj) {\n    var objtypename = Sk.abstr.typeName(obj);\n    var obj_asnum = Sk.builtin.asnum$(obj); // this will also convert bool type to int\n\n    if (obj instanceof Sk.builtin.bool) {\n        obj = new Sk.builtin.int_(obj_asnum);\n    }\n\n    if (obj.nb$negative) {\n        return obj.nb$positive();\n    }\n\n    throw new Sk.builtin.TypeError(\"bad operand type for unary +: '\" + objtypename + \"'\");\n};\n\nSk.abstr.objectDelItem = function (o, key) {\n    var otypename;\n    var keytypename;\n    var keyValue;\n    if (o !== null) {\n        if (o.mp$del_subscript) {\n            o.mp$del_subscript(key);\n            return;\n        }\n        if (o.sq$ass_item) {\n            keyValue = Sk.misceval.asIndex(key);\n            if (keyValue === undefined) {\n                keytypename = Sk.abstr.typeName(key);\n                throw new Sk.builtin.TypeError(\"sequence index must be integer, not '\" + keytypename + \"'\");\n            }\n            Sk.abstr.sequenceDelItem(o, keyValue);\n            return;\n        }\n        // if o is a slice do something else...\n    }\n\n    otypename = Sk.abstr.typeName(o);\n    throw new Sk.builtin.TypeError(\"'\" + otypename + \"' object does not support item deletion\");\n};\nSk.exportSymbol(\"Sk.abstr.objectDelItem\", Sk.abstr.objectDelItem);\n\nSk.abstr.objectGetItem = function (o, key, canSuspend) {\n    var otypename;\n    if (o !== null) {\n        if (o.tp$getitem) {\n            return o.tp$getitem(key, canSuspend);\n        } else if (o.mp$subscript) {\n            return o.mp$subscript(key, canSuspend);\n        } else if (Sk.misceval.isIndex(key) && o.sq$item) {\n            return Sk.abstr.sequenceGetItem(o, Sk.misceval.asIndex(key), canSuspend);\n        }\n    }\n\n    otypename = Sk.abstr.typeName(o);\n    throw new Sk.builtin.TypeError(\"'\" + otypename + \"' does not support indexing\");\n};\nSk.exportSymbol(\"Sk.abstr.objectGetItem\", Sk.abstr.objectGetItem);\n\nSk.abstr.objectSetItem = function (o, key, v, canSuspend) {\n    var otypename;\n    if (o !== null) {\n        if (o.tp$setitem) {\n            return o.tp$setitem(key, v, canSuspend);\n        } else if (o.mp$ass_subscript) {\n            return o.mp$ass_subscript(key, v, canSuspend);\n        } else if (Sk.misceval.isIndex(key) && o.sq$ass_item) {\n            return Sk.abstr.sequenceSetItem(o, Sk.misceval.asIndex(key), v, canSuspend);\n        }\n    }\n\n    otypename = Sk.abstr.typeName(o);\n    throw new Sk.builtin.TypeError(\"'\" + otypename + \"' does not support item assignment\");\n};\nSk.exportSymbol(\"Sk.abstr.objectSetItem\", Sk.abstr.objectSetItem);\n\n\nSk.abstr.gattr = function (obj, pyName, canSuspend) {\n    var ret, f;\n    var objname = Sk.abstr.typeName(obj);\n    var jsName = pyName.$jsstr();\n\n    if (obj === null) {\n        throw new Sk.builtin.AttributeError(\"'\" + objname + \"' object has no attribute '\" + jsName + \"'\");\n    }\n\n    if (obj.tp$getattr !== undefined) {\n        ret = obj.tp$getattr(pyName, canSuspend);\n    }\n\n    ret = Sk.misceval.chain(ret, function(r) {\n        if (r === undefined) {\n            throw new Sk.builtin.AttributeError(\"'\" + objname + \"' object has no attribute '\" + jsName + \"'\");\n        }\n        return r;\n    });\n\n    return canSuspend ? ret : Sk.misceval.retryOptionalSuspensionOrThrow(ret);\n};\nSk.exportSymbol(\"Sk.abstr.gattr\", Sk.abstr.gattr);\n\n\nSk.abstr.sattr = function (obj, pyName, data, canSuspend) {\n    var objname = Sk.abstr.typeName(obj), r, setf;\n    var jsName = pyName.$jsstr();\n\n    if (obj === null) {\n        throw new Sk.builtin.AttributeError(\"'\" + objname + \"' object has no attribute '\" + jsName + \"'\");\n    }\n\n    if (obj.tp$setattr !== undefined) {\n        return obj.tp$setattr(pyName, data, canSuspend);\n    } else {\n        throw new Sk.builtin.AttributeError(\"'\" + objname + \"' object has no attribute '\" + jsName + \"'\");\n    }\n};\nSk.exportSymbol(\"Sk.abstr.sattr\", Sk.abstr.sattr);\n\n\nSk.abstr.iternext = function (it, canSuspend) {\n    return it.tp$iternext(canSuspend);\n};\nSk.exportSymbol(\"Sk.abstr.iternext\", Sk.abstr.iternext);\n\n\n/**\n * Get the iterator for a Python object  This iterator could be one of the following.\n * This is the preferred mechanism for consistently getting the correct iterator.  You should\n * not just use tp$iter because that could lead to incorrect behavior of a user created class.\n *\n * - tp$iter\n * - A user defined `__iter__` method\n * - A user defined `__getitem__` method\n *\n * @param obj\n *\n * @throws {Sk.builtin.TypeError}\n * @returns {Object}\n */\n\nSk.abstr.iter = function(obj) {\n    var iter;\n    var getit;\n    var ret;\n\n    /**\n     * Builds an iterator around classes that have a __getitem__ method.\n     *\n     * @constructor\n     */\n    var seqIter = function (obj) {\n        this.idx = 0;\n        this.myobj = obj;\n        this.getitem = Sk.abstr.lookupSpecial(obj, Sk.builtin.str.$getitem);\n        this.tp$iternext = function () {\n            var ret;\n            try {\n                ret = Sk.misceval.callsimArray(this.getitem, [this.myobj, Sk.ffi.remapToPy(this.idx)]);\n            } catch (e) {\n                if (e instanceof Sk.builtin.IndexError || e instanceof Sk.builtin.StopIteration) {\n                    return undefined;\n                } else {\n                    throw e;\n                }\n            }\n            this.idx++;\n            return ret;\n        };\n    };\n\n    if (obj.tp$getattr) {\n        iter =  Sk.abstr.lookupSpecial(obj, Sk.builtin.str.$iter);\n        if (iter) {\n            ret = Sk.misceval.callsimArray(iter, [obj]);\n            if (ret.tp$iternext) {\n                return ret;\n            }\n        }\n    }\n    if (obj.tp$iter) {\n        try {  // catch and ignore not iterable error here.\n            ret = obj.tp$iter();\n            if (ret.tp$iternext) {\n                return ret;\n            }\n        } catch (e) { }\n    }\n    getit = Sk.abstr.lookupSpecial(obj, Sk.builtin.str.$getitem);\n    if (getit) {\n        // create internal iterobject if __getitem__\n        return new seqIter(obj);\n    }\n    throw new Sk.builtin.TypeError(\"'\" + Sk.abstr.typeName(obj) + \"' object is not iterable\");\n};\nSk.exportSymbol(\"Sk.abstr.iter\", Sk.abstr.iter);\n\n/**\n * Special method look up. First try getting the method via\n * internal dict and getattr. If getattr is not present (builtins)\n * try if method is defined on the object itself\n *\n * @returns {null|Object} Return null if not found or the function\n */\nSk.abstr.lookupSpecial = function(op, pyName) {\n    var res;\n    var obtp;\n    if (op.ob$type) {\n        obtp = op.ob$type;\n    } else {\n        return null;\n    }\n\n    return Sk.builtin.type.typeLookup(obtp, pyName);\n};\nSk.exportSymbol(\"Sk.abstr.lookupSpecial\", Sk.abstr.lookupSpecial);\n\n/**\n * Mark a class as unhashable and prevent its `__hash__` function from being called.\n * @param  {*} thisClass The class to mark as unhashable.\n * @return {undefined}\n */\nSk.abstr.markUnhashable = function (thisClass) {\n    var proto = thisClass.prototype;\n    proto.__hash__ = Sk.builtin.none.none$;\n    proto.tp$hash = Sk.builtin.none.none$;\n};\n\n/**\n * Code taken from goog.inherits\n *\n * Newer versions of the closure library add a \"base\"attribute,\n * which we don't want/need.  So, this code is the remainder of\n * the goog.inherits function.\n */\nSk.abstr.inherits = function (childCtor, parentCtor) {\n    /** @constructor */\n    function tempCtor() {}\n    tempCtor.prototype = parentCtor.prototype;\n    childCtor.superClass_ = parentCtor.prototype;\n    childCtor.prototype = new tempCtor();\n    /** @override */\n    childCtor.prototype.constructor = childCtor;\n};\n\n/**\n * Set up inheritance between two Python classes. This allows only for single\n * inheritance -- multiple inheritance is not supported by Javascript.\n *\n * Javascript's inheritance is prototypal. This means that properties must\n * be defined on the superclass' prototype in order for subclasses to inherit\n * them.\n *\n * ```\n * Sk.superclass.myProperty                 # will NOT be inherited\n * Sk.superclass.prototype.myProperty       # will be inherited\n * ```\n *\n * In order for a class to be subclassable, it must (directly or indirectly)\n * inherit from Sk.builtin.object so that it will be properly initialized in\n * {@link Sk.doOneTimeInitialization} (in src/import.js). Further, all Python\n * builtins should inherit from Sk.builtin.object.\n *\n * @param {string} childName The Python name of the child (subclass).\n * @param {*} child     The subclass.\n * @param {*} parent    The superclass.\n * @return {undefined}\n */\nSk.abstr.setUpInheritance = function (childName, child, parent) {\n    Sk.abstr.inherits(child, parent);\n    child.prototype.tp$base = parent;\n    child.prototype.tp$name = childName;\n    child.prototype.ob$type = Sk.builtin.type.makeIntoTypeObj(childName, child);\n};\n\n/**\n * Call the super constructor of the provided class, with the object `self` as\n * the `this` value of that constructor. Any arguments passed to this function\n * after `self` will be passed as-is to the constructor.\n *\n * @param  {*} thisClass The subclass.\n * @param  {Object} self      The instance of the subclas.\n * @param  {...?} args Arguments to pass to the constructor.\n * @return {undefined}\n */\nSk.abstr.superConstructor = function (thisClass, self, args) {\n    var argumentsForConstructor = Array.prototype.slice.call(arguments, 2);\n    thisClass.prototype.tp$base.apply(self, argumentsForConstructor);\n};\n\n\n/***/ }),\n/* 11 */\n/***/ (function(module, exports) {\n\n/**\n * @constructor\n * Sk.builtin.object\n *\n * @description\n * Constructor for Python object. All Python classes (builtin and user-defined)\n * should inherit from this class.\n *\n * @return {Sk.builtin.object} Python object\n */\nSk.builtin.object = function () {\n    if (!(this instanceof Sk.builtin.object)) {\n        return new Sk.builtin.object();\n    }\n\n    return this;\n};\n\nSk.builtin.object.prototype.__init__ = function __init__() {\n    return Sk.builtin.none.none$;\n};\nSk.builtin.object.prototype.__init__.co_kwargs = 1;\n\nSk.builtin._tryGetSubscript = function(dict, pyName) {\n    try {\n        return dict.mp$subscript(pyName);\n    } catch (x) {\n        return undefined;\n    }\n};\nSk.exportSymbol(\"Sk.builtin._tryGetSubscript\", Sk.builtin._tryGetSubscript);\n\n\n/**\n * Get an attribute\n * @param {Object} pyName Python string name of the attribute\n * @param {boolean=} canSuspend Can we return a suspension?\n * @return {undefined}\n */\nSk.builtin.object.prototype.GenericGetAttr = function (pyName, canSuspend) {\n    var res;\n    var f;\n    var descr;\n    var tp;\n    var dict;\n    var getf;\n    var jsName = pyName.$jsstr();\n\n    tp = this.ob$type;\n    Sk.asserts.assert(tp !== undefined, \"object has no ob$type!\");\n\n    dict = this[\"$d\"] || this.constructor[\"$d\"];\n    //print(\"getattr\", tp.tp$name, name);\n\n    // todo; assert? force?\n    if (dict) {\n        if (dict.mp$lookup) {\n            res = dict.mp$lookup(pyName);\n        } else if (dict.mp$subscript) {\n            res = Sk.builtin._tryGetSubscript(dict, pyName);\n        } else if (typeof dict === \"object\") {\n            res = dict[jsName];\n        }\n        if (res !== undefined) {\n            return res;\n        }\n    }\n\n    descr = Sk.builtin.type.typeLookup(tp, pyName);\n\n    // otherwise, look in the type for a descr\n    if (descr !== undefined && descr !== null) {\n        f = descr.tp$descr_get;\n        // todo - data descriptors (ie those with tp$descr_set too) get a different lookup priority\n\n        if (f) {\n            // non-data descriptor\n            return f.call(descr, this, this.ob$type, canSuspend);\n        }\n    }\n\n    if (descr !== undefined) {\n        return descr;\n    }\n\n    // OK, try __getattr__\n\n    descr = Sk.builtin.type.typeLookup(tp, Sk.builtin.str.$getattr);\n    if (descr !== undefined && descr !== null) {\n        f = descr.tp$descr_get;\n        if (f) {\n            getf = f.call(descr, this, this.ob$type);\n        } else {\n            getf = descr;\n        }\n\n        res = Sk.misceval.tryCatch(function() {\n            return Sk.misceval.callsimOrSuspendArray(getf, [pyName]);\n        }, function(e) {\n            if (e instanceof Sk.builtin.AttributeError) {\n                return undefined;\n            } else {\n                throw e;\n            }\n        });\n        return canSuspend ? res : Sk.misceval.retryOptionalSuspensionOrThrow(res);\n    }\n\n\n    return undefined;\n};\nSk.exportSymbol(\"Sk.builtin.object.prototype.GenericGetAttr\", Sk.builtin.object.prototype.GenericGetAttr);\n\nSk.builtin.object.prototype.GenericPythonGetAttr = function(self, pyName) {\n    var r = Sk.builtin.object.prototype.GenericGetAttr.call(self, pyName, true);\n    if (r === undefined) {\n        throw new Sk.builtin.AttributeError(pyName);\n    }\n    return r;\n};\nSk.exportSymbol(\"Sk.builtin.object.prototype.GenericPythonGetAttr\", Sk.builtin.object.prototype.GenericPythonGetAttr);\n\n/**\n * @param {Object} pyName\n * @param {Object} value\n * @param {boolean=} canSuspend\n * @return {undefined}\n */\nSk.builtin.object.prototype.GenericSetAttr = function (pyName, value, canSuspend) {\n    var objname = Sk.abstr.typeName(this);\n    var jsName = pyName.$jsstr();\n    var dict;\n    var tp = this.ob$type;\n    var descr;\n    var f;\n\n    Sk.asserts.assert(tp !== undefined, \"object has no ob$type!\");\n\n    dict = this[\"$d\"] || this.constructor[\"$d\"];\n\n    if (jsName == \"__class__\") {\n        if (value.tp$mro === undefined || value.tp$name === undefined) {\n            throw new Sk.builtin.TypeError(\n                \"attempted to assign non-class to __class__\");\n        }\n        this.ob$type = value;\n        this.tp$name = value.tp$name;\n        return;\n    }\n\n    descr = Sk.builtin.type.typeLookup(tp, pyName);\n\n    // otherwise, look in the type for a descr\n    if (descr !== undefined && descr !== null) {\n        f = descr.tp$descr_set;\n        // todo; is this the right lookup priority for data descriptors?\n        if (f) {\n            return f.call(descr, this, value, canSuspend);\n        }\n    }\n\n    if (dict.mp$ass_subscript) {\n        if (this instanceof Sk.builtin.object && !(this.ob$type.sk$klass) &&\n            dict.mp$lookup(pyName) === undefined) {\n            // Cannot add new attributes to a builtin object\n            throw new Sk.builtin.AttributeError(\"'\" + objname + \"' object has no attribute '\" + Sk.unfixReserved(jsName) + \"'\");\n        }\n        dict.mp$ass_subscript(pyName, value);\n    } else if (typeof dict === \"object\") {\n        dict[jsName] = value;\n    }\n};\nSk.exportSymbol(\"Sk.builtin.object.prototype.GenericSetAttr\", Sk.builtin.object.prototype.GenericSetAttr);\n\nSk.builtin.object.prototype.GenericPythonSetAttr = function(self, pyName, value) {\n    return Sk.builtin.object.prototype.GenericSetAttr.call(self, pyName, value, true);\n};\nSk.exportSymbol(\"Sk.builtin.object.prototype.GenericPythonSetAttr\", Sk.builtin.object.prototype.GenericPythonSetAttr);\n\nSk.builtin.object.prototype.HashNotImplemented = function () {\n    throw new Sk.builtin.TypeError(\"unhashable type: '\" + Sk.abstr.typeName(this) + \"'\");\n};\n\nSk.builtin.object.prototype.tp$getattr = Sk.builtin.object.prototype.GenericGetAttr;\nSk.builtin.object.prototype.tp$setattr = Sk.builtin.object.prototype.GenericSetAttr;\n\n// Although actual attribute-getting happens in pure Javascript via tp$getattr, classes\n// overriding __getattribute__ etc need to be able to call object.__getattribute__ etc from Python\nSk.builtin.object.prototype[\"__getattribute__\"] = Sk.builtin.object.prototype.GenericPythonGetAttr;\nSk.builtin.object.prototype[\"__setattr__\"] = Sk.builtin.object.prototype.GenericPythonSetAttr;\n\n/**\n * The name of this class.\n * @type {string}\n */\nSk.builtin.object.prototype.tp$name = \"object\";\n\n/**\n * The type object of this class.\n * @type {Sk.builtin.type|Object}\n */\nSk.builtin.object.prototype.ob$type = Sk.builtin.type.makeIntoTypeObj(\"object\", Sk.builtin.object);\nSk.builtin.object.prototype.ob$type.sk$klass = undefined;   // Nonsense for closure compiler\nSk.builtin.object.prototype.tp$descr_set = undefined;   // Nonsense for closure compiler\n\n/** Default implementations of dunder methods found in all Python objects */\n/**\n * Default implementation of __new__ just calls the class constructor\n * @name  __new__\n * @memberOf Sk.builtin.object.prototype\n * @instance\n */\nSk.builtin.object.prototype[\"__new__\"] = function (cls) {\n    Sk.builtin.pyCheckArgsLen(\"__new__\", arguments.length, 1, 1, false, false);\n\n    return new cls([], []);\n};\n\n/**\n * Python wrapper for `__repr__` method.\n * @name  __repr__\n * @memberOf Sk.builtin.object.prototype\n * @instance\n */\nSk.builtin.object.prototype[\"__repr__\"] = function (self) {\n    Sk.builtin.pyCheckArgsLen(\"__repr__\", arguments.length, 0, 0, false, true);\n\n    return self[\"$r\"]();\n};\n\n\nSk.builtin.object.prototype[\"__format__\"] = function (self, format_spec) {\n    var formatstr;\n    Sk.builtin.pyCheckArgsLen(\"__format__\", arguments.length, 2, 2);\n\n    if (!Sk.builtin.checkString(format_spec)) {\n        if (Sk.__future__.exceptions) {\n            throw new Sk.builtin.TypeError(\"format() argument 2 must be str, not \" + Sk.abstr.typeName(format_spec));\n        } else {\n            throw new Sk.builtin.TypeError(\"format expects arg 2 to be string or unicode, not \" + Sk.abstr.typeName(format_spec));\n        }\n    } else {\n        formatstr = Sk.ffi.remapToJs(format_spec);\n        if (formatstr !== \"\") {\n            throw new Sk.builtin.NotImplementedError(\"format spec is not yet implemented\");\n        }\n    }\n\n    return new Sk.builtin.str(self);\n};\n\n\n/**\n * Python wrapper for `__str__` method.\n * @name  __str__\n * @memberOf Sk.builtin.object.prototype\n * @instance\n */\nSk.builtin.object.prototype[\"__str__\"] = function (self) {\n    Sk.builtin.pyCheckArgsLen(\"__str__\", arguments.length, 0, 0, false, true);\n\n    return self[\"$r\"]();\n};\n\n/**\n * Python wrapper for `__hash__` method.\n * @name  __hash__\n * @memberOf Sk.builtin.object.prototype\n * @instance\n */\nSk.builtin.object.prototype[\"__hash__\"] = function (self) {\n    Sk.builtin.pyCheckArgsLen(\"__hash__\", arguments.length, 0, 0, false, true);\n\n    return self.tp$hash();\n};\n\n/**\n * Python wrapper for `__eq__` method.\n * @name  __eq__\n * @memberOf Sk.builtin.object.prototype\n * @instance\n */\nSk.builtin.object.prototype[\"__eq__\"] = function (self, other) {\n    Sk.builtin.pyCheckArgsLen(\"__eq__\", arguments.length, 1, 1, false, true);\n\n    return self.ob$eq(other);\n};\n\n/**\n * Python wrapper for `__ne__` method.\n * @name  __ne__\n * @memberOf Sk.builtin.object.prototype\n * @instance\n */\nSk.builtin.object.prototype[\"__ne__\"] = function (self, other) {\n    Sk.builtin.pyCheckArgsLen(\"__ne__\", arguments.length, 1, 1, false, true);\n\n    return self.ob$ne(other);\n};\n\n/**\n * Python wrapper for `__lt__` method.\n * @name  __lt__\n * @memberOf Sk.builtin.object.prototype\n * @instance\n */\nSk.builtin.object.prototype[\"__lt__\"] = function (self, other) {\n    Sk.builtin.pyCheckArgsLen(\"__lt__\", arguments.length, 1, 1, false, true);\n\n    return self.ob$lt(other);\n};\n\n/**\n * Python wrapper for `__le__` method.\n * @name  __le__\n * @memberOf Sk.builtin.object.prototype\n * @instance\n */\nSk.builtin.object.prototype[\"__le__\"] = function (self, other) {\n    Sk.builtin.pyCheckArgsLen(\"__le__\", arguments.length, 1, 1, false, true);\n\n    return self.ob$le(other);\n};\n\n/**\n * Python wrapper for `__gt__` method.\n * @name  __gt__\n * @memberOf Sk.builtin.object.prototype\n * @instance\n */\nSk.builtin.object.prototype[\"__gt__\"] = function (self, other) {\n    Sk.builtin.pyCheckArgsLen(\"__gt__\", arguments.length, 1, 1, false, true);\n\n    return self.ob$gt(other);\n};\n\n/**\n * Python wrapper for `__ge__` method.\n * @name  __ge__\n * @memberOf Sk.builtin.object.prototype\n * @instance\n */\nSk.builtin.object.prototype[\"__ge__\"] = function (self, other) {\n    Sk.builtin.pyCheckArgsLen(\"__ge__\", arguments.length, 1, 1, false, true);\n\n    return self.ob$ge(other);\n};\n\n/** Default implementations of Javascript functions used in dunder methods */\n\n/**\n * Return the string representation of this instance.\n *\n * Javascript function, returns Python object.\n *\n * @name  $r\n * @memberOf Sk.builtin.object.prototype\n * @return {Sk.builtin.str} The Python string representation of this instance.\n */\nSk.builtin.object.prototype[\"$r\"] = function () {\n    return new Sk.builtin.str(\"<object>\");\n};\n\nSk.builtin.hashCount = 1;\nSk.builtin.idCount = 1;\n\n/**\n * Return the hash value of this instance.\n *\n * Javascript function, returns Python object.\n *\n * @return {Sk.builtin.int_} The hash value\n */\nSk.builtin.object.prototype.tp$hash = function () {\n    if (!this.$savedHash_) {\n        this.$savedHash_ = new Sk.builtin.int_(Sk.builtin.hashCount++);\n    }\n\n    return this.$savedHash_;\n};\n\n/**\n * Perform equality check between this instance and a Python object (i.e. this == other).\n *\n * Implements `__eq__` dunder method.\n *\n * Javascript function, returns Python object.\n *\n * @param  {Object} other The Python object to check for equality.\n * @return {(Sk.builtin.bool|Sk.builtin.NotImplemented)} true if equal, false otherwise\n */\nSk.builtin.object.prototype.ob$eq = function (other) {\n    if (this === other) {\n        return Sk.builtin.bool.true$;\n    }\n\n    return Sk.builtin.NotImplemented.NotImplemented$;\n};\n\n/**\n * Perform non-equality check between this instance and a Python object (i.e. this != other).\n *\n * Implements `__ne__` dunder method.\n *\n * Javascript function, returns Python object.\n *\n * @param  {Object} other The Python object to check for non-equality.\n * @return {(Sk.builtin.bool|Sk.builtin.NotImplemented)} true if not equal, false otherwise\n */\nSk.builtin.object.prototype.ob$ne = function (other) {\n    if (this === other) {\n        return Sk.builtin.bool.false$;\n    }\n\n    return Sk.builtin.NotImplemented.NotImplemented$;\n};\n\n/**\n * Determine if this instance is less than a Python object (i.e. this < other).\n *\n * Implements `__lt__` dunder method.\n *\n * Javascript function, returns Python object.\n *\n * @param  {Object} other The Python object to compare.\n * @return {(Sk.builtin.bool|Sk.builtin.NotImplemented)} true if this < other, false otherwise\n */\nSk.builtin.object.prototype.ob$lt = function (other) {\n    return Sk.builtin.NotImplemented.NotImplemented$;\n};\n\n/**\n * Determine if this instance is less than or equal to a Python object (i.e. this <= other).\n *\n * Implements `__le__` dunder method.\n *\n * Javascript function, returns Python object.\n *\n * @param  {Object} other The Python object to compare.\n * @return {(Sk.builtin.bool|Sk.builtin.NotImplemented)} true if this <= other, false otherwise\n */\nSk.builtin.object.prototype.ob$le = function (other) {\n    return Sk.builtin.NotImplemented.NotImplemented$;\n};\n\n/**\n * Determine if this instance is greater than a Python object (i.e. this > other).\n *\n * Implements `__gt__` dunder method.\n *\n * Javascript function, returns Python object.\n *\n * @param  {Object} other The Python object to compare.\n * @return {(Sk.builtin.bool|Sk.builtin.NotImplemented)} true if this > other, false otherwise\n */\nSk.builtin.object.prototype.ob$gt = function (other) {\n    return Sk.builtin.NotImplemented.NotImplemented$;\n};\n\n/**\n * Determine if this instance is greater than or equal to a Python object (i.e. this >= other).\n *\n * Implements `__ge__` dunder method.\n *\n * Javascript function, returns Python object.\n *\n * @param  {Object} other The Python object to compare.\n * @return {(Sk.builtin.bool|Sk.builtin.NotImplemented)} true if this >= other, false otherwise\n */\nSk.builtin.object.prototype.ob$ge = function (other) {\n    return Sk.builtin.NotImplemented.NotImplemented$;\n};\n\n// Wrap the following functions in Sk.builtin.func once that class is initialized\n/**\n * Array of all the Python functions which are methods of this class.\n * @type {Array}\n */\nSk.builtin.object.pythonFunctions = [\n    \"__repr__\", \"__str__\", \"__hash__\",\n    \"__eq__\", \"__ne__\", \"__lt__\", \"__le__\",\n    \"__gt__\", \"__ge__\", \"__getattribute__\",\n    \"__setattr__\", \"__format__\"\n];\n\n/**\n * @constructor\n * Sk.builtin.none\n *\n * @extends {Sk.builtin.object}\n */\nSk.builtin.none = function () {\n    this.v = null;\n};\nSk.abstr.setUpInheritance(\"NoneType\", Sk.builtin.none, Sk.builtin.object);\n\n/** @override */\nSk.builtin.none.prototype[\"$r\"] = function () { return new Sk.builtin.str(\"None\"); };\n\n/** @override */\nSk.builtin.none.prototype.tp$hash = function () {\n    return new Sk.builtin.int_(0);\n};\n\n/**\n * Python None constant.\n * @type {Sk.builtin.none}\n */\nSk.builtin.none.none$ = new Sk.builtin.none();\n\n/**\n * @constructor\n * Sk.builtin.NotImplemented\n *\n * @extends {Sk.builtin.object}\n */\nSk.builtin.NotImplemented = function() { };\nSk.abstr.setUpInheritance(\"NotImplementedType\", Sk.builtin.NotImplemented, Sk.builtin.object);\n\n/** @override */\nSk.builtin.NotImplemented.prototype[\"$r\"] = function () { return new Sk.builtin.str(\"NotImplemented\"); };\n\n/**\n * Python NotImplemented constant.\n * @type {Sk.builtin.NotImplemented}\n */\nSk.builtin.NotImplemented.NotImplemented$ = new Sk.builtin.NotImplemented();\n\nSk.exportSymbol(\"Sk.builtin.none\", Sk.builtin.none);\nSk.exportSymbol(\"Sk.builtin.NotImplemented\", Sk.builtin.NotImplemented);\n\n\n/***/ }),\n/* 12 */\n/***/ (function(module, exports) {\n\n/**\n * @namespace Sk.builtin\n */\n\n\n/**\n * Check arguments to Python functions to ensure the correct number of\n * arguments are passed.\n *\n * @param {string} name the name of the function\n * @param {Object} args the args passed to the function\n * @param {number} minargs the minimum number of allowable arguments\n * @param {number=} maxargs optional maximum number of allowable\n * arguments (default: Infinity)\n * @param {boolean=} kwargs optional true if kwargs, false otherwise\n * (default: false)\n * @param {boolean=} free optional true if free vars, false otherwise\n * (default: false)\n */\nSk.builtin.pyCheckArgs = function (name, args, minargs, maxargs, kwargs, free) {\n    var nargs = args.length;\n    var msg = \"\";\n\n    if (maxargs === undefined) {\n        maxargs = Infinity;\n    }\n    if (kwargs) {\n        nargs -= 1;\n    }\n    if (free) {\n        nargs -= 1;\n    }\n    if ((nargs < minargs) || (nargs > maxargs)) {\n        if (minargs === maxargs) {\n            msg = name + \"() takes exactly \" + minargs + \" arguments\";\n        } else if (nargs < minargs) {\n            msg = name + \"() takes at least \" + minargs + \" arguments\";\n        } else {\n            msg = name + \"() takes at most \" + maxargs + \" arguments\";\n        }\n        msg += \" (\" + nargs + \" given)\";\n        throw new Sk.builtin.TypeError(msg);\n    }\n};\nSk.exportSymbol(\"Sk.builtin.pyCheckArgs\", Sk.builtin.pyCheckArgs);\n\n/**\n * Check arguments to Python functions to ensure the correct number of\n * arguments are passed.\n *\n * @param {string} name the name of the function\n * @param {number} nargs the args passed to the function\n * @param {number} minargs the minimum number of allowable arguments\n * @param {number=} maxargs optional maximum number of allowable\n * arguments (default: Infinity)\n * @param {boolean=} kwargs optional true if kwargs, false otherwise\n * (default: false)\n * @param {boolean=} free optional true if free vars, false otherwise\n * (default: false)\n */\nSk.builtin.pyCheckArgsLen = function (name, nargs, minargs, maxargs, kwargs, free) {\n    var msg = \"\";\n\n    if (maxargs === undefined) {\n        maxargs = Infinity;\n    }\n    if (kwargs) {\n        nargs -= 1;\n    }\n    if (free) {\n        nargs -= 1;\n    }\n    if ((nargs < minargs) || (nargs > maxargs)) {\n        if (minargs === maxargs) {\n            msg = name + \"() takes exactly \" + minargs + \" arguments\";\n        } else if (nargs < minargs) {\n            msg = name + \"() takes at least \" + minargs + \" arguments\";\n        } else {\n            msg = name + \"() takes at most \" + maxargs + \" arguments\";\n        }\n        msg += \" (\" + nargs + \" given)\";\n        throw new Sk.builtin.TypeError(msg);\n    }\n};\n\n/**\n * Check type of argument to Python functions.\n *\n * @param {string} name the name of the argument\n * @param {string} exptype string of the expected type name\n * @param {boolean} check truthy if type check passes, falsy otherwise\n */\nSk.builtin.pyCheckType = function (name, exptype, check) {\n    if (!check) {\n        throw new Sk.builtin.TypeError(name + \" must be a \" + exptype);\n    }\n};\nSk.exportSymbol(\"Sk.builtin.pyCheckType\", Sk.builtin.pyCheckType);\n\nSk.builtin.checkSequence = function (arg) {\n    return (arg !== null && arg.mp$subscript !== undefined);\n};\nSk.exportSymbol(\"Sk.builtin.checkSequence\", Sk.builtin.checkSequence);\n\n/**\n * Use this to test whether or not a Python object is iterable.  You should **not** rely\n * on the presence of tp$iter on the object as a good test, as it could be a user defined\n * class with `__iter__` defined or ``__getitem__``  This tests for all of those cases\n *\n * @param arg {Object}   A Python object\n * @returns {boolean} true if the object is iterable\n */\nSk.builtin.checkIterable = function (arg) {\n    var ret = false;\n    if (arg !== null ) {\n        try {\n            ret = Sk.abstr.iter(arg);\n            if (ret) {\n                return true;\n            } else {\n                return false;\n            }\n        } catch (e) {\n            if (e instanceof Sk.builtin.TypeError) {\n                return false;\n            } else {\n                throw e;\n            }\n        }\n    }\n    return ret;\n};\nSk.exportSymbol(\"Sk.builtin.checkIterable\", Sk.builtin.checkIterable);\n\nSk.builtin.checkCallable = function (obj) {\n    // takes care of builtin functions and methods, builtins\n    if (typeof obj === \"function\") {\n        return true;\n    }\n    // takes care of python function, methods and lambdas\n    if (obj instanceof Sk.builtin.func) {\n        return true;\n    }\n    // takes care of instances of methods\n    if (obj instanceof Sk.builtin.method) {\n        return true;\n    }\n    // go up the prototype chain to see if the class has a __call__ method\n    if (Sk.abstr.lookupSpecial(obj, Sk.builtin.str.$call) !== undefined) {\n        return true;\n    }\n    return false;\n};\n\nSk.builtin.checkNumber = function (arg) {\n    return (arg !== null && (typeof arg === \"number\" ||\n        arg instanceof Sk.builtin.int_ ||\n        arg instanceof Sk.builtin.float_ ||\n        arg instanceof Sk.builtin.lng));\n};\nSk.exportSymbol(\"Sk.builtin.checkNumber\", Sk.builtin.checkNumber);\n\n/**\n * Checks for complex type, delegates to internal method\n * Most skulpt users would search here!\n */\nSk.builtin.checkComplex = function (arg) {\n    return Sk.builtin.complex._complex_check(arg);\n};\nSk.exportSymbol(\"Sk.builtin.checkComplex\", Sk.builtin.checkComplex);\n\nSk.builtin.checkInt = function (arg) {\n    return (arg !== null) && ((typeof arg === \"number\" && arg === (arg | 0)) ||\n        arg instanceof Sk.builtin.int_ ||\n        arg instanceof Sk.builtin.lng);\n};\nSk.exportSymbol(\"Sk.builtin.checkInt\", Sk.builtin.checkInt);\n\nSk.builtin.checkFloat = function (arg) {\n    return (arg !== null) && (arg instanceof Sk.builtin.float_);\n};\nSk.exportSymbol(\"Sk.builtin.checkFloat\", Sk.builtin.checkFloat);\n\nSk.builtin.checkString = function (arg) {\n    return (arg !== null && arg.__class__ == Sk.builtin.str);\n};\nSk.exportSymbol(\"Sk.builtin.checkString\", Sk.builtin.checkString);\n\nSk.builtin.checkClass = function (arg) {\n    return (arg !== null && arg.sk$type);\n};\nSk.exportSymbol(\"Sk.builtin.checkClass\", Sk.builtin.checkClass);\n\nSk.builtin.checkBool = function (arg) {\n    return (arg instanceof Sk.builtin.bool);\n};\nSk.exportSymbol(\"Sk.builtin.checkBool\", Sk.builtin.checkBool);\n\nSk.builtin.checkNone = function (arg) {\n    return (arg instanceof Sk.builtin.none);\n};\nSk.exportSymbol(\"Sk.builtin.checkNone\", Sk.builtin.checkNone);\n\nSk.builtin.checkFunction = function (arg) {\n    return (arg !== null && arg.tp$call !== undefined);\n};\nSk.exportSymbol(\"Sk.builtin.checkFunction\", Sk.builtin.checkFunction);\n\n/**\n * @constructor\n * Sk.builtin.func\n *\n * @description\n * This function converts a Javascript function into a Python object that is callable.  Or just\n * think of it as a Python function rather than a Javascript function now.  This is an important\n * distinction in skulpt because once you have Python function you cannot just call it.\n * You must now use Sk.misceval.callsim to call the Python function.\n *\n * @param {Function} code the javascript implementation of this function\n * @param {Object=} globals the globals where this function was defined.\n * Can be undefined (which will be stored as null) for builtins. (is\n * that ok?)\n * @param {Object=} closure dict of free variables\n * @param {Object=} closure2 another dict of free variables that will be\n * merged into 'closure'. there's 2 to simplify generated code (one is $free,\n * the other is $cell)\n *\n * closure is the cell variables from the parent scope that we need to close\n * over. closure2 is the free variables in the parent scope that we also might\n * need to access.\n *\n * NOTE: co_varnames and co_name are defined by compiled code only, so we have\n * to access them via dict-style lookup for closure.\n *\n */\nSk.builtin.func = function (code, globals, closure, closure2) {\n    if (!(this instanceof Sk.builtin.func)) {\n        // otherwise it assigned .func_code and .func_globals somewhere and in certain\n        // situations that will cause a lot of strange errors.\n        throw new Error(\"builtin func should be called as a class with `new`\");\n    }\n\n    var k;\n    this.func_code = code;\n    this.func_globals = globals || null;\n    if (closure2 !== undefined) {\n        // todo; confirm that modification here can't cause problems\n        for (k in closure2) {\n            closure[k] = closure2[k];\n        }\n    }\n\n    this[\"$d\"] = {\n        \"__name__\": code[\"co_name\"],\n        \"__class__\": Sk.builtin.func\n    };\n    this.func_closure = closure;\n    this.tp$name = (this.func_code && this.func_code[\"co_name\"] && this.func_code[\"co_name\"].v) || this.func_code.name || \"<native JS>\";\n    return this;\n};\n\nSk.abstr.setUpInheritance(\"function\", Sk.builtin.func, Sk.builtin.object);\n\nSk.exportSymbol(\"Sk.builtin.func\", Sk.builtin.func);\n\nSk.builtin.func.prototype.tp$name = \"function\";\n\nSk.builtin.func.prototype.tp$descr_get = function (obj, objtype) {\n    Sk.asserts.assert(!(obj === undefined && objtype === undefined));\n    if (objtype && objtype.tp$name in Sk.builtin && Sk.builtin[objtype.tp$name] === objtype) {\n        // it's a builtin\n        return new Sk.builtin.method(this, obj, objtype, true);\n    }\n    return new Sk.builtin.method(this, obj, objtype);\n};\n\nSk.builtin.func.pythonFunctions = [\"__get__\"];\n\nSk.builtin.func.prototype.__get__ = function __get__(self, instance, owner) {\n    Sk.builtin.pyCheckArgsLen(\"__get__\", arguments.length, 1, 2, false, true);\n    if (instance === Sk.builtin.none.none$ && owner === Sk.builtin.none.none$) {\n        throw new Sk.builtin.TypeError(\"__get__(None, None) is invalid\");\n    }\n\n    return self.tp$descr_get(instance, owner);\n};\n\nSk.builtin.func.prototype.tp$getname = function () {\n    return (this.func_code && this.func_code[\"co_name\"] && this.func_code[\"co_name\"].v) || this.func_code.name || \"<native JS>\";\n};\n\nSk.builtin.func.prototype.tp$call = function (posargs, kw) {\n    // This function is a logical Javascript port of\n    // _PyEval_EvalCodeWithName, and follows its logic.\n\n    let co_argcount = this.func_code.co_argcount;\n\n    if (co_argcount === undefined) {\n        co_argcount = this.func_code.co_varnames ? this.func_code.co_varnames.length : posargs.length;\n    }\n    let varnames = this.func_code.co_varnames || [];\n    let co_kwonlyargcount = this.func_code.co_kwonlyargcount || 0;\n    let totalArgs = co_argcount + co_kwonlyargcount;\n    let kwargs;\n\n    /* Create a NOT-a-dictionary for keyword parameters (**kwags) */\n    if (this.func_code.co_kwargs) {\n        kwargs = [];\n    }\n\n    /* Copy positional arguments into arguments to our JS function*/\n    let nposargs = posargs.length;\n    let args = (posargs.length <= co_argcount) ? posargs : posargs.slice(0, co_argcount);\n\n\n    /* Pack other positional arguments into the *args argument */\n    if (this.func_code.co_varargs) {\n        let vararg = (posargs.length > args.length) ? posargs.slice(args.length) : [];\n        args[totalArgs] = new Sk.builtin.tuple(vararg);\n    } else if (nposargs > co_argcount) {\n        throw new Sk.builtin.TypeError(this.tp$getname() + \"() takes \" + co_argcount + \" positional argument\" + (co_argcount == 1 ? \"\" : \"s\") + \" but \" + nposargs + (nposargs == 1 ? \" was \" : \" were \") + \" given\");\n    }\n\n    /* Handle keyword arguments */\n    if (kw) {\n        if (this.func_code[\"no_kw\"]) {\n            throw new Sk.builtin.TypeError(this.tp$getname() + \"() takes no keyword arguments\");\n        }\n\n        for (let i = 0; i < kw.length; i += 2) {\n            let name = kw[i]; // JS string\n            let value = kw[i+1]; // Python value\n            let idx = varnames.indexOf(name);\n\n            if (idx >= 0) {\n                if (args[idx] !== undefined) {\n                    throw new Sk.builtin.TypeError(this.tp$getname() + \"() got multiple values for argument '\" + name + \"'\");\n                }\n                args[idx] = value;\n            } else if (kwargs) {\n                kwargs.push(new Sk.builtin.str(name), value);\n            } else {\n                throw new Sk.builtin.TypeError(this.tp$getname() + \"() got an unexpected keyword argument '\" + name + \"'\");\n            }\n        }\n    }\n\n    /* \"Check the number of positional arguments\" (which only checks for too many)\n       has been handled before keywords */\n\n    /* Add missing positional arguments (copy default values from defs)\n       (also checks for missing args where no defaults) */\n    {\n        let defaults = this.func_code.$defaults || [];\n        let i = 0, missing = [], missingUnnamed = false;\n        // Positional args for which we *don't* have a default\n        let defaultStart = co_argcount - defaults.length;\n        for (; i < defaultStart; i++) {\n            if (args[i] === undefined) {\n                missing.push(varnames[i]);\n                if (varnames[i] === undefined) {\n                    missingUnnamed = true;\n                }\n            }\n        }\n        if (missing.length != 0 && (this.func_code.co_argcount || this.func_code.co_varnames)) {\n            throw new Sk.builtin.TypeError(this.tp$getname() + \"() missing \" + missing.length + \" required argument\" + (missing.length==1?\"\":\"s\") + (missingUnnamed ? \"\" : (\": \" + missing.join(\", \"))));\n        }\n        for (; i < co_argcount; i++) {\n            if (args[i] === undefined) {\n                args[i] = defaults[i - defaultStart];\n            }\n        }\n    }\n\n    /* Add missing keyword arguments (copy default values from kwdefs) */\n\n    if (co_kwonlyargcount > 0) {\n        let missing = [];\n        let kwdefs = this.func_code.$kwdefs;\n\n        for (let i = co_argcount; i < totalArgs; i++) {\n            if (args[i] === undefined) {\n                if (kwdefs[i-co_argcount] !== undefined) {\n                    args[i] = kwdefs[i-co_argcount];\n                } else {\n                    missing.push(varnames[i]);\n                }\n            }\n        }\n        if (missing.length !== 0) {\n            throw new Sk.builtin.TypeError(this.tp$getname() + \"() missing \" + missing.length + \" required keyword argument\" + (missing.length==1?\"\":\"s\") + \": \" + missing.join(\", \"));\n        }\n    }\n\n    if (this.func_closure) {\n        // todo; OK to modify?\n        if (varnames) {\n            // Make sure all default arguments are in args before adding closure\n            for (let i = args.length; i < varnames.length; i++) {\n                args.push(undefined);\n            }\n        }\n\n        args.push(this.func_closure);\n    }\n\n    if (kwargs) {\n        args.unshift(kwargs);\n    }\n\n    // note: functions expect 'this' to be globals to avoid having to\n    // slice/unshift onto the main args\n    return this.func_code.apply(this.func_globals, args);\n\n};\n\nSk.builtin.func.prototype[\"$r\"] = function () {\n    var name = this.tp$getname();\n    if (name in Sk.builtins && this === Sk.builtins[name]) {\n        return new Sk.builtin.str(\"<built-in function \" + name + \">\");\n    } else {\n        return new Sk.builtin.str(\"<function \" + name + \">\");\n    }\n};\n\n\n/***/ }),\n/* 13 */\n/***/ (function(module, exports) {\n\n/**\n * builtins are supposed to come from the __builtin__ module, but we don't do\n * that yet.\n * todo; these should all be func objects too, otherwise str() of them won't\n * work, etc.\n */\n\nSk.builtin.range = function range (start, stop, step) {\n    this.start = start;\n    this.stop = stop;\n    this.step = step;\n\n    var ret = [];\n    var i;\n\n    Sk.builtin.pyCheckArgsLen(\"range\", arguments.length, 1, 3);\n    Sk.builtin.pyCheckType(\"start\", \"integer\", Sk.builtin.checkInt(start));\n    if (stop !== undefined) {\n        Sk.builtin.pyCheckType(\"stop\", \"integer\", Sk.builtin.checkInt(stop));\n    }\n    if (step !== undefined) {\n        Sk.builtin.pyCheckType(\"step\", \"integer\", Sk.builtin.checkInt(step));\n    }\n\n    start = Sk.builtin.asnum$(start);\n    stop = Sk.builtin.asnum$(stop);\n    step = Sk.builtin.asnum$(step);\n\n    if ((stop === undefined) && (step === undefined)) {\n        stop = start;\n        start = 0;\n        step = 1;\n    } else if (step === undefined) {\n        step = 1;\n    }\n\n    if (step === 0) {\n        throw new Sk.builtin.ValueError(\"range() step argument must not be zero\");\n    }\n\n    if (step > 0) {\n        for (i = start; i < stop; i += step) {\n            ret.push(new Sk.builtin.int_(i));\n        }\n    } else {\n        for (i = start; i > stop; i += step) {\n            ret.push(new Sk.builtin.int_(i));\n        }\n    }\n    return new Sk.builtin.list(ret); \n};\n\nSk.builtin.asnum$ = function (a) {\n    if (a === undefined) {\n        return a;\n    }\n    if (a === null) {\n        return a;\n    }\n    if (a instanceof Sk.builtin.none) {\n        return null;\n    }\n    if (a instanceof Sk.builtin.bool) {\n        if (a.v) {\n            return 1;\n        }\n        return 0;\n    }\n    if (typeof a === \"number\") {\n        return a;\n    }\n    if (typeof a === \"string\") {\n        return a;\n    }\n    if (a instanceof Sk.builtin.int_) {\n        return a.v;\n    }\n    if (a instanceof Sk.builtin.float_) {\n        return a.v;\n    }\n    if (a instanceof Sk.builtin.lng) {\n        if (a.cantBeInt()) {\n            return a.str$(10, true);\n        }\n        return a.toInt$();\n    }\n    if (a.constructor === Sk.builtin.biginteger) {\n        if ((a.trueCompare(new Sk.builtin.biginteger(Sk.builtin.int_.threshold$)) > 0) ||\n            (a.trueCompare(new Sk.builtin.biginteger(-Sk.builtin.int_.threshold$)) < 0)) {\n            return a.toString();\n        }\n        return a.intValue();\n    }\n\n    return a;\n};\n\nSk.exportSymbol(\"Sk.builtin.asnum$\", Sk.builtin.asnum$);\n\n/**\n * Return a Python number (either float or int) from a Javascript number.\n *\n * Javacsript function, returns Python object.\n *\n * @param  {number} a Javascript number to transform into Python number.\n * @return {(Sk.builtin.int_|Sk.builtin.float_)} A Python number.\n */\nSk.builtin.assk$ = function (a) {\n    if (a % 1 === 0) {\n        return new Sk.builtin.int_(a);\n    } else {\n        return new Sk.builtin.float_(a);\n    }\n};\nSk.exportSymbol(\"Sk.builtin.assk$\", Sk.builtin.assk$);\n\nSk.builtin.asnum$nofloat = function (a) {\n    var decimal;\n    var mantissa;\n    var expon;\n    if (a === undefined) {\n        return a;\n    }\n    if (a === null) {\n        return a;\n    }\n    if (a.constructor === Sk.builtin.none) {\n        return null;\n    }\n    if (a.constructor === Sk.builtin.bool) {\n        if (a.v) {\n            return 1;\n        }\n        return 0;\n    }\n    if (typeof a === \"number\") {\n        a = a.toString();\n    }\n    if (a.constructor === Sk.builtin.int_) {\n        a = a.v.toString();\n    }\n    if (a.constructor === Sk.builtin.float_) {\n        a = a.v.toString();\n    }\n    if (a.constructor === Sk.builtin.lng) {\n        a = a.str$(10, true);\n    }\n    if (a.constructor === Sk.builtin.biginteger) {\n        a = a.toString();\n    }\n\n    //  Sk.debugout(\"INITIAL: \" + a);\n\n    //  If not a float, great, just return this\n    if (a.indexOf(\".\") < 0 && a.indexOf(\"e\") < 0 && a.indexOf(\"E\") < 0) {\n        return a;\n    }\n\n    expon = 0;\n\n    if (a.indexOf(\"e\") >= 0) {\n        mantissa = a.substr(0, a.indexOf(\"e\"));\n        expon = a.substr(a.indexOf(\"e\") + 1);\n    } else if (a.indexOf(\"E\") >= 0) {\n        mantissa = a.substr(0, a.indexOf(\"e\"));\n        expon = a.substr(a.indexOf(\"E\") + 1);\n    } else {\n        mantissa = a;\n    }\n\n    expon = parseInt(expon, 10);\n\n    decimal = mantissa.indexOf(\".\");\n\n    //  Simplest case, no decimal\n    if (decimal < 0) {\n        if (expon >= 0) {\n            // Just add more zeroes and we're done\n            while (expon-- > 0) {\n                mantissa += \"0\";\n            }\n            return mantissa;\n        } else {\n            if (mantissa.length > -expon) {\n                return mantissa.substr(0, mantissa.length + expon);\n            } else {\n                return 0;\n            }\n        }\n    }\n\n    //  Negative exponent OR decimal (neg or pos exp)\n    if (decimal === 0) {\n        mantissa = mantissa.substr(1);\n    } else if (decimal < mantissa.length) {\n        mantissa = mantissa.substr(0, decimal) + mantissa.substr(decimal + 1);\n    } else {\n        mantissa = mantissa.substr(0, decimal);\n    }\n\n    decimal = decimal + expon;\n    while (decimal > mantissa.length) {\n        mantissa += \"0\";\n    }\n\n    if (decimal <= 0) {\n        mantissa = 0;\n    } else {\n        mantissa = mantissa.substr(0, decimal);\n    }\n\n    return mantissa;\n};\nSk.exportSymbol(\"Sk.builtin.asnum$nofloat\", Sk.builtin.asnum$nofloat);\n\nSk.builtin.round = function round (number, ndigits) {\n    var special;\n    Sk.builtin.pyCheckArgsLen(\"round\", arguments.length, 1, 2);\n\n    if (!Sk.builtin.checkNumber(number)) {\n        if (!Sk.builtin.checkFunction(number)) {\n            throw new Sk.builtin.TypeError(\"a float is required\");\n        } else {\n            if (!Sk.__future__.exceptions) {\n                throw new Sk.builtin.AttributeError(Sk.abstr.typeName(number) + \" instance has no attribute '__float__'\");\n            }\n        }\n    }\n\n    if ((ndigits !== undefined) && !Sk.misceval.isIndex(ndigits)) {\n        throw new Sk.builtin.TypeError(\"'\" + Sk.abstr.typeName(ndigits) + \"' object cannot be interpreted as an index\");\n    }\n\n    if (!Sk.__future__.dunder_round && number.round$) {\n        return number.round$(number, ndigits);\n    }\n\n    // try calling internal magic method\n    special = Sk.abstr.lookupSpecial(number, Sk.builtin.str.$round);\n    if (special != null) {\n        // method on builtin, provide this arg\n        if (!Sk.builtin.checkFunction(number)) {\n            return Sk.misceval.callsimArray(special, [number, ndigits]);\n        } else {\n            return Sk.misceval.callsimArray(special, [number]);\n        }\n    } else {\n        throw new Sk.builtin.TypeError(\"a float is required\");\n    }\n};\n\nSk.builtin.len = function len (item) {\n    var intcheck;\n    var special;\n    Sk.builtin.pyCheckArgsLen(\"len\", arguments.length, 1, 1);\n\n    var int_ = function(i) { return new Sk.builtin.int_(i); };\n    intcheck = function(j) {\n        if (Sk.builtin.checkInt(j)) {\n            return int_(j);\n        } else {\n            if (Sk.__future__.exceptions) {\n                throw new Sk.builtin.TypeError(\"'\" + Sk.abstr.typeName(j) + \"' object cannot be interpreted as an integer\");\n            } else {\n                throw new Sk.builtin.TypeError(\"__len__() should return an int\");\n            }\n        }\n    };\n\n    if (item.sq$length) {\n        return Sk.misceval.chain(item.sq$length(true), intcheck);\n    }\n\n    if (item.mp$length) {\n        return Sk.misceval.chain(item.mp$length(), int_);\n    }\n\n    if (item.tp$length) {\n        if (Sk.builtin.checkFunction(item)) {\n            special = Sk.abstr.lookupSpecial(item, Sk.builtin.str.$len);\n            if (special != null) {\n                return Sk.misceval.callsimArray(special, [item]);\n            } else {\n                if (Sk.__future__.exceptions) {\n                    throw new Sk.builtin.TypeError(\"object of type '\" + Sk.abstr.typeName(item) + \"' has no len()\");\n                } else {\n                    throw new Sk.builtin.AttributeError(Sk.abstr.typeName(item) + \" instance has no attribute '__len__'\");\n                }\n            }\n        } else {\n            return Sk.misceval.chain(item.tp$length(true), intcheck);\n        }\n    }\n\n    throw new Sk.builtin.TypeError(\"object of type '\" + Sk.abstr.typeName(item) + \"' has no len()\");\n};\n\nSk.builtin.min = function min () {\n    var i;\n    var lowest;\n    var args;\n    Sk.builtin.pyCheckArgsLen(\"min\", arguments.length, 1);\n\n    args = Sk.misceval.arrayFromArguments(arguments);\n    lowest = args[0];\n\n    if (lowest === undefined) {\n        throw new Sk.builtin.ValueError(\"min() arg is an empty sequence\");\n    }\n\n    for (i = 1; i < args.length; ++i) {\n        if (Sk.misceval.richCompareBool(args[i], lowest, \"Lt\")) {\n            lowest = args[i];\n        }\n    }\n    return lowest;\n};\n\nSk.builtin.max = function max () {\n    var i;\n    var highest;\n    var args;\n    Sk.builtin.pyCheckArgsLen(\"max\", arguments.length, 1);\n\n    args = Sk.misceval.arrayFromArguments(arguments);\n    highest = args[0];\n\n    if (highest === undefined) {\n        throw new Sk.builtin.ValueError(\"max() arg is an empty sequence\");\n    }\n\n    for (i = 1; i < args.length; ++i) {\n        if (Sk.misceval.richCompareBool(args[i], highest, \"Gt\")) {\n            highest = args[i];\n        }\n    }\n    return highest;\n};\n\nSk.builtin.any = function any (iter) {\n    var it, i;\n\n    Sk.builtin.pyCheckArgsLen(\"any\", arguments.length, 1, 1);\n    if (!Sk.builtin.checkIterable(iter)) {\n        throw new Sk.builtin.TypeError(\"'\" + Sk.abstr.typeName(iter) +\n            \"' object is not iterable\");\n    }\n\n    it = Sk.abstr.iter(iter);\n    for (i = it.tp$iternext(); i !== undefined; i = it.tp$iternext()) {\n        if (Sk.misceval.isTrue(i)) {\n            return Sk.builtin.bool.true$;\n        }\n    }\n\n    return Sk.builtin.bool.false$;\n};\n\nSk.builtin.all = function all (iter) {\n    var it, i;\n\n    Sk.builtin.pyCheckArgsLen(\"all\", arguments.length, 1, 1);\n    if (!Sk.builtin.checkIterable(iter)) {\n        throw new Sk.builtin.TypeError(\"'\" + Sk.abstr.typeName(iter) +\n            \"' object is not iterable\");\n    }\n\n    it = Sk.abstr.iter(iter);\n    for (i = it.tp$iternext(); i !== undefined; i = it.tp$iternext()) {\n        if (!Sk.misceval.isTrue(i)) {\n            return Sk.builtin.bool.false$;\n        }\n    }\n\n    return Sk.builtin.bool.true$;\n};\n\nSk.builtin.sum = function sum (iter, start) {\n    var tot;\n    var intermed;\n    var it, i;\n    var has_float;\n\n    Sk.builtin.pyCheckArgsLen(\"sum\", arguments.length, 1, 2);\n    Sk.builtin.pyCheckType(\"iter\", \"iterable\", Sk.builtin.checkIterable(iter));\n    if (start !== undefined && Sk.builtin.checkString(start)) {\n        throw new Sk.builtin.TypeError(\"sum() can't sum strings [use ''.join(seq) instead]\");\n    }\n    if (start === undefined) {\n        tot = new Sk.builtin.int_(0);\n    } else {\n        tot = start;\n    }\n\n    it = Sk.abstr.iter(iter);\n    for (i = it.tp$iternext(); i !== undefined; i = it.tp$iternext()) {\n        if (i instanceof Sk.builtin.float_) {\n            has_float = true;\n            if (!(tot instanceof Sk.builtin.float_)) {\n                tot = new Sk.builtin.float_(Sk.builtin.asnum$(tot));\n            }\n        } else if (i instanceof Sk.builtin.lng) {\n            if (!has_float) {\n                if (!(tot instanceof Sk.builtin.lng)) {\n                    tot = new Sk.builtin.lng(tot);\n                }\n            }\n        }\n\n        if (tot.nb$add !== undefined) {\n            intermed = tot.nb$add(i);\n            if ((intermed !== undefined) && (intermed !== Sk.builtin.NotImplemented.NotImplemented$)) {\n                tot = tot.nb$add(i);\n                continue;\n            }\n        }\n\n        throw new Sk.builtin.TypeError(\"unsupported operand type(s) for +: '\" +\n                    Sk.abstr.typeName(tot) + \"' and '\" +\n                    Sk.abstr.typeName(i) + \"'\");\n    }\n\n    return tot;\n};\n\nSk.builtin.zip = function zip () {\n    var el;\n    var tup;\n    var done;\n    var res;\n    var i;\n    var iters;\n    if (arguments.length === 0) {\n        return new Sk.builtin.list([]);\n    }\n\n    iters = [];\n    for (i = 0; i < arguments.length; i++) {\n        if (Sk.builtin.checkIterable(arguments[i])) {\n            iters.push(Sk.abstr.iter(arguments[i]));\n        } else {\n            throw new Sk.builtin.TypeError(\"argument \" + i + \" must support iteration\");\n        }\n    }\n    res = [];\n    done = false;\n    while (!done) {\n        tup = [];\n        for (i = 0; i < arguments.length; i++) {\n            el = iters[i].tp$iternext();\n            if (el === undefined) {\n                done = true;\n                break;\n            }\n            tup.push(el);\n        }\n        if (!done) {\n            res.push(new Sk.builtin.tuple(tup));\n        }\n    }\n    return new Sk.builtin.list(res);\n};\n\nSk.builtin.abs = function abs (x) {\n    Sk.builtin.pyCheckArgsLen(\"abs\", arguments.length, 1, 1);\n\n    if (x instanceof Sk.builtin.int_) {\n        return new Sk.builtin.int_(Math.abs(x.v));\n    }\n    if (x instanceof Sk.builtin.float_) {\n        return new Sk.builtin.float_(Math.abs(x.v));\n    }\n    if (Sk.builtin.checkNumber(x)) {\n        return Sk.builtin.assk$(Math.abs(Sk.builtin.asnum$(x)));\n    } else if (Sk.builtin.checkComplex(x)) {\n        return Sk.misceval.callsimArray(x.__abs__, [x]);\n    }\n\n    // call custom __abs__ methods\n    if (x.tp$getattr) {\n        var f = x.tp$getattr(Sk.builtin.str.$abs);\n        return Sk.misceval.callsimArray(f);\n    }\n\n    throw new TypeError(\"bad operand type for abs(): '\" + Sk.abstr.typeName(x) + \"'\");\n};\n\n// fabs belongs in the math module but has been a Skulpt builtin since 41665a97d (2012).\n// Left in for backwards compatibility for now\nSk.builtin.fabs = function fabs(x) {\n    return Sk.builtin.abs(x);\n};\n\nSk.builtin.ord = function ord (x) {\n    Sk.builtin.pyCheckArgsLen(\"ord\", arguments.length, 1, 1);\n\n    if (!Sk.builtin.checkString(x)) {\n        throw new Sk.builtin.TypeError(\"ord() expected a string of length 1, but \" + Sk.abstr.typeName(x) + \" found\");\n    } else if (x.v.length !== 1) {\n        throw new Sk.builtin.TypeError(\"ord() expected a character, but string of length \" + x.v.length + \" found\");\n    }\n    return new Sk.builtin.int_((x.v).charCodeAt(0));\n};\n\nSk.builtin.chr = function chr (x) {\n    Sk.builtin.pyCheckArgsLen(\"chr\", arguments.length, 1, 1);\n    if (!Sk.builtin.checkInt(x)) {\n        throw new Sk.builtin.TypeError(\"an integer is required\");\n    }\n    x = Sk.builtin.asnum$(x);\n\n\n    if ((x < 0) || (x > 255)) {\n        throw new Sk.builtin.ValueError(\"chr() arg not in range(256)\");\n    }\n\n    return new Sk.builtin.str(String.fromCharCode(x));\n};\n\nSk.builtin.unichr = function unichr (x) {\n    Sk.builtin.pyCheckArgsLen(\"chr\", arguments.length, 1, 1);\n    if (!Sk.builtin.checkInt(x)) {\n        throw new Sk.builtin.TypeError(\"an integer is required\");\n    }\n    x = Sk.builtin.asnum$(x);\n\n    try {\n        return new Sk.builtin.str(String.fromCodePoint(x));\n    } catch (err) {\n        if (err instanceof RangeError) {\n            throw new Sk.builtin.ValueError(err.message);\n        }\n        throw err;\n    }\n};\n\nSk.builtin.int2str_ = function helper_ (x, radix, prefix) {\n    var suffix;\n    var str = \"\";\n    if (x instanceof Sk.builtin.lng) {\n        suffix = \"\";\n        if (radix !== 2) {\n            suffix = \"L\";\n        }\n\n        str = x.str$(radix, false);\n        if (x.nb$isnegative()) {\n            return new Sk.builtin.str(\"-\" + prefix + str + suffix);\n        }\n        return new Sk.builtin.str(prefix + str + suffix);\n    } else {\n        x = Sk.misceval.asIndex(x);\n        str = x.toString(radix);\n        if (x < 0) {\n            return new Sk.builtin.str(\"-\" + prefix + str.slice(1));\n        }\n        return new Sk.builtin.str(prefix + str);\n    }\n};\n\nSk.builtin.hex = function hex (x) {\n    Sk.builtin.pyCheckArgsLen(\"hex\", arguments.length, 1, 1);\n    if (!Sk.misceval.isIndex(x)) {\n        throw new Sk.builtin.TypeError(\"hex() argument can't be converted to hex\");\n    }\n    return Sk.builtin.int2str_(x, 16, \"0x\");\n};\n\nSk.builtin.oct = function oct (x) {\n    Sk.builtin.pyCheckArgsLen(\"oct\", arguments.length, 1, 1);\n    if (!Sk.misceval.isIndex(x)) {\n        throw new Sk.builtin.TypeError(\"oct() argument can't be converted to hex\");\n    }\n    if (Sk.__future__.octal_number_literal) {\n        return Sk.builtin.int2str_(x, 8, \"0o\");\n    } else {\n        return Sk.builtin.int2str_(x, 8, \"0\");\n    }\n};\n\nSk.builtin.bin = function bin (x) {\n    Sk.builtin.pyCheckArgsLen(\"bin\", arguments.length, 1, 1);\n    if (!Sk.misceval.isIndex(x)) {\n        throw new Sk.builtin.TypeError(\"'\" + Sk.abstr.typeName(x) + \"' object can't be interpreted as an index\");\n    }\n    return Sk.builtin.int2str_(x, 2, \"0b\");\n};\n\nSk.builtin.dir = function dir (x) {\n    var last;\n    var it;\n    var prop;\n    var base;\n    var mro;\n    var i;\n    var s;\n    var k;\n    var names;\n    var getName;\n    Sk.builtin.pyCheckArgsLen(\"dir\", arguments.length, 1, 1);\n\n    getName = function (k) {\n        var s = null;\n        var internal = [\n            \"__bases__\", \"__mro__\", \"__class__\", \"__name__\", \"GenericGetAttr\",\n            \"GenericSetAttr\", \"GenericPythonGetAttr\", \"GenericPythonSetAttr\",\n            \"pythonFunctions\", \"HashNotImplemented\", \"constructor\", \"__dict__\"\n        ];\n        if (internal.indexOf(k) !== -1) {\n            return null;\n        }\n        if (k.indexOf(\"$\") !== -1) {\n            s = Sk.builtin.dir.slotNameToRichName(k);\n        } else if (k.charAt(k.length - 1) !== \"_\") {\n            s = k;\n        } else if (k.charAt(0) === \"_\") {\n            s = k;\n        }\n        return s;\n    };\n\n    names = [];\n\n    var _seq;\n\n    // try calling magic method\n    var special = Sk.abstr.lookupSpecial(x, Sk.builtin.str.$dir);\n    if(special != null) {\n        // method on builtin, provide this arg\n        _seq = Sk.misceval.callsimArray(special, [x]);\n\n        if (!Sk.builtin.checkSequence(_seq)) {\n            throw new Sk.builtin.TypeError(\"__dir__ must return sequence.\");\n        }\n\n        // proper unwrapping\n        _seq = Sk.ffi.remapToJs(_seq);\n\n        for (i = 0; i < _seq.length; ++i) {\n            names.push(new Sk.builtin.str(_seq[i]));\n        }\n    } else {\n        // Add all object properties\n        for (k in x.constructor.prototype) {\n            s = getName(k);\n            if (s) {\n                names.push(new Sk.builtin.str(s));\n            }\n        }\n\n        // Add all attributes\n        if (x[\"$d\"]) {\n            if (x[\"$d\"].tp$iter) {\n                // Dictionary\n                it = x[\"$d\"].tp$iter();\n                for (i = it.tp$iternext(); i !== undefined; i = it.tp$iternext()) {\n                    s = new Sk.builtin.str(i);\n                    s = getName(s.v);\n                    if (s) {\n                        names.push(new Sk.builtin.str(s));\n                    }\n                }\n            } else {\n                // Object\n                for (s in x[\"$d\"]) {\n                    names.push(new Sk.builtin.str(s));\n                }\n            }\n        }\n\n        // Add all class attributes\n        mro = x.tp$mro;\n        if(!mro && x.ob$type) {\n            mro = x.ob$type.tp$mro;\n        }\n        if (mro) {\n            for (i = 0; i < mro.v.length; ++i) {\n                base = mro.v[i];\n                for (prop in base) {\n                    if (base.hasOwnProperty(prop)) {\n                        s = getName(prop);\n                        if (s) {\n                            names.push(new Sk.builtin.str(s));\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    // Sort results\n    names.sort(function (a, b) {\n        return (a.v > b.v) - (a.v < b.v);\n    });\n\n    // Get rid of duplicates before returning, as duplicates should\n    //  only occur when they are shadowed\n    last = function (value, index, self) {\n        // Returns true iff the value is not the same as the next value\n        return value !== self[index + 1];\n    };\n    return new Sk.builtin.list(names.filter(last));\n};\n\nSk.builtin.dir.slotNameToRichName = function (k) {\n    // todo; map tp$xyz to __xyz__ properly\n    return undefined;\n};\n\nSk.builtin.repr = function repr (x) {\n    Sk.builtin.pyCheckArgsLen(\"repr\", arguments.length, 1, 1);\n\n    return Sk.misceval.objectRepr(x);\n};\n\nSk.builtin.open = function open (filename, mode, bufsize) {\n    Sk.builtin.pyCheckArgsLen(\"open\", arguments.length, 1, 3);\n    if (mode === undefined) {\n        mode = new Sk.builtin.str(\"r\");\n    }\n\n    if (/\\+/.test(mode.v)) {\n        throw \"todo; haven't implemented read/write mode\";\n    } else if ((mode.v === \"w\" || mode.v === \"wb\" || mode.v === \"a\" || mode.v === \"ab\") && !Sk.nonreadopen) {\n        throw \"todo; haven't implemented non-read opens\";\n    }\n\n    return new Sk.builtin.file(filename, mode, bufsize);\n};\n\nSk.builtin.isinstance = function isinstance (obj, type) {\n    var issubclass;\n    var i;\n    Sk.builtin.pyCheckArgsLen(\"isinstance\", arguments.length, 2, 2);\n    if (!Sk.builtin.checkClass(type) && !(type instanceof Sk.builtin.tuple)) {\n        throw new Sk.builtin.TypeError(\"isinstance() arg 2 must be a class, type, or tuple of classes and types\");\n    }\n\n    if (type === Sk.builtin.none.prototype.ob$type) {\n        if (obj instanceof Sk.builtin.none) {\n            return Sk.builtin.bool.true$;\n        } else {\n            return Sk.builtin.bool.false$;\n        }\n    }\n\n    // Normal case\n    if (obj.ob$type === type) {\n        return Sk.builtin.bool.true$;\n    }\n\n    // Handle tuple type argument\n    if (type instanceof Sk.builtin.tuple) {\n        for (i = 0; i < type.v.length; ++i) {\n            if (Sk.misceval.isTrue(Sk.builtin.isinstance(obj, type.v[i]))) {\n                return Sk.builtin.bool.true$;\n            }\n        }\n        return Sk.builtin.bool.false$;\n    }\n\n    // Check for Javascript inheritance\n    if (obj instanceof type) {\n        return Sk.builtin.bool.true$;\n    }\n\n\n    issubclass = function (klass, base) {\n        var i;\n        var bases;\n        if (klass === base) {\n            return Sk.builtin.bool.true$;\n        }\n        if (klass[\"$d\"] === undefined) {\n            return Sk.builtin.bool.false$;\n        }\n        bases = klass[\"$d\"].mp$subscript(Sk.builtin.type.basesStr_);\n        for (i = 0; i < bases.v.length; ++i) {\n            if (Sk.misceval.isTrue(issubclass(bases.v[i], base))) {\n                return Sk.builtin.bool.true$;\n            }\n        }\n        return Sk.builtin.bool.false$;\n    };\n\n    return issubclass(obj.ob$type, type);\n};\n\nSk.builtin.hash = function hash (value) {\n    var junk;\n    Sk.builtin.pyCheckArgsLen(\"hash\", arguments.length, 1, 1);\n\n    // Useless object to get compiler to allow check for __hash__ property\n    junk = {__hash__: function () {\n        return 0;\n    }};\n\n    if (value instanceof Object) {\n        if (Sk.builtin.checkNone(value.tp$hash)) {\n            // python sets the hash function to None , so we have to catch this case here\n            throw new Sk.builtin.TypeError(new Sk.builtin.str(\"unhashable type: '\" + Sk.abstr.typeName(value) + \"'\"));\n        } else if (value.tp$hash !== undefined) {\n            if (value.$savedHash_) {\n                return value.$savedHash_;\n            }\n            value.$savedHash_ = value.tp$hash();\n            return value.$savedHash_;\n        } else {\n            if (value.__hash === undefined) {\n                Sk.builtin.hashCount += 1;\n                value.__hash = Sk.builtin.hashCount;\n            }\n            return new Sk.builtin.int_(value.__hash);\n        }\n    } else if (typeof value === \"number\" || value === null ||\n        value === true || value === false) {\n        throw new Sk.builtin.TypeError(\"unsupported Javascript type\");\n    }\n\n    return new Sk.builtin.str((typeof value) + \" \" + String(value));\n    // todo; throw properly for unhashable types\n};\n\nSk.builtin.getattr = function getattr (obj, pyName, default_) {\n    var ret, mangledName, jsName;\n    Sk.builtin.pyCheckArgsLen(\"getattr\", arguments.length, 2, 3);\n    if (!Sk.builtin.checkString(pyName)) {\n        throw new Sk.builtin.TypeError(\"attribute name must be string\");\n    }\n\n    jsName = pyName.$jsstr();\n    mangledName = new Sk.builtin.str(Sk.fixReservedWords(jsName));\n    ret = obj.tp$getattr(mangledName);\n    if (ret === undefined) {\n        if (default_ !== undefined) {\n            return default_;\n        } else {\n            throw new Sk.builtin.AttributeError(\"'\" + Sk.abstr.typeName(obj) + \"' object has no attribute '\" + jsName + \"'\");\n        }\n    }\n    return ret;\n};\n\nSk.builtin.setattr = function setattr (obj, pyName, value) {\n    var jsName;\n    Sk.builtin.pyCheckArgsLen(\"setattr\", arguments.length, 3, 3);\n    // cannot set or del attr from builtin type\n    if (obj === undefined || obj[\"$r\"] === undefined || obj[\"$r\"]().v.slice(1,5) !== \"type\") {\n        if (!Sk.builtin.checkString(pyName)) {\n            throw new Sk.builtin.TypeError(\"attribute name must be string\");\n        }\n        jsName = pyName.$jsstr();\n        if (obj.tp$setattr) {\n            obj.tp$setattr(new Sk.builtin.str(Sk.fixReservedWords(jsName)), value);\n        } else {\n            throw new Sk.builtin.AttributeError(\"object has no attribute \" + jsName);\n        }\n        return Sk.builtin.none.none$;\n    }\n\n    throw new Sk.builtin.TypeError(\"can't set attributes of built-in/extension type '\" + obj.tp$name + \"'\");\n};\n\nSk.builtin.raw_input = function (prompt) {\n    var lprompt = prompt ? prompt : \"\";\n\n    return Sk.misceval.chain(Sk.importModule(\"sys\", false, true), function (sys) {\n        if (Sk.inputfunTakesPrompt) {\n            return Sk.misceval.callsimOrSuspendArray(Sk.builtin.file.$readline, [sys[\"$d\"][\"stdin\"], null, lprompt]);\n        } else {\n            return Sk.misceval.chain(undefined, function() {\n                return Sk.misceval.callsimOrSuspendArray(sys[\"$d\"][\"stdout\"][\"write\"], [sys[\"$d\"][\"stdout\"], new Sk.builtin.str(lprompt)]);\n            }, function () {\n                return Sk.misceval.callsimOrSuspendArray(sys[\"$d\"][\"stdin\"][\"readline\"], [sys[\"$d\"][\"stdin\"]]);\n            });\n        }\n    });\n};\n\nSk.builtin.input = Sk.builtin.raw_input;\n\nSk.builtin.jseval = function jseval (evalcode) {\n    var result = Sk.global[\"eval\"](Sk.ffi.remapToJs(evalcode));\n    try {\n        return Sk.ffi.remapToPy(result);\n    } catch (err) {\n        if (err.constructor === Sk.asserts.AssertionError) {\n            return Sk.builtin.none.none$;\n        }\n\n        throw err;\n    }\n};\n\nSk.builtin.jsmillis = function jsmillis () {\n    var now = new Date();\n    return now.valueOf();\n};\n\nSk.builtin.eval_ = function eval_ () {\n    throw new Sk.builtin.NotImplementedError(\"eval is not yet implemented\");\n};\n\nSk.builtin.map = function map (fun, seq) {\n    var retval = [];\n    var next;\n    var nones;\n    var args;\n    var argnum;\n    var i;\n    var iterables;\n    var combined;\n    Sk.builtin.pyCheckArgsLen(\"map\", arguments.length, 2);\n\n    if (arguments.length > 2) {\n        // Pack sequences into one list of Javascript Arrays\n\n        combined = [];\n        iterables = Array.prototype.slice.apply(arguments).slice(1);\n        for (i = 0; i < iterables.length; i++) {\n            if (!Sk.builtin.checkIterable(iterables[i])) {\n                argnum = parseInt(i, 10) + 2;\n                throw new Sk.builtin.TypeError(\"argument \" + argnum + \" to map() must support iteration\");\n            }\n            iterables[i] = Sk.abstr.iter(iterables[i]);\n        }\n\n        while (true) {\n            args = [];\n            nones = 0;\n            for (i = 0; i < iterables.length; i++) {\n                next = iterables[i].tp$iternext();\n                if (next === undefined) {\n                    args.push(Sk.builtin.none.none$);\n                    nones++;\n                } else {\n                    args.push(next);\n                }\n            }\n            if (nones !== iterables.length) {\n                combined.push(args);\n            } else {\n                // All iterables are done\n                break;\n            }\n        }\n        seq = new Sk.builtin.list(combined);\n    }\n\n    if (!Sk.builtin.checkIterable(seq)) {\n        throw new Sk.builtin.TypeError(\"'\" + Sk.abstr.typeName(seq) + \"' object is not iterable\");\n    }\n\n    return Sk.misceval.chain(Sk.misceval.iterFor(Sk.abstr.iter(seq), function (item) {\n\n        if (fun === Sk.builtin.none.none$) {\n            if (item instanceof Array) {\n                // With None function and multiple sequences,\n                // map should return a list of tuples\n                item = new Sk.builtin.tuple(item);\n            }\n            retval.push(item);\n        } else {\n            if (!(item instanceof Array)) {\n                // If there was only one iterable, convert to Javascript\n                // Array for call to apply.\n                item = [item];\n            }\n\n            return Sk.misceval.chain(Sk.misceval.applyOrSuspend(fun, undefined, undefined, undefined, item), function (result) {\n                retval.push(result);\n            });\n        }\n    }), function () {\n        return new Sk.builtin.list(retval);\n    });\n};\n\nSk.builtin.reduce = function reduce (fun, seq, initializer) {\n    var item;\n    var accum_value;\n    var iter;\n    Sk.builtin.pyCheckArgsLen(\"reduce\", arguments.length, 2, 3);\n    if (!Sk.builtin.checkIterable(seq)) {\n        throw new Sk.builtin.TypeError(\"'\" + Sk.abstr.typeName(seq) + \"' object is not iterable\");\n    }\n\n    iter = Sk.abstr.iter(seq);\n    if (initializer === undefined) {\n        initializer = iter.tp$iternext();\n        if (initializer === undefined) {\n            throw new Sk.builtin.TypeError(\"reduce() of empty sequence with no initial value\");\n        }\n    }\n    accum_value = initializer;\n    for (item = iter.tp$iternext();\n        item !== undefined;\n        item = iter.tp$iternext()) {\n        accum_value = Sk.misceval.callsimArray(fun, [accum_value, item]);\n    }\n\n    return accum_value;\n};\n\nSk.builtin.filter = function filter (fun, iterable) {\n    var result;\n    var iter, item;\n    var retval;\n    var ret;\n    var add;\n    var ctor;\n    Sk.builtin.pyCheckArgsLen(\"filter\", arguments.length, 2, 2);\n\n    if (!Sk.builtin.checkIterable(iterable)) {\n        throw new Sk.builtin.TypeError(\"'\" + Sk.abstr.typeName(iterable) + \"' object is not iterable\");\n    }\n\n    ctor = function () {\n        return [];\n    };\n    add = function (iter, item) {\n        iter.push(item);\n        return iter;\n    };\n    ret = function (iter) {\n        return new Sk.builtin.list(iter);\n    };\n\n    if (iterable.__class__ === Sk.builtin.str) {\n        ctor = function () {\n            return new Sk.builtin.str(\"\");\n        };\n        add = function (iter, item) {\n            return iter.sq$concat(item);\n        };\n        ret = function (iter) {\n            return iter;\n        };\n    } else if (iterable.__class__ === Sk.builtin.tuple) {\n        ret = function (iter) {\n            return new Sk.builtin.tuple(iter);\n        };\n    }\n\n    retval = ctor();\n\n    for (iter = Sk.abstr.iter(iterable), item = iter.tp$iternext();\n        item !== undefined;\n        item = iter.tp$iternext()) {\n        if (fun === Sk.builtin.none.none$) {\n            result = new Sk.builtin.bool( item);\n        } else {\n            result = Sk.misceval.callsimArray(fun, [item]);\n        }\n\n        if (Sk.misceval.isTrue(result)) {\n            retval = add(retval, item);\n        }\n    }\n\n    return ret(retval);\n};\n\nSk.builtin.hasattr = function hasattr (obj, attr) {\n    Sk.builtin.pyCheckArgsLen(\"hasattr\", arguments.length, 2, 2);\n    var special, ret;\n    if (!Sk.builtin.checkString(attr)) {\n        throw new Sk.builtin.TypeError(\"hasattr(): attribute name must be string\");\n    }\n\n    if (obj.tp$getattr) {\n        if (obj.tp$getattr(attr)) {\n            return Sk.builtin.bool.true$;\n        } else {\n            return Sk.builtin.bool.false$;\n        }\n    } else {\n        throw new Sk.builtin.AttributeError(\"Object has no tp$getattr method\");\n    }\n};\n\n\nSk.builtin.pow = function pow (a, b, c) {\n    var ret;\n    var res;\n    var right;\n    var left;\n    var c_num;\n    var b_num;\n    var a_num;\n    Sk.builtin.pyCheckArgsLen(\"pow\", arguments.length, 2, 3);\n\n    if (c instanceof Sk.builtin.none) {\n        c = undefined;\n    }\n\n    // add complex type hook here, builtin is messed up anyways\n    if (Sk.builtin.checkComplex(a)) {\n        return a.nb$power(b, c); // call complex pow function\n    }\n\n    a_num = Sk.builtin.asnum$(a);\n    b_num = Sk.builtin.asnum$(b);\n    c_num = Sk.builtin.asnum$(c);\n\n    if (!Sk.builtin.checkNumber(a) || !Sk.builtin.checkNumber(b)) {\n        if (c === undefined) {\n            throw new Sk.builtin.TypeError(\"unsupported operand type(s) for pow(): '\" + Sk.abstr.typeName(a) + \"' and '\" + Sk.abstr.typeName(b) + \"'\");\n        }\n        throw new Sk.builtin.TypeError(\"unsupported operand type(s) for pow(): '\" + Sk.abstr.typeName(a) + \"', '\" + Sk.abstr.typeName(b) + \"', '\" + Sk.abstr.typeName(c) + \"'\");\n    }\n    if (a_num < 0 && b instanceof Sk.builtin.float_) {\n        throw new Sk.builtin.ValueError(\"negative number cannot be raised to a fractional power\");\n    }\n\n    if (c === undefined) {\n        if ((a instanceof Sk.builtin.float_ || b instanceof Sk.builtin.float_) || (b_num < 0)) {\n            return new Sk.builtin.float_(Math.pow(a_num, b_num));\n        }\n\n        left = new Sk.builtin.int_(a_num);\n        right = new Sk.builtin.int_(b_num);\n        res = left.nb$power(right);\n\n        if (a instanceof Sk.builtin.lng || b instanceof Sk.builtin.lng) {\n            return new Sk.builtin.lng(res);\n        }\n\n        return res;\n    } else {\n        if (!Sk.builtin.checkInt(a) || !Sk.builtin.checkInt(b) || !Sk.builtin.checkInt(c)) {\n            throw new Sk.builtin.TypeError(\"pow() 3rd argument not allowed unless all arguments are integers\");\n        }\n        if (b_num < 0) {\n            if (Sk.__future__.exceptions) {\n                throw new Sk.builtin.ValueError(\"pow() 2nd argument cannot be negative when 3rd argument specified\");\n            } else {\n                throw new Sk.builtin.TypeError(\"pow() 2nd argument cannot be negative when 3rd argument specified\");\n            }\n        }\n        if (c_num === 0) {\n            throw new Sk.builtin.ValueError(\"pow() 3rd argument cannot be 0\");\n        }\n        if ((a instanceof Sk.builtin.lng || b instanceof Sk.builtin.lng || c instanceof Sk.builtin.lng) ||\n            (Math.pow(a_num, b_num) === Infinity)) {\n            // convert a to a long so that we can use biginteger's modPowInt method\n            a = new Sk.builtin.lng(a);\n            return a.nb$power(b, c);\n        } else {\n            ret = new Sk.builtin.int_(Math.pow(a_num, b_num));\n            return ret.nb$remainder(c);\n        }\n    }\n};\n\nSk.builtin.quit = function quit (msg) {\n    var s = new Sk.builtin.str(msg).v;\n    throw new Sk.builtin.SystemExit(s);\n};\n\n\nSk.builtin.issubclass = function issubclass (c1, c2) {\n    var i;\n    var issubclass_internal;\n    Sk.builtin.pyCheckArgsLen(\"issubclass\", arguments.length, 2, 2);\n    if (!Sk.builtin.checkClass(c1)) {\n        throw new Sk.builtin.TypeError(\"issubclass() arg 1 must be a class\");\n    }\n\n    if (!Sk.builtin.checkClass(c2) && !(c2 instanceof Sk.builtin.tuple)) {\n        throw new Sk.builtin.TypeError(\"issubclass() arg 2 must be a class or tuple of classes\");\n    }\n\n    issubclass_internal = function (klass, base) {\n        var i;\n        var bases;\n        if (klass === base) {\n            return true;\n        }\n        if (klass[\"$d\"] === undefined) {\n            return false;\n        }\n        if (klass[\"$d\"].mp$subscript) {\n            // old style classes don't have bases\n            if (klass[\"$d\"].sq$contains(Sk.builtin.type.basesStr_)) {\n                bases = klass[\"$d\"].mp$subscript(Sk.builtin.type.basesStr_);\n            } else {\n                return false;\n            }\n        } else {\n            return false;\n        }\n        for (i = 0; i < bases.v.length; ++i) {\n            if (issubclass_internal(bases.v[i], base)) {\n                return true;\n            }\n        }\n        return false;\n    };\n\n    if (Sk.builtin.checkClass(c2)) {\n        /* Quick test for an exact match */\n        if (c1 === c2) {\n            return true;\n        }\n\n        return issubclass_internal(c1, c2);\n    }\n\n    // Handle tuple type argument\n    if (c2 instanceof Sk.builtin.tuple) {\n        for (i = 0; i < c2.v.length; ++i) {\n            if (Sk.builtin.issubclass(c1, c2.v[i])) {\n                return true;\n            }\n        }\n        return false;\n    }\n};\n\nSk.builtin.globals = function globals () {\n    var i;\n    var ret = new Sk.builtin.dict([]);\n    for (i in Sk[\"globals\"]) {\n        ret.mp$ass_subscript(new Sk.builtin.str(i), Sk[\"globals\"][i]);\n    }\n\n    return ret;\n\n};\n\nSk.builtin.divmod = function divmod (a, b) {\n    return Sk.abstr.numberBinOp(a, b, \"DivMod\");\n};\n\n/**\n * Convert a value to a formatted representation, as controlled by format_spec. The interpretation of format_spec\n * will depend on the type of the value argument, however there is a standard formatting syntax that is used by most\n * built-in types: Format Specification Mini-Language.\n */\nSk.builtin.format = function format (value, format_spec) {\n    Sk.builtin.pyCheckArgsLen(\"format\", arguments.length, 1, 2);\n\n    if (format_spec === undefined) {\n        format_spec = Sk.builtin.str.$emptystr;\n    }\n\n    return Sk.abstr.objectFormat(value, format_spec);\n};\n\nSk.builtin.reversed = function reversed (seq) {\n    Sk.builtin.pyCheckArgsLen(\"reversed\", arguments.length, 1, 1);\n\n    var special = Sk.abstr.lookupSpecial(seq, Sk.builtin.str.$reversed);\n    if (special != null) {\n        return Sk.misceval.callsimArray(special, [seq]);\n    } else {\n        if (!Sk.builtin.checkSequence(seq)) {\n            throw new Sk.builtin.TypeError(\"'\" + Sk.abstr.typeName(seq) + \"' object is not a sequence\");\n        }\n\n        /**\n         * Builds an iterator that outputs the items form last to first.\n         *\n         * @constructor\n         */\n        var reverseIter = function (obj) {\n            this.idx = obj.sq$length() - 1;\n            this.myobj = obj;\n            this.getitem = Sk.abstr.lookupSpecial(obj, Sk.builtin.str.$getitem);\n            this.tp$iter = function() {\n                return this;\n            },\n            this.tp$iternext = function () {\n                var ret;\n\n                if (this.idx < 0) {\n                    return undefined;\n                }\n\n                try {\n                    ret = Sk.misceval.callsimArray(this.getitem, [this.myobj, Sk.ffi.remapToPy(this.idx)]);\n                } catch (e) {\n                    if (e instanceof Sk.builtin.IndexError) {\n                        return undefined;\n                    } else {\n                        throw e;\n                    }\n                }\n                this.idx--;\n                return ret;\n            };\n        };\n\n        return new reverseIter(seq);\n    }\n};\n\nSk.builtin.id = function (obj) {\n    Sk.builtin.pyCheckArgsLen(\"id\", arguments.length, 1, 1);\n\n    if (obj.__id === undefined) {\n        Sk.builtin.idCount += 1;\n        obj.__id = Sk.builtin.idCount;\n    }\n\n    return new Sk.builtin.int_(obj.__id);\n};\n\nSk.builtin.bytearray = function bytearray () {\n    throw new Sk.builtin.NotImplementedError(\"bytearray is not yet implemented\");\n};\n\nSk.builtin.callable = function callable (obj) {\n    // check num of args\n    Sk.builtin.pyCheckArgsLen(\"callable\", arguments.length, 1, 1);\n\n    if (Sk.builtin.checkCallable(obj)) {\n        return Sk.builtin.bool.true$;\n    }\n    return Sk.builtin.bool.false$;\n};\n\nSk.builtin.delattr = function delattr (obj, attr) {\n    Sk.builtin.pyCheckArgsLen(\"delattr\", arguments.length, 2, 2);\n    if (obj[\"$d\"][attr.v] !== undefined) {\n        var ret = Sk.misceval.tryCatch(function() {\n            var try1 = Sk.builtin.setattr(obj, attr, undefined);\n            return try1;\n        }, function(e) {\n            Sk.misceval.tryCatch(function() {\n                var try2 = Sk.builtin.setattr(obj[\"$d\"], attr, undefined);\n\n                return try2;\n            }, function(e) {\n                if (e instanceof Sk.builtin.AttributeError) {\n                    throw new Sk.builtin.AttributeError(Sk.abstr.typeName(obj) + \" instance has no attribute '\"+ attr.v+ \"'\");\n                } else {\n                    throw e;\n                }\n            });\n        });\n        return ret;\n    } // cannot set or del attr from builtin type\n    if (obj[\"$r\"]().v.slice(1,5) !== \"type\") {\n        if (obj.ob$type === Sk.builtin.type && obj[attr.v] !== undefined) {\n            obj[attr.v] = undefined;\n            return Sk.builtin.none.none$;\n        }\n        throw new Sk.builtin.AttributeError(Sk.abstr.typeName(obj) + \" instance has no attribute '\"+ attr.v+ \"'\");\n    }\n    throw new Sk.builtin.TypeError(\"can't set attributes of built-in/extension type '\" + obj.tp$name + \"'\");\n};\n\nSk.builtin.execfile = function execfile () {\n    throw new Sk.builtin.NotImplementedError(\"execfile is not yet implemented\");\n};\n\nSk.builtin.frozenset = function frozenset () {\n    throw new Sk.builtin.NotImplementedError(\"frozenset is not yet implemented\");\n};\n\nSk.builtin.help = function help () {\n    throw new Sk.builtin.NotImplementedError(\"help is not yet implemented\");\n};\n\nSk.builtin.iter = function iter (obj, sentinel) {\n    Sk.builtin.pyCheckArgsLen(\"iter\", arguments.length, 1, 2);\n    if (arguments.length === 1) {\n        if (!Sk.builtin.checkIterable(obj)) {\n            throw new Sk.builtin.TypeError(\"'\" + Sk.abstr.typeName(obj) +\n                \"' object is not iterable\");\n        } else {\n            return new Sk.builtin.iterator(obj);\n        }\n    } else {\n        if (Sk.builtin.checkCallable(obj)) {\n            return new Sk.builtin.iterator(obj, sentinel);\n        } else {\n            throw new TypeError(\"iter(v, w): v must be callable\");\n        }\n    }\n};\n\nSk.builtin.locals = function locals () {\n    throw new Sk.builtin.NotImplementedError(\"locals is not yet implemented\");\n};\nSk.builtin.memoryview = function memoryview () {\n    throw new Sk.builtin.NotImplementedError(\"memoryview is not yet implemented\");\n};\n\nSk.builtin.next_ = function next_ (iter, default_) {\n    var nxt;\n    Sk.builtin.pyCheckArgsLen(\"next\", arguments.length, 1, 2);\n    if (!iter.tp$iternext) {\n        throw new Sk.builtin.TypeError(\"'\" + Sk.abstr.typeName(iter) +\n            \"' object is not an iterator\");\n    }\n    nxt = iter.tp$iternext();\n    if (nxt === undefined) {\n        if (default_) {\n            return default_;\n        }\n        throw new Sk.builtin.StopIteration();\n    }\n    return nxt;\n};\n\nSk.builtin.reload = function reload () {\n    throw new Sk.builtin.NotImplementedError(\"reload is not yet implemented\");\n};\nSk.builtin.vars = function vars () {\n    throw new Sk.builtin.NotImplementedError(\"vars is not yet implemented\");\n};\nSk.builtin.xrange = Sk.builtin.range;\nSk.builtin.apply_ = function apply_ () {\n    throw new Sk.builtin.NotImplementedError(\"apply is not yet implemented\");\n};\nSk.builtin.buffer = function buffer_ () {\n    throw new Sk.builtin.NotImplementedError(\"buffer is not yet implemented\");\n};\nSk.builtin.coerce = function coerce () {\n    throw new Sk.builtin.NotImplementedError(\"coerce is not yet implemented\");\n};\nSk.builtin.intern = function intern () {\n    throw new Sk.builtin.NotImplementedError(\"intern is not yet implemented\");\n};\n\n/*\n Sk.builtinFiles = {};\n Sk.builtin.read = function read(x) {\n if (Sk.builtinFiles === undefined || Sk.builtinFiles[\"files\"][x] === undefined)\n throw \"File not found: '\" + x + \"'\";\n return Sk.builtinFiles[\"files\"][x];\n };\n Sk.builtinFiles = undefined;\n */\n\n\n/***/ }),\n/* 14 */\n/***/ (function(module, exports) {\n\n/*! https://mths.be/fromcodepoint v0.2.1 by @mathias */\nif (!String.fromCodePoint) {\n    (function() {\n        var defineProperty = (function() {\n            // IE 8 only supports `Object.defineProperty` on DOM elements\n            var result;\n            try {\n                var object = {};\n                var $defineProperty = Object.defineProperty;\n                result = $defineProperty(object, \"foo\", object) && $defineProperty;\n            } catch(error) {}\n            return result;\n        }());\n        var stringFromCharCode = String.fromCharCode;\n        var floor = Math.floor;\n        var fromCodePoint = function(_) {\n            var MAX_SIZE = 0x4000;\n            var codeUnits = [];\n            var highSurrogate;\n            var lowSurrogate;\n            var index = -1;\n            var length = arguments.length;\n            if (!length) {\n                return \"\";\n            }\n            var result = \"\";\n            while (++index < length) {\n                var codePoint = Number(arguments[index]);\n                if (\n                    !isFinite(codePoint) || // `NaN`, `+Infinity`, or `-Infinity`\n                    codePoint < 0 || // not a valid Unicode code point\n                    codePoint > 0x10FFFF || // not a valid Unicode code point\n                    floor(codePoint) != codePoint // not an integer\n                ) {\n                    throw RangeError(\"Invalid code point: \" + codePoint);\n                }\n                if (codePoint <= 0xFFFF) { // BMP code point\n                    codeUnits.push(codePoint);\n                } else { // Astral code point; split in surrogate halves\n                    // https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae\n                    codePoint -= 0x10000;\n                    highSurrogate = (codePoint >> 10) + 0xD800;\n                    lowSurrogate = (codePoint % 0x400) + 0xDC00;\n                    codeUnits.push(highSurrogate, lowSurrogate);\n                }\n                if (index + 1 == length || codeUnits.length > MAX_SIZE) {\n                    result += stringFromCharCode.apply(null, codeUnits);\n                    codeUnits.length = 0;\n                }\n            }\n            return result;\n        };\n        if (defineProperty) {\n            defineProperty(String, \"fromCodePoint\", {\n                \"value\": fromCodePoint,\n                \"configurable\": true,\n                \"writable\": true\n            });\n        } else {\n            String.fromCodePoint = fromCodePoint;\n        }\n    }());\n}\n\n\n/***/ }),\n/* 15 */\n/***/ (function(module, exports) {\n\n/*\n * The filename, line number, and column number of exceptions are\n * stored within the exception object.  Note that not all exceptions\n * clearly report the column number.  To customize the exception\n * message to use any/all of these fields, you can either modify\n * tp$str below to print the desired message, or use them in the\n * skulpt wrapper (i.e., runit) to present the exception message.\n */\n\n\n/**\n * @constructor\n * @param {...Object|null} args\n */\nSk.builtin.BaseException = function (args) {\n    var i, o;\n\n    if (!(this instanceof Sk.builtin.BaseException)) {\n        o = Object.create(Sk.builtin.BaseException.prototype);\n        o.constructor.apply(o, arguments);\n        return o;\n    }\n\n    args = Array.prototype.slice.call(arguments);\n    // hackage to allow shorter throws\n    for (i = 0; i < args.length; ++i) {\n        if (typeof args[i] === \"string\") {\n            args[i] = new Sk.builtin.str(args[i]);\n        }\n    }\n    this.args = new Sk.builtin.tuple(args);\n    this.traceback = [];\n\n    // For errors occurring during normal execution, the line/col/etc\n    // of the error are populated by each stack frame of the runtime code,\n    // but we can seed it with the supplied parameters.\n    if (this.args.sq$length() >= 3) {\n\n        // if !this.args[1].v, this is an error, and the exception that causes it\n        // probably needs to be fixed, but we mark as \"<unknown>\" for now\n        this.traceback.push({\n            lineno: this.args.v[2],\n            filename: this.args.v[1].v || \"<unknown>\"\n        });\n    }\n};\nSk.abstr.setUpInheritance(\"BaseException\", Sk.builtin.BaseException, Sk.builtin.object);\n\nSk.builtin.BaseException.prototype.tp$str = function () {\n    var i;\n    var ret = \"\";\n\n    ret += this.tp$name;\n    if (this.args) {\n        ret += \": \" + (this.args.v.length > 0 ? this.args.v[0].v : \"\");\n    }\n    if (this.traceback.length !== 0) {\n        ret += \" on line \" + this.traceback[0].lineno;\n    } else {\n        ret += \" at <unknown>\";\n    }\n\n    if (this.args.v.length > 4) {\n        ret += \"\\n\" + this.args.v[4].v + \"\\n\";\n        for (i = 0; i < this.args.v[3]; ++i) {\n            ret += \" \";\n        }\n        ret += \"^\\n\";\n    }\n\n    /*for (i = 0; i < this.traceback.length; i++) {\n        ret += \"\\n  at \" + this.traceback[i].filename + \" line \" + this.traceback[i].lineno;\n        if (\"colno\" in this.traceback[i]) {\n            ret += \" column \" + this.traceback[i].colno;\n        }\n    }*/\n\n    return new Sk.builtin.str(ret);\n};\n\nSk.builtin.BaseException.prototype.toString = function () {\n    return this.tp$str().v;\n};\n\n// Create a descriptor to return the 'args' of an exception.\n// This is a hack to get around a weird mismatch between builtin\n// objects and proper types\nSk.builtin.BaseException.prototype.args = {\n    \"tp$descr_get\": function(self, clstype) {\n        return self.args;\n    }\n};\n\nSk.exportSymbol(\"Sk.builtin.BaseException\", Sk.builtin.BaseException);\n\n/**\n * @constructor\n * @extends Sk.builtin.BaseException\n * @param {...*} args\n */\nSk.builtin.Exception = function (args) {\n    var o;\n    if (!(this instanceof Sk.builtin.Exception)) {\n        o = Object.create(Sk.builtin.Exception.prototype);\n        o.constructor.apply(o, arguments);\n        return o;\n    }\n    Sk.builtin.BaseException.apply(this, arguments);\n};\nSk.abstr.setUpInheritance(\"Exception\", Sk.builtin.Exception, Sk.builtin.BaseException);\nSk.exportSymbol(\"Sk.builtin.Exception\", Sk.builtin.Exception);\n\n/**\n * @constructor\n * @extends Sk.builtin.Exception\n * @param {...*} args\n */\nSk.builtin.StandardError = function (args) {\n    var o;\n    if (!(this instanceof Sk.builtin.StandardError)) {\n        o = Object.create(Sk.builtin.StandardError.prototype);\n        o.constructor.apply(o, arguments);\n        return o;\n    }\n    Sk.builtin.Exception.apply(this, arguments);\n};\nSk.abstr.setUpInheritance(\"StandardError\", Sk.builtin.StandardError, Sk.builtin.Exception);\nSk.exportSymbol(\"Sk.builtin.StandardError\", Sk.builtin.StandardError);\n\n/**\n * @constructor\n * @extends Sk.builtin.StandardError\n * @param {...*} args\n */\nSk.builtin.AssertionError = function (args) {\n    var o;\n    if (!(this instanceof Sk.builtin.AssertionError)) {\n        o = Object.create(Sk.builtin.AssertionError.prototype);\n        o.constructor.apply(o, arguments);\n        return o;\n    }\n    Sk.builtin.StandardError.apply(this, arguments);\n};\nSk.abstr.setUpInheritance(\"AssertionError\", Sk.builtin.AssertionError, Sk.builtin.StandardError);\nSk.exportSymbol(\"Sk.builtin.AssertionError\", Sk.builtin.AssertionError);\n\n/**\n * @constructor\n * @extends Sk.builtin.StandardError\n * @param {...*} args\n */\nSk.builtin.AttributeError = function (args) {\n    var o;\n    if (!(this instanceof Sk.builtin.AttributeError)) {\n        o = Object.create(Sk.builtin.AttributeError.prototype);\n        o.constructor.apply(o, arguments);\n        return o;\n    }\n    Sk.builtin.StandardError.apply(this, arguments);\n};\nSk.abstr.setUpInheritance(\"AttributeError\", Sk.builtin.AttributeError, Sk.builtin.StandardError);\n\n/**\n * @constructor\n * @extends Sk.builtin.StandardError\n * @param {...*} args\n */\nSk.builtin.ImportError = function (args) {\n    var o;\n    if (!(this instanceof Sk.builtin.ImportError)) {\n        o = Object.create(Sk.builtin.ImportError.prototype);\n        o.constructor.apply(o, arguments);\n        return o;\n    }\n    Sk.builtin.StandardError.apply(this, arguments);\n};\nSk.abstr.setUpInheritance(\"ImportError\", Sk.builtin.ImportError, Sk.builtin.StandardError);\n\n/**\n * @constructor\n * @extends Sk.builtin.StandardError\n * @param {...*} args\n */\nSk.builtin.IndentationError = function (args) {\n    var o;\n    if (!(this instanceof Sk.builtin.IndentationError)) {\n        o = Object.create(Sk.builtin.IndentationError.prototype);\n        o.constructor.apply(o, arguments);\n        return o;\n    }\n    Sk.builtin.StandardError.apply(this, arguments);\n};\nSk.abstr.setUpInheritance(\"IndentationError\", Sk.builtin.IndentationError, Sk.builtin.StandardError);\n\n/**\n * @constructor\n * @extends Sk.builtin.StandardError\n * @param {...*} args\n */\nSk.builtin.IndexError = function (args) {\n    var o;\n    if (!(this instanceof Sk.builtin.IndexError)) {\n        o = Object.create(Sk.builtin.IndexError.prototype);\n        o.constructor.apply(o, arguments);\n        return o;\n    }\n    Sk.builtin.StandardError.apply(this, arguments);\n};\nSk.abstr.setUpInheritance(\"IndexError\", Sk.builtin.IndexError, Sk.builtin.StandardError);\n\n/**\n * @constructor\n * @extends Sk.builtin.StandardError\n * @param {...*} args\n */\nSk.builtin.KeyError = function (args) {\n    var o;\n    if (!(this instanceof Sk.builtin.KeyError)) {\n        o = Object.create(Sk.builtin.KeyError.prototype);\n        o.constructor.apply(o, arguments);\n        return o;\n    }\n    Sk.builtin.StandardError.apply(this, arguments);\n};\nSk.abstr.setUpInheritance(\"KeyError\", Sk.builtin.KeyError, Sk.builtin.StandardError);\n\n/**\n * @constructor\n * @extends Sk.builtin.StandardError\n * @param {...*} args\n */\nSk.builtin.NameError = function (args) {\n    var o;\n    if (!(this instanceof Sk.builtin.NameError)) {\n        o = Object.create(Sk.builtin.NameError.prototype);\n        o.constructor.apply(o, arguments);\n        return o;\n    }\n    Sk.builtin.StandardError.apply(this, arguments);\n};\nSk.abstr.setUpInheritance(\"NameError\", Sk.builtin.NameError, Sk.builtin.StandardError);\n\n/**\n * @constructor\n * @extends Sk.builtin.StandardError\n * @param {...*} args\n */\nSk.builtin.UnboundLocalError = function (args) {\n    var o;\n    if (!(this instanceof Sk.builtin.UnboundLocalError)) {\n        o = Object.create(Sk.builtin.UnboundLocalError.prototype);\n        o.constructor.apply(o, arguments);\n        return o;\n    }\n    Sk.builtin.StandardError.apply(this, arguments);\n};\nSk.abstr.setUpInheritance(\"UnboundLocalError\", Sk.builtin.UnboundLocalError, Sk.builtin.StandardError);\n\n/**\n * @constructor\n * @extends Sk.builtin.StandardError\n * @param {...*} args\n */\nSk.builtin.OverflowError = function (args) {\n    var o;\n    if (!(this instanceof Sk.builtin.OverflowError)) {\n        o = Object.create(Sk.builtin.OverflowError.prototype);\n        o.constructor.apply(o, arguments);\n        return o;\n    }\n    Sk.builtin.StandardError.apply(this, arguments);\n};\nSk.abstr.setUpInheritance(\"OverflowError\", Sk.builtin.OverflowError, Sk.builtin.StandardError);\n\n\n/**\n * @constructor\n * @extends Sk.builtin.StandardError\n * @param {...*} args\n */\nSk.builtin.SyntaxError = function (args) {\n    var o;\n    if (!(this instanceof Sk.builtin.SyntaxError)) {\n        o = Object.create(Sk.builtin.SyntaxError.prototype);\n        o.constructor.apply(o, arguments);\n        return o;\n    }\n    Sk.builtin.StandardError.apply(this, arguments);\n};\nSk.abstr.setUpInheritance(\"SyntaxError\", Sk.builtin.SyntaxError, Sk.builtin.StandardError);\n\n/**\n * @constructor\n * @extends Sk.builtin.StandardError\n * @param {...*} args\n */\nSk.builtin.RuntimeError = function (args) {\n    var o;\n    if (!(this instanceof Sk.builtin.RuntimeError)) {\n        o = Object.create(Sk.builtin.RuntimeError.prototype);\n        o.constructor.apply(o, arguments);\n        return o;\n    }\n    Sk.builtin.StandardError.apply(this, arguments);\n};\nSk.abstr.setUpInheritance(\"RuntimeError\", Sk.builtin.RuntimeError, Sk.builtin.StandardError);\nSk.exportSymbol(\"Sk.builtin.RuntimeError\", Sk.builtin.RuntimeError);\n\n\n/**\n * @constructor\n * @extends Sk.builtin.StandardError\n * @param {...*} args\n */\nSk.builtin.SuspensionError = function (args) {\n    var o;\n    if (!(this instanceof Sk.builtin.SuspensionError)) {\n        o = Object.create(Sk.builtin.SuspensionError.prototype);\n        o.constructor.apply(o, arguments);\n        return o;\n    }\n    Sk.builtin.StandardError.apply(this, arguments);\n};\nSk.abstr.setUpInheritance(\"SuspensionError\", Sk.builtin.SuspensionError, Sk.builtin.StandardError);\nSk.exportSymbol(\"Sk.builtin.SuspensionError\", Sk.builtin.SuspensionError);\n\n\n/**\n * @constructor\n * @extends Sk.builtin.BaseException\n * @param {...*} args\n */\nSk.builtin.SystemExit = function (args) {\n    var o;\n    if (!(this instanceof Sk.builtin.SystemExit)) {\n        o = Object.create(Sk.builtin.SystemExit.prototype);\n        o.constructor.apply(o, arguments);\n        return o;\n    }\n    Sk.builtin.BaseException.apply(this, arguments);\n};\nSk.abstr.setUpInheritance(\"SystemExit\", Sk.builtin.SystemExit, Sk.builtin.BaseException);\nSk.exportSymbol(\"Sk.builtin.SystemExit\", Sk.builtin.SystemExit);\n\n\n/**\n * @constructor\n * @extends Sk.builtin.StandardError\n * @param {...*} args\n */\nSk.builtin.TypeError = function (args) {\n    var o;\n    if (!(this instanceof Sk.builtin.TypeError)) {\n        o = Object.create(Sk.builtin.TypeError.prototype);\n        o.constructor.apply(o, arguments);\n        return o;\n    }\n    Sk.builtin.StandardError.apply(this, arguments);\n};\nSk.abstr.setUpInheritance(\"TypeError\", Sk.builtin.TypeError, Sk.builtin.StandardError);\nSk.exportSymbol(\"Sk.builtin.TypeError\", Sk.builtin.TypeError);\n/**\n * @constructor\n * @extends Sk.builtin.StandardError\n * @param {...*} args\n */\nSk.builtin.ValueError = function (args) {\n    var o;\n    if (!(this instanceof Sk.builtin.ValueError)) {\n        o = Object.create(Sk.builtin.ValueError.prototype);\n        o.constructor.apply(o, arguments);\n        return o;\n    }\n    Sk.builtin.StandardError.apply(this, arguments);\n};\nSk.abstr.setUpInheritance(\"ValueError\", Sk.builtin.ValueError, Sk.builtin.StandardError);\nSk.exportSymbol(\"Sk.builtin.ValueError\", Sk.builtin.ValueError);\n\n/**\n * @constructor\n * @extends Sk.builtin.StandardError\n * @param {...*} args\n */\nSk.builtin.ZeroDivisionError = function (args) {\n    var o;\n    if (!(this instanceof Sk.builtin.ZeroDivisionError)) {\n        o = Object.create(Sk.builtin.ZeroDivisionError.prototype);\n        o.constructor.apply(o, arguments);\n        return o;\n    }\n    Sk.builtin.StandardError.apply(this, arguments);\n};\nSk.abstr.setUpInheritance(\"ZeroDivisionError\", Sk.builtin.ZeroDivisionError, Sk.builtin.StandardError);\n\n/**\n * @constructor\n * @extends Sk.builtin.StandardError\n * @param {...*} args\n */\nSk.builtin.TimeLimitError = function (args) {\n    var o;\n    if (!(this instanceof Sk.builtin.TimeLimitError)) {\n        o = Object.create(Sk.builtin.TimeLimitError.prototype);\n        o.constructor.apply(o, arguments);\n        return o;\n    }\n    Sk.builtin.StandardError.apply(this, arguments);\n};\nSk.abstr.setUpInheritance(\"TimeLimitError\", Sk.builtin.TimeLimitError, Sk.builtin.StandardError);\nSk.exportSymbol(\"Sk.builtin.TimeLimitError\", Sk.builtin.TimeLimitError);\n\n/**\n * @constructor\n * @extends Sk.builtin.StandardError\n * @param {...*} args\n */\nSk.builtin.IOError = function (args) {\n    var o;\n    if (!(this instanceof Sk.builtin.IOError)) {\n        o = Object.create(Sk.builtin.IOError.prototype);\n        o.constructor.apply(o, arguments);\n        return o;\n    }\n    Sk.builtin.StandardError.apply(this, arguments);\n};\nSk.abstr.setUpInheritance(\"IOError\", Sk.builtin.IOError, Sk.builtin.StandardError);\nSk.exportSymbol(\"Sk.builtin.IOError\", Sk.builtin.IOError);\n\n\n/**\n * @constructor\n * @extends Sk.builtin.StandardError\n * @param {...*} args\n */\nSk.builtin.NotImplementedError = function (args) {\n    var o;\n    if (!(this instanceof Sk.builtin.NotImplementedError)) {\n        o = Object.create(Sk.builtin.NotImplementedError.prototype);\n        o.constructor.apply(o, arguments);\n        return o;\n    }\n    Sk.builtin.StandardError.apply(this, arguments);\n};\nSk.abstr.setUpInheritance(\"NotImplementedError\", Sk.builtin.NotImplementedError, Sk.builtin.StandardError);\nSk.exportSymbol(\"Sk.builtin.NotImplementedError\", Sk.builtin.NotImplementedError);\n\n/**\n * @constructor\n * @extends Sk.builtin.StandardError\n * @param {...*} args\n */\nSk.builtin.NegativePowerError = function (args) {\n    var o;\n    if (!(this instanceof Sk.builtin.NegativePowerError)) {\n        o = Object.create(Sk.builtin.NegativePowerError.prototype);\n        o.constructor.apply(o, arguments);\n        return o;\n    }\n    Sk.builtin.StandardError.apply(this, arguments);\n};\nSk.abstr.setUpInheritance(\"NegativePowerError\", Sk.builtin.NegativePowerError, Sk.builtin.StandardError);\nSk.exportSymbol(\"Sk.builtin.NegativePowerError\", Sk.builtin.NegativePowerError);\n\n/**\n * @constructor\n * @extends Sk.builtin.StandardError\n * @param {*} nativeError\n * @param {...*} args\n */\nSk.builtin.ExternalError = function (nativeError, args) {\n    var o;\n    if (!(this instanceof Sk.builtin.ExternalError)) {\n        o = Object.create(Sk.builtin.ExternalError.prototype);\n        o.constructor.apply(o, arguments);\n        return o;\n    }\n    // Make the first argument a string, so it can be printed in Python without errors,\n    // but save a reference to the real thing for Javascript consumption\n    args = Array.prototype.slice.call(arguments);\n    this.nativeError = args[0];\n    if (!(args[0] instanceof Sk.builtin.str)) {\n        args[0] = \"\"+args[0];\n    }\n    Sk.builtin.StandardError.apply(this, args);\n};\nSk.abstr.setUpInheritance(\"ExternalError\", Sk.builtin.ExternalError, Sk.builtin.StandardError);\nSk.exportSymbol(\"Sk.builtin.ExternalError\", Sk.builtin.ExternalError);\n\n/**\n * @constructor\n * @extends Sk.builtin.StandardError\n * @param {...*} args\n */\nSk.builtin.OperationError = function (args) {\n    var o;\n    if (!(this instanceof Sk.builtin.OperationError)) {\n        o = Object.create(Sk.builtin.OperationError.prototype);\n        o.constructor.apply(o, arguments);\n        return o;\n    }\n    Sk.builtin.StandardError.apply(this, arguments);\n};\nSk.abstr.setUpInheritance(\"OperationError\", Sk.builtin.OperationError, Sk.builtin.StandardError);\nSk.exportSymbol(\"Sk.builtin.OperationError\", Sk.builtin.OperationError);\n\n/**\n * @constructor\n * @extends Sk.builtin.StandardError\n * @param {...*} args\n */\nSk.builtin.SystemError = function (args) {\n    var o;\n    if (!(this instanceof Sk.builtin.SystemError)) {\n        o = Object.create(Sk.builtin.SystemError.prototype);\n        o.constructor.apply(o, arguments);\n        return o;\n    }\n    Sk.builtin.StandardError.apply(this, arguments);\n};\nSk.abstr.setUpInheritance(\"SystemError\", Sk.builtin.SystemError, Sk.builtin.StandardError);\nSk.exportSymbol(\"Sk.builtin.SystemError\", Sk.builtin.SystemError);\n\n/**\n * @constructor\n * @extends Sk.builtin.Exception\n * @param {...*} args\n */\nSk.builtin.StopIteration = function (args) {\n    var o;\n    if (!(this instanceof Sk.builtin.StopIteration)) {\n        o = Object.create(Sk.builtin.StopIteration.prototype);\n        o.constructor.apply(o, arguments);\n        return o;\n    }\n    Sk.builtin.Exception.apply(this, arguments);\n};\nSk.abstr.setUpInheritance(\"StopIteration\", Sk.builtin.StopIteration, Sk.builtin.Exception);\nSk.exportSymbol(\"Sk.builtin.StopIteration\", Sk.builtin.StopIteration);\n\n\n// TODO: Extract into sys.exc_info(). Work out how the heck\n// to find out what exceptions are being processed by parent stack frames...\nSk.builtin.getExcInfo = function(e) {\n    var v = [e.ob$type || Sk.builtin.none.none$, e, Sk.builtin.none.none$];\n\n    // TODO create a Traceback object for the third tuple element\n\n    return new Sk.builtin.tuple(v);\n};\n// NOT exported\n\n\n\n/***/ }),\n/* 16 */\n/***/ (function(module, exports) {\n\n/**\n * @constructor\n *\n * @param {Sk.builtin.func|Sk.builtin.method} func\n * @param {Object} self\n * @param {Sk.builtin.type|Sk.builtin.none} klass\n * @param {boolean=} builtin\n * \n * co_varnames and co_name come from generated code, must access as dict.\n */\nSk.builtin.method = function (func, self, klass, builtin) {\n    if (!(this instanceof Sk.builtin.method)) {\n        Sk.builtin.pyCheckArgsLen(\"method\", arguments.length, 3, 3);\n        if (!Sk.builtin.checkCallable(func)) {\n            throw new Sk.builtin.TypeError(\"First argument must be callable\");\n        }\n        if (self.ob$type === undefined) {\n            throw new Sk.builtin.TypeError(\"Second argument must be object of known type\");\n        }\n        return new Sk.builtin.method(func, self, klass);\n    }\n    this.tp$name = func.tp$name;\n    this.im_func = func;\n    this.im_self = self || Sk.builtin.none.none$;\n    this.im_class = klass || Sk.builtin.none.none$;\n    this.im_builtin = builtin;\n    this[\"$d\"] = {\n        im_func: func,\n        im_self: self,\n        im_class: klass\n    };\n};\n\nSk.exportSymbol(\"Sk.builtin.method\", Sk.builtin.method);\nSk.abstr.setUpInheritance(\"instancemethod\", Sk.builtin.method, Sk.builtin.object);\n\nSk.builtin.method.prototype.tp$name = \"method\";\n\nSk.builtin.method.prototype.ob$eq = function (other) {\n    if (((this.im_self == Sk.builtin.none.none$) && (other.im_self != Sk.builtin.none.none$)) ||  ((other.im_self == Sk.builtin.none.none$) && (this.im_self != Sk.builtin.none.none$))) {\n        return false;\n    }\n    try {\n        return Sk.misceval.richCompareBool(this.im_self, other.im_self, \"Eq\", false) && (this.im_func == other.im_func);\n    } catch (x) {\n        return false;\n    }\n};\n\nSk.builtin.method.prototype.ob$ne = function (other) {\n    return !(this.ob$eq(other));\n};\n\nSk.builtin.method.prototype.tp$hash = function () {\n    var selfhash, funchash;\n\n    if (this.im_self == Sk.builtin.none.none$) {\n        selfhash = 0;\n    } else {\n        selfhash = Sk.builtin.asnum$(Sk.builtin.hash(this.im_self));\n    }\n    funchash = Sk.builtin.asnum$(Sk.builtin.hash(this.im_func));\n\n    return new Sk.builtin.int_(selfhash + funchash);\n};\n\nSk.builtin.method.prototype.tp$call = function (args, kw) {\n    // Sk.asserts.assert(this.im_func instanceof Sk.builtin.func);\n\n    // 'args' and 'kw' get mucked around with heavily in applyOrSuspend();\n    // changing it here is OK.\n    if (this.im_self !== Sk.builtin.none.none$) {\n        args.unshift(this.im_self);\n    }\n\n    // if there is no first argument or\n    // if the first argument is not a subclass of the class this method belongs to we throw an error\n    // unless it's a builtin method, because they shouldn't have been __get__ and left in this unbound\n    // state.\n    if (this.im_self === Sk.builtin.none.none$) {\n        var getMessage = (function (reason) {\n            return \"unbound method \" + this.tp$name + \"() must be called with \" + Sk.abstr.typeName(this.im_class) + \" instance as first argument (got \" + reason + \" instead)\";\n        }).bind(this);\n\n        if (args.length > 0) {\n            if (this.im_class != Sk.builtin.none.none$ && !Sk.builtin.issubclass(args[0].ob$type, this.im_class) && !this.im_builtin) {\n                throw new Sk.builtin.TypeError(getMessage(Sk.abstr.typeName(args[0].ob$type) + \" instance\"));\n            }\n        } else {\n            throw new Sk.builtin.TypeError(getMessage(\"nothing\"));\n        }\n    }\n\n    // A method call is just a call to this.im_func with 'self' on the beginning of the args.\n    // Do the necessary.\n    return this.im_func.tp$call(args, kw);\n};\n\nSk.builtin.method.prototype.tp$descr_get = function (obj, objtype) {\n    Sk.asserts.assert(obj !== undefined && objtype !== undefined);\n    return new Sk.builtin.method(this, obj, objtype, this.im_builtin);\n};\n\nSk.builtin.method.pythonFunctions = [\"__get__\"];\n\nSk.builtin.method.prototype.__get__ = function __get__(self, instance, owner) {\n    Sk.builtin.pyCheckArgsLen(\"__get__\", arguments.length, 1, 2, false, true);\n    if (instance === Sk.builtin.none.none$ && owner === Sk.builtin.none.none$) {\n        throw new Sk.builtin.TypeError(\"__get__(None, None) is invalid\");\n    }\n\n    // if the owner is specified it needs to be a a subclass of im_self\n    if (owner && owner !== Sk.builtin.none.none$) {\n        if (Sk.builtin.issubclass(owner, self.im_class)) {\n            return self.tp$descr_get(instance, owner);\n        }\n\n        // if it's not we're not bound\n        return self;\n    }\n\n    // use the original type to get a bound object\n    return self.tp$descr_get(instance, Sk.builtin.none.none$);\n};\n\nSk.builtin.method.prototype[\"$r\"] = function () {\n    if (this.im_builtin) {\n        return new Sk.builtin.str(\"<built-in method \" + this.tp$name + \" of type object>\");\n    }\n\n    if (this.im_self === Sk.builtin.none.none$) {\n        return new Sk.builtin.str(\"<unbound method \" + Sk.abstr.typeName(this.im_class) + \".\" + this.tp$name + \">\");\n    }\n\n    var owner = this.im_class !== Sk.builtin.none.none$ ? Sk.abstr.typeName(this.im_class) : \"?\";\n    return new Sk.builtin.str(\"<bound method \" + owner  + \".\" + this.tp$name + \" of \" + Sk.ffi.remapToJs(Sk.misceval.objectRepr(this.im_self)) + \">\");\n};\n\n\n/***/ }),\n/* 17 */\n/***/ (function(module, exports) {\n\n/**\n * @namespace Sk.misceval\n *\n */\nSk.misceval = {};\n\n/*\n  Suspension object format:\n  {resume: function() {...}, // the continuation - returns either another suspension or the return value\n   data: <copied down from innermost level>,\n   optional: <if true, can be resumed immediately (eg debug stops)>,\n   child: <Suspension, or null if we are the innermost level>,\n   $blk: <>, $loc: <>, $gbl: <>, $exc: <>, $err: <>, [$cell: <>],\n  }\n*/\n\n/**\n *\n * Hi kids lets make a suspension...\n * @constructor\n * @param{function(?)=} resume A function to be called on resume. child is resumed first and its return value is passed to this function.\n * @param{Object=} child A child suspension. 'optional' will be copied from here if supplied.\n * @param{Object=} data Data attached to this suspension. Will be copied from child if not supplied.\n */\nSk.misceval.Suspension = function Suspension(resume, child, data) {\n    this.$isSuspension = true;\n    if (resume !== undefined && child !== undefined) {\n        this.resume = function() { return resume(child.resume()); };\n    }\n    this.child = child;\n    this.optional = child !== undefined && child.optional;\n    if (data === undefined && child !== undefined) {\n        this.data = child.data;\n    } else {\n        this.data = data;\n    }\n};\nSk.exportSymbol(\"Sk.misceval.Suspension\", Sk.misceval.Suspension);\n\n/**\n *\n * Well this seems pretty obvious by the name what it should do..\n *\n * @param{Sk.misceval.Suspension} susp\n * @param{string=} message\n */\nSk.misceval.retryOptionalSuspensionOrThrow = function (susp, message) {\n    while (susp instanceof Sk.misceval.Suspension) {\n        if (!susp.optional) {\n            throw new Sk.builtin.SuspensionError(message || \"Cannot call a function that blocks or suspends here\");\n        }\n        susp = susp.resume();\n    }\n    return susp;\n};\nSk.exportSymbol(\"Sk.misceval.retryOptionalSuspensionOrThrow\", Sk.misceval.retryOptionalSuspensionOrThrow);\n\n/**\n * Check if the given object is valid to use as an index. Only ints, or if the object has an `__index__` method.\n * @param o\n * @returns {boolean}\n */\nSk.misceval.isIndex = function (o) {\n    if (Sk.builtin.checkInt(o)) {\n        return true;\n    }\n    if (Sk.abstr.lookupSpecial(o, Sk.builtin.str.$index)) {\n        return true;\n    }\n    return false;\n};\nSk.exportSymbol(\"Sk.misceval.isIndex\", Sk.misceval.isIndex);\n\nSk.misceval.asIndex = function (o) {\n    var idxfn, ret;\n\n    if (!Sk.misceval.isIndex(o)) {\n        return undefined;\n    }\n    if (o === null) {\n        return undefined;\n    }\n    if (o === true) {\n        return 1;\n    }\n    if (o === false) {\n        return 0;\n    }\n    if (typeof o === \"number\") {\n        return o;\n    }\n    if (o.constructor === Sk.builtin.int_) {\n        return o.v;\n    }\n    if (o.constructor === Sk.builtin.lng) {\n        return o.tp$index();\n    }\n    if (o.constructor === Sk.builtin.bool) {\n        return Sk.builtin.asnum$(o);\n    }\n    idxfn = Sk.abstr.lookupSpecial(o, Sk.builtin.str.$index);\n    if (idxfn) {\n        ret = Sk.misceval.callsimArray(idxfn, [o]);\n        if (!Sk.builtin.checkInt(ret)) {\n            throw new Sk.builtin.TypeError(\"__index__ returned non-(int,long) (type \" +\n                                           Sk.abstr.typeName(ret) + \")\");\n        }\n        return Sk.builtin.asnum$(ret);\n    }\n    Sk.asserts.fail(\"todo asIndex;\");\n};\n\n/**\n * return u[v:w]\n */\nSk.misceval.applySlice = function (u, v, w, canSuspend) {\n    var ihigh;\n    var ilow;\n    if (u.sq$slice && Sk.misceval.isIndex(v) && Sk.misceval.isIndex(w)) {\n        ilow = Sk.misceval.asIndex(v);\n        if (ilow === undefined) {\n            ilow = 0;\n        }\n        ihigh = Sk.misceval.asIndex(w);\n        if (ihigh === undefined) {\n            ihigh = 1e100;\n        }\n        return Sk.abstr.sequenceGetSlice(u, ilow, ihigh);\n    }\n    return Sk.abstr.objectGetItem(u, new Sk.builtin.slice(v, w, null), canSuspend);\n};\nSk.exportSymbol(\"Sk.misceval.applySlice\", Sk.misceval.applySlice);\n\n/**\n * u[v:w] = x\n */\nSk.misceval.assignSlice = function (u, v, w, x, canSuspend) {\n    var slice;\n    var ihigh;\n    var ilow;\n    if (u.sq$ass_slice && Sk.misceval.isIndex(v) && Sk.misceval.isIndex(w)) {\n        ilow = Sk.misceval.asIndex(v) || 0;\n        ihigh = Sk.misceval.asIndex(w) || 1e100;\n        if (x === null) {\n            Sk.abstr.sequenceDelSlice(u, ilow, ihigh);\n        } else {\n            Sk.abstr.sequenceSetSlice(u, ilow, ihigh, x);\n        }\n    } else {\n        slice = new Sk.builtin.slice(v, w);\n        if (x === null) {\n            return Sk.abstr.objectDelItem(u, slice);\n        } else {\n            return Sk.abstr.objectSetItem(u, slice, x, canSuspend);\n        }\n    }\n};\nSk.exportSymbol(\"Sk.misceval.assignSlice\", Sk.misceval.assignSlice);\n\n/**\n * Used by min() and max() to get an array from arbitrary input.\n * Note that this does no validation, just coercion.\n */\nSk.misceval.arrayFromArguments = function (args) {\n    // If args is not a single thing return as is\n    var it, i;\n    var res;\n    var arg;\n    if (args.length != 1) {\n        return args;\n    }\n    arg = args[0];\n    if (arg instanceof Sk.builtin.set) {\n        // this is a Sk.builtin.set\n        arg = arg.tp$iter().$obj;\n    } else if (arg instanceof Sk.builtin.dict) {\n        // this is a Sk.builtin.list\n        arg = Sk.builtin.dict.prototype[\"keys\"].func_code(arg);\n    }\n\n    // shouldn't else if here as the above may output lists to arg.\n    if (arg instanceof Sk.builtin.list || arg instanceof Sk.builtin.tuple) {\n        return arg.v;\n    } else if (Sk.builtin.checkIterable(arg)) {\n        // handle arbitrary iterable (strings, generators, etc.)\n        res = [];\n        for (it = Sk.abstr.iter(arg), i = it.tp$iternext();\n            i !== undefined; i = it.tp$iternext()) {\n            res.push(i);\n        }\n        return res;\n    }\n\n    throw new Sk.builtin.TypeError(\"'\" + Sk.abstr.typeName(arg) + \"' object is not iterable\");\n};\nSk.exportSymbol(\"Sk.misceval.arrayFromArguments\", Sk.misceval.arrayFromArguments);\n\n/**\n * for reversed comparison: Gt -> Lt, etc.\n */\nSk.misceval.swappedOp_ = {\n    \"Eq\"   : \"Eq\",\n    \"NotEq\": \"NotEq\",\n    \"Lt\"   : \"GtE\",\n    \"LtE\"  : \"Gt\",\n    \"Gt\"   : \"LtE\",\n    \"GtE\"  : \"Lt\",\n    \"Is\"   : \"IsNot\",\n    \"IsNot\": \"Is\",\n    \"In_\"  : \"NotIn\",\n    \"NotIn\": \"In_\"\n};\n\n/**\n* @param{*} v\n* @param{*} w\n* @param{string} op\n* @param{boolean=} canSuspend\n */\nSk.misceval.richCompareBool = function (v, w, op, canSuspend) {\n    // v and w must be Python objects. will return Javascript true or false for internal use only\n    // if you want to return a value from richCompareBool to Python you must wrap as Sk.builtin.bool first\n    var wname,\n        vname,\n        ret,\n        swapped_method,\n        method,\n        swapped_shortcut,\n        shortcut,\n        v_has_shortcut,\n        w_has_shortcut,\n        op2shortcut,\n        vcmp,\n        wcmp,\n        w_seq_type,\n        w_num_type,\n        v_seq_type,\n        v_num_type,\n        sequence_types,\n        numeric_types,\n        w_type,\n        v_type;\n\n    Sk.asserts.assert((v !== null) && (v !== undefined), \"passed null or undefined parameter to Sk.misceval.richCompareBool\");\n    Sk.asserts.assert((w !== null) && (w !== undefined), \"passed null or undefined parameter to Sk.misceval.richCompareBool\");\n\n    v_type = new Sk.builtin.type(v);\n    w_type = new Sk.builtin.type(w);\n\n    // Python has specific rules when comparing two different builtin types\n    // currently, this code will execute even if the objects are not builtin types\n    // but will fall through and not return anything in this section\n    if ((v_type !== w_type) &&\n        (op === \"GtE\" || op === \"Gt\" || op === \"LtE\" || op === \"Lt\")) {\n        // note: sets are omitted here because they can only be compared to other sets\n        numeric_types = [Sk.builtin.float_.prototype.ob$type,\n                         Sk.builtin.int_.prototype.ob$type,\n                         Sk.builtin.lng.prototype.ob$type,\n                         Sk.builtin.bool.prototype.ob$type];\n        sequence_types = [Sk.builtin.dict.prototype.ob$type,\n                          Sk.builtin.enumerate.prototype.ob$type,\n                          Sk.builtin.list.prototype.ob$type,\n                          Sk.builtin.str.prototype.ob$type,\n                          Sk.builtin.tuple.prototype.ob$type];\n\n        v_num_type = numeric_types.indexOf(v_type);\n        v_seq_type = sequence_types.indexOf(v_type);\n        w_num_type = numeric_types.indexOf(w_type);\n        w_seq_type = sequence_types.indexOf(w_type);\n\n        // NoneTypes are considered less than any other type in Python\n        // note: this only handles comparing NoneType with any non-NoneType.\n        // Comparing NoneType with NoneType is handled further down.\n        if (v_type === Sk.builtin.none.prototype.ob$type) {\n            switch (op) {\n                case \"Lt\":\n                    return true;\n                case \"LtE\":\n                    return true;\n                case \"Gt\":\n                    return false;\n                case \"GtE\":\n                    return false;\n            }\n        }\n\n        if (w_type === Sk.builtin.none.prototype.ob$type) {\n            switch (op) {\n                case \"Lt\":\n                    return false;\n                case \"LtE\":\n                    return false;\n                case \"Gt\":\n                    return true;\n                case \"GtE\":\n                    return true;\n            }\n        }\n\n        // numeric types are always considered smaller than sequence types in Python\n        if (v_num_type !== -1 && w_seq_type !== -1) {\n            switch (op) {\n                case \"Lt\":\n                    return true;\n                case \"LtE\":\n                    return true;\n                case \"Gt\":\n                    return false;\n                case \"GtE\":\n                    return false;\n            }\n        }\n\n        if (v_seq_type !== -1 && w_num_type !== -1) {\n            switch (op) {\n                case \"Lt\":\n                    return false;\n                case \"LtE\":\n                    return false;\n                case \"Gt\":\n                    return true;\n                case \"GtE\":\n                    return true;\n            }\n        }\n\n        // in Python, different sequence types are ordered alphabetically\n        // by name so that dict < list < str < tuple\n        if (v_seq_type !== -1 && w_seq_type !== -1) {\n            switch (op) {\n                case \"Lt\":\n                    return v_seq_type < w_seq_type;\n                case \"LtE\":\n                    return v_seq_type <= w_seq_type;\n                case \"Gt\":\n                    return v_seq_type > w_seq_type;\n                case \"GtE\":\n                    return v_seq_type >= w_seq_type;\n            }\n        }\n    }\n\n\n    // handle identity and membership comparisons\n    if (op === \"Is\") {\n        if (v instanceof Sk.builtin.int_ && w instanceof Sk.builtin.int_) {\n            return v.numberCompare(w) === 0;\n        } else if (v instanceof Sk.builtin.float_ && w instanceof Sk.builtin.float_) {\n            return v.numberCompare(w) === 0;\n        } else if (v instanceof Sk.builtin.lng && w instanceof Sk.builtin.lng) {\n            return v.longCompare(w) === 0;\n        }\n\n        return v === w;\n    }\n\n    if (op === \"IsNot\") {\n        if (v instanceof Sk.builtin.int_ && w instanceof Sk.builtin.int_) {\n            return v.numberCompare(w) !== 0;\n        } else if (v instanceof Sk.builtin.float_ && w instanceof Sk.builtin.float_) {\n            return v.numberCompare(w) !== 0;\n        }else if (v instanceof Sk.builtin.lng && w instanceof Sk.builtin.lng) {\n            return v.longCompare(w) !== 0;\n        }\n\n        return v !== w;\n    }\n\n    if (op === \"In\") {\n        return Sk.misceval.chain(Sk.abstr.sequenceContains(w, v, canSuspend), Sk.misceval.isTrue);\n    }\n    if (op === \"NotIn\") {\n        return Sk.misceval.chain(\n            Sk.abstr.sequenceContains(w, v, canSuspend),\n            function(x) { return !Sk.misceval.isTrue(x); }\n        );\n    }\n\n    // Call Javascript shortcut method if exists for either object\n\n    op2shortcut = {\n        \"Eq\"   : \"ob$eq\",\n        \"NotEq\": \"ob$ne\",\n        \"Gt\"   : \"ob$gt\",\n        \"GtE\"  : \"ob$ge\",\n        \"Lt\"   : \"ob$lt\",\n        \"LtE\"  : \"ob$le\"\n    };\n\n    shortcut = op2shortcut[op];\n    v_has_shortcut = v.constructor.prototype.hasOwnProperty(shortcut);\n    if (v_has_shortcut) {\n        if ((ret = v[shortcut](w)) !== Sk.builtin.NotImplemented.NotImplemented$) {\n            return Sk.misceval.isTrue(ret);\n        }\n    }\n\n    swapped_shortcut = op2shortcut[Sk.misceval.swappedOp_[op]];\n    w_has_shortcut = w.constructor.prototype.hasOwnProperty(swapped_shortcut);\n    if (w_has_shortcut) {\n\n        if ((ret = w[swapped_shortcut](v)) !== Sk.builtin.NotImplemented.NotImplemented$) {\n            return Sk.misceval.isTrue(ret);\n        }\n    }\n\n    // use comparison methods if they are given for either object\n    if (v.tp$richcompare && (ret = v.tp$richcompare(w, op)) !== undefined) {\n        if (ret != Sk.builtin.NotImplemented.NotImplemented$) {\n            return Sk.misceval.isTrue(ret);\n        }\n    }\n\n    if (w.tp$richcompare && (ret = w.tp$richcompare(v, Sk.misceval.swappedOp_[op])) !== undefined) {\n        if (ret != Sk.builtin.NotImplemented.NotImplemented$) {\n            return Sk.misceval.isTrue(ret);\n        }\n    }\n\n\n    // depending on the op, try left:op:right, and if not, then\n    // right:reversed-top:left\n\n    method = Sk.abstr.lookupSpecial(v, Sk.misceval.op2method_[op]);\n    if (method && !v_has_shortcut) {\n        ret = Sk.misceval.callsimArray(method, [v, w]);\n        if (ret != Sk.builtin.NotImplemented.NotImplemented$) {\n            return Sk.misceval.isTrue(ret);\n        }\n    }\n\n    swapped_method = Sk.abstr.lookupSpecial(w, Sk.misceval.op2method_[Sk.misceval.swappedOp_[op]]);\n    if (swapped_method && !w_has_shortcut) {\n        ret = Sk.misceval.callsimArray(swapped_method, [w, v]);\n        if (ret != Sk.builtin.NotImplemented.NotImplemented$) {\n            return Sk.misceval.isTrue(ret);\n        }\n    }\n\n    vcmp = Sk.abstr.lookupSpecial(v, Sk.builtin.str.$cmp);\n    if (vcmp) {\n        try {\n            ret = Sk.misceval.callsimArray(vcmp, [v, w]);\n            if (Sk.builtin.checkNumber(ret)) {\n                ret = Sk.builtin.asnum$(ret);\n                if (op === \"Eq\") {\n                    return ret === 0;\n                } else if (op === \"NotEq\") {\n                    return ret !== 0;\n                } else if (op === \"Lt\") {\n                    return ret < 0;\n                } else if (op === \"Gt\") {\n                    return ret > 0;\n                } else if (op === \"LtE\") {\n                    return ret <= 0;\n                } else if (op === \"GtE\") {\n                    return ret >= 0;\n                }\n            }\n\n            if (ret !== Sk.builtin.NotImplemented.NotImplemented$) {\n                throw new Sk.builtin.TypeError(\"comparison did not return an int\");\n            }\n        } catch (e) {\n            throw new Sk.builtin.TypeError(\"comparison did not return an int\");\n        }\n    }\n\n    wcmp = Sk.abstr.lookupSpecial(w, Sk.builtin.str.$cmp);\n    if (wcmp) {\n        // note, flipped on return value and call\n        try {\n            ret = Sk.misceval.callsimArray(wcmp, [w, v]);\n            if (Sk.builtin.checkNumber(ret)) {\n                ret = Sk.builtin.asnum$(ret);\n                if (op === \"Eq\") {\n                    return ret === 0;\n                } else if (op === \"NotEq\") {\n                    return ret !== 0;\n                } else if (op === \"Lt\") {\n                    return ret > 0;\n                } else if (op === \"Gt\") {\n                    return ret < 0;\n                } else if (op === \"LtE\") {\n                    return ret >= 0;\n                } else if (op === \"GtE\") {\n                    return ret <= 0;\n                }\n            }\n\n            if (ret !== Sk.builtin.NotImplemented.NotImplemented$) {\n                throw new Sk.builtin.TypeError(\"comparison did not return an int\");\n            }\n        } catch (e) {\n            throw new Sk.builtin.TypeError(\"comparison did not return an int\");\n        }\n    }\n\n    // handle special cases for comparing None with None or Bool with Bool\n    if (((v instanceof Sk.builtin.none) && (w instanceof Sk.builtin.none)) ||\n        ((v instanceof Sk.builtin.bool) && (w instanceof Sk.builtin.bool))) {\n        // Javascript happens to return the same values when comparing null\n        // with null or true/false with true/false as Python does when\n        // comparing None with None or True/False with True/False\n\n        if (op === \"Eq\") {\n            return v.v === w.v;\n        }\n        if (op === \"NotEq\") {\n            return v.v !== w.v;\n        }\n        if (op === \"Gt\") {\n            return v.v > w.v;\n        }\n        if (op === \"GtE\") {\n            return v.v >= w.v;\n        }\n        if (op === \"Lt\") {\n            return v.v < w.v;\n        }\n        if (op === \"LtE\") {\n            return v.v <= w.v;\n        }\n    }\n\n\n    // handle equality comparisons for any remaining objects\n    if (op === \"Eq\") {\n        if ((v instanceof Sk.builtin.str) && (w instanceof Sk.builtin.str)) {\n            return v.v === w.v;\n        }\n        return v === w;\n    }\n    if (op === \"NotEq\") {\n        if ((v instanceof Sk.builtin.str) && (w instanceof Sk.builtin.str)) {\n            return v.v !== w.v;\n        }\n        return v !== w;\n    }\n\n    vname = Sk.abstr.typeName(v);\n    wname = Sk.abstr.typeName(w);\n    throw new Sk.builtin.ValueError(\"don't know how to compare '\" + vname + \"' and '\" + wname + \"'\");\n};\nSk.exportSymbol(\"Sk.misceval.richCompareBool\", Sk.misceval.richCompareBool);\n\nSk.misceval.objectRepr = function (v) {\n    Sk.asserts.assert(v !== undefined, \"trying to repr undefined\");\n    if ((v === null) || (v instanceof Sk.builtin.none)) {\n        return new Sk.builtin.str(\"None\");\n    } else if (v === true) {\n        // todo; these should be consts\n        return new Sk.builtin.str(\"True\");\n    } else if (v === false) {\n        return new Sk.builtin.str(\"False\");\n    } else if (typeof v === \"number\") {\n        return new Sk.builtin.str(\"\" + v);\n    } else if (typeof v === \"string\") {\n        return new Sk.builtin.str(v);\n    } else if (!v[\"$r\"]) {\n        if (v.tp$name) {\n            return new Sk.builtin.str(\"<\" + v.tp$name + \" object>\");\n        } else {\n            return new Sk.builtin.str(\"<unknown>\");\n        }\n    } else if (v.constructor === Sk.builtin.float_) {\n        if (v.v === Infinity) {\n            return new Sk.builtin.str(\"inf\");\n        } else if (v.v === -Infinity) {\n            return new Sk.builtin.str(\"-inf\");\n        } else {\n            return v[\"$r\"]();\n        }\n    } else if (v.constructor === Sk.builtin.int_) {\n        return v[\"$r\"]();\n    } else {\n        return v[\"$r\"]();\n    }\n};\nSk.exportSymbol(\"Sk.misceval.objectRepr\", Sk.misceval.objectRepr);\n\nSk.misceval.opAllowsEquality = function (op) {\n    switch (op) {\n        case \"LtE\":\n        case \"Eq\":\n        case \"GtE\":\n            return true;\n    }\n    return false;\n};\nSk.exportSymbol(\"Sk.misceval.opAllowsEquality\", Sk.misceval.opAllowsEquality);\n\nSk.misceval.isTrue = function (x) {\n    var ret;\n    if (x === true) {\n        return true;\n    }\n    if (x === false) {\n        return false;\n    }\n    if (x === null) {\n        return false;\n    }\n    if (x.constructor === Sk.builtin.none) {\n        return false;\n    }\n\n    if (x.constructor === Sk.builtin.NotImplemented) {\n        return false;\n    }\n\n    if (x.constructor === Sk.builtin.bool) {\n        return x.v;\n    }\n    if (typeof x === \"number\") {\n        return x !== 0;\n    }\n    if (x instanceof Sk.builtin.lng) {\n        return x.nb$nonzero();\n    }\n    if (x.constructor === Sk.builtin.int_) {\n        return x.v !== 0;\n    }\n    if (x.constructor === Sk.builtin.float_) {\n        return x.v !== 0;\n    }\n    if (x[\"__nonzero__\"]) {\n        ret = Sk.misceval.callsimArray(x[\"__nonzero__\"], [x]);\n        if (!Sk.builtin.checkInt(ret)) {\n            throw new Sk.builtin.TypeError(\"__nonzero__ should return an int\");\n        }\n        return Sk.builtin.asnum$(ret) !== 0;\n    }\n    if (x[\"__len__\"]) {\n        ret = Sk.misceval.callsimArray(x[\"__len__\"], [x]);\n        if (!Sk.builtin.checkInt(ret)) {\n            throw new Sk.builtin.TypeError(\"__len__ should return an int\");\n        }\n        return Sk.builtin.asnum$(ret) !== 0;\n    }\n    if (x.mp$length) {\n        return Sk.builtin.asnum$(x.mp$length()) !== 0;\n    }\n    if (x.sq$length) {\n        return Sk.builtin.asnum$(x.sq$length()) !== 0;\n    }\n    return true;\n};\nSk.exportSymbol(\"Sk.misceval.isTrue\", Sk.misceval.isTrue);\n\nSk.misceval.softspace_ = false;\nSk.misceval.print_ = function (x) {\n    var s;\n\n    function isspace(c) {\n        return c === \"\\n\" || c === \"\\t\" || c === \"\\r\";\n    }\n\n    if (Sk.misceval.softspace_) {\n        if (x !== \"\\n\") {\n            Sk.output(\" \");\n        }\n        Sk.misceval.softspace_ = false;\n    }\n\n    s = new Sk.builtin.str(x);\n\n    return Sk.misceval.chain(Sk.importModule(\"sys\", false, true), function(sys) {\n        return Sk.misceval.apply(sys[\"$d\"][\"stdout\"][\"write\"], undefined, undefined, undefined, [sys[\"$d\"][\"stdout\"], s]);\n    }, function () {\n        if (s.v.length === 0 || !isspace(s.v[s.v.length - 1]) || s.v[s.v.length - 1] === \" \") {\n            Sk.misceval.softspace_ = true;\n        }\n    });\n};\nSk.exportSymbol(\"Sk.misceval.print_\", Sk.misceval.print_);\n\n/**\n * @param {string} name\n * @param {Object=} other generally globals\n */\nSk.misceval.loadname = function (name, other) {\n    var bi;\n    var v = other[name];\n    if (v !== undefined) {\n        if (typeof v === \"function\" && v[\"$d\"] === undefined && v[\"tp$name\"] === undefined) {\n            return v();\n        }\n        return v;\n    }\n\n    bi = Sk.builtins[name];\n    if (bi !== undefined) {\n        return bi;\n    }\n\n    throw new Sk.builtin.NameError(\"name '\" + Sk.unfixReserved(name) + \"' is not defined\");\n};\nSk.exportSymbol(\"Sk.misceval.loadname\", Sk.misceval.loadname);\n\n/**\n *\n * Notes on necessity for 'call()':\n *\n * Classes are callable in python to create an instance of the class. If\n * we're calling \"C()\" we cannot tell at the call site whether we're\n * calling a standard function, or instantiating a class.\n *\n * JS does not support user-level callables. So, we can't use the normal\n * prototype hierarchy to make the class inherit from a 'class' type\n * where the various tp$getattr, etc. methods would live.\n *\n * Instead, we must copy all the methods from the prototype of our class\n * type onto every instance of the class constructor function object.\n * That way, both \"C()\" and \"C.tp$getattr(...)\" can still work. This is\n * of course quite expensive.\n *\n * The alternative would be to indirect all calls (whether classes or\n * regular functions) through something like C.$call(...). In the case\n * of class construction, $call could then call the constructor after\n * munging arguments to pass them on. This would impose a penalty on\n * regular function calls unfortunately, as they would have to do the\n * same thing.\n *\n * Note that the same problem exists for function objects too (a \"def\"\n * creates a function object that also has properties). It just happens\n * that attributes on classes in python are much more useful and common\n * that the attributes on functions.\n *\n * Also note, that for full python compatibility we have to do the $call\n * method because any python object could have a __call__ method which\n * makes the python object callable too. So, unless we were to make\n * *all* objects simply (function(){...}) and use the dict to create\n * hierarchy, there would be no way to call that python user function. I\n * think I'm prepared to sacrifice __call__ support, or only support it\n * post-ECMA5 or something.\n *\n * Is using (function(){...}) as the only object type too crazy?\n * Probably. Better or worse than having two levels of function\n * invocation for every function call?\n *\n * For a class `C' with instance `inst' we have the following cases:\n *\n * 1. C.attr\n *\n * 2. C.staticmeth()\n *\n * 3. x = C.staticmeth; x()\n *\n * 4. inst = C()\n *\n * 5. inst.attr\n *\n * 6. inst.meth()\n *\n * 7. x = inst.meth; x()\n *\n * 8. inst(), where C defines a __call__\n *\n * Because in general these are accomplished by a helper function\n * (tp$getattr/setattr/slice/ass_slice/etc.) it seems appropriate to add\n * a call that generally just calls through, but sometimes handles the\n * unusual cases. Once ECMA-5 is more broadly supported we can revisit\n * and hopefully optimize.\n *\n * @param {Object} func the thing to call\n * @param {Object=} kwdict **kwargs\n * @param {Object=} varargseq **args\n * @param {Object=} kws keyword args or undef\n * @param {...*} args stuff to pass it\n *\n *\n * TODO I think all the above is out of date.\n */\nSk.misceval.call = function (func, kwdict, varargseq, kws, args) {\n    args = Array.prototype.slice.call(arguments, 4);\n    // todo; possibly inline apply to avoid extra stack frame creation\n    return Sk.misceval.apply(func, kwdict, varargseq, kws, args);\n};\nSk.exportSymbol(\"Sk.misceval.call\", Sk.misceval.call);\n\n/**\n * @param {?Object} suspensionHandlers\n * @param {Object} func the thing to call\n * @param {Object=} kwdict **kwargs\n * @param {Object=} varargseq **args\n * @param {Object=} kws keyword args or undef\n * @param {...*} args stuff to pass it\n *\n *\n * TODO I think all the above is out of date.\n */\n\nSk.misceval.callAsync = function (suspensionHandlers, func, kwdict, varargseq, kws, args) {\n    args = Array.prototype.slice.call(arguments, 5);\n    // todo; possibly inline apply to avoid extra stack frame creation\n    return Sk.misceval.applyAsync(suspensionHandlers, func, kwdict, varargseq, kws, args);\n};\nSk.exportSymbol(\"Sk.misceval.callAsync\", Sk.misceval.callAsync);\n\n\nSk.misceval.callOrSuspend = function (func, kwdict, varargseq, kws, args) {\n    args = Array.prototype.slice.call(arguments, 4);\n    // todo; possibly inline apply to avoid extra stack frame creation\n    return Sk.misceval.applyOrSuspend(func, kwdict, varargseq, kws, args);\n};\nSk.exportSymbol(\"Sk.misceval.callOrSuspend\", Sk.misceval.callOrSuspend);\n\n/**\n * @param {Object} func the thing to call\n * @param {...*} args stuff to pass it\n */\nSk.misceval.callsim = function (func, args) {\n    args = Array.prototype.slice.call(arguments, 1);\n    return Sk.misceval.apply(func, undefined, undefined, undefined, args);\n};\nSk.exportSymbol(\"Sk.misceval.callsim\", Sk.misceval.callsim);\n\n/**\n * @param {Object} func the thing to call\n * @param {Array=} args an array of arguments to pass to the func\n *\n * Does the same thing as callsim without expensive call to Array.slice.\n * Requires args to be a Javascript array.\n */\nSk.misceval.callsimArray = function(func, args) {\n    var argarray = args ? args : [];\n    return Sk.misceval.apply(func, undefined, undefined, undefined, argarray);\n};\nSk.exportSymbol(\"Sk.misceval.callsimArray\", Sk.misceval.callsimArray);\n\n/**\n * @param {?Object} suspensionHandlers any custom suspension handlers\n * @param {Object} func the thing to call\n * @param {...*} args stuff to pass it\n */\nSk.misceval.callsimAsync = function (suspensionHandlers, func, args) {\n    args = Array.prototype.slice.call(arguments, 2);\n    return Sk.misceval.applyAsync(suspensionHandlers, func, undefined, undefined, undefined, args);\n};\nSk.exportSymbol(\"Sk.misceval.callsimAsync\", Sk.misceval.callsimAsync);\n\n\n/**\n * @param {Object} func the thing to call\n * @param {...*} args stuff to pass it\n */\nSk.misceval.callsimOrSuspend = function (func, args) {\n    args = Array.prototype.slice.call(arguments, 1);\n    return Sk.misceval.applyOrSuspend(func, undefined, undefined, undefined, args);\n};\nSk.exportSymbol(\"Sk.misceval.callsimOrSuspend\", Sk.misceval.callsimOrSuspend);\n\n/**\n * @param {Object} func the thing to call\n * @param {Array=} args an array of arguments to pass to the func\n *\n * Does the same thing as callsimOrSuspend without expensive call to\n * Array.slice.  Requires args to be a Javascript array.\n */\nSk.misceval.callsimOrSuspendArray = function (func, args) {\n    var argarray = args ? args : [];\n    return Sk.misceval.applyOrSuspend(func, undefined, undefined, undefined, argarray);\n};\nSk.exportSymbol(\"Sk.misceval.callsimOrSuspendArray\", Sk.misceval.callsimOrSuspendArray);\n\n/**\n * Wrap Sk.misceval.applyOrSuspend, but throw an error if we suspend\n */\nSk.misceval.apply = function (func, kwdict, varargseq, kws, args) {\n    var r = Sk.misceval.applyOrSuspend(func, kwdict, varargseq, kws, args);\n    if (r instanceof Sk.misceval.Suspension) {\n        return Sk.misceval.retryOptionalSuspensionOrThrow(r);\n    } else {\n        return r;\n    }\n};\nSk.exportSymbol(\"Sk.misceval.apply\", Sk.misceval.apply);\n\n/**\n * Wraps anything that can return an Sk.misceval.Suspension, and returns a\n * JS Promise with the result. Also takes an object map of suspension handlers:\n * pass in {\"suspType\": function (susp) {} }, and your function will be called\n * with the Suspension object if susp.type==\"suspType\". The type \"*\" will match\n * all otherwise unhandled suspensions.\n *\n * A suspension handler should return a Promise yielding the return value of\n * r.resume() - ie, either the final return value of this call or another\n * Suspension. That is, the null suspension handler is:\n *\n *     function handler(susp) {\n *       return new Promise(function(resolve, reject) {\n *         try {\n *           resolve(susp.resume());\n *         } catch(e) {\n *           reject(e);\n *         }\n *       });\n *     }\n *\n * Alternatively, a handler can return null to perform the default action for\n * that suspension type.\n *\n * (Note: do *not* call asyncToPromise() in a suspension handler; this will\n * create a new Promise object for each such suspension that occurs)\n *\n * asyncToPromise() returns a Promise that will be resolved with the final\n * return value, or rejected with an exception if one is thrown.\n *\n * @param{function()} suspendablefn returns either a result or a Suspension\n * @param{Object=} suspHandlers an object map of suspension handlers\n */\nSk.misceval.asyncToPromise = function(suspendablefn, suspHandlers) {\n    return new Promise(function(resolve, reject) {\n        try {\n            var r = suspendablefn();\n\n            (function handleResponse (r) {\n                try {\n                    // jsh*nt insists these be defined outside the loop\n                    var resume = function() {\n                        try {\n                            handleResponse(r.resume());\n                        } catch (e) {\n                            reject(e);\n                        }\n                    };\n                    var resumeWithData = function resolved(x) {\n                        try {\n                            r.data[\"result\"] = x;\n                            resume();\n                        } catch(e) {\n                            reject(e);\n                        }\n                    };\n                    var resumeWithError = function rejected(e) {\n                        try {\n                            r.data[\"error\"] = e;\n                            resume();\n                        } catch(ex) {\n                            reject(ex);\n                        }\n                    };\n\n\n                    while (r instanceof Sk.misceval.Suspension) {\n\n                        var handler = suspHandlers && (suspHandlers[r.data[\"type\"]] || suspHandlers[\"*\"]);\n\n                        if (handler) {\n                            var handlerPromise = handler(r);\n                            if (handlerPromise) {\n                                handlerPromise.then(handleResponse, reject);\n                                return;\n                            }\n                        }\n\n                        if (r.data[\"type\"] == \"Sk.promise\") {\n                            r.data[\"promise\"].then(resumeWithData, resumeWithError);\n                            return;\n\n                        } else if (r.data[\"type\"] == \"Sk.yield\") {\n                            // Assumes all yields are optional, as Sk.setTimeout might\n                            // not be able to yield.\n                            //Sk.setTimeout(resume, 0);\n                            Sk.global[\"setImmediate\"](resume);\n                            return;\n\n                        } else if (r.data[\"type\"] == \"Sk.delay\") {\n                            //Sk.setTimeout(resume, 1);\n                            Sk.global[\"setImmediate\"](resume);\n                            return;\n\n                        } else if (r.optional) {\n                            // Unhandled optional suspensions just get\n                            // resumed immediately, and we go around the loop again.\n                            r = r.resume();\n\n                        } else {\n                            // Unhandled, non-optional suspension.\n                            throw new Sk.builtin.SuspensionError(\"Unhandled non-optional suspension of type '\"+r.data[\"type\"]+\"'\");\n                        }\n                    }\n\n                    resolve(r);\n                } catch(e) {\n                    reject(e);\n                }\n            })(r);\n\n        } catch (e) {\n            reject(e);\n        }\n    });\n};\nSk.exportSymbol(\"Sk.misceval.asyncToPromise\", Sk.misceval.asyncToPromise);\n\nSk.misceval.applyAsync = function (suspHandlers, func, kwdict, varargseq, kws, args) {\n    return Sk.misceval.asyncToPromise(function() {\n        return Sk.misceval.applyOrSuspend(func, kwdict, varargseq, kws, args);\n    }, suspHandlers);\n};\nSk.exportSymbol(\"Sk.misceval.applyAsync\", Sk.misceval.applyAsync);\n\n/**\n * Chain together a set of functions, each of which might return a value or\n * an Sk.misceval.Suspension. Each function is called with the return value of\n * the preceding function, but does not see any suspensions. If a function suspends,\n * Sk.misceval.chain() returns a suspension that will resume the chain once an actual\n * return value is available.\n *\n * The idea is to allow a Promise-like chaining of possibly-suspending steps without\n * repeating boilerplate suspend-and-resume code.\n *\n * For example, imagine we call Sk.misceval.chain(x, f).\n *  - If x is a value, we return f(x).\n *  - If x is a suspension, we suspend. We will suspend and resume until we get a\n *    return value, and then we will return f(<resumed-value).\n * This can be expanded to an arbitrary number of functions\n * (eg Sk.misceval.chain(x, f, g), which is equivalent to chain(chain(x, f), g).)\n * @template T\n * @param {T}              initialValue\n * @param {...function(T)} chainedFns\n */\n\nSk.misceval.chain = function (initialValue, chainedFns) {\n    // We try to minimse overhead when nothing suspends (the common case)\n    var i = 1, value = initialValue, j, fs;\n\n    while (true) {\n        if (i == arguments.length) {\n            return value;\n        }\n        if (value && value.$isSuspension) { break; } // oops, slow case\n        value = arguments[i](value);\n        i++;\n    }\n\n    // Okay, we've suspended at least once, so we're taking the slow(er) path.\n\n    // Copy our remaining arguments into an array (inline, because passing\n    // \"arguments\" out of a function kills the V8 optimiser).\n    // (discussion: https://github.com/skulpt/skulpt/pull/552)\n    fs = new Array(arguments.length - i);\n\n    for (j = 0; j < arguments.length - i; j++) {\n        fs[j] = arguments[i+j];\n    }\n\n    j = 0;\n\n    return (function nextStep(r) {\n        while (j < fs.length) {\n            if (r instanceof Sk.misceval.Suspension) {\n                return new Sk.misceval.Suspension(nextStep, r);\n            }\n\n            r = fs[j](r);\n            j++;\n        }\n\n        return r;\n    })(value);\n};\nSk.exportSymbol(\"Sk.misceval.chain\", Sk.misceval.chain);\n\n\n/**\n * Catch any exceptions thrown by a function, or by resuming any suspension it\n * returns.\n *\n *     var result = Sk.misceval.tryCatch(asyncFunc, function(err) {\n *       console.log(err);\n *     });\n *\n * Because exceptions are returned asynchronously aswell you can't catch them\n * with a try/catch. That's what this function is for.\n */\nSk.misceval.tryCatch = function (tryFn, catchFn) {\n    var r;\n\n    try {\n        r = tryFn();\n    } catch(e) {\n        return catchFn(e);\n    }\n\n    if (r instanceof Sk.misceval.Suspension) {\n        var susp = new Sk.misceval.Suspension(undefined, r);\n        susp.resume = function() { return Sk.misceval.tryCatch(r.resume, catchFn); };\n        return susp;\n    } else {\n        return r;\n    }\n};\nSk.exportSymbol(\"Sk.misceval.tryCatch\", Sk.misceval.tryCatch);\n\n/**\n * Perform a suspension-aware for-each on an iterator, without\n * blowing up the stack.\n * forFn() is called for each element in the iterator, with two\n * arguments: the current element and the previous return value\n * of forFn() (or initialValue on the first call). In this way,\n * iterFor() can be used as a simple for loop, or alternatively\n * as a 'reduce' operation. The return value of the final call to\n * forFn() will be the return value of iterFor() (after all\n * suspensions are resumed, that is; if the iterator is empty then\n * initialValue will be returned.)\n *\n * The iteration can be terminated early, by returning\n * an instance of Sk.misceval.Break. If an argument is given to\n * the Sk.misceval.Break() constructor, that value will be\n * returned from iterFor(). It is therefore possible to use\n * iterFor() on infinite iterators.\n *\n * @param {*} iter\n * @param {function(*,*=)} forFn\n * @param {*=} initialValue\n */\nSk.misceval.iterFor = function (iter, forFn, initialValue) {\n    var prevValue = initialValue;\n\n    var breakOrIterNext = function(r) {\n        prevValue = r;\n        return (r instanceof Sk.misceval.Break) ? r : iter.tp$iternext(true);\n    };\n\n    return (function nextStep(i) {\n        while (i !== undefined) {\n            if (i instanceof Sk.misceval.Suspension) {\n                return new Sk.misceval.Suspension(nextStep, i);\n            }\n\n            if (i === Sk.misceval.Break || i instanceof Sk.misceval.Break) {\n                return i.brValue;\n            }\n\n            i = Sk.misceval.chain(\n                forFn(i, prevValue),\n                breakOrIterNext\n            );\n        }\n        return prevValue;\n    })(iter.tp$iternext(true));\n};\nSk.exportSymbol(\"Sk.misceval.iterFor\", Sk.misceval.iterFor);\n\n/**\n * A special value to return from an iterFor() function,\n * to abort the iteration. Optionally supply a value for iterFor() to return\n * (defaults to 'undefined')\n *\n * @constructor\n * @param {*=}  brValue\n */\nSk.misceval.Break = function(brValue) {\n    if (!(this instanceof Sk.misceval.Break)) {\n        return new Sk.misceval.Break(brValue);\n    }\n\n    this.brValue = brValue;\n};\nSk.exportSymbol(\"Sk.misceval.Break\", Sk.misceval.Break);\n\n/**\n * same as Sk.misceval.call except args is an actual array, rather than\n * varargs.\n */\nSk.misceval.applyOrSuspend = function (func, kwdict, varargseq, kws, args) {\n    var fcall;\n    var it, i;\n\n    if (func === null || func instanceof Sk.builtin.none) {\n        throw new Sk.builtin.TypeError(\"'\" + Sk.abstr.typeName(func) + \"' object is not callable\");\n    }\n\n    if (typeof func === \"function\" && func.tp$call === undefined) {\n        func = new Sk.builtin.func(func);\n    }\n\n    fcall = func.tp$call;\n    if (fcall !== undefined) {\n        if (varargseq) {\n            for (it = varargseq.tp$iter(), i = it.tp$iternext(); i !== undefined; i = it.tp$iternext()) {\n                args.push(i);\n            }\n        }\n\n        if (kwdict) {\n            for (it = Sk.abstr.iter(kwdict), i = it.tp$iternext(); i!== undefined; i = it.tp$iternext()) {\n                if (!Sk.builtin.checkString(i)) {\n                    throw new Sk.builtin.TypeError(\"Function keywords must be strings\");\n                }\n                kws.push(i.v);\n                kws.push(Sk.abstr.objectGetItem(kwdict, i, false));\n            }\n        }\n        return fcall.call(func, args, kws, kwdict);\n    }\n\n    // todo; can we push this into a tp$call somewhere so there's\n    // not redundant checks everywhere for all of these __x__ ones?\n    fcall = func.__call__;\n    if (fcall !== undefined) {\n        // func is actually the object here because we got __call__\n        // from it. todo; should probably use descr_get here\n        args.unshift(func);\n        return Sk.misceval.apply(fcall, kwdict, varargseq, kws, args);\n    }\n\n    throw new Sk.builtin.TypeError(\"'\" + Sk.abstr.typeName(func) + \"' object is not callable\");\n};\nSk.exportSymbol(\"Sk.misceval.applyOrSuspend\", Sk.misceval.applyOrSuspend);\n\n/**\n * Do the boilerplate suspension stuff.\n */\nSk.misceval.promiseToSuspension = function(promise) {\n    var suspension = new Sk.misceval.Suspension();\n\n    suspension.resume = function() {\n        if (suspension.data[\"error\"]) {\n            throw suspension.data[\"error\"];\n        }\n\n        return suspension.data[\"result\"];\n    };\n\n    suspension.data = {\n        type: \"Sk.promise\",\n        promise: promise\n    };\n\n    return suspension;\n};\nSk.exportSymbol(\"Sk.misceval.promiseToSuspension\", Sk.misceval.promiseToSuspension);\n\n/**\n * Constructs a class object given a code object representing the body\n * of the class, the name of the class, and the list of bases.\n *\n * There are no \"old-style\" classes in Skulpt, so use the user-specified\n * metaclass (todo;) if there is one, the type of the 0th base class if\n * there's bases, or otherwise the 'type' type.\n *\n * The func code object is passed a (js) dict for its locals which it\n * stores everything into.\n *\n * The metaclass is then called as metaclass(name, bases, locals) and\n * should return a newly constructed class object.\n *\n */\nSk.misceval.buildClass = function (globals, func, name, bases, cell) {\n    // todo; metaclass\n    var klass;\n    var meta = Sk.builtin.type;\n\n    var l_cell = cell === undefined ? {} : cell;\n    var locals = {};\n\n    // init the dict for the class\n    func(globals, locals, l_cell);\n    // ToDo: check if func contains the __meta__ attribute\n    // or if the bases contain __meta__\n    // new Syntax would be different\n\n    // file's __name__ is class's __module__\n    locals.__module__ = globals[\"__name__\"];\n    var _name = new Sk.builtin.str(name);\n    var _bases = new Sk.builtin.tuple(bases);\n    var _locals = [];\n    var key;\n\n    // build array for python dict\n    for (key in locals) {\n        if (!locals.hasOwnProperty(key)) {\n            //The current property key not a direct property of p\n            continue;\n        }\n        _locals.push(new Sk.builtin.str(key)); // push key\n        _locals.push(locals[key]); // push associated value\n    }\n    _locals = new Sk.builtin.dict(_locals);\n\n    klass = Sk.misceval.callsimArray(meta, [_name, _bases, _locals]);\n\n    return klass;\n};\nSk.exportSymbol(\"Sk.misceval.buildClass\", Sk.misceval.buildClass);\n\n\n/***/ }),\n/* 18 */\n/***/ (function(module, exports) {\n\n/**\n * @constructor\n * Sk.builtin.seqtype\n *\n * @description\n * Abstract class for Python sequence types.\n *\n * @extends {Sk.builtin.object}\n *\n * @return {undefined} Cannot instantiate a Sk.builtin.seqtype object\n */\nSk.builtin.seqtype = function () {\n\n    throw new Sk.builtin.ExternalError(\"Cannot instantiate abstract Sk.builtin.seqtype class\");\n\n};\n\nSk.abstr.setUpInheritance(\"SequenceType\", Sk.builtin.seqtype, Sk.builtin.object);\n\nSk.builtin.seqtype.sk$abstract = true;\n\n/**\n * Python wrapper of `__len__` method.\n *\n * @name  __len__\n * @instance\n * @memberOf Sk.builtin.seqtype.prototype\n */\nSk.builtin.seqtype.prototype[\"__len__\"] = new Sk.builtin.func(function (self) {\n\n    Sk.builtin.pyCheckArgsLen(\"__len__\", arguments.length, 0, 0, false, true);\n\n    return new Sk.builtin.int_(self.sq$length());    \n\n});\n\n/**\n * Python wrapper of `__iter__` method.\n *\n * @name  __iter__\n * @instance\n * @memberOf Sk.builtin.seqtype.prototype\n */\nSk.builtin.seqtype.prototype[\"__iter__\"] = new Sk.builtin.func(function (self) {\n\n    Sk.builtin.pyCheckArgsLen(\"__iter__\", arguments.length, 0, 0, false, true);\n\n    return self.tp$iter();\n\n});\n\n/**\n * Python wrapper of `__contains__` method.\n *\n * @name  __contains__\n * @instance\n * @memberOf Sk.builtin.seqtype.prototype\n */\nSk.builtin.seqtype.prototype[\"__contains__\"] = new Sk.builtin.func(function (self, item) {\n\n    Sk.builtin.pyCheckArgsLen(\"__contains__\", arguments.length, 1, 1, false, true);\n\n    if (self.sq$contains(item)) {\n        return Sk.builtin.bool.true$;\n    } else {\n        return Sk.builtin.bool.false$;\n    }\n\n});\n\n/**\n * Python wrapper of `__getitem__` method.\n *\n * @name  __getitem__\n * @instance\n * @memberOf Sk.builtin.seqtype.prototype\n */\nSk.builtin.seqtype.prototype[\"__getitem__\"] = new Sk.builtin.func(function (self, key) {\n\n    Sk.builtin.pyCheckArgsLen(\"__getitem__\", arguments.length, 1, 1, false, true);\n\n    return self.mp$subscript(key);\n\n});\n\n/**\n * Python wrapper of `__add__` method.\n *\n * @name  __add__\n * @instance\n * @memberOf Sk.builtin.seqtype.prototype\n */\nSk.builtin.seqtype.prototype[\"__add__\"] = new Sk.builtin.func(function (self, other) {\n\n    Sk.builtin.pyCheckArgsLen(\"__add__\", arguments.length, 1, 1, false, true);\n\n    return self.sq$concat(other);\n\n});\n\n/**\n * Python wrapper of `__mul__` method.\n *\n * @name  __mul__\n * @instance\n * @memberOf Sk.builtin.seqtype.prototype\n */\nSk.builtin.seqtype.prototype[\"__mul__\"] = new Sk.builtin.func(function (self, n) {\n\n    Sk.builtin.pyCheckArgsLen(\"__mul__\", arguments.length, 1, 1, false, true);\n\n    if (!Sk.misceval.isIndex(n)) {\n        throw new Sk.builtin.TypeError(\"can't multiply sequence by non-int of type '\" + Sk.abstr.typeName(n) + \"'\");\n    }\n\n    return self.sq$repeat(n);\n\n});\n\n/**\n * Python wrapper of `__rmul__` method.\n *\n * @name  __rmul__\n * @instance\n * @memberOf Sk.builtin.seqtype.prototype\n */\nSk.builtin.seqtype.prototype[\"__rmul__\"] = new Sk.builtin.func(function (self, n) {\n\n    Sk.builtin.pyCheckArgsLen(\"__rmul__\", arguments.length, 1, 1, false, true);\n\n    return self.sq$repeat(n);    \n\n});\n\n\n/***/ }),\n/* 19 */\n/***/ (function(module, exports) {\n\n/**\n * @constructor\n * @param {Array.<Object>=} L\n * @param {boolean=} canSuspend (defaults to true in this case, as list() is used directly from Python)\n * @extends Sk.builtin.object\n */\nSk.builtin.list = function (L, canSuspend) {\n    var v, it, thisList;\n\n    if (this instanceof Sk.builtin.list) {\n        canSuspend = canSuspend || false;\n    } else {\n        // Default to true in this case, because 'list' gets called directly from Python\n        return new Sk.builtin.list(L, canSuspend || true);\n    }\n\n    this.__class__ = Sk.builtin.list;\n\n    if (L === undefined) {\n        v = [];\n    } else if (Object.prototype.toString.apply(L) === \"[object Array]\") {\n        v = L;\n    } else if (Sk.builtin.checkIterable(L)) {\n        v = [];\n        it = Sk.abstr.iter(L);\n\n        thisList = this;\n\n        return (function next(i) {\n            while(true) {\n                if (i instanceof Sk.misceval.Suspension) {\n                    return new Sk.misceval.Suspension(next, i);\n                } else if (i === undefined) {\n                    // done!\n                    thisList.v = v;\n                    return thisList;\n                } else {\n                    v.push(i);\n                    i = it.tp$iternext(canSuspend);\n                }\n            }\n        })(it.tp$iternext(canSuspend));\n    } else {\n        throw new Sk.builtin.TypeError(\"'\" + Sk.abstr.typeName(L)+ \"' \" +\"object is not iterable\");\n    }\n\n    this[\"v\"] = this.v = v;\n    return this;\n};\n\nSk.abstr.setUpInheritance(\"list\", Sk.builtin.list, Sk.builtin.seqtype);\nSk.abstr.markUnhashable(Sk.builtin.list);\n\nSk.builtin.list.prototype.list_concat_ = function (other) {\n    // other not a list\n    var i;\n    var ret;\n    if (!other.__class__ || other.__class__ != Sk.builtin.list) {\n        throw new Sk.builtin.TypeError(\"can only concatenate list to list\");\n    }\n\n    ret = this.v.slice();\n    for (i = 0; i < other.v.length; ++i) {\n        ret.push(other.v[i]);\n    }\n    return new Sk.builtin.list(ret, false);\n};\n\nSk.builtin.list.prototype.list_extend_ = function (other) {\n    var it, i;\n    var newb;\n    if (!Sk.builtin.checkIterable(other)) {\n        throw new Sk.builtin.TypeError(\"'\" + Sk.abstr.typeName(other) +\n            \"' object is not iterable\");\n    }\n\n    if (this == other) {\n        // Handle extending list with itself\n        newb = [];\n        for (it = Sk.abstr.iter(other), i = it.tp$iternext(); i !== undefined; i = it.tp$iternext()) {\n            newb.push(i);\n        }\n\n        // Concatenate\n        this.v.push.apply(this.v, newb);\n    } else {\n        for (it = Sk.abstr.iter(other), i = it.tp$iternext(); i !== undefined; i = it.tp$iternext()) {\n            this.v.push(i);\n        }\n    }\n\n    return this;\n};\n\nSk.builtin.list.prototype.list_del_item_ = function (i) {\n    i = Sk.builtin.asnum$(i);\n    if (i < 0 || i >= this.v.length) {\n        throw new Sk.builtin.IndexError(\"list assignment index out of range\");\n    }\n    this.list_del_slice_(i, i + 1);\n};\n\nSk.builtin.list.prototype.list_del_slice_ = function (ilow, ihigh) {\n    var args;\n    ilow = Sk.builtin.asnum$(ilow);\n    ihigh = Sk.builtin.asnum$(ihigh);\n    args = [];\n    args.unshift(ihigh - ilow);\n    args.unshift(ilow);\n    this.v.splice.apply(this.v, args);\n};\n\nSk.builtin.list.prototype.list_ass_item_ = function (i, v) {\n    i = Sk.builtin.asnum$(i);\n    if (i < 0 || i >= this.v.length) {\n        throw new Sk.builtin.IndexError(\"list assignment index out of range\");\n    }\n    this.v[i] = v;\n};\n\nSk.builtin.list.prototype.list_ass_slice_ = function (ilow, ihigh, v) {\n    var args;\n    ilow = Sk.builtin.asnum$(ilow);\n    ihigh = Sk.builtin.asnum$(ihigh);\n\n    if (Sk.builtin.checkIterable(v)) {\n        args = new Sk.builtin.list(v, false).v.slice(0);\n    } else {\n        throw new Sk.builtin.TypeError(\"can only assign an iterable\");\n    }\n    args.unshift(ihigh - ilow);\n    args.unshift(ilow);\n    this.v.splice.apply(this.v, args);\n};\n\nSk.builtin.list.prototype[\"$r\"] = function () {\n    var it, i;\n    var ret = [];\n    for (it = Sk.abstr.iter(this), i = it.tp$iternext(); i !== undefined; i = it.tp$iternext()) {\n        if(i === this) {\n            ret.push(\"[...]\");\n        } else {\n            ret.push(Sk.misceval.objectRepr(i).v);\n        }\n    }\n    return new Sk.builtin.str(\"[\" + ret.join(\", \") + \"]\");\n};\n\nSk.builtin.list.prototype.tp$richcompare = function (w, op) {\n    // todo; can't figure out where cpy handles this silly case (test/run/t96.py)\n    // perhaps by trapping a stack overflow? otherwise i'm not sure for more\n    // complicated cases. bleh\n    //\n    // if the comparison allows for equality then short-circuit it here\n    var k;\n    var i;\n    var wl;\n    var vl;\n    var v;\n    if (this === w && Sk.misceval.opAllowsEquality(op)) {\n        return true;\n    }\n\n    // w not a list\n    if (!w.__class__ || w.__class__ != Sk.builtin.list) {\n        // shortcuts for eq/not\n        if (op === \"Eq\") {\n            return false;\n        }\n        if (op === \"NotEq\") {\n            return true;\n        }\n\n        // todo; other types should have an arbitrary order\n        return false;\n    }\n\n    v = this.v;\n    w = w.v;\n    vl = v.length;\n    wl = w.length;\n\n    for (i = 0; i < vl && i < wl; ++i) {\n        k = Sk.misceval.richCompareBool(v[i], w[i], \"Eq\");\n        if (!k) {\n            break;\n        }\n    }\n\n    if (i >= vl || i >= wl) {\n        // no more items to compare, compare sizes\n        switch (op) {\n            case \"Lt\":\n                return vl < wl;\n            case \"LtE\":\n                return vl <= wl;\n            case \"Eq\":\n                return vl === wl;\n            case \"NotEq\":\n                return vl !== wl;\n            case \"Gt\":\n                return vl > wl;\n            case \"GtE\":\n                return vl >= wl;\n            default:\n                Sk.asserts.fail();\n        }\n    }\n\n    // we have an item that's different\n\n    // shortcuts for eq/not\n    if (op === \"Eq\") {\n        return false;\n    }\n    if (op === \"NotEq\") {\n        return true;\n    }\n\n    // or, compare the differing element using the proper operator\n    return Sk.misceval.richCompareBool(v[i], w[i], op);\n};\n\nSk.builtin.list.prototype.__iter__ = new Sk.builtin.func(function (self) {\n    Sk.builtin.pyCheckArgsLen(\"__iter__\", arguments.length, 0, 0, true, false);\n    return new Sk.builtin.list_iter_(self);\n});\n\nSk.builtin.list.prototype.tp$iter = function () {\n    return new Sk.builtin.list_iter_(this);\n};\n\nSk.builtin.list.prototype.sq$length = function () {\n    return this.v.length;\n};\nSk.builtin.list.prototype.sq$concat = Sk.builtin.list.prototype.list_concat_;\nSk.builtin.list.prototype.nb$add = Sk.builtin.list.prototype.list_concat_;\nSk.builtin.list.prototype.nb$inplace_add = Sk.builtin.list.prototype.list_extend_;\nSk.builtin.list.prototype.sq$repeat = function (n) {\n    var j;\n    var i;\n    var ret;\n    if (!Sk.misceval.isIndex(n)) {\n        throw new Sk.builtin.TypeError(\"can't multiply sequence by non-int of type '\" + Sk.abstr.typeName(n) + \"'\");\n    }\n\n    n = Sk.misceval.asIndex(n);\n    ret = [];\n    for (i = 0; i < n; ++i) {\n        for (j = 0; j < this.v.length; ++j) {\n            ret.push(this.v[j]);\n        }\n    }\n    return new Sk.builtin.list(ret, false);\n};\nSk.builtin.list.prototype.nb$multiply = Sk.builtin.list.prototype.sq$repeat;\nSk.builtin.list.prototype.nb$inplace_multiply = function(n) {\n    var j;\n    var i;\n    var len;\n    if (!Sk.misceval.isIndex(n)) {\n        throw new Sk.builtin.TypeError(\"can't multiply sequence by non-int of type '\" + Sk.abstr.typeName(n) + \"'\");\n    }\n\n    // works on list itself --> inplace\n    n = Sk.misceval.asIndex(n);\n    len = this.v.length;\n    for (i = 1; i < n; ++i) {\n        for (j = 0; j < len; ++j) {\n            this.v.push(this.v[j]);\n        }\n    }\n\n    return this;\n};\n\n/*\n Sk.builtin.list.prototype.sq$item = list_item;\n Sk.builtin.list.prototype.sq$slice = list_slice;\n */\nSk.builtin.list.prototype.sq$ass_item = Sk.builtin.list.prototype.list_ass_item_;\nSk.builtin.list.prototype.sq$del_item = Sk.builtin.list.prototype.list_del_item_;\nSk.builtin.list.prototype.sq$ass_slice = Sk.builtin.list.prototype.list_ass_slice_;\nSk.builtin.list.prototype.sq$del_slice = Sk.builtin.list.prototype.list_del_slice_;\n\nSk.builtin.list.prototype.sq$contains = function (item) {\n    var it, i;\n\n    for (it = this.tp$iter(), i = it.tp$iternext(); i !== undefined; i = it.tp$iternext()) {\n        if (Sk.misceval.richCompareBool(i, item, \"Eq\")) {\n            return true;\n        }\n    }\n    return false;\n};\n\nSk.builtin.list.prototype.__contains__ = new Sk.builtin.func(function(self, item) {\n    Sk.builtin.pyCheckArgsLen(\"__contains__\", arguments.length, 2, 2);\n    return new Sk.builtin.bool(self.sq$contains(item));\n});\n\n/*\n Sk.builtin.list.prototype.sq$inplace_concat = list_inplace_concat;\n Sk.builtin.list.prototype.sq$inplace_repeat = list_inplace_repeat;\n */\n\nSk.builtin.list.prototype.list_subscript_ = function (index) {\n    var ret;\n    var i;\n    if (Sk.misceval.isIndex(index)) {\n        i = Sk.misceval.asIndex(index);\n        if (i !== undefined) {\n            if (i < 0) {\n                i = this.v.length + i;\n            }\n            if (i < 0 || i >= this.v.length) {\n                throw new Sk.builtin.IndexError(\"list index out of range\");\n            }\n            return this.v[i];\n        }\n    } else if (index instanceof Sk.builtin.slice) {\n        ret = [];\n        index.sssiter$(this, function (i, wrt) {\n            ret.push(wrt.v[i]);\n        });\n        return new Sk.builtin.list(ret, false);\n    }\n\n    throw new Sk.builtin.TypeError(\"list indices must be integers, not \" + Sk.abstr.typeName(index));\n};\n\nSk.builtin.list.prototype.list_ass_subscript_ = function (index, value) {\n    var i;\n    var j;\n    var tosub;\n    var indices;\n    if (Sk.misceval.isIndex(index)) {\n        i = Sk.misceval.asIndex(index);\n        if (i !== undefined) {\n            if (i < 0) {\n                i = this.v.length + i;\n            }\n            this.list_ass_item_(i, value);\n            return;\n        }\n    } else if (index instanceof Sk.builtin.slice) {\n        indices = index.slice_indices_(this.v.length);\n        if (indices[2] === 1) {\n            this.list_ass_slice_(indices[0], indices[1], value);\n        } else {\n            tosub = [];\n            index.sssiter$(this, function (i, wrt) {\n                tosub.push(i);\n            });\n            j = 0;\n            if (tosub.length !== value.v.length) {\n                throw new Sk.builtin.ValueError(\"attempt to assign sequence of size \" + value.v.length + \" to extended slice of size \" + tosub.length);\n            }\n            for (i = 0; i < tosub.length; ++i) {\n                this.v.splice(tosub[i], 1, value.v[j]);\n                j += 1;\n            }\n        }\n        return;\n    }\n\n    throw new Sk.builtin.TypeError(\"list indices must be integers, not \" + Sk.abstr.typeName(index));\n};\n\nSk.builtin.list.prototype.list_del_subscript_ = function (index) {\n    var offdir;\n    var dec;\n    var self;\n    var indices;\n    var i;\n    if (Sk.misceval.isIndex(index)) {\n        i = Sk.misceval.asIndex(index);\n        if (i !== undefined) {\n            if (i < 0) {\n                i = this.v.length + i;\n            }\n            this.list_del_item_(i);\n            return;\n        }\n    } else if (index instanceof Sk.builtin.slice) {\n        indices = index.slice_indices_(this.v.length);\n        if (indices[2] === 1) {\n            this.list_del_slice_(indices[0], indices[1]);\n        } else {\n            self = this;\n            dec = 0; // offset of removal for next index (because we'll have removed, but the iterator is giving orig indices)\n            offdir = indices[2] > 0 ? 1 : 0;\n            index.sssiter$(this, function (i, wrt) {\n                self.v.splice(i - dec, 1);\n                dec += offdir;\n            });\n        }\n        return;\n    }\n\n    throw new Sk.builtin.TypeError(\"list indices must be integers, not \" + typeof index);\n};\n\nSk.builtin.list.prototype.mp$subscript = Sk.builtin.list.prototype.list_subscript_;\nSk.builtin.list.prototype.mp$ass_subscript = Sk.builtin.list.prototype.list_ass_subscript_;\nSk.builtin.list.prototype.mp$del_subscript = Sk.builtin.list.prototype.list_del_subscript_;\n\nSk.builtin.list.prototype.__getitem__ = new Sk.builtin.func(function (self, index) {\n    return Sk.builtin.list.prototype.list_subscript_.call(self, index);\n});\n\nSk.builtin.list.prototype.__setitem__ = new Sk.builtin.func(function (self, index, val) {\n    return Sk.builtin.list.prototype.list_ass_subscript_.call(self, index, val);\n});\n\nSk.builtin.list.prototype.__delitem__ = new Sk.builtin.func(function (self, index) {\n    return Sk.builtin.list.prototype.list_del_subscript_.call(self, index);\n});\n\n/**\n * @param {?=} self\n * @param {?=} cmp optional\n * @param {?=} key optional\n * @param {?=} reverse optional\n */\nSk.builtin.list.prototype.list_sort_ = function sort(self, cmp, key, reverse) {\n    var mucked;\n    var j;\n    var keyvalue;\n    var item;\n    var i;\n    var zero;\n    var timsort;\n    var has_key = key !== undefined && key !== null && key !== Sk.builtin.none.none$;\n    var has_cmp = cmp !== undefined && cmp !== null && cmp !== Sk.builtin.none.none$;\n    var rev;\n\n    if (reverse === undefined) {\n        rev = false;\n    } else if (reverse === Sk.builtin.none.none$) {\n        throw new Sk.builtin.TypeError(\"an integer is required\");\n    } else {\n        rev = Sk.misceval.isTrue(reverse);\n    }\n\n    timsort = new Sk.builtin.timSort(self);\n\n    self.v = [];\n    zero = new Sk.builtin.int_(0);\n\n    if (has_key) {\n        if (has_cmp) {\n            timsort.lt = function (a, b) {\n                var res = Sk.misceval.callsimArray(cmp, [a[0], b[0]]);\n                return Sk.misceval.richCompareBool(res, zero, \"Lt\");\n            };\n        } else {\n            timsort.lt = function (a, b) {\n                return Sk.misceval.richCompareBool(a[0], b[0], \"Lt\");\n            };\n        }\n        for (i = 0; i < timsort.listlength; i++) {\n            item = timsort.list.v[i];\n            keyvalue = Sk.misceval.callsimArray(key, [item]);\n            timsort.list.v[i] = [keyvalue, item];\n        }\n    } else if (has_cmp) {\n        timsort.lt = function (a, b) {\n            var res = Sk.misceval.callsimArray(cmp, [a, b]);\n            return Sk.misceval.richCompareBool(res, zero, \"Lt\");\n        };\n    }\n\n    if (rev) {\n        timsort.list.list_reverse_(timsort.list);\n    }\n\n    timsort.sort();\n\n    if (rev) {\n        timsort.list.list_reverse_(timsort.list);\n    }\n\n    if (has_key) {\n        for (j = 0; j < timsort.listlength; j++) {\n            item = timsort.list.v[j][1];\n            timsort.list.v[j] = item;\n        }\n    }\n\n    mucked = self.sq$length() > 0;\n\n    self.v = timsort.list.v;\n\n    if (mucked) {\n        throw new Sk.builtin.OperationError(\"list modified during sort\");\n    }\n\n    return Sk.builtin.none.none$;\n};\nSk.builtin.list.prototype.list_sort_.co_varnames = [\"__self__\", \"cmp\", \"key\", \"reverse\"];\nSk.builtin.list.prototype.list_sort_.$defaults = [Sk.builtin.none.none$, Sk.builtin.none.none$, false];\n\n/**\n * @param {Sk.builtin.list=} self optional\n **/\nSk.builtin.list.prototype.list_reverse_ = function (self) {\n    var i;\n    var newarr;\n    var old;\n    var len;\n    Sk.builtin.pyCheckArgsLen(\"reverse\", arguments.length, 1, 1);\n\n    len = self.v.length;\n    old = self.v;\n    newarr = [];\n    for (i = len - 1; i > -1; --i) {\n        newarr.push(old[i]);\n    }\n    self[\"v\"] = newarr;\n    return Sk.builtin.none.none$;\n};\n\n//Sk.builtin.list.prototype.__reversed__ = todo;\n\nSk.builtin.list.prototype[\"append\"] = new Sk.builtin.func(function (self, item) {\n    Sk.builtin.pyCheckArgsLen(\"append\", arguments.length, 2, 2);\n\n    self.v.push(item);\n    return Sk.builtin.none.none$;\n});\n\nSk.builtin.list.prototype[\"insert\"] = new Sk.builtin.func(function (self, i, x) {\n    Sk.builtin.pyCheckArgsLen(\"insert\", arguments.length, 3, 3);\n    if (!Sk.builtin.checkNumber(i)) {\n        throw new Sk.builtin.TypeError(\"an integer is required\");\n    }\n\n    i = Sk.builtin.asnum$(i);\n    if (i < 0) {\n        i = i + self.v.length;\n    }\n    if (i < 0) {\n        i = 0;\n    } else if (i > self.v.length) {\n        i = self.v.length;\n    }\n    self.v.splice(i, 0, x);\n    return Sk.builtin.none.none$;\n});\n\nSk.builtin.list.prototype[\"extend\"] = new Sk.builtin.func(function (self, b) {\n    Sk.builtin.pyCheckArgsLen(\"extend\", arguments.length, 2, 2);\n    self.list_extend_(b);\n    return Sk.builtin.none.none$;\n});\n\nSk.builtin.list.prototype[\"pop\"] = new Sk.builtin.func(function (self, i) {\n    var ret;\n    Sk.builtin.pyCheckArgsLen(\"pop\", arguments.length, 1, 2);\n    if (i === undefined) {\n        i = self.v.length - 1;\n    }\n\n    if (!Sk.builtin.checkNumber(i)) {\n        throw new Sk.builtin.TypeError(\"an integer is required\");\n    }\n\n    i = Sk.builtin.asnum$(i);\n    if (i < 0) {\n        i = i + self.v.length;\n    }\n    if ((i < 0) || (i >= self.v.length)) {\n        throw new Sk.builtin.IndexError(\"pop index out of range\");\n    }\n    ret = self.v[i];\n    self.v.splice(i, 1);\n    return ret;\n});\n\nSk.builtin.list.prototype[\"remove\"] = new Sk.builtin.func(function (self, item) {\n    var idx;\n    Sk.builtin.pyCheckArgsLen(\"remove\", arguments.length, 2, 2);\n\n    idx = Sk.builtin.list.prototype[\"index\"].func_code(self, item);\n    self.v.splice(Sk.builtin.asnum$(idx), 1);\n    return Sk.builtin.none.none$;\n});\n\nSk.builtin.list.prototype.clear$ = function (self) {\n    Sk.builtin.pyCheckArgsLen(\"clear\", arguments.length, 1, 1);\n    self.v = [];\n    return Sk.builtin.none.none$;\n};\n\nSk.builtin.list.prototype[\"index\"] = new Sk.builtin.func(function (self, item, start, stop) {\n    var i;\n    var obj;\n    var len;\n    Sk.builtin.pyCheckArgsLen(\"index\", arguments.length, 2, 4);\n    if (start !== undefined && !Sk.builtin.checkInt(start)) {\n        throw new Sk.builtin.TypeError(\"slice indices must be integers\");\n    }\n    if (stop !== undefined && !Sk.builtin.checkInt(stop)) {\n        throw new Sk.builtin.TypeError(\"slice indices must be integers\");\n    }\n\n    len = self.v.length;\n    obj = self.v;\n\n    start = (start === undefined) ? 0 : start.v;\n    if (start < 0) {\n        start = ((start + len) >= 0) ? start + len : 0;\n    }\n\n    stop = (stop === undefined) ? len : stop.v;\n    if (stop < 0) {\n        stop = ((stop + len) >= 0) ? stop + len : 0;\n    }\n\n    for (i = start; i < stop; ++i) {\n        if (Sk.misceval.richCompareBool(obj[i], item, \"Eq\")) {\n            return new Sk.builtin.int_(i);\n        }\n    }\n    throw new Sk.builtin.ValueError(\"list.index(x): x not in list\");\n});\n\nSk.builtin.list.prototype[\"count\"] = new Sk.builtin.func(function (self, item) {\n    var i;\n    var count;\n    var obj;\n    var len;\n    Sk.builtin.pyCheckArgsLen(\"count\", arguments.length, 2, 2);\n\n    len = self.v.length;\n    obj = self.v;\n    count = 0;\n    for (i = 0; i < len; ++i) {\n        if (Sk.misceval.richCompareBool(obj[i], item, \"Eq\")) {\n            count += 1;\n        }\n    }\n    return new Sk.builtin.int_(count);\n});\n\nSk.builtin.list.prototype[\"reverse\"] = new Sk.builtin.func(Sk.builtin.list.prototype.list_reverse_);\nSk.builtin.list.prototype[\"sort\"] = new Sk.builtin.func(Sk.builtin.list.prototype.list_sort_);\n\nSk.exportSymbol(\"Sk.builtin.list\", Sk.builtin.list);\n\n/**\n * @constructor\n * @param {Object} lst\n */\nSk.builtin.list_iter_ = function (lst) {\n    if (!(this instanceof Sk.builtin.list_iter_)) {\n        return new Sk.builtin.list_iter_(lst);\n    }\n    this.$index = 0;\n    this.lst = lst.v.slice();\n    this.sq$length = this.lst.length;\n    this.tp$iter = this;\n    this.tp$iternext = function () {\n        if (this.$index >= this.sq$length) {\n            return undefined;\n        }\n        return this.lst[this.$index++];\n    };\n    this.$r = function () {\n        return new Sk.builtin.str(\"listiterator\");\n    };\n    return this;\n};\n\nSk.abstr.setUpInheritance(\"listiterator\", Sk.builtin.list_iter_, Sk.builtin.object);\n\nSk.builtin.list_iter_.prototype.__class__ = Sk.builtin.list_iter_;\n\nSk.builtin.list_iter_.prototype.__iter__ = new Sk.builtin.func(function (self) {\n    return self;\n});\n\nSk.builtin.list_iter_.prototype.next$ = function (self) {\n    var ret = self.tp$iternext();\n    if (ret === undefined) {\n        throw new Sk.builtin.StopIteration();\n    }\n    return ret;\n};\n\n\n/***/ }),\n/* 20 */\n/***/ (function(module, exports) {\n\nSk.builtin.interned = {};\n\n/**\n * @constructor\n * @param {*} x\n * @extends Sk.builtin.object\n */\nSk.builtin.str = function (x) {\n    var ret;\n\n    Sk.builtin.pyCheckArgsLen(\"str\", arguments.length, 0, 1);\n\n    if (x === undefined) {\n        x = \"\";\n    }\n    if (x instanceof Sk.builtin.str) {\n        return x;\n    }\n    if (!(this instanceof Sk.builtin.str)) {\n        return new Sk.builtin.str(x);\n    }\n\n\n    // convert to js string\n    if (x === true) {\n        ret = \"True\";\n    } else if (x === false) {\n        ret = \"False\";\n    } else if ((x === null) || (x instanceof Sk.builtin.none)) {\n        ret = \"None\";\n    } else if (x instanceof Sk.builtin.bool) {\n        if (x.v) {\n            ret = \"True\";\n        } else {\n            ret = \"False\";\n        }\n    } else if (typeof x === \"number\") {\n        ret = x.toString();\n        if (ret === \"Infinity\") {\n            ret = \"inf\";\n        } else if (ret === \"-Infinity\") {\n            ret = \"-inf\";\n        }\n    } else if (typeof x === \"string\") {\n        ret = x;\n    } else if (x.tp$str !== undefined) {\n        ret = x.tp$str();\n        if (!(ret instanceof Sk.builtin.str)) {\n            throw new Sk.builtin.ValueError(\"__str__ didn't return a str\");\n        }\n        return ret;\n    } else {\n        return Sk.misceval.objectRepr(x);\n    }\n\n    // interning required for strings in py\n    if (Sk.builtin.interned[\"1\" + ret]) {\n        return Sk.builtin.interned[\"1\" + ret];\n    }\n\n    this.__class__ = Sk.builtin.str;\n    this.v = ret;\n    this[\"v\"] = this.v;\n    Sk.builtin.interned[\"1\" + ret] = this;\n    return this;\n\n};\nSk.exportSymbol(\"Sk.builtin.str\", Sk.builtin.str);\n\nSk.abstr.setUpInheritance(\"str\", Sk.builtin.str, Sk.builtin.seqtype);\n\nSk.builtin.str.prototype.$jsstr = function () {\n    return this.v;\n};\n\nSk.builtin.str.prototype.mp$subscript = function (index) {\n    var ret;\n    if (Sk.misceval.isIndex(index)) {\n        index = Sk.misceval.asIndex(index);\n        if (index < 0) {\n            index = this.v.length + index;\n        }\n        if (index < 0 || index >= this.v.length) {\n            throw new Sk.builtin.IndexError(\"string index out of range\");\n        }\n        return new Sk.builtin.str(this.v.charAt(index));\n    } else if (index instanceof Sk.builtin.slice) {\n        ret = \"\";\n        index.sssiter$(this, function (i, wrt) {\n            if (i >= 0 && i < wrt.v.length) {\n                ret += wrt.v.charAt(i);\n            }\n        });\n        return new Sk.builtin.str(ret);\n    } else {\n        throw new Sk.builtin.TypeError(\"string indices must be integers, not \" + Sk.abstr.typeName(index));\n    }\n};\n\nSk.builtin.str.prototype.sq$length = function () {\n    return this.v.length;\n};\nSk.builtin.str.prototype.sq$concat = function (other) {\n    var otypename;\n    if (!other || !Sk.builtin.checkString(other)) {\n        otypename = Sk.abstr.typeName(other);\n        throw new Sk.builtin.TypeError(\"cannot concatenate 'str' and '\" + otypename + \"' objects\");\n    }\n    return new Sk.builtin.str(this.v + other.v);\n};\nSk.builtin.str.prototype.nb$add = Sk.builtin.str.prototype.sq$concat;\nSk.builtin.str.prototype.nb$inplace_add = Sk.builtin.str.prototype.sq$concat;\nSk.builtin.str.prototype.sq$repeat = function (n) {\n    var i;\n    var ret;\n\n    if (!Sk.misceval.isIndex(n)) {\n        throw new Sk.builtin.TypeError(\"can't multiply sequence by non-int of type '\" + Sk.abstr.typeName(n) + \"'\");\n    }\n\n    n = Sk.misceval.asIndex(n);\n    ret = \"\";\n    for (i = 0; i < n; ++i) {\n        ret += this.v;\n    }\n    return new Sk.builtin.str(ret);\n};\nSk.builtin.str.prototype.nb$multiply = Sk.builtin.str.prototype.sq$repeat;\nSk.builtin.str.prototype.nb$inplace_multiply = Sk.builtin.str.prototype.sq$repeat;\nSk.builtin.str.prototype.sq$item = function () {\n    Sk.asserts.fail();\n};\nSk.builtin.str.prototype.sq$slice = function (i1, i2) {\n    i1 = Sk.builtin.asnum$(i1);\n    i2 = Sk.builtin.asnum$(i2);\n    if (i1 < 0) {\n        i1 = 0;\n    }\n    return new Sk.builtin.str(this.v.substr(i1, i2 - i1));\n};\n\nSk.builtin.str.prototype.sq$contains = function (ob) {\n    if (!(ob instanceof Sk.builtin.str)) {\n        throw new Sk.builtin.TypeError(\"TypeError: 'In <string> requires string as left operand\");\n    }\n    return this.v.indexOf(ob.v) != -1;\n};\n\nSk.builtin.str.prototype.__iter__ = new Sk.builtin.func(function (self) {\n    return new Sk.builtin.str_iter_(self);\n});\n\nSk.builtin.str.prototype.tp$iter = function () {\n    return new Sk.builtin.str_iter_(this);\n};\n\nSk.builtin.str.prototype.tp$richcompare = function (other, op) {\n    if (!(other instanceof Sk.builtin.str)) {\n        return undefined;\n    }\n\n    switch (op) {\n        case \"Lt\":\n            return this.v < other.v;\n        case \"LtE\":\n            return this.v <= other.v;\n        case \"Eq\":\n            return this.v === other.v;\n        case \"NotEq\":\n            return this.v !== other.v;\n        case \"Gt\":\n            return this.v > other.v;\n        case \"GtE\":\n            return this.v >= other.v;\n        default:\n            Sk.asserts.fail();\n    }\n};\n\nSk.builtin.str.prototype[\"$r\"] = function () {\n    // single is preferred\n    var ashex;\n    var c;\n    var i;\n    var ret;\n    var len;\n    var quote = \"'\";\n    //jshint ignore:start\n    if (this.v.indexOf(\"'\") !== -1 && this.v.indexOf('\"') === -1) {\n        quote = '\"';\n    }\n    //jshint ignore:end\n    len = this.v.length;\n    ret = quote;\n    for (i = 0; i < len; ++i) {\n        c = this.v.charAt(i);\n        if (c === quote || c === \"\\\\\") {\n            ret += \"\\\\\" + c;\n        } else if (c === \"\\t\") {\n            ret += \"\\\\t\";\n        } else if (c === \"\\n\") {\n            ret += \"\\\\n\";\n        } else if (c === \"\\r\") {\n            ret += \"\\\\r\";\n        } else if (c < \" \" || c >= 0x7f) {\n            ashex = c.charCodeAt(0).toString(16);\n            if (ashex.length < 2) {\n                ashex = \"0\" + ashex;\n            }\n            ret += \"\\\\x\" + ashex;\n        } else {\n            ret += c;\n        }\n    }\n    ret += quote;\n    return new Sk.builtin.str(ret);\n};\n\n\nSk.builtin.str.re_escape_ = function (s) {\n    var c;\n    var i;\n    var ret = [];\n    var re = /^[A-Za-z0-9]+$/;\n    for (i = 0; i < s.length; ++i) {\n        c = s.charAt(i);\n\n        if (re.test(c)) {\n            ret.push(c);\n        } else {\n            if (c === \"\\\\000\") {\n                ret.push(\"\\\\000\");\n            } else {\n                ret.push(\"\\\\\" + c);\n            }\n        }\n    }\n    return ret.join(\"\");\n};\n\nSk.builtin.str.prototype[\"lower\"] = new Sk.builtin.func(function (self) {\n    Sk.builtin.pyCheckArgsLen(\"lower\", arguments.length, 1, 1);\n    return new Sk.builtin.str(self.v.toLowerCase());\n});\n\nSk.builtin.str.prototype[\"upper\"] = new Sk.builtin.func(function (self) {\n    Sk.builtin.pyCheckArgsLen(\"upper\", arguments.length, 1, 1);\n    return new Sk.builtin.str(self.v.toUpperCase());\n});\n\nSk.builtin.str.prototype[\"capitalize\"] = new Sk.builtin.func(function (self) {\n    var i;\n    var cap;\n    var orig;\n    Sk.builtin.pyCheckArgsLen(\"capitalize\", arguments.length, 1, 1);\n    orig = self.v;\n\n    if (orig.length === 0) {\n        return new Sk.builtin.str(\"\");\n    }\n    cap = orig.charAt(0).toUpperCase();\n\n    for (i = 1; i < orig.length; i++) {\n        cap += orig.charAt(i).toLowerCase();\n    }\n    return new Sk.builtin.str(cap);\n});\n\nSk.builtin.str.prototype[\"join\"] = new Sk.builtin.func(function (self, seq) {\n    var it, i;\n    var arrOfStrs;\n    Sk.builtin.pyCheckArgsLen(\"join\", arguments.length, 2, 2);\n    Sk.builtin.pyCheckType(\"seq\", \"iterable\", Sk.builtin.checkIterable(seq));\n    arrOfStrs = [];\n    for (it = seq.tp$iter(), i = it.tp$iternext(); i !== undefined; i = it.tp$iternext()) {\n        if (i.constructor !== Sk.builtin.str) {\n            throw new Sk.builtin.TypeError(\"TypeError: sequence item \" + arrOfStrs.length + \": expected string, \" + typeof i + \" found\");\n        }\n        arrOfStrs.push(i.v);\n    }\n    return new Sk.builtin.str(arrOfStrs.join(self.v));\n});\n\nSk.builtin.str.prototype[\"split\"] = new Sk.builtin.func(function (self, on, howmany) {\n    var splits;\n    var index;\n    var match;\n    var result;\n    var s;\n    var str;\n    var regex;\n    Sk.builtin.pyCheckArgsLen(\"split\", arguments.length, 1, 3);\n    if ((on === undefined) || (on instanceof Sk.builtin.none)) {\n        on = null;\n    }\n    if ((on !== null) && !Sk.builtin.checkString(on)) {\n        throw new Sk.builtin.TypeError(\"expected a string\");\n    }\n    if ((on !== null) && on.v === \"\") {\n        throw new Sk.builtin.ValueError(\"empty separator\");\n    }\n    if ((howmany !== undefined) && !Sk.builtin.checkInt(howmany)) {\n        throw new Sk.builtin.TypeError(\"an integer is required\");\n    }\n\n    howmany = Sk.builtin.asnum$(howmany);\n    regex = /[\\s\\xa0]+/g;\n    str = self.v;\n    if (on === null) {\n        // Remove leading whitespace\n        str = str.replace(/^[\\s\\xa0]+/, \"\");\n    } else {\n        // Escape special characters in \"on\" so we can use a regexp\n        s = on.v.replace(/([.*+?=|\\\\\\/()\\[\\]\\{\\}^$])/g, \"\\\\$1\");\n        regex = new RegExp(s, \"g\");\n    }\n\n    // This is almost identical to re.split,\n    // except how the regexp is constructed\n\n    result = [];\n    index = 0;\n    splits = 0;\n    while ((match = regex.exec(str)) != null) {\n        if (match.index === regex.lastIndex) {\n            // empty match\n            break;\n        }\n        result.push(new Sk.builtin.str(str.substring(index, match.index)));\n        index = regex.lastIndex;\n        splits += 1;\n        if (howmany && (splits >= howmany)) {\n            break;\n        }\n    }\n    str = str.substring(index);\n    if (on !== null || (str.length > 0)) {\n        result.push(new Sk.builtin.str(str));\n    }\n\n    return new Sk.builtin.list(result);\n});\n\nSk.builtin.str.prototype[\"strip\"] = new Sk.builtin.func(function (self, chars) {\n    var regex;\n    var pattern;\n    Sk.builtin.pyCheckArgsLen(\"strip\", arguments.length, 1, 2);\n    if ((chars !== undefined) && !Sk.builtin.checkString(chars)) {\n        throw new Sk.builtin.TypeError(\"strip arg must be None or str\");\n    }\n    if (chars === undefined) {\n        pattern = /^\\s+|\\s+$/g;\n    } else {\n        regex = Sk.builtin.str.re_escape_(chars.v);\n        pattern = new RegExp(\"^[\" + regex + \"]+|[\" + regex + \"]+$\", \"g\");\n    }\n    return new Sk.builtin.str(self.v.replace(pattern, \"\"));\n});\n\nSk.builtin.str.prototype[\"lstrip\"] = new Sk.builtin.func(function (self, chars) {\n    var regex;\n    var pattern;\n    Sk.builtin.pyCheckArgsLen(\"lstrip\", arguments.length, 1, 2);\n    if ((chars !== undefined) && !Sk.builtin.checkString(chars)) {\n        throw new Sk.builtin.TypeError(\"lstrip arg must be None or str\");\n    }\n    if (chars === undefined) {\n        pattern = /^\\s+/g;\n    } else {\n        regex = Sk.builtin.str.re_escape_(chars.v);\n        pattern = new RegExp(\"^[\" + regex + \"]+\", \"g\");\n    }\n    return new Sk.builtin.str(self.v.replace(pattern, \"\"));\n});\n\nSk.builtin.str.prototype[\"rstrip\"] = new Sk.builtin.func(function (self, chars) {\n    var regex;\n    var pattern;\n    Sk.builtin.pyCheckArgsLen(\"rstrip\", arguments.length, 1, 2);\n    if ((chars !== undefined) && !Sk.builtin.checkString(chars)) {\n        throw new Sk.builtin.TypeError(\"rstrip arg must be None or str\");\n    }\n    if (chars === undefined) {\n        pattern = /\\s+$/g;\n    } else {\n        regex = Sk.builtin.str.re_escape_(chars.v);\n        pattern = new RegExp(\"[\" + regex + \"]+$\", \"g\");\n    }\n    return new Sk.builtin.str(self.v.replace(pattern, \"\"));\n});\n\nSk.builtin.str.prototype[\"__format__\"] = new Sk.builtin.func(function (self, format_spec) {\n    var formatstr;\n    Sk.builtin.pyCheckArgsLen(\"__format__\", arguments.length, 2, 2);\n\n    if (!Sk.builtin.checkString(format_spec)) {\n        if (Sk.__future__.exceptions) {\n            throw new Sk.builtin.TypeError(\"format() argument 2 must be str, not \" + Sk.abstr.typeName(format_spec));\n        } else {\n            throw new Sk.builtin.TypeError(\"format expects arg 2 to be string or unicode, not \" + Sk.abstr.typeName(format_spec));\n        }\n    } else {\n        formatstr = Sk.ffi.remapToJs(format_spec);\n        if (formatstr !== \"\" && formatstr !== \"s\") {\n            throw new Sk.builtin.NotImplementedError(\"format spec is not yet implemented\");\n        }\n    }\n\n    return new Sk.builtin.str(self);\n});\n\nSk.builtin.str.prototype[\"partition\"] = new Sk.builtin.func(function (self, sep) {\n    var pos;\n    var sepStr;\n    Sk.builtin.pyCheckArgsLen(\"partition\", arguments.length, 2, 2);\n    Sk.builtin.pyCheckType(\"sep\", \"string\", Sk.builtin.checkString(sep));\n    sepStr = new Sk.builtin.str(sep);\n    pos = self.v.indexOf(sepStr.v);\n    if (pos < 0) {\n        return new Sk.builtin.tuple([self, Sk.builtin.str.$emptystr, Sk.builtin.str.$emptystr]);\n    }\n\n    return new Sk.builtin.tuple([\n        new Sk.builtin.str(self.v.substring(0, pos)),\n        sepStr,\n        new Sk.builtin.str(self.v.substring(pos + sepStr.v.length))]);\n});\n\nSk.builtin.str.prototype[\"rpartition\"] = new Sk.builtin.func(function (self, sep) {\n    var pos;\n    var sepStr;\n    Sk.builtin.pyCheckArgsLen(\"rpartition\", arguments.length, 2, 2);\n    Sk.builtin.pyCheckType(\"sep\", \"string\", Sk.builtin.checkString(sep));\n    sepStr = new Sk.builtin.str(sep);\n    pos = self.v.lastIndexOf(sepStr.v);\n    if (pos < 0) {\n        return new Sk.builtin.tuple([Sk.builtin.str.$emptystr, Sk.builtin.str.$emptystr, self]);\n    }\n\n    return new Sk.builtin.tuple([\n        new Sk.builtin.str(self.v.substring(0, pos)),\n        sepStr,\n        new Sk.builtin.str(self.v.substring(pos + sepStr.v.length))]);\n});\n\nSk.builtin.str.prototype[\"count\"] = new Sk.builtin.func(function (self, pat, start, end) {\n    var normaltext;\n    var ctl;\n    var slice;\n    var m;\n    Sk.builtin.pyCheckArgsLen(\"count\", arguments.length, 2, 4);\n    if (!Sk.builtin.checkString(pat)) {\n        throw new Sk.builtin.TypeError(\"expected a character buffer object\");\n    }\n    if ((start !== undefined) && !Sk.builtin.checkInt(start)) {\n        throw new Sk.builtin.TypeError(\"slice indices must be integers or None or have an __index__ method\");\n    }\n    if ((end !== undefined) && !Sk.builtin.checkInt(end)) {\n        throw new Sk.builtin.TypeError(\"slice indices must be integers or None or have an __index__ method\");\n    }\n\n    if (start === undefined) {\n        start = 0;\n    } else {\n        start = Sk.builtin.asnum$(start);\n        start = start >= 0 ? start : self.v.length + start;\n    }\n\n    if (end === undefined) {\n        end = self.v.length;\n    } else {\n        end = Sk.builtin.asnum$(end);\n        end = end >= 0 ? end : self.v.length + end;\n    }\n\n    normaltext = pat.v.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, \"\\\\$&\");\n    m = new RegExp(normaltext, \"g\");\n    slice = self.v.slice(start, end);\n    ctl = slice.match(m);\n    if (!ctl) {\n        return  new Sk.builtin.int_(0);\n    } else {\n        return new Sk.builtin.int_(ctl.length);\n    }\n\n});\n\nSk.builtin.str.prototype[\"ljust\"] = new Sk.builtin.func(function (self, len, fillchar) {\n    var newstr;\n    Sk.builtin.pyCheckArgsLen(\"ljust\", arguments.length, 2, 3);\n    if (!Sk.builtin.checkInt(len)) {\n        throw new Sk.builtin.TypeError(\"integer argument exepcted, got \" + Sk.abstr.typeName(len));\n    }\n    if ((fillchar !== undefined) && (!Sk.builtin.checkString(fillchar) || fillchar.v.length !== 1)) {\n        throw new Sk.builtin.TypeError(\"must be char, not \" + Sk.abstr.typeName(fillchar));\n    }\n    if (fillchar === undefined) {\n        fillchar = \" \";\n    } else {\n        fillchar = fillchar.v;\n    }\n    len = Sk.builtin.asnum$(len);\n    if (self.v.length >= len) {\n        return self;\n    } else {\n        newstr = Array.prototype.join.call({length: Math.floor(len - self.v.length) + 1}, fillchar);\n        return new Sk.builtin.str(self.v + newstr);\n    }\n});\n\nSk.builtin.str.prototype[\"rjust\"] = new Sk.builtin.func(function (self, len, fillchar) {\n    var newstr;\n    Sk.builtin.pyCheckArgsLen(\"rjust\", arguments.length, 2, 3);\n    if (!Sk.builtin.checkInt(len)) {\n        throw new Sk.builtin.TypeError(\"integer argument exepcted, got \" + Sk.abstr.typeName(len));\n    }\n    if ((fillchar !== undefined) && (!Sk.builtin.checkString(fillchar) || fillchar.v.length !== 1)) {\n        throw new Sk.builtin.TypeError(\"must be char, not \" + Sk.abstr.typeName(fillchar));\n    }\n    if (fillchar === undefined) {\n        fillchar = \" \";\n    } else {\n        fillchar = fillchar.v;\n    }\n    len = Sk.builtin.asnum$(len);\n    if (self.v.length >= len) {\n        return self;\n    } else {\n        newstr = Array.prototype.join.call({length: Math.floor(len - self.v.length) + 1}, fillchar);\n        return new Sk.builtin.str(newstr + self.v);\n    }\n\n});\n\nSk.builtin.str.prototype[\"center\"] = new Sk.builtin.func(function (self, len, fillchar) {\n    var newstr;\n    var newstr1;\n    Sk.builtin.pyCheckArgsLen(\"center\", arguments.length, 2, 3);\n    if (!Sk.builtin.checkInt(len)) {\n        throw new Sk.builtin.TypeError(\"integer argument exepcted, got \" + Sk.abstr.typeName(len));\n    }\n    if ((fillchar !== undefined) && (!Sk.builtin.checkString(fillchar) || fillchar.v.length !== 1)) {\n        throw new Sk.builtin.TypeError(\"must be char, not \" + Sk.abstr.typeName(fillchar));\n    }\n    if (fillchar === undefined) {\n        fillchar = \" \";\n    } else {\n        fillchar = fillchar.v;\n    }\n    len = Sk.builtin.asnum$(len);\n    if (self.v.length >= len) {\n        return self;\n    } else {\n        newstr1 = Array.prototype.join.call({length: Math.floor((len - self.v.length) / 2) + 1}, fillchar);\n        newstr = newstr1 + self.v + newstr1;\n        if (newstr.length < len) {\n            newstr = newstr + fillchar;\n        }\n        return new Sk.builtin.str(newstr);\n    }\n\n});\n\nSk.builtin.str.prototype[\"find\"] = new Sk.builtin.func(function (self, tgt, start, end) {\n    var idx;\n    Sk.builtin.pyCheckArgsLen(\"find\", arguments.length, 2, 4);\n    if (!Sk.builtin.checkString(tgt)) {\n        throw new Sk.builtin.TypeError(\"expected a character buffer object\");\n    }\n    if ((start !== undefined) && !Sk.builtin.checkInt(start)) {\n        throw new Sk.builtin.TypeError(\"slice indices must be integers or None or have an __index__ method\");\n    }\n    if ((end !== undefined) && !Sk.builtin.checkInt(end)) {\n        throw new Sk.builtin.TypeError(\"slice indices must be integers or None or have an __index__ method\");\n    }\n\n    if (start === undefined) {\n        start = 0;\n    } else {\n        start = Sk.builtin.asnum$(start);\n        start = start >= 0 ? start : self.v.length + start;\n    }\n\n    if (end === undefined) {\n        end = self.v.length;\n    } else {\n        end = Sk.builtin.asnum$(end);\n        end = end >= 0 ? end : self.v.length + end;\n    }\n\n    idx = self.v.indexOf(tgt.v, start);\n    idx = ((idx >= start) && (idx < end)) ? idx : -1;\n\n    return new Sk.builtin.int_(idx);\n});\n\nSk.builtin.str.prototype[\"index\"] = new Sk.builtin.func(function (self, tgt, start, end) {\n    var idx;\n    Sk.builtin.pyCheckArgsLen(\"index\", arguments.length, 2, 4);\n    idx = Sk.misceval.callsimArray(self[\"find\"], [self, tgt, start, end]);\n    if (Sk.builtin.asnum$(idx) === -1) {\n        throw new Sk.builtin.ValueError(\"substring not found\");\n    }\n    return idx;\n});\n\nSk.builtin.str.prototype[\"rfind\"] = new Sk.builtin.func(function (self, tgt, start, end) {\n    var idx;\n    Sk.builtin.pyCheckArgsLen(\"rfind\", arguments.length, 2, 4);\n    if (!Sk.builtin.checkString(tgt)) {\n        throw new Sk.builtin.TypeError(\"expected a character buffer object\");\n    }\n    if ((start !== undefined) && !Sk.builtin.checkInt(start)) {\n        throw new Sk.builtin.TypeError(\"slice indices must be integers or None or have an __index__ method\");\n    }\n    if ((end !== undefined) && !Sk.builtin.checkInt(end)) {\n        throw new Sk.builtin.TypeError(\"slice indices must be integers or None or have an __index__ method\");\n    }\n\n    if (start === undefined) {\n        start = 0;\n    } else {\n        start = Sk.builtin.asnum$(start);\n        start = start >= 0 ? start : self.v.length + start;\n    }\n\n    if (end === undefined) {\n        end = self.v.length;\n    } else {\n        end = Sk.builtin.asnum$(end);\n        end = end >= 0 ? end : self.v.length + end;\n    }\n\n    idx = self.v.lastIndexOf(tgt.v, end);\n    idx = (idx !== end) ? idx : self.v.lastIndexOf(tgt.v, end - 1);\n    idx = ((idx >= start) && (idx < end)) ? idx : -1;\n\n    return new Sk.builtin.int_(idx);\n});\n\nSk.builtin.str.prototype[\"rindex\"] = new Sk.builtin.func(function (self, tgt, start, end) {\n    var idx;\n    Sk.builtin.pyCheckArgsLen(\"rindex\", arguments.length, 2, 4);\n    idx = Sk.misceval.callsimArray(self[\"rfind\"], [self, tgt, start, end]);\n    if (Sk.builtin.asnum$(idx) === -1) {\n        throw new Sk.builtin.ValueError(\"substring not found\");\n    }\n    return idx;\n});\n\nSk.builtin.str.prototype[\"startswith\"] = new Sk.builtin.func(function (self, tgt) {\n    Sk.builtin.pyCheckArgsLen(\"startswith\", arguments.length, 2, 2);\n    Sk.builtin.pyCheckType(\"tgt\", \"string\", Sk.builtin.checkString(tgt));\n    return new Sk.builtin.bool( self.v.indexOf(tgt.v) === 0);\n});\n\n// http://stackoverflow.com/questions/280634/endswith-in-javascript\nSk.builtin.str.prototype[\"endswith\"] = new Sk.builtin.func(function (self, tgt) {\n    Sk.builtin.pyCheckArgsLen(\"endswith\", arguments.length, 2, 2);\n    Sk.builtin.pyCheckType(\"tgt\", \"string\", Sk.builtin.checkString(tgt));\n    return new Sk.builtin.bool( self.v.indexOf(tgt.v, self.v.length - tgt.v.length) !== -1);\n});\n\nSk.builtin.str.prototype[\"replace\"] = new Sk.builtin.func(function (self, oldS, newS, count) {\n    var c;\n    var patt;\n    Sk.builtin.pyCheckArgsLen(\"replace\", arguments.length, 3, 4);\n    Sk.builtin.pyCheckType(\"oldS\", \"string\", Sk.builtin.checkString(oldS));\n    Sk.builtin.pyCheckType(\"newS\", \"string\", Sk.builtin.checkString(newS));\n    if ((count !== undefined) && !Sk.builtin.checkInt(count)) {\n        throw new Sk.builtin.TypeError(\"integer argument expected, got \" +\n            Sk.abstr.typeName(count));\n    }\n    count = Sk.builtin.asnum$(count);\n    patt = new RegExp(Sk.builtin.str.re_escape_(oldS.v), \"g\");\n\n    if ((count === undefined) || (count < 0)) {\n        return new Sk.builtin.str(self.v.replace(patt, newS.v));\n    }\n\n    c = 0;\n\n    function replacer (match) {\n        c++;\n        if (c <= count) {\n            return newS.v;\n        }\n        return match;\n    }\n\n    return new Sk.builtin.str(self.v.replace(patt, replacer));\n});\n\nSk.builtin.str.prototype[\"zfill\"] = new Sk.builtin.func(function (self, len) {\n    var str = self.v;\n    var ret;\n    var zeroes;\n    var offset;\n    var pad = \"\";\n\n    Sk.builtin.pyCheckArgsLen(\"zfill\", arguments.length, 2, 2);\n    if (! Sk.builtin.checkInt(len)) {\n        throw new Sk.builtin.TypeError(\"integer argument exepected, got \" + Sk.abstr.typeName(len));\n    }\n\n    // figure out how many zeroes are needed to make the proper length\n    zeroes = len.v - str.length;\n    // offset by 1 if there is a +/- at the beginning of the string\n    offset = (str[0] === \"+\" || str[0] === \"-\") ? 1 : 0;\n    for(var i = 0; i < zeroes; i++){\n        pad += \"0\";\n    }\n    // combine the string and the zeroes\n    ret = str.substr(0, offset) + pad + str.substr(offset);\n    return new Sk.builtin.str(ret);\n\n\n});\n\nSk.builtin.str.prototype[\"isdigit\"] = new Sk.builtin.func(function (self) {\n    Sk.builtin.pyCheckArgsLen(\"isdigit\", arguments.length, 1, 1);\n    return new Sk.builtin.bool( /^\\d+$/.test(self.v));\n});\n\nSk.builtin.str.prototype[\"isspace\"] = new Sk.builtin.func(function (self) {\n    Sk.builtin.pyCheckArgsLen(\"isspace\", arguments.length, 1, 1);\n    return new Sk.builtin.bool( /^\\s+$/.test(self.v));\n});\n\n\nSk.builtin.str.prototype[\"expandtabs\"] = new Sk.builtin.func(function (self, tabsize) {\n    // var input = self.v;\n    // var expanded = \"\";\n    // var split;\n    // var spacestr = \"\";\n    // var spacerem;\n\n\n    var spaces;\n    var expanded;\n\n    Sk.builtin.pyCheckArgsLen(\"expandtabs\", arguments.length, 1, 2);\n\n\n    if ((tabsize !== undefined) && ! Sk.builtin.checkInt(tabsize)) {\n        throw new Sk.builtin.TypeError(\"integer argument exepected, got \" + Sk.abstr.typeName(tabsize));\n    }\n    if (tabsize === undefined) {\n        tabsize = 8;\n    } else {\n        tabsize = Sk.builtin.asnum$(tabsize);\n    }\n\n    spaces = (new Array(tabsize + 1)).join(\" \");\n    expanded = self.v.replace(/([^\\r\\n\\t]*)\\t/g, function(a, b) {\n        return b + spaces.slice(b.length % tabsize);\n    });\n    return new Sk.builtin.str(expanded);\n});\n\nSk.builtin.str.prototype[\"swapcase\"] = new Sk.builtin.func(function (self) {\n    var ret;\n    Sk.builtin.pyCheckArgsLen(\"swapcase\", arguments.length, 1, 1);\n\n\n    ret = self.v.replace(/[a-z]/gi, function(c) {\n        var lc = c.toLowerCase();\n        return lc === c ? c.toUpperCase() : lc;\n    });\n\n    return new Sk.builtin.str(ret);\n});\n\nSk.builtin.str.prototype[\"splitlines\"] = new Sk.builtin.func(function (self, keepends) {\n    var data = self.v;\n    var i = 0;\n    var j = i;\n    var selflen = self.v.length;\n    var strs_w = [];\n    var ch;\n    var eol;\n    var sol = 0;\n    var slice;\n    Sk.builtin.pyCheckArgsLen(\"splitlines\", arguments.length, 1, 2);\n    if ((keepends !== undefined) && ! Sk.builtin.checkBool(keepends)) {\n        throw new Sk.builtin.TypeError(\"boolean argument expected, got \" + Sk.abstr.typeName(keepends));\n    }\n    if (keepends === undefined) {\n        keepends = false;\n    } else {\n        keepends = keepends.v;\n    }\n\n\n    for (i = 0; i < selflen; i ++) {\n        ch = data.charAt(i);\n        if (data.charAt(i + 1) === \"\\n\" && ch === \"\\r\") {\n            eol = i + 2;\n            slice = data.slice(sol, eol);\n            if (! keepends) {\n                slice = slice.replace(/(\\r|\\n)/g, \"\");\n            }\n            strs_w.push(new Sk.builtin.str(slice));\n            sol = eol;\n        } else if ((ch === \"\\n\" && data.charAt(i - 1) !== \"\\r\") || ch === \"\\r\") {\n            eol = i + 1;\n            slice = data.slice(sol, eol);\n            if (! keepends) {\n                slice = slice.replace(/(\\r|\\n)/g, \"\");\n            }\n            strs_w.push(new Sk.builtin.str(slice));\n            sol = eol;\n        }\n\n    }\n    if (sol < selflen) {\n        eol = selflen;\n        slice = data.slice(sol, eol);\n        if (! keepends) {\n            slice = slice.replace(/(\\r|\\n)/g, \"\");\n        }\n        strs_w.push(new Sk.builtin.str(slice));\n    }\n    return new Sk.builtin.list(strs_w);\n});\n\nSk.builtin.str.prototype[\"title\"] = new Sk.builtin.func(function (self) {\n    var ret;\n\n    Sk.builtin.pyCheckArgsLen(\"title\", arguments.length, 1, 1);\n\n    ret = self.v.replace(/[a-z][a-z]*/gi, function(str) {\n        return str[0].toUpperCase() + str.substr(1).toLowerCase();\n    });\n\n    return new Sk.builtin.str(ret);\n});\n\nSk.builtin.str.prototype[\"isalpha\"] = new Sk.builtin.func(function (self) {\n    Sk.builtin.pyCheckArgsLen(\"isalpha\", arguments.length, 1, 1);\n    return new Sk.builtin.bool( self.v.length && !/[^a-zA-Z]/.test(self.v));\n});\n\nSk.builtin.str.prototype[\"isalnum\"] = new Sk.builtin.func(function (self) {\n    Sk.builtin.pyCheckArgsLen(\"isalnum\", arguments.length, 1, 1);\n    return new Sk.builtin.bool( self.v.length && !/[^a-zA-Z0-9]/.test(self.v));\n});\n\n// does not account for unicode numeric values\nSk.builtin.str.prototype[\"isnumeric\"] = new Sk.builtin.func(function (self) {\n    Sk.builtin.pyCheckArgsLen(\"isnumeric\", arguments.length, 1, 1);\n    return new Sk.builtin.bool( self.v.length && !/[^0-9]/.test(self.v));\n});\n\nSk.builtin.str.prototype[\"islower\"] = new Sk.builtin.func(function (self) {\n    Sk.builtin.pyCheckArgsLen(\"islower\", arguments.length, 1, 1);\n    return new Sk.builtin.bool( self.v.length && /[a-z]/.test(self.v) && !/[A-Z]/.test(self.v));\n});\n\nSk.builtin.str.prototype[\"isupper\"] = new Sk.builtin.func(function (self) {\n    Sk.builtin.pyCheckArgsLen(\"isupper\", arguments.length, 1, 1);\n    return new Sk.builtin.bool( self.v.length && !/[a-z]/.test(self.v) && /[A-Z]/.test(self.v));\n});\n\nSk.builtin.str.prototype[\"istitle\"] = new Sk.builtin.func(function (self) {\n    // Comparing to str.title() seems the most intuitive thing, but it fails on \"\",\n    // Other empty-ish strings with no change.\n    var input = self.v;\n    var cased = false;\n    var previous_is_cased = false;\n    var pos;\n    var ch;\n    Sk.builtin.pyCheckArgsLen(\"istitle\", arguments.length, 1, 1);\n    for (pos = 0; pos < input.length; pos ++) {\n        ch = input.charAt(pos);\n        if (! /[a-z]/.test(ch) && /[A-Z]/.test(ch)) {\n            if (previous_is_cased) {\n                return new Sk.builtin.bool( false);\n            }\n            previous_is_cased = true;\n            cased = true;\n        } else if (/[a-z]/.test(ch) && ! /[A-Z]/.test(ch)) {\n            if (! previous_is_cased) {\n                return new Sk.builtin.bool( false);\n            }\n            cased = true;\n        } else {\n            previous_is_cased = false;\n        }\n    }\n    return new Sk.builtin.bool( cased);\n});\n\nSk.builtin.str.prototype.nb$remainder = function (rhs) {\n    // % format op. rhs can be a value, a tuple, or something with __getitem__ (dict)\n\n    // From http://docs.python.org/library/stdtypes.html#string-formatting the\n    // format looks like:\n    // 1. The '%' character, which marks the start of the specifier.\n    // 2. Mapping key (optional), consisting of a parenthesised sequence of characters (for example, (somename)).\n    // 3. Conversion flags (optional), which affect the result of some conversion types.\n    // 4. Minimum field width (optional). If specified as an '*' (asterisk), the actual width is read from the next\n    // element of the tuple in values, and the object to convert comes after the minimum field width and optional\n    // precision. 5. Precision (optional), given as a '.' (dot) followed by the precision. If specified as '*' (an\n    // asterisk), the actual width is read from the next element of the tuple in values, and the value to convert comes\n    // after the precision. 6. Length modifier (optional). 7. Conversion type.  length modifier is ignored\n\n    var ret;\n    var replFunc;\n    var index;\n    var regex;\n    if (rhs.constructor !== Sk.builtin.tuple && (rhs.mp$subscript === undefined || rhs.constructor === Sk.builtin.str)) {\n        rhs = new Sk.builtin.tuple([rhs]);\n    }\n\n    // general approach is to use a regex that matches the format above, and\n    // do an re.sub with a function as replacement to make the subs.\n\n    //           1 2222222222222222   33333333   444444444   5555555555555  66666  777777777777777777\n    regex = /%(\\([a-zA-Z0-9]+\\))?([#0 +\\-]+)?(\\*|[0-9]+)?(\\.(\\*|[0-9]+))?[hlL]?([diouxXeEfFgGcrs%])/g;\n    index = 0;\n    replFunc = function (substring, mappingKey, conversionFlags, fieldWidth, precision, precbody, conversionType) {\n        var result;\n        var convName;\n        var convValue;\n        var base;\n        var r;\n        var mk;\n        var value;\n        var handleWidth;\n        var formatNumber;\n        var alternateForm;\n        var precedeWithSign;\n        var blankBeforePositive;\n        var leftAdjust;\n        var zeroPad;\n        var i;\n        fieldWidth = Sk.builtin.asnum$(fieldWidth);\n        precision = Sk.builtin.asnum$(precision);\n\n        if (mappingKey === undefined || mappingKey === \"\") {\n            i = index++;\n        } // ff passes '' not undef for some reason\n\n        if (precision === \"\") { // ff passes '' here aswell causing problems with G,g, etc.\n            precision = undefined;\n        }\n\n        zeroPad = false;\n        leftAdjust = false;\n        blankBeforePositive = false;\n        precedeWithSign = false;\n        alternateForm = false;\n        if (conversionFlags) {\n            if (conversionFlags.indexOf(\"-\") !== -1) {\n                leftAdjust = true;\n            } else if (conversionFlags.indexOf(\"0\") !== -1) {\n                zeroPad = true;\n            }\n\n            if (conversionFlags.indexOf(\"+\") !== -1) {\n                precedeWithSign = true;\n            } else if (conversionFlags.indexOf(\" \") !== -1) {\n                blankBeforePositive = true;\n            }\n\n            alternateForm = conversionFlags.indexOf(\"#\") !== -1;\n        }\n\n        if (precision) {\n            precision = parseInt(precision.substr(1), 10);\n        }\n\n        formatNumber = function (n, base) {\n            var precZeroPadded;\n            var prefix;\n            var didSign;\n            var neg;\n            var r;\n            var j;\n            base = Sk.builtin.asnum$(base);\n            neg = false;\n            didSign = false;\n            if (typeof n === \"number\") {\n                if (n < 0) {\n                    n = -n;\n                    neg = true;\n                }\n                r = n.toString(base);\n            } else if (n instanceof Sk.builtin.float_) {\n                r = n.str$(base, false);\n                if (r.length > 2 && r.substr(-2) === \".0\") {\n                    r = r.substr(0, r.length - 2);\n                }\n                neg = n.nb$isnegative();\n            } else if (n instanceof Sk.builtin.int_) {\n                r = n.str$(base, false);\n                neg = n.nb$isnegative();\n            } else if (n instanceof Sk.builtin.lng) {\n                r = n.str$(base, false);\n                neg = n.nb$isnegative();\n            }\n\n            Sk.asserts.assert(r !== undefined, \"unhandled number format\");\n\n            precZeroPadded = false;\n\n            if (precision) {\n                //print(\"r.length\",r.length,\"precision\",precision);\n                for (j = r.length; j < precision; ++j) {\n                    r = \"0\" + r;\n                    precZeroPadded = true;\n                }\n            }\n\n            prefix = \"\";\n\n            if (neg) {\n                prefix = \"-\";\n            } else if (precedeWithSign) {\n                prefix = \"+\" + prefix;\n            } else if (blankBeforePositive) {\n                prefix = \" \" + prefix;\n            }\n\n            if (alternateForm) {\n                if (base === 16) {\n                    prefix += \"0x\";\n                } else if (base === 8 && !precZeroPadded && r !== \"0\") {\n                    prefix += \"0\";\n                }\n            }\n\n            return [prefix, r];\n        };\n\n        handleWidth = function (args) {\n            var totLen;\n            var prefix = args[0];\n            var r = args[1];\n            var j;\n            if (fieldWidth) {\n                fieldWidth = parseInt(fieldWidth, 10);\n                totLen = r.length + prefix.length;\n                if (zeroPad) {\n                    for (j = totLen; j < fieldWidth; ++j) {\n                        r = \"0\" + r;\n                    }\n                } else if (leftAdjust) {\n                    for (j = totLen; j < fieldWidth; ++j) {\n                        r = r + \" \";\n                    }\n                } else {\n                    for (j = totLen; j < fieldWidth; ++j) {\n                        prefix = \" \" + prefix;\n                    }\n                }\n            }\n            return prefix + r;\n        };\n\n        //print(\"Rhs:\",rhs, \"ctor\", rhs.constructor);\n        if (rhs.constructor === Sk.builtin.tuple) {\n            value = rhs.v[i];\n        } else if (rhs.mp$subscript !== undefined && mappingKey !== undefined) {\n            mk = mappingKey.substring(1, mappingKey.length - 1);\n            //print(\"mk\",mk);\n            value = rhs.mp$subscript(new Sk.builtin.str(mk));\n        } else if (rhs.constructor === Sk.builtin.dict || rhs.constructor === Sk.builtin.list) {\n            // new case where only one argument is provided\n            value = rhs;\n        } else {\n            throw new Sk.builtin.AttributeError(rhs.tp$name + \" instance has no attribute 'mp$subscript'\");\n        }\n        base = 10;\n        if (conversionType === \"d\" || conversionType === \"i\") {\n            return handleWidth(formatNumber(value, 10));\n        } else if (conversionType === \"o\") {\n            return handleWidth(formatNumber(value, 8));\n        } else if (conversionType === \"x\") {\n            return handleWidth(formatNumber(value, 16));\n        } else if (conversionType === \"X\") {\n            return handleWidth(formatNumber(value, 16)).toUpperCase();\n        } else if (conversionType === \"f\" || conversionType === \"F\" || conversionType === \"e\" || conversionType === \"E\" || conversionType === \"g\" || conversionType === \"G\") {\n            convValue = Sk.builtin.asnum$(value);\n            if (typeof convValue === \"string\") {\n                convValue = Number(convValue);\n            }\n            if (convValue === Infinity) {\n                return \"inf\";\n            }\n            if (convValue === -Infinity) {\n                return \"-inf\";\n            }\n            if (isNaN(convValue)) {\n                return \"nan\";\n            }\n            convName = [\"toExponential\", \"toFixed\", \"toPrecision\"][\"efg\".indexOf(conversionType.toLowerCase())];\n            if (precision === undefined || precision === \"\") {\n                if (conversionType === \"e\" || conversionType === \"E\") {\n                    precision = 6;\n                } else if (conversionType === \"f\" || conversionType === \"F\") {\n                    precision = 7;\n                }\n            }\n            result = (convValue)[convName](precision); // possible loose of negative zero sign\n\n            // apply sign to negative zeros, floats only!\n            if(Sk.builtin.checkFloat(value)) {\n                if(convValue === 0 && 1/convValue === -Infinity) {\n                    result = \"-\" + result; // add sign for zero\n                }\n            }\n\n            if (\"EFG\".indexOf(conversionType) !== -1) {\n                result = result.toUpperCase();\n            }\n            return handleWidth([\"\", result]);\n        } else if (conversionType === \"c\") {\n            if (typeof value === \"number\") {\n                return String.fromCharCode(value);\n            } else if (value instanceof Sk.builtin.int_) {\n                return String.fromCharCode(value.v);\n            } else if (value instanceof Sk.builtin.float_) {\n                return String.fromCharCode(value.v);\n            } else if (value instanceof Sk.builtin.lng) {\n                return String.fromCharCode(value.str$(10, false)[0]);\n            } else if (value.constructor === Sk.builtin.str) {\n                return value.v.substr(0, 1);\n            } else {\n                throw new Sk.builtin.TypeError(\"an integer is required\");\n            }\n        } else if (conversionType === \"r\") {\n            r = Sk.builtin.repr(value);\n            if (precision) {\n                return r.v.substr(0, precision);\n            }\n            return r.v;\n        } else if (conversionType === \"s\") {\n            r = new Sk.builtin.str(value);\n            r = r.$jsstr();\n            if (precision) {\n                return r.substr(0, precision);\n            }\n            if(fieldWidth) {\n                r = handleWidth([\" \", r]);\n            }\n            return r;\n        } else if (conversionType === \"%\") {\n            return \"%\";\n        }\n    };\n\n    ret = this.v.replace(regex, replFunc);\n    return new Sk.builtin.str(ret);\n};\n\n/**\n * @constructor\n * @param {Object} obj\n */\nSk.builtin.str_iter_ = function (obj) {\n    if (!(this instanceof Sk.builtin.str_iter_)) {\n        return new Sk.builtin.str_iter_(obj);\n    }\n    this.$index = 0;\n    this.$obj = obj.v.slice();\n    this.sq$length = this.$obj.length;\n    this.tp$iter = this;\n    this.tp$iternext = function () {\n        if (this.$index >= this.sq$length) {\n            return undefined;\n        }\n        return new Sk.builtin.str(this.$obj.substr(this.$index++, 1));\n    };\n    this.$r = function () {\n        return new Sk.builtin.str(\"iterator\");\n    };\n    return this;\n};\n\nSk.abstr.setUpInheritance(\"iterator\", Sk.builtin.str_iter_, Sk.builtin.object);\n\nSk.builtin.str_iter_.prototype.__class__ = Sk.builtin.str_iter_;\n\nSk.builtin.str_iter_.prototype.__iter__ = new Sk.builtin.func(function (self) {\n    Sk.builtin.pyCheckArgsLen(\"__iter__\", arguments.length, 0, 0, true, false);\n    return self;\n});\n\nSk.builtin.str_iter_.prototype.next$ = function (self) {\n    var ret = self.tp$iternext();\n    if (ret === undefined) {\n        throw new Sk.builtin.StopIteration();\n    }\n    return ret;\n};\n\n\n/***/ }),\n/* 21 */\n/***/ (function(module, exports) {\n\nvar format = function (kwa) {\n    // following PEP 3101\n\n    var a, args, key, kwargs;\n    var ret;\n    var regex;\n    var index;\n    var replFunc;\n    var arg_dict = {};\n\n    Sk.builtin.pyCheckArgsLen(\"format\", arguments.length, 0, Infinity, true, true);\n\n    args = new Sk.builtins[\"tuple\"](Array.prototype.slice.call(arguments, 1)); /*vararg*/\n    kwargs = new Sk.builtins[\"dict\"](kwa);\n\n    if (arguments[1] === undefined) {\n        return args.v;\n    }\n    index = 0;\n    regex = /{(((?:\\d+)|(?:\\w+))?((?:\\.(\\w+))|(?:\\[((?:\\d+)|(?:\\w+))\\])?))?(?:\\!([rs]))?(?:\\:((?:(.)?([<\\>\\=\\^]))?([\\+\\-\\s])?(#)?(0)?(\\d+)?(,)?(?:\\.(\\d+))?([bcdeEfFgGnosxX%])?))?}/g;\n    // ex: {o.name!r:*^+#030,.9b}\n    // Field 1, Field_name, o.name\n    // Field 2, arg_name, o\n    // Field 3, attribute_name/Element_index , .name\n    // Field 4, Attribute name, name\n    // Field 5, element_index, [0]\n    // Field 6, conversion, r\n    // Field 7, format_spec,*^+#030,.9b\n    // Field 9, fill_character,*\n    // Field 10, fill_align, ^\n    // Field 11, sign, +\n    // Field 12, 0x, #\n    // Filed 13, sign-aware 0 padding, 0\n    // Field 14, width, 30\n    // Field 15, comma, ,\n    // Field 16, precision, .9\n    // Field 17, conversionType, b\n\n    // Detect empty/int/complex name\n    // retrive field value\n    // hand off format spec\n    // return resulting spec to function\n\n\n    if(kwargs.size !== 0){\n\n        var kwItems = Sk.misceval.callsimArray(Sk.builtin.dict.prototype[\"items\"], [kwargs]);\n\n        for (var n in kwItems.v){\n            arg_dict[kwItems.v[n].v[0].v] = kwItems.v[n].v[1];\n        }\n    }\n    for(var i in args.v){\n        if(i !== \"0\") {\n            arg_dict[i-1] = args.v[i];\n        }\n    }\n\n    replFunc = function (substring, field_name, arg_name, attr_name, attribute_name, element_index, conversion, format_spec, fill_char, fill_align, sign, zero_pad, sign_aware, fieldWidth, comma, precision, conversionType, offset, str_whole) {\n        var return_str;\n        var formatNumber;\n        var formatFormat;\n        var result;\n        var base;\n        var value;\n        var handleWidth;\n        var alternateForm;\n        var precedeWithSign;\n        var blankBeforePositive;\n        var leftAdjust;\n        var centerAdjust;\n        var zeroPad;\n        var convName;\n        var convValue;\n        var percent;\n        var container;\n        fieldWidth = Sk.builtin.asnum$(fieldWidth);\n        precision = Sk.builtin.asnum$(precision);\n\n        if(element_index !== undefined && element_index !== \"\"){\n            container = arg_dict[arg_name];\n            if (container.constructor === Array) {\n                value = container[element_index];\n            } else {\n                if (container instanceof Sk.builtin.dict) {\n                    value = Sk.abstr.objectGetItem(container, new Sk.builtin.str(element_index), false);\n                } else {\n                    value = Sk.abstr.objectGetItem(container, new Sk.builtin.int_(parseInt(element_index, 10)), false);\n                }\n            }\n            index++;\n        } else if(attribute_name !== undefined && attribute_name !== \"\"){\n            value = arg_dict[arg_name][attribute_name];\n            index++;\n        } else if(arg_name !== undefined && arg_name !== \"\"){\n            value = arg_dict[arg_name];\n            index++;\n        } else if(field_name === undefined || field_name === \"\"){\n            return_str = arg_dict[index];\n            index++;\n            value = return_str;\n        } else if(field_name instanceof Sk.builtin.int_ ||\n                  field_name instanceof Sk.builtin.float_ ||\n                  field_name instanceof Sk.builtin.lng || !isNaN(parseInt(field_name, 10))){\n            return_str = arg_dict[field_name];\n            index++;\n            value = return_str;\n        }\n\n        if (precision === \"\") { // ff passes '' here aswell causing problems with G,g, etc.\n            precision = undefined;\n        }\n        if(fill_char === undefined || fill_char === \"\"){\n            fill_char = \" \";\n        }\n\n        zeroPad = false;\n        leftAdjust = false;\n        centerAdjust = false;\n        blankBeforePositive = false;\n        precedeWithSign = false;\n        alternateForm = false;\n        if (format_spec) {\n            if(sign !== undefined && sign !== \"\"){\n                if (\"-\".indexOf(sign) !== -1) {\n                    leftAdjust = true;\n                } else if (\"+\".indexOf(sign) !== -1) {\n                    precedeWithSign = true;\n                } else if (\" \".indexOf(sign) !== -1) {\n                    blankBeforePositive = true;\n                }\n            }\n            if(zero_pad){\n                alternateForm = \"#\".indexOf(zero_pad) !== -1;\n            }\n            if(fieldWidth !== undefined && fieldWidth !== \"\"){\n                if(fill_char === undefined || fill_char === \"\"){\n                    fill_char = \" \";\n                }\n            }\n            if(\"%\".indexOf(conversionType) !== -1){\n                percent = true;\n            }\n        }\n        if (precision) {\n            precision = parseInt(precision, 10);\n        }\n\n        formatFormat = function(value){\n            var r;\n            var s;\n            if(conversion === undefined || conversion === \"\" || conversion == \"s\"){\n                s = new Sk.builtin.str(value);\n                return s.v;\n            } else if(conversion == \"r\"){\n                r = Sk.builtin.repr(value);\n                return r.v;\n            }\n\n        };\n\n        handleWidth = function (prefix, r) {\n            // print(prefix);\n            var totLen;\n            r = Sk.ffi.remapToJs(r);\n\n            var j;\n            if(percent){\n                r = r +\"%\";\n            }\n            if (fieldWidth !== undefined && fieldWidth !== \"\") {\n                fieldWidth = parseInt(fieldWidth, 10);\n                totLen = r.length + prefix.length;\n                if (zeroPad) {\n                    for (j = totLen; j < fieldWidth; ++j) {\n                        r = \"0\" + r;\n                    }\n                } else if (leftAdjust) {\n                    for (j = totLen; j < fieldWidth; ++j) {\n                        r = r + fill_char;\n                    }\n                } else if(\">\".indexOf(fill_align) !== -1){\n                    for (j = totLen; j < fieldWidth; ++j) {\n                        prefix = fill_char + prefix;\n                    }\n                } else if(\"^\".indexOf(fill_align) !== -1){\n                    for (j = totLen; j < fieldWidth; ++j) {\n                        if(j % 2 === 0){\n                            prefix = fill_char + prefix;\n                        } else if ( j % 2 === 1){\n                            r = r + fill_char;\n                        }\n                    }\n                } else if(\"=\".indexOf(fill_align) !== -1){\n                    for (j = totLen; j < fieldWidth; ++j) {\n                        r =  fill_char + r;\n                    }\n                } else{\n                    for (j = totLen; j < fieldWidth; ++j) {\n                        r = r + fill_char;\n                    }\n                }\n            }\n            return formatFormat(prefix + r);\n        };\n\n        formatNumber = function(n, base){\n            var precZeroPadded;\n            var prefix;\n            var neg;\n            var r;\n\n            base = Sk.builtin.asnum$(base);\n            neg = false;\n\n            if(format_spec === undefined){\n                return formatFormat(value);\n            }\n\n            if (typeof n === \"number\") {\n                if (n < 0) {\n                    n = -n;\n                    neg = true;\n                }\n                r = n.toString(base);\n            } else if (n instanceof Sk.builtin.float_) {\n                r = n.str$(base, false);\n                if (r.length > 2 && r.substr(-2) === \".0\") {\n                    r = r.substr(0, r.length - 2);\n                }\n                neg = n.nb$isnegative();\n            } else if (n instanceof Sk.builtin.int_) {\n                r = n.str$(base, false);\n                neg = n.nb$isnegative();\n            } else if (n instanceof Sk.builtin.lng) {\n                r = n.str$(base, false);\n                neg = n.nb$isnegative();    //  neg = n.size$ < 0;  RNL long.js change\n            } else{\n                r = n;\n            }\n\n            if (precision) {\n                n = Number(r);\n                if (n < 0) {\n                    n = -n;\n                    neg = true;\n                }\n                r = n.toFixed(precision);\n            }\n\n            precZeroPadded = false;\n            prefix = \"\";\n\n            if (neg) {\n                prefix = \"-\";\n            } else if (precedeWithSign) {\n                prefix = \"+\" ;\n            } else if (blankBeforePositive) {\n                prefix = \" \" ;\n            }\n\n            if (alternateForm) {\n                if (base === 16) {\n                    prefix += \"0x\";\n                } else if (base === 8 && !precZeroPadded && r !== \"0\") {\n                    prefix += \"0o\";\n                } else if (base === 2 && !precZeroPadded && r !== \"0\"){\n                    prefix += \"0b\";\n                }\n            }\n\n            if(conversionType === \"n\"){\n                r=r.toLocaleString();\n            } else if(\",\".indexOf(comma) !== -1){\n                var parts = r.toString().split(\".\");\n                parts[0] = parts[0].replace(/\\B(?=(\\d{3})+(?!\\d))/g, \",\");\n                r = parts.join(\".\");\n            }\n            return handleWidth(prefix, r);\n        };\n\n        base = 10;\n        if(conversionType === \"d\" || conversionType === \"n\" || conversionType === \"\" || conversionType === undefined){\n            return formatNumber(value, 10);\n        }else if (conversionType === \"b\") {\n            return formatNumber(value, 2);\n        }else if (conversionType === \"o\") {\n            return formatNumber(value, 8);\n        } else if (conversionType === \"x\") {\n            return formatNumber(value, 16);\n        } else if (conversionType === \"X\") {\n            return formatNumber(value, 16).toUpperCase();\n        } else if (conversionType === \"f\" || conversionType === \"F\" || conversionType === \"e\" || conversionType === \"E\" || conversionType === \"g\" || conversionType === \"G\") {\n            if(alternateForm){\n                throw new Sk.builtin.ValueError(\"Alternate form (#) not allowed in float format specifier\");\n            }\n            convValue = Sk.builtin.asnum$(value);\n            if (typeof convValue === \"string\") {\n                convValue = Number(convValue);\n            }\n            if (convValue === Infinity) {\n                return handleWidth(\"\",\"inf\");\n            }\n            if (convValue === -Infinity) {\n                return handleWidth(\"-\",\"inf\");\n            }\n            if (isNaN(convValue)) {\n                return handleWidth(\"\",\"nan\");\n            }\n            convName = [\"toExponential\", \"toFixed\", \"toPrecision\"][\"efg\".indexOf(conversionType.toLowerCase())];\n            if (precision === undefined || precision === \"\") {\n                if (conversionType === \"e\" || conversionType === \"E\" || conversionType === \"%\") {\n                    precision = parseInt(6, 10);\n                } else if (conversionType === \"f\" || conversionType === \"F\") {\n                    precision = parseInt(6, 10);\n                }\n            }\n            result = (convValue)[convName](precision);\n            if (\"EFG\".indexOf(conversionType) !== -1) {\n                result = result.toUpperCase();\n            }\n            return formatNumber(result, 10);\n        } else if (conversionType === \"c\") {\n            if (typeof value === \"number\") {\n                return handleWidth(\"\", String.fromCharCode(value));\n            } else if (value instanceof Sk.builtin.int_) {\n                return handleWidth(\"\", String.fromCharCode(value.v));\n            } else if (value instanceof Sk.builtin.float_) {\n                return handleWidth(\"\", String.fromCharCode(value.v));\n            } else if (value instanceof Sk.builtin.lng) {\n                return handleWidth(\"\", String.fromCharCode(value.str$(10, false)[0]));\n            } else if (value.constructor === Sk.builtin.str) {\n                return handleWidth(\"\", value.v.substr(0, 1));\n            } else {\n                throw new Sk.builtin.TypeError(\"an integer is required\");\n            }\n        } else if (percent) {\n            if(precision === undefined){precision = parseInt(7,10);}\n            return formatNumber(value.nb$multiply(new Sk.builtin.int_(100)), 10);\n        }\n\n    };\n\n    ret = args.v[0].v.replace(regex, replFunc);\n    return new Sk.builtin.str(ret);\n};\n\nformat[\"co_kwargs\"] = true;\nSk.builtin.str.prototype[\"format\"] = new Sk.builtin.func(format);\n\n\n/***/ }),\n/* 22 */\n/***/ (function(module, exports) {\n\n/**\n * @constructor\n * @param {Array.<Object>|Object} L\n */\nSk.builtin.tuple = function (L) {\n    var it, i;\n    if (!(this instanceof Sk.builtin.tuple)) {\n        Sk.builtin.pyCheckArgsLen(\"tuple\", arguments.length, 0, 1);\n        return new Sk.builtin.tuple(L);\n    }\n\n\n    if (L === undefined) {\n        L = [];\n    }\n\n    if (Object.prototype.toString.apply(L) === \"[object Array]\") {\n        this.v = L;\n    } else {\n        if (Sk.builtin.checkIterable(L)) {\n            this.v = [];\n            for (it = Sk.abstr.iter(L), i = it.tp$iternext(); i !== undefined; i = it.tp$iternext()) {\n                this.v.push(i);\n            }\n        } else {\n            throw new Sk.builtin.TypeError(\"expecting Array or iterable\");\n        }\n    }\n\n    this.__class__ = Sk.builtin.tuple;\n\n    this[\"v\"] = this.v;\n    return this;\n};\n\nSk.abstr.setUpInheritance(\"tuple\", Sk.builtin.tuple, Sk.builtin.seqtype);\n\nSk.builtin.tuple.prototype[\"$r\"] = function () {\n    var ret;\n    var i;\n    var bits;\n    if (this.v.length === 0) {\n        return new Sk.builtin.str(\"()\");\n    }\n    bits = [];\n    for (i = 0; i < this.v.length; ++i) {\n        bits[i] = Sk.misceval.objectRepr(this.v[i]).v;\n    }\n    ret = bits.join(\", \");\n    if (this.v.length === 1) {\n        ret += \",\";\n    }\n    return new Sk.builtin.str(\"(\" + ret + \")\");\n};\n\nSk.builtin.tuple.prototype.mp$subscript = function (index) {\n    var ret;\n    var i;\n    if (Sk.misceval.isIndex(index)) {\n        i = Sk.misceval.asIndex(index);\n        if (i !== undefined) {\n            if (i < 0) {\n                i = this.v.length + i;\n            }\n            if (i < 0 || i >= this.v.length) {\n                throw new Sk.builtin.IndexError(\"tuple index out of range\");\n            }\n            return this.v[i];\n        }\n    } else if (index instanceof Sk.builtin.slice) {\n        ret = [];\n        index.sssiter$(this, function (i, wrt) {\n            ret.push(wrt.v[i]);\n        });\n        return new Sk.builtin.tuple(ret);\n    }\n\n    throw new Sk.builtin.TypeError(\"tuple indices must be integers, not \" + Sk.abstr.typeName(index));\n};\n\n// todo; the numbers and order are taken from python, but the answer's\n// obviously not the same because there's no int wrapping. shouldn't matter,\n// but would be nice to make the hash() values the same if it's not too\n// expensive to simplify tests.\nSk.builtin.tuple.prototype.tp$hash = function () {\n    var y;\n    var i;\n    var mult = 1000003;\n    var x = 0x345678;\n    var len = this.v.length;\n    for (i = 0; i < len; ++i) {\n        y = Sk.builtin.hash(this.v[i]).v;\n        if (y === -1) {\n            return new Sk.builtin.int_(-1);\n        }\n        x = (x ^ y) * mult;\n        mult += 82520 + len + len;\n    }\n    x += 97531;\n    if (x === -1) {\n        x = -2;\n    }\n    return new Sk.builtin.int_(x | 0);\n};\n\nSk.builtin.tuple.prototype.sq$repeat = function (n) {\n    var j;\n    var i;\n    var ret;\n\n    n = Sk.misceval.asIndex(n);\n    ret = [];\n    for (i = 0; i < n; ++i) {\n        for (j = 0; j < this.v.length; ++j) {\n            ret.push(this.v[j]);\n        }\n    }\n    return new Sk.builtin.tuple(ret);\n};\nSk.builtin.tuple.prototype.nb$multiply = Sk.builtin.tuple.prototype.sq$repeat;\nSk.builtin.tuple.prototype.nb$inplace_multiply = Sk.builtin.tuple.prototype.sq$repeat;\n\nSk.builtin.tuple.prototype.__iter__ = new Sk.builtin.func(function (self) {\n    Sk.builtin.pyCheckArgsLen(\"__iter__\", arguments.length, 1, 1);\n    return new Sk.builtin.tuple_iter_(self);\n});\n\nSk.builtin.tuple.prototype.tp$iter = function () {\n    return new Sk.builtin.tuple_iter_(this);\n};\n\nSk.builtin.tuple.prototype.tp$richcompare = function (w, op) {\n    //print(\"  tup rc\", JSON.stringify(this.v), JSON.stringify(w), op);\n\n    // w not a tuple\n    var k;\n    var i;\n    var wl;\n    var vl;\n    var v;\n    if (!w.__class__ ||\n        !Sk.misceval.isTrue(Sk.builtin.isinstance(w, Sk.builtin.tuple))) {\n        // shortcuts for eq/not\n        if (op === \"Eq\") {\n            return false;\n        }\n        if (op === \"NotEq\") {\n            return true;\n        }\n\n        // todo; other types should have an arbitrary order\n        return false;\n    }\n\n    v = this.v;\n    w = w.v;\n    vl = v.length;\n    wl = w.length;\n\n    for (i = 0; i < vl && i < wl; ++i) {\n        k = Sk.misceval.richCompareBool(v[i], w[i], \"Eq\");\n        if (!k) {\n            break;\n        }\n    }\n\n    if (i >= vl || i >= wl) {\n        // no more items to compare, compare sizes\n        switch (op) {\n            case \"Lt\":\n                return vl < wl;\n            case \"LtE\":\n                return vl <= wl;\n            case \"Eq\":\n                return vl === wl;\n            case \"NotEq\":\n                return vl !== wl;\n            case \"Gt\":\n                return vl > wl;\n            case \"GtE\":\n                return vl >= wl;\n            default:\n                Sk.asserts.fail();\n        }\n    }\n\n    // we have an item that's different\n\n    // shortcuts for eq/not\n    if (op === \"Eq\") {\n        return false;\n    }\n    if (op === \"NotEq\") {\n        return true;\n    }\n\n    // or, compare the differing element using the proper operator\n    //print(\"  tup rcb end\", i, v[i] instanceof Sk.builtin.str, JSON.stringify(v[i]), w[i] instanceof Sk.builtin.str, JSON.stringify(w[i]), op);\n    return Sk.misceval.richCompareBool(v[i], w[i], op);\n};\n\nSk.builtin.tuple.prototype.sq$concat = function (other) {\n    var msg;\n    if (other.__class__ != Sk.builtin.tuple) {\n        msg = \"can only concatenate tuple (not \\\"\";\n        msg += Sk.abstr.typeName(other) + \"\\\") to tuple\";\n        throw new Sk.builtin.TypeError(msg);\n    }\n\n    return new Sk.builtin.tuple(this.v.concat(other.v));\n};\n\nSk.builtin.tuple.prototype.sq$contains = function (ob) {\n    var it, i;\n\n    for (it = this.tp$iter(), i = it.tp$iternext(); i !== undefined; i = it.tp$iternext()) {\n        if (Sk.misceval.richCompareBool(i, ob, \"Eq\")) {\n            return true;\n        }\n    }\n\n    return false;\n};\n\nSk.builtin.tuple.prototype.nb$add = Sk.builtin.tuple.prototype.sq$concat;\nSk.builtin.tuple.prototype.nb$inplace_add = Sk.builtin.tuple.prototype.sq$concat;\n\nSk.builtin.tuple.prototype.sq$length = function () {\n    return this.v.length;\n};\n\n\nSk.builtin.tuple.prototype[\"index\"] = new Sk.builtin.func(function (self, item) {\n    var i;\n    var len = self.v.length;\n    var obj = self.v;\n    for (i = 0; i < len; ++i) {\n        if (Sk.misceval.richCompareBool(obj[i], item, \"Eq\")) {\n            return new Sk.builtin.int_(i);\n        }\n    }\n    throw new Sk.builtin.ValueError(\"tuple.index(x): x not in tuple\");\n});\n\nSk.builtin.tuple.prototype[\"count\"] = new Sk.builtin.func(function (self, item) {\n    var i;\n    var len = self.v.length;\n    var obj = self.v;\n    var count = 0;\n    for (i = 0; i < len; ++i) {\n        if (Sk.misceval.richCompareBool(obj[i], item, \"Eq\")) {\n            count += 1;\n        }\n    }\n    return  new Sk.builtin.int_(count);\n});\n\nSk.exportSymbol(\"Sk.builtin.tuple\", Sk.builtin.tuple);\n\n/**\n * @constructor\n * @param {Object} obj\n */\nSk.builtin.tuple_iter_ = function (obj) {\n    if (!(this instanceof Sk.builtin.tuple_iter_)) {\n        return new Sk.builtin.tuple_iter_(obj);\n    }\n    this.$index = 0;\n    this.$obj = obj.v.slice();\n    this.sq$length = this.$obj.length;\n    this.tp$iter = this;\n    this.tp$iternext = function () {\n        if (this.$index >= this.sq$length) {\n            return undefined;\n        }\n        return this.$obj[this.$index++];\n    };\n    this.$r = function () {\n        return new Sk.builtin.str(\"tupleiterator\");\n    };\n    return this;\n};\n\nSk.abstr.setUpInheritance(\"tupleiterator\", Sk.builtin.tuple_iter_, Sk.builtin.object);\n\nSk.builtin.tuple_iter_.prototype.__class__ = Sk.builtin.tuple_iter_;\n\nSk.builtin.tuple_iter_.prototype.__iter__ = new Sk.builtin.func(function (self) {\n    return self;\n});\n\nSk.builtin.tuple_iter_.prototype.next$ = function (self) {\n    var ret = self.tp$iternext();\n    if (ret === undefined) {\n        throw new Sk.builtin.StopIteration();\n    }\n    return ret;\n};\n\n\n/***/ }),\n/* 23 */\n/***/ (function(module, exports) {\n\n/**\n * @constructor\n * @param {Array.<Object>} L\n */\nSk.builtin.dict = function dict (L) {\n    var v;\n    var it, k;\n    var i;\n    if (!(this instanceof Sk.builtin.dict)) {\n        return new Sk.builtin.dict(L);\n    }\n\n\n    if (L === undefined) {\n        L = [];\n    }\n\n    this.size = 0;\n    this.buckets = {};\n\n    if (Object.prototype.toString.apply(L) === \"[object Array]\") {\n        // Handle dictionary literals\n        for (i = 0; i < L.length; i += 2) {\n            this.mp$ass_subscript(L[i], L[i + 1]);\n        }\n    } else if (L instanceof Sk.builtin.dict) {\n        // Handle calls of type \"dict(mapping)\" from Python code\n        for (it = Sk.abstr.iter(L), k = it.tp$iternext();\n            k !== undefined;\n            k = it.tp$iternext()) {\n            v = L.mp$subscript(k);\n            if (v === undefined) {\n                //print(k, \"had undefined v\");\n                v = null;\n            }\n            this.mp$ass_subscript(k, v);\n        }\n    } else if (Sk.builtin.checkIterable(L)) {\n        // Handle calls of type \"dict(iterable)\" from Python code\n        for (it = Sk.abstr.iter(L), i = it.tp$iternext(); i !== undefined; i = it.tp$iternext()) {\n            if (i.mp$subscript) {\n                this.mp$ass_subscript(i.mp$subscript(0), i.mp$subscript(1));\n            } else {\n                throw new Sk.builtin.TypeError(\"element \" + this.size + \" is not a sequence\");\n            }\n        }\n    } else {\n        throw new Sk.builtin.TypeError(\"object is not iterable\");\n    }\n\n    this.__class__ = Sk.builtin.dict;\n    this.tp$call = undefined; // Not callable, even though constructor is\n\n    return this;\n};\n\nSk.builtin.dict.tp$call = function(args, kw) {\n    var d, i;\n    Sk.builtin.pyCheckArgsLen(\"dict\", args, 0, 1);\n    d = new Sk.builtin.dict(args[0]);\n    if (kw) {\n        for (i = 0; i < kw.length; i += 2) {\n            d.mp$ass_subscript(new Sk.builtin.str(kw[i]), kw[i+1]);\n        }\n    }\n    return d;\n};\n\nSk.abstr.setUpInheritance(\"dict\", Sk.builtin.dict, Sk.builtin.object);\nSk.abstr.markUnhashable(Sk.builtin.dict);\n\nvar kf = Sk.builtin.hash;\n\nSk.builtin.dict.prototype.key$lookup = function (bucket, key) {\n    var item;\n    var eq;\n    var i;\n\n    for (i = 0; i < bucket.items.length; i++) {\n        item = bucket.items[i];\n        eq = Sk.misceval.richCompareBool(item.lhs, key, \"Eq\");\n        if (eq) {\n            return item;\n        }\n    }\n\n    return null;\n};\n\nSk.builtin.dict.prototype.key$pop = function (bucket, key) {\n    var item;\n    var eq;\n    var i;\n\n    for (i = 0; i < bucket.items.length; i++) {\n        item = bucket.items[i];\n        eq = Sk.misceval.richCompareBool(item.lhs, key, \"Eq\");\n        if (eq) {\n            bucket.items.splice(i, 1);\n            this.size -= 1;\n            return item;\n        }\n    }\n    return undefined;\n};\n\n// Perform dictionary lookup, either return value or undefined if key not in dictionary\nSk.builtin.dict.prototype.mp$lookup = function (key) {\n    var k = kf(key);\n    var bucket = this.buckets[k.v];\n    var item;\n\n    // todo; does this need to go through mp$ma_lookup\n\n    if (bucket !== undefined) {\n        item = this.key$lookup(bucket, key);\n        if (item) {\n            return item.rhs;\n        }\n    }\n\n    // Not found in dictionary\n    return undefined;\n};\n\nSk.builtin.dict.prototype.mp$subscript = function (key) {\n    Sk.builtin.pyCheckArgsLen(\"[]\", arguments.length, 1, 2, false, false);\n    var s;\n    var res = this.mp$lookup(key);\n\n    if (res !== undefined) {\n        // Found in dictionary\n        return res;\n    } else {\n        // Not found in dictionary\n        s = new Sk.builtin.str(key);\n        throw new Sk.builtin.KeyError(s.v);\n    }\n};\n\nSk.builtin.dict.prototype.sq$contains = function (ob) {\n    var res = this.mp$lookup(ob);\n\n    return (res !== undefined);\n};\n\nSk.builtin.dict.prototype.mp$ass_subscript = function (key, w) {\n    var k = kf(key);\n    var bucket = this.buckets[k.v];\n    var item;\n\n    if (bucket === undefined) {\n        // New bucket\n        bucket = {$hash: k, items: [\n            {lhs: key, rhs: w}\n        ]};\n        this.buckets[k.v] = bucket;\n        this.size += 1;\n        return;\n    }\n\n    item = this.key$lookup(bucket, key);\n    if (item) {\n        item.rhs = w;\n        return;\n    }\n\n    // Not found in dictionary\n    bucket.items.push({lhs: key, rhs: w});\n    this.size += 1;\n};\n\nSk.builtin.dict.prototype.mp$del_subscript = function (key) {\n    Sk.builtin.pyCheckArgsLen(\"del\", arguments.length, 1, 1, false, false);\n    var k = kf(key);\n    var bucket = this.buckets[k.v];\n    var item;\n    var s;\n\n    // todo; does this need to go through mp$ma_lookup\n\n    if (bucket !== undefined) {\n        item = this.key$pop(bucket, key);\n        if (item !== undefined) {\n            return;\n        }\n    }\n\n    // Not found in dictionary\n    s = new Sk.builtin.str(key);\n    throw new Sk.builtin.KeyError(s.v);\n};\n\nSk.builtin.dict.prototype[\"$r\"] = function () {\n    var v;\n    var iter, k;\n    var ret = [];\n    for (iter = Sk.abstr.iter(this), k = iter.tp$iternext();\n        k !== undefined;\n        k = iter.tp$iternext()) {\n        v = this.mp$subscript(k);\n        if (v === undefined) {\n            //print(k, \"had undefined v\");\n            v = null;\n        }\n\n        // we need to check if value is same as object\n        // otherwise it would cause an stack overflow\n        if(v === this) {\n            ret.push(Sk.misceval.objectRepr(k).v + \": {...}\");\n        } else {\n            ret.push(Sk.misceval.objectRepr(k).v + \": \" + Sk.misceval.objectRepr(v).v);\n        }\n    }\n    return new Sk.builtin.str(\"{\" + ret.join(\", \") + \"}\");\n};\n\nSk.builtin.dict.prototype.mp$length = function () {\n    return this.size;\n};\n\nSk.builtin.dict.prototype[\"get\"] = new Sk.builtin.func(function (self, k, d) {\n    Sk.builtin.pyCheckArgsLen(\"get()\", arguments.length, 1, 2, false, true);\n    var ret;\n\n    if (d === undefined) {\n        d = Sk.builtin.none.none$;\n    }\n\n    ret = self.mp$lookup(k);\n    if (ret === undefined) {\n        ret = d;\n    }\n\n    return ret;\n});\n\nSk.builtin.dict.prototype[\"pop\"] = new Sk.builtin.func(function (self, key, d) {\n    Sk.builtin.pyCheckArgsLen(\"pop()\", arguments.length, 1, 2, false, true);\n    var k = kf(key);\n    var bucket = self.buckets[k.v];\n    var item;\n    var s;\n\n    // todo; does this need to go through mp$ma_lookup\n    if (bucket !== undefined) {\n        item = self.key$pop(bucket, key);\n        if (item !== undefined) {\n            return item.rhs;\n        }\n    }\n\n    // Not found in dictionary\n    if (d !== undefined) {\n        return d;\n    }\n\n    s = new Sk.builtin.str(key);\n    throw new Sk.builtin.KeyError(s.v);\n});\n\nSk.builtin.dict.prototype[\"has_key\"] = new Sk.builtin.func(function (self, k) {\n    Sk.builtin.pyCheckArgsLen(\"has_key()\", arguments.length, 1, 1, false, true);\n    return new Sk.builtin.bool( self.sq$contains(k));\n});\n\nSk.builtin.dict.prototype[\"items\"] = new Sk.builtin.func(function (self) {\n    Sk.builtin.pyCheckArgsLen(\"items()\", arguments.length, 0, 0, false, true);\n    var v;\n    var iter, k;\n    var ret = [];\n\n    for (iter = Sk.abstr.iter(self), k = iter.tp$iternext();\n        k !== undefined;\n        k = iter.tp$iternext()) {\n        v = self.mp$subscript(k);\n        if (v === undefined) {\n            //print(k, \"had undefined v\");\n            v = null;\n        }\n        ret.push(new Sk.builtin.tuple([k, v]));\n    }\n    return new Sk.builtin.list(ret);\n});\n\nSk.builtin.dict.prototype[\"keys\"] = new Sk.builtin.func(function (self) {\n    Sk.builtin.pyCheckArgsLen(\"keys()\", arguments.length, 0, 0, false, true);\n    var iter, k;\n    var ret = [];\n\n    for (iter = Sk.abstr.iter(self), k = iter.tp$iternext();\n        k !== undefined;\n        k = iter.tp$iternext()) {\n        ret.push(k);\n    }\n    return new Sk.builtin.list(ret);\n});\n\nSk.builtin.dict.prototype[\"values\"] = new Sk.builtin.func(function (self) {\n    Sk.builtin.pyCheckArgsLen(\"values()\", arguments.length, 0, 0, false, true);\n    var v;\n    var iter, k;\n    var ret = [];\n\n    for (iter = Sk.abstr.iter(self), k = iter.tp$iternext();\n        k !== undefined;\n        k = iter.tp$iternext()) {\n        v = self.mp$subscript(k);\n        if (v === undefined) {\n            v = null;\n        }\n        ret.push(v);\n    }\n    return new Sk.builtin.list(ret);\n});\n\nSk.builtin.dict.prototype[\"clear\"] = new Sk.builtin.func(function (self) {\n    Sk.builtin.pyCheckArgsLen(\"clear()\", arguments.length, 0, 0, false, true);\n    var k;\n    var iter;\n\n    for (iter = Sk.abstr.iter(self), k = iter.tp$iternext();\n        k !== undefined;\n        k = iter.tp$iternext()) {\n        self.mp$del_subscript(k);\n    }\n});\n\nSk.builtin.dict.prototype[\"setdefault\"] = new Sk.builtin.func(function (self, key, default_) {\n    try {\n        return self.mp$subscript(key);\n    } catch (e) {\n        if (default_ === undefined) {\n            default_ = Sk.builtin.none.none$;\n        }\n        self.mp$ass_subscript(key, default_);\n        return default_;\n    }\n});\n\n/*\n    this function mimics the cpython implementation, which is also the reason for the\n    almost similar code, this may be changed in future\n*/\nSk.builtin.dict.prototype.dict_merge = function(b) {\n    var iter;\n    var k, v;\n    if(b instanceof Sk.builtin.dict) {\n        // fast way\n        for (iter = b.tp$iter(), k = iter.tp$iternext(); k !== undefined; k = iter.tp$iternext()) {\n            v = b.mp$subscript(k);\n            if (v === undefined) {\n                throw new Sk.builtin.AttributeError(\"cannot get item for key: \" + k.v);\n            }\n            this.mp$ass_subscript(k, v);\n        }\n    } else {\n        // generic slower way\n        var keys = Sk.misceval.callsimArray(b[\"keys\"], [b]);\n        for (iter = Sk.abstr.iter(keys), k = iter.tp$iternext(); k !== undefined; k = iter.tp$iternext()) {\n            v = b.tp$getitem(k); // get value\n            if (v === undefined) {\n                throw new Sk.builtin.AttributeError(\"cannot get item for key: \" + k.v);\n            }\n            this.mp$ass_subscript(k, v);\n        }\n    }\n};\n\n/**\n *   update() accepts either another dictionary object or an iterable of key/value pairs (as tuples or other iterables of length two).\n *   If keyword arguments are specified, the dictionary is then updated with those key/value pairs: d.update(red=1, blue=2).\n *   https://hg.python.org/cpython/file/4ff865976bb9/Objects/dictobject.c\n */\nvar update_f = function (kwargs, self, other) {\n    // case another dict or obj with keys and getitem has been provided\n    if(other !== undefined && (other.tp$name === \"dict\" || other[\"keys\"])) {\n        self.dict_merge(other); // we merge with override\n    } else if(other !== undefined && Sk.builtin.checkIterable(other)) {\n        // 2nd case, we expect an iterable that contains another iterable of length 2\n        var iter;\n        var k, v;\n        var seq_i = 0; // index of current sequence item\n        for (iter = Sk.abstr.iter(other), k = iter.tp$iternext(); k !== undefined; k = iter.tp$iternext(), seq_i++) {\n            // check if value is iter\n            if (!Sk.builtin.checkIterable(k)) {\n                throw new Sk.builtin.TypeError(\"cannot convert dictionary update sequence element #\" + seq_i + \" to a sequence\");\n            }\n\n            // cpython impl. would transform iterable into sequence\n            // we just call iternext twice if k has length of 2\n            if(k.sq$length() === 2) {\n                var k_iter = Sk.abstr.iter(k);\n                var k_key = k_iter.tp$iternext();\n                var k_value = k_iter.tp$iternext();\n                self.mp$ass_subscript(k_key, k_value);\n            } else {\n                // throw exception\n                throw new Sk.builtin.ValueError(\"dictionary update sequence element #\" + seq_i + \" has length \" + k.sq$length() + \"; 2 is required\");\n            }\n        }\n    } else if(other !== undefined) {\n        // other is not a dict or iterable\n        throw new Sk.builtin.TypeError(\"'\" +Sk.abstr.typeName(other) + \"' object is not iterable\");\n    }\n\n    // apply all key/value pairs of kwargs\n    // create here kwargs_dict, there could be exceptions in other cases before\n    var kwargs_dict = new Sk.builtins.dict(kwargs);\n    self.dict_merge(kwargs_dict);\n\n    // returns none, when successful or throws exception\n    return  Sk.builtin.none.none$;\n};\n\nupdate_f.co_kwargs = true;\nSk.builtin.dict.prototype.update = new Sk.builtin.func(update_f);\n\nSk.builtin.dict.prototype.__contains__ = new Sk.builtin.func(function (self, item) {\n    Sk.builtin.pyCheckArgsLen(\"__contains__\", arguments.length, 2, 2);\n    return new Sk.builtin.bool(self.sq$contains(item));\n});\n\nSk.builtin.dict.prototype.__cmp__ = new Sk.builtin.func(function (self, other, op) {\n    // __cmp__ cannot be supported until dict lt/le/gt/ge operations are supported\n    return Sk.builtin.NotImplemented.NotImplemented$;\n});\n\nSk.builtin.dict.prototype.__delitem__ = new Sk.builtin.func(function (self, item) {\n    Sk.builtin.pyCheckArgsLen(\"__delitem__\", arguments.length, 1, 1, false, true);\n    return Sk.builtin.dict.prototype.mp$del_subscript.call(self, item);\n});\n\nSk.builtin.dict.prototype.__getitem__ = new Sk.builtin.func(function (self, item) {\n    Sk.builtin.pyCheckArgsLen(\"__getitem__\", arguments.length, 1, 1, false, true);\n    return Sk.builtin.dict.prototype.mp$subscript.call(self, item);\n});\n\nSk.builtin.dict.prototype.__setitem__ = new Sk.builtin.func(function (self, item, value) {\n    Sk.builtin.pyCheckArgsLen(\"__setitem__\", arguments.length, 2, 2, false, true);\n    return Sk.builtin.dict.prototype.mp$ass_subscript.call(self, item, value);\n});\n\nSk.builtin.dict.prototype.__hash__ = new Sk.builtin.func(function (self) {\n    Sk.builtin.pyCheckArgsLen(\"__hash__\", arguments.length, 0, 0, false, true);\n    return Sk.builtin.dict.prototype.tp$hash.call(self);\n});\n\nSk.builtin.dict.prototype.__len__ = new Sk.builtin.func(function (self) {\n    Sk.builtin.pyCheckArgsLen(\"__len__\", arguments.length, 0, 0, false, true);\n    return Sk.builtin.dict.prototype.mp$length.call(self);\n});\n\nSk.builtin.dict.prototype.__getattribute__ = new Sk.builtin.func(function (self, attr) {\n    Sk.builtin.pyCheckArgsLen(\"__getattribute__\", arguments.length, 1, 1, false, true);\n    if (!Sk.builtin.checkString(attr)) { throw new Sk.builtin.TypeError(\"__getattribute__ requires a string\"); }\n    return Sk.builtin.dict.prototype.tp$getattr.call(self, attr);\n});\n\nSk.builtin.dict.prototype.__iter__ = new Sk.builtin.func(function (self) {\n    Sk.builtin.pyCheckArgsLen(\"__iter__\", arguments.length, 0, 0, false, true);\n\n    return new Sk.builtin.dict_iter_(self);\n});\n\nSk.builtin.dict.prototype.tp$iter = function () {\n    return new Sk.builtin.dict_iter_(this);\n};\n\nSk.builtin.dict.prototype.__repr__ = new Sk.builtin.func(function (self) {\n    Sk.builtin.pyCheckArgsLen(\"__repr__\", arguments.length, 0, 0, false, true);\n    return Sk.builtin.dict.prototype[\"$r\"].call(self);\n});\n\n/* python3 recommends implementing simple ops */\nSk.builtin.dict.prototype.ob$eq = function (other) {\n\n    var iter, k, v, otherv;\n\n    if (this === other) {\n        return Sk.builtin.bool.true$;\n    }\n\n    if (!(other instanceof Sk.builtin.dict)) {\n        return Sk.builtin.NotImplemented.NotImplemented$;\n    }\n\n    if (this.size !== other.size) {\n        return Sk.builtin.bool.false$;\n    }\n\n    for (iter = this.tp$iter(), k = iter.tp$iternext();\n        k !== undefined;\n        k = iter.tp$iternext()) {\n        v = this.mp$subscript(k);\n        otherv = other.mp$subscript(k);\n\n        if (!Sk.misceval.richCompareBool(v, otherv, \"Eq\")) {\n            return Sk.builtin.bool.false$;\n        }\n    }\n\n    return Sk.builtin.bool.true$;\n};\n\nSk.builtin.dict.prototype.ob$ne = function (other) {\n\n    var isEqual = this.ob$eq(other);\n\n    if (isEqual instanceof Sk.builtin.NotImplemented) {\n        return isEqual;\n    } else if (isEqual.v) {\n        return Sk.builtin.bool.false$;\n    } else {\n        return Sk.builtin.bool.true$;\n    }\n\n};\n\nSk.builtin.dict.prototype[\"copy\"] = new Sk.builtin.func(function (self) {\n    Sk.builtin.pyCheckArgsLen(\"copy\", arguments.length, 0, 0, false, true);\n\n    var it; // Iterator\n    var k; // Key of dict item\n    var v; // Value of dict item\n    var newCopy = new Sk.builtin.dict([]);\n\n    for (it = Sk.abstr.iter(self), k = it.tp$iternext();\n        k !== undefined;\n        k = it.tp$iternext()) {\n        v = self.mp$subscript(k);\n        if (v === undefined) {\n            v = null;\n        }\n        newCopy.mp$ass_subscript(k, v);\n    }\n\n    return newCopy;\n});\n\nSk.builtin.dict.$fromkeys = function fromkeys(self, seq, value) {\n    var k, iter, val, res, iterable;\n\n    if (self instanceof Sk.builtin.dict) {\n        // instance call\n        Sk.builtin.pyCheckArgsLen(\"fromkeys\", arguments.length, 1, 2, false, true);\n\n        res = self;\n        iterable = seq;\n        val = value === undefined ? Sk.builtin.none.none$ : value;\n    } else {\n        // static call\n        Sk.builtin.pyCheckArgsLen(\"fromkeys\", arguments.length, 1, 2, false, false);\n\n        res = new Sk.builtin.dict([]);\n        iterable = self;\n        val = seq === undefined ? Sk.builtin.none.none$ : seq;\n    }\n\n    if (!Sk.builtin.checkIterable(iterable)) {\n        throw new Sk.builtin.TypeError(\"'\" + Sk.abstr.typeName(iterable) + \"' object is not iterable\");\n    }\n\n    for (iter = Sk.abstr.iter(iterable), k = iter.tp$iternext();\n        k !== undefined;\n        k = iter.tp$iternext()) {\n        res.mp$ass_subscript(k, val);\n    }\n\n    return res;\n};\n\n\nSk.builtin.dict.prototype[\"iteritems\"] = new Sk.builtin.func(function (self) {\n    throw new Sk.builtin.NotImplementedError(\"dict.iteritems is not yet implemented in Skulpt\");\n});\n\nSk.builtin.dict.prototype[\"iterkeys\"] = new Sk.builtin.func(function (self) {\n    throw new Sk.builtin.NotImplementedError(\"dict.iterkeys is not yet implemented in Skulpt\");\n});\n\nSk.builtin.dict.prototype[\"itervalues\"] = new Sk.builtin.func(function (self) {\n    throw new Sk.builtin.NotImplementedError(\"dict.itervalues is not yet implemented in Skulpt\");\n});\n\nSk.builtin.dict.prototype[\"popitem\"] = new Sk.builtin.func(function (self) {\n    throw new Sk.builtin.NotImplementedError(\"dict.popitem is not yet implemented in Skulpt\");\n});\n\nSk.builtin.dict.prototype[\"viewitems\"] = new Sk.builtin.func(function (self) {\n    throw new Sk.builtin.NotImplementedError(\"dict.viewitems is not yet implemented in Skulpt\");\n});\n\nSk.builtin.dict.prototype[\"viewkeys\"] = new Sk.builtin.func(function (self) {\n    throw new Sk.builtin.NotImplementedError(\"dict.viewkeys is not yet implemented in Skulpt\");\n});\n\nSk.builtin.dict.prototype[\"viewvalues\"] = new Sk.builtin.func(function (self) {\n    throw new Sk.builtin.NotImplementedError(\"dict.viewvalues is not yet implemented in Skulpt\");\n});\n\nSk.exportSymbol(\"Sk.builtin.dict\", Sk.builtin.dict);\n\n/**\n * @constructor\n * @param {Object} obj\n */\nSk.builtin.dict_iter_ = function (obj) {\n    var k, i, bucket, allkeys, buckets;\n    if (!(this instanceof Sk.builtin.dict_iter_)) {\n        return new Sk.builtin.dict_iter_(obj);\n    }\n    this.$index = 0;\n    this.$obj = obj;\n    allkeys = [];\n    buckets = obj.buckets;\n    for (k in buckets) {\n        if (buckets.hasOwnProperty(k)) {\n            bucket = buckets[k];\n            if (bucket && bucket.$hash !== undefined && bucket.items !== undefined) {\n                // skip internal stuff. todo; merge pyobj and this\n                for (i = 0; i < bucket.items.length; i++) {\n                    allkeys.push(bucket.items[i].lhs);\n                }\n            }\n        }\n    }\n    this.$keys = allkeys;\n    this.tp$iter = this;\n    this.tp$iternext = function () {\n        // todo; StopIteration\n        if (this.$index >= this.$keys.length) {\n            return undefined;\n        }\n        return this.$keys[this.$index++];\n        // return this.$obj[this.$keys[this.$index++]].lhs;\n    };\n    this.$r = function () {\n        return new Sk.builtin.str(\"dictionary-keyiterator\");\n    };\n    return this;\n};\n\nSk.abstr.setUpInheritance(\"dictionary-keyiterator\", Sk.builtin.dict_iter_, Sk.builtin.object);\n\nSk.builtin.dict_iter_.prototype.__class__ = Sk.builtin.dict_iter_;\n\nSk.builtin.dict_iter_.prototype.__iter__ = new Sk.builtin.func(function (self) {\n    return self;\n});\n\nSk.builtin.dict_iter_.prototype.next$ = function (self) {\n    var ret = self.tp$iternext();\n    if (ret === undefined) {\n        throw new Sk.builtin.StopIteration();\n    }\n    return ret;\n};\n\n\n/***/ }),\n/* 24 */\n/***/ (function(module, exports) {\n\n/**\n * @constructor\n * Sk.builtin.numtype\n *\n * @description\n * Abstract class for Python numeric types.\n *\n * @extends {Sk.builtin.object}\n *\n * @return {undefined} Cannot instantiate a Sk.builtin.numtype object\n */\nSk.builtin.numtype = function () {\n\n    throw new Sk.builtin.ExternalError(\"Cannot instantiate abstract Sk.builtin.numtype class\");\n\n};\n\nSk.abstr.setUpInheritance(\"NumericType\", Sk.builtin.numtype, Sk.builtin.object);\n\nSk.builtin.numtype.sk$abstract = true;\n\n/**\n * Python wrapper of `__abs__` method.\n *\n * @name  __abs__\n * @instance\n * @memberOf Sk.builtin.numtype.prototype\n */\nSk.builtin.numtype.prototype[\"__abs__\"] = new Sk.builtin.func(function (self) {\n\n    if (self.nb$abs === undefined) {\n        throw new Sk.builtin.NotImplementedError(\"__abs__ is not yet implemented\");\n    }\n\n    Sk.builtin.pyCheckArgsLen(\"__abs__\", arguments.length, 0, 0, false, true);\n    return self.nb$abs();\n\n});\n\n/**\n * Python wrapper of `__neg__` method.\n *\n * @name  __neg__\n * @instance\n * @memberOf Sk.builtin.numtype.prototype\n */\nSk.builtin.numtype.prototype[\"__neg__\"] = new Sk.builtin.func(function (self) {\n\n    if (self.nb$negative === undefined) {\n        throw new Sk.builtin.NotImplementedError(\"__neg__ is not yet implemented\");\n    }\n\n    Sk.builtin.pyCheckArgsLen(\"__neg__\", arguments.length, 0, 0, false, true);\n    return self.nb$negative();\n\n});\n\n/**\n * Python wrapper of `__pos__` method.\n *\n * @name  __pos__\n * @instance\n * @memberOf Sk.builtin.numtype.prototype\n */\nSk.builtin.numtype.prototype[\"__pos__\"] = new Sk.builtin.func(function (self) {\n\n    if (self.nb$positive === undefined) {\n        throw new Sk.builtin.NotImplementedError(\"__pos__ is not yet implemented\");\n    }\n\n    Sk.builtin.pyCheckArgsLen(\"__pos__\", arguments.length, 0, 0, false, true);\n    return self.nb$positive();\n\n});\n\n/**\n * Python wrapper of `__int__` method.\n *\n * @name  __int__\n * @instance\n * @memberOf Sk.builtin.numtype.prototype\n */\nSk.builtin.numtype.prototype[\"__int__\"] = new Sk.builtin.func(function (self) {\n\n    if (self.nb$int_ === undefined) {\n        throw new Sk.builtin.NotImplementedError(\"__int__ is not yet implemented\");\n    }\n\n    Sk.builtin.pyCheckArgsLen(\"__int__\", arguments.length, 0, 0, false, true);\n    return self.nb$int_();\n\n});\n\n/**\n * Python wrapper of `__long__` method.\n *\n * @name  __long__\n * @instance\n * @memberOf Sk.builtin.numtype.prototype\n */\nSk.builtin.numtype.prototype[\"__long__\"] = new Sk.builtin.func(function (self) {\n\n    if (self.nb$lng === undefined) {\n        throw new Sk.builtin.NotImplementedError(\"__long__ is not yet implemented\");\n    }\n\n    Sk.builtin.pyCheckArgsLen(\"__long__\", arguments.length, 0, 0, false, true);\n    return self.nb$lng();\n\n});\n\n/**\n * Python wrapper of `__float__` method.\n *\n * @name  __float__\n * @instance\n * @memberOf Sk.builtin.numtype.prototype\n */\nSk.builtin.numtype.prototype[\"__float__\"] = new Sk.builtin.func(function (self) {\n\n    if (self.nb$float_ === undefined) {\n        throw new Sk.builtin.NotImplementedError(\"__float__ is not yet implemented\");\n    }\n\n    Sk.builtin.pyCheckArgsLen(\"__float__\", arguments.length, 0, 0, false, true);\n    return self.nb$float_();\n\n});\n\n/**\n * Python wrapper of `__add__` method.\n *\n * @name  __add__\n * @instance\n * @memberOf Sk.builtin.numtype.prototype\n */\nSk.builtin.numtype.prototype[\"__add__\"] = new Sk.builtin.func(function (self, other) {\n\n    if (self.nb$add === undefined) {\n        throw new Sk.builtin.NotImplementedError(\"__add__ is not yet implemented\");\n    }\n\n    Sk.builtin.pyCheckArgsLen(\"__add__\", arguments.length, 1, 1, false, true);\n    return self.nb$add(other);\n\n});\n\n/**\n * Python wrapper of `__radd__` method.\n *\n * @name  __radd__\n * @instance\n * @memberOf Sk.builtin.numtype.prototype\n */\nSk.builtin.numtype.prototype[\"__radd__\"] = new Sk.builtin.func(function (self, other) {\n\n    if (self.nb$reflected_add === undefined) {\n        throw new Sk.builtin.NotImplementedError(\"__radd__ is not yet implemented\");\n    }\n\n    Sk.builtin.pyCheckArgsLen(\"__radd__\", arguments.length, 1, 1, false, true);\n    return self.nb$reflected_add(other);\n\n});\n\n/**\n * Python wrapper of `__sub__` method.\n *\n * @name  __sub__\n * @instance\n * @memberOf Sk.builtin.numtype.prototype\n */\nSk.builtin.numtype.prototype[\"__sub__\"] = new Sk.builtin.func(function (self, other) {\n\n    if (self.nb$subtract === undefined) {\n        throw new Sk.builtin.NotImplementedError(\"__sub__ is not yet implemented\");\n    }\n\n    Sk.builtin.pyCheckArgsLen(\"__sub__\", arguments.length, 1, 1, false, true);\n    return self.nb$subtract(other);\n\n});\n\n/**\n * Python wrapper of `__rsub__` method.\n *\n * @name  __rsub__\n * @instance\n * @memberOf Sk.builtin.numtype.prototype\n */\nSk.builtin.numtype.prototype[\"__rsub__\"] = new Sk.builtin.func(function (self, other) {\n\n    if (self.nb$reflected_subtract === undefined) {\n        throw new Sk.builtin.NotImplementedError(\"__rsub__ is not yet implemented\");\n    }\n\n    Sk.builtin.pyCheckArgsLen(\"__rsub__\", arguments.length, 1, 1, false, true);\n    return self.nb$reflected_subtract(other);\n\n});\n\n/**\n * Python wrapper of `__mul__` method.\n *\n * @name  __mul__\n * @instance\n * @memberOf Sk.builtin.numtype.prototype\n */\nSk.builtin.numtype.prototype[\"__mul__\"] = new Sk.builtin.func(function (self, other) {\n\n    if (self.nb$multiply === undefined) {\n        throw new Sk.builtin.NotImplementedError(\"__mul__ is not yet implemented\");\n    }\n\n    Sk.builtin.pyCheckArgsLen(\"__mul__\", arguments.length, 1, 1, false, true);\n    return self.nb$multiply(other);\n\n});\n\n/**\n * Python wrapper of `__rmul__` method.\n *\n * @name  __rmul__\n * @instance\n * @memberOf Sk.builtin.numtype.prototype\n */\nSk.builtin.numtype.prototype[\"__rmul__\"] = new Sk.builtin.func(function (self, other) {\n\n    if (self.nb$reflected_multiply === undefined) {\n        throw new Sk.builtin.NotImplementedError(\"__rmul__ is not yet implemented\");\n    }\n\n    Sk.builtin.pyCheckArgsLen(\"__rmul__\", arguments.length, 1, 1, false, true);\n    return self.nb$reflected_multiply(other);\n\n});\n\n/**\n * Python wrapper of `__div__` method.\n *\n * @name  __div__\n * @instance\n * @memberOf Sk.builtin.numtype.prototype\n */\nSk.builtin.numtype.prototype[\"__div__\"] = new Sk.builtin.func(function (self, other) {\n\n    if (self.nb$divide === undefined) {\n        throw new Sk.builtin.NotImplementedError(\"__div__ is not yet implemented\");\n    }\n\n    Sk.builtin.pyCheckArgsLen(\"__div__\", arguments.length, 1, 1, false, true);\n    return self.nb$divide(other);\n\n});\n\n/**\n * Python wrapper of `__rdiv__` method.\n *\n * @name  __rdiv__\n * @instance\n * @memberOf Sk.builtin.numtype.prototype\n */\nSk.builtin.numtype.prototype[\"__rdiv__\"] = new Sk.builtin.func(function (self, other) {\n\n    if (self.nb$reflected_divide === undefined) {\n        throw new Sk.builtin.NotImplementedError(\"__rdiv__ is not yet implemented\");\n    }\n\n    Sk.builtin.pyCheckArgsLen(\"__rdiv__\", arguments.length, 1, 1, false, true);\n    return self.nb$reflected_divide(other);\n\n});\n\n/**\n * Python wrapper of `__floordiv__` method.\n *\n * @name  __floordiv__\n * @instance\n * @memberOf Sk.builtin.numtype.prototype\n */\nSk.builtin.numtype.prototype[\"__floordiv__\"] = new Sk.builtin.func(function (self, other) {\n\n    if (self.nb$floor_divide === undefined) {\n        throw new Sk.builtin.NotImplementedError(\"__floordiv__ is not yet implemented\");\n    }\n\n    Sk.builtin.pyCheckArgsLen(\"__floordiv__\", arguments.length, 1, 1, false, true);\n    return self.nb$floor_divide(other);\n\n});\n\n/**\n * Python wrapper of `__rfloordiv__` method.\n *\n * @name  __rfloordiv__\n * @instance\n * @memberOf Sk.builtin.numtype.prototype\n */\nSk.builtin.numtype.prototype[\"__rfloordiv__\"] = new Sk.builtin.func(function (self, other) {\n\n    if (self.nb$reflected_floor_divide === undefined) {\n        throw new Sk.builtin.NotImplementedError(\"__rfloordiv__ is not yet implemented\");\n    }\n\n    Sk.builtin.pyCheckArgsLen(\"__rfloordiv__\", arguments.length, 1, 1, false, true);\n    return self.nb$reflected_floor_divide(other);\n\n});\n\n/**\n * Python wrapper of `__mod__` method.\n *\n * @name  __mod__\n * @instance\n * @memberOf Sk.builtin.numtype.prototype\n */\nSk.builtin.numtype.prototype[\"__mod__\"] = new Sk.builtin.func(function (self, other) {\n\n    if (self.nb$remainder === undefined) {\n        throw new Sk.builtin.NotImplementedError(\"__mod__ is not yet implemented\");\n    }\n\n    Sk.builtin.pyCheckArgsLen(\"__mod__\", arguments.length, 1, 1, false, true);\n    return self.nb$remainder(other);\n\n});\n\n/**\n * Python wrapper of `__rmod__` method.\n *\n * @name  __rmod__\n * @instance\n * @memberOf Sk.builtin.numtype.prototype\n */\nSk.builtin.numtype.prototype[\"__rmod__\"] = new Sk.builtin.func(function (self, other) {\n\n    if (self.nb$reflected_remainder === undefined) {\n        throw new Sk.builtin.NotImplementedError(\"__rmod__ is not yet implemented\");\n    }\n\n    Sk.builtin.pyCheckArgsLen(\"__rmod__\", arguments.length, 1, 1, false, true);\n    return self.nb$reflected_remainder(other);\n\n});\n\n/**\n * Python wrapper of `__divmod__` method.\n *\n * @name  __divmod__\n * @instance\n * @memberOf Sk.builtin.numtype.prototype\n */\nSk.builtin.numtype.prototype[\"__divmod__\"] = new Sk.builtin.func(function (self, other) {\n\n    if (self.nb$divmod === undefined) {\n        throw new Sk.builtin.NotImplementedError(\"__divmod__ is not yet implemented\");\n    }\n\n    Sk.builtin.pyCheckArgsLen(\"__divmod__\", arguments.length, 1, 1, false, true);\n    return self.nb$divmod(other);\n\n});\n\n/**\n * Python wrapper of `__rdivmod__` method.\n *\n * @name  __rdivmod__\n * @instance\n * @memberOf Sk.builtin.numtype.prototype\n */\nSk.builtin.numtype.prototype[\"__rdivmod__\"] = new Sk.builtin.func(function (self, other) {\n\n    if (self.nb$reflected_divmod === undefined) {\n        throw new Sk.builtin.NotImplementedError(\"__rdivmod__ is not yet implemented\");\n    }\n\n    Sk.builtin.pyCheckArgsLen(\"__rdivmod__\", arguments.length, 1, 1, false, true);\n    return self.nb$reflected_divmod(other);\n\n});\n\n/**\n * Python wrapper of `__pow__` method.\n *\n * @name  __pow__\n * @instance\n * @memberOf Sk.builtin.numtype.prototype\n */\nSk.builtin.numtype.prototype[\"__pow__\"] = new Sk.builtin.func(function (self, other) {\n\n    if (self.nb$power === undefined) {\n        throw new Sk.builtin.NotImplementedError(\"__pow__ is not yet implemented\");\n    }\n\n    Sk.builtin.pyCheckArgsLen(\"__pow__\", arguments.length, 1, 1, false, true);\n    return self.nb$power(other);\n\n});\n\n/**\n * Python wrapper of `__rpow__` method.\n *\n * @name  __rpow__\n * @instance\n * @memberOf Sk.builtin.numtype.prototype\n */\nSk.builtin.numtype.prototype[\"__rpow__\"] = new Sk.builtin.func(function (self, other) {\n\n    if (self.nb$reflected_power === undefined) {\n        throw new Sk.builtin.NotImplementedError(\"__rpow__ is not yet implemented\");\n    }\n\n    Sk.builtin.pyCheckArgsLen(\"__rpow__\", arguments.length, 1, 1, false, true);\n    return self.nb$reflected_power(other);\n\n});\n\n/**\n * Python wrapper of `__coerce__` method.\n *\n * @name  __coerce__\n * @instance\n * @memberOf Sk.builtin.numtype.prototype\n */\nSk.builtin.numtype.prototype[\"__coerce__\"] = new Sk.builtin.func(function (self, other) {\n\n    throw new Sk.builtin.NotImplementedError(\"__coerce__ is not yet implemented\");\n\n});\n\n/**\n * Add a Python object to this instance and return the result (i.e. this + other).\n *\n * Returns NotImplemented if addition between this type and other type is unsupported.\n *\n * Javscript function, returns Python object.\n *\n * @param  {!Sk.builtin.object} other The Python object to add.\n * @return {(Sk.builtin.numtype|Sk.builtin.NotImplemented)} The result of the addition.\n */\nSk.builtin.numtype.prototype.nb$add = function (other) {\n    return Sk.builtin.NotImplemented.NotImplemented$;\n};\n\nSk.builtin.numtype.prototype.nb$reflected_add = function (other) {\n    return Sk.builtin.NotImplemented.NotImplemented$;\n};\n\nSk.builtin.numtype.prototype.nb$inplace_add = function (other) {\n    return Sk.builtin.NotImplemented.NotImplemented$;\n};\n\n/**\n * Subtract a Python object from this instance and return the result (i.e. this - other).\n *\n * Returns NotImplemented if subtraction between this type and other type is unsupported.\n *\n * Javscript function, returns Python object.\n *\n * @param  {!Sk.builtin.object} other The Python object to subtract.\n * @return {(Sk.builtin.numtype|Sk.builtin.NotImplemented)} The result of the subtraction.\n */\nSk.builtin.numtype.prototype.nb$subtract = function (other) {\n    return Sk.builtin.NotImplemented.NotImplemented$;\n};\n\nSk.builtin.numtype.prototype.nb$reflected_subtract = function (other) {\n    return Sk.builtin.NotImplemented.NotImplemented$;\n};\n\nSk.builtin.numtype.prototype.nb$inplace_subtract = function (other) {\n    return Sk.builtin.NotImplemented.NotImplemented$;\n};\n\n/**\n * Multiply this instance by a Python object and return the result (i.e. this * other).\n *\n * Returns NotImplemented if multiplication between this type and other type is unsupported.\n *\n * Javscript function, returns Python object.\n *\n * @param  {!Sk.builtin.object} other The multiplier, which must be a Python object.\n * @return {(Sk.builtin.numtype|Sk.builtin.NotImplemented)} The result of the multiplication\n */\nSk.builtin.numtype.prototype.nb$multiply = function (other) {\n    return Sk.builtin.NotImplemented.NotImplemented$;\n};\n\n\nSk.builtin.numtype.prototype.nb$reflected_multiply = function (other) {\n    return Sk.builtin.NotImplemented.NotImplemented$;\n};\n\nSk.builtin.numtype.prototype.nb$inplace_multiply = function (other) {\n    return Sk.builtin.NotImplemented.NotImplemented$;\n};\n\n/**\n * Divide this instance by a Python object and return the result (i.e this / other).\n *\n * Returns NotImplemented if division between this type and other type is unsupported.\n *\n * Javscript function, returns Python object.\n *\n * @param  {!Sk.builtin.object} other The divisor, which must be a Python object.\n * @return {(Sk.builtin.numtype|Sk.builtin.NotImplemented)} The result of the division\n */\nSk.builtin.numtype.prototype.nb$divide = function (other) {\n    return Sk.builtin.NotImplemented.NotImplemented$;\n};\n\nSk.builtin.numtype.prototype.nb$reflected_divide = function (other) {\n    return Sk.builtin.NotImplemented.NotImplemented$;\n};\n\nSk.builtin.numtype.prototype.nb$inplace_divide = function (other) {\n    return Sk.builtin.NotImplemented.NotImplemented$;\n};\n\n/**\n * Floor divide this instance by a Python object and return the result (i.e. this // other).\n *\n * Returns NotImplemented if floor division between this type and other type is unsupported.\n *\n * Javscript function, returns Python object.\n *\n * @param  {!Sk.builtin.object} other The divisor, which must be a Python object.\n * @return {(Sk.builtin.numtype|Sk.builtin.NotImplemented)} The result of the floor division\n */\nSk.builtin.numtype.prototype.nb$floor_divide = function (other) {\n    return Sk.builtin.NotImplemented.NotImplemented$;\n};\n\nSk.builtin.numtype.prototype.nb$reflected_floor_divide = function (other) {\n    return Sk.builtin.NotImplemented.NotImplemented$;\n};\n\nSk.builtin.numtype.prototype.nb$inplace_floor_divide = function (other) {\n    return Sk.builtin.NotImplemented.NotImplemented$;\n};\n\n/**\n * Modulo this instance by a Python object and return the result (i.e. this % other).\n *\n * Returns NotImplemented if modulation between this type and other type is unsupported.\n *\n * Javscript function, returns Python object.\n *\n * @param  {!Sk.builtin.object} other The divisor, which must be a Python object.\n * @return {(Sk.builtin.numtype|Sk.builtin.NotImplemented)} The result of the modulation\n */\nSk.builtin.numtype.prototype.nb$remainder = function (other) {\n    return Sk.builtin.NotImplemented.NotImplemented$;\n};\n\nSk.builtin.numtype.prototype.nb$reflected_remainder = function (other) {\n    return Sk.builtin.NotImplemented.NotImplemented$;\n};\n\nSk.builtin.numtype.prototype.nb$inplace_remainder = function (other) {\n    return Sk.builtin.NotImplemented.NotImplemented$;\n};\n\n/**\n * Compute the quotient and the remainder of this instance and a given Python object and return the result.\n *\n * Returns NotImplemented if division or modulo operations between this type and other type are unsupported.\n *\n * Javscript function, returns Python object.\n *\n * @param  {!Sk.builtin.object} other The divisor, which must be a Python object.\n * @return {(Sk.builtin.tuple|Sk.builtin.NotImplemented)} The result of the operation.\n * If both operations are supported, a Python tuple containing (quotient, remainder) in that order.\n */\nSk.builtin.numtype.prototype.nb$divmod = function (other) {\n    return Sk.builtin.NotImplemented.NotImplemented$;\n};\n\nSk.builtin.numtype.prototype.nb$reflected_divmod = function (other) {\n    return Sk.builtin.NotImplemented.NotImplemented$;\n};\n\n/**\n * Raise this instance by a Python object, optionally modulo the exponent, and return the final result.\n *\n * If mod is undefined, return this \\*\\* other. Else, return (this \\*\\* other) % mod.\n *\n * Returns NotImplemented if exponentiation or modulation between this type and other type is unsupported.\n *\n * Javscript function, returns Python object.\n *\n * @param  {!Sk.builtin.object} other The exponent, which must be a Python object.\n * @param  {!Sk.builtin.object=} mod The optional divisor, which must be a Python object if defined.\n * @return {(Sk.builtin.numtype|Sk.builtin.NotImplemented)} The result of the exponentiation.\n */\nSk.builtin.numtype.prototype.nb$power = function (other, mod) {\n    return Sk.builtin.NotImplemented.NotImplemented$;\n};\n\nSk.builtin.numtype.prototype.nb$reflected_power = function (other, mod) {\n    return Sk.builtin.NotImplemented.NotImplemented$;\n};\n\nSk.builtin.numtype.prototype.nb$inplace_power = function (other) {\n    return Sk.builtin.NotImplemented.NotImplemented$;\n};\n\n/**\n * Compute the absolute value of this instance and return.\n *\n * Javascript function, returns Python object.\n *\n * @return {(Sk.builtin.numtype|Sk.builtin.NotImplemented)} The absolute value\n */\nSk.builtin.numtype.prototype.nb$abs = function () {\n    return Sk.builtin.NotImplemented.NotImplemented$;\n};\n\n/**\n * Compute the unary negative of this instance (i.e. -this).\n *\n * Javscript function, returns Python object.\n *\n * @return {(Sk.builtin.numtype|Sk.builtin.NotImplemented)} A copy of this instance with the value negated\n */\nSk.builtin.numtype.prototype.nb$negative = function () {\n    return Sk.builtin.NotImplemented.NotImplemented$;\n};\n\n/**\n * Compute the unary positive of this instance (i.e. +this).\n *\n * Javscript function, returns Python object.\n *\n * @return {(Sk.builtin.numtype|Sk.builtin.NotImplemented)} A copy of this instance with the value unchanged\n */\nSk.builtin.numtype.prototype.nb$positive = function () {\n    return Sk.builtin.NotImplemented.NotImplemented$;\n};\n\n/**\n * Determine if this instance is nonzero.\n *\n * Javscript function, returns Javascript object or Sk.builtin.NotImplemented.\n *\n * @return {(boolean|Sk.builtin.NotImplemented)} true if this instance is not equal to zero, false otherwise\n */\nSk.builtin.numtype.prototype.nb$nonzero = function () {\n    return Sk.builtin.NotImplemented.NotImplemented$;\n};\n\n/**\n * Determine if this instance is negative.\n *\n * Javscript function, returns Javascript object or Sk.builtin.NotImplemented.\n *\n * @return {(boolean|Sk.builtin.NotImplemented)} true if this instance is negative, false otherwise\n */\nSk.builtin.numtype.prototype.nb$isnegative = function () {\n    return Sk.builtin.NotImplemented.NotImplemented$;\n};\n\n/**\n * Determine if this instance is positive.\n *\n * Javscript function, returns Javascript object or Sk.builtin.NotImplemented.\n *\n * @return {(boolean|Sk.builtin.NotImplemented)} true if this instance is positive, false otherwise\n */\nSk.builtin.numtype.prototype.nb$ispositive = function () {\n    return Sk.builtin.NotImplemented.NotImplemented$;\n};\n\n\n/***/ }),\n/* 25 */\n/***/ (function(module, exports) {\n\n/**\n * @fileoverview\n * @suppress {checkTypes}\n */\n\n/*\n * Basic JavaScript BN library - subset useful for RSA encryption.\n *\n * Copyright (c) 2003-2005  Tom Wu\n * All Rights Reserved.\n *\n * Permission is hereby granted, free of charge, to any person obtaining\n * a copy of this software and associated documentation files (the\n * \"Software\"), to deal in the Software without restriction, including\n * without limitation the rights to use, copy, modify, merge, publish,\n * distribute, sublicense, and/or sell copies of the Software, and to\n * permit persons to whom the Software is furnished to do so, subject to\n * the following conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS-IS\" AND WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS, IMPLIED OR OTHERWISE, INCLUDING WITHOUT LIMITATION, ANY\n * WARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.\n *\n * IN NO EVENT SHALL TOM WU BE LIABLE FOR ANY SPECIAL, INCIDENTAL,\n * INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY KIND, OR ANY DAMAGES WHATSOEVER\n * RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER OR NOT ADVISED OF\n * THE POSSIBILITY OF DAMAGE, AND ON ANY THEORY OF LIABILITY, ARISING OUT\n * OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n *\n * In addition, the following condition applies:\n *\n * All redistributions must retain an intact copy of this copyright notice\n * and disclaimer.\n */\n\n\n// (public) Constructor\n/**\n * @constructor\n * @param {number|string|null} a\n * @param {number=} b\n * @param {*=} c\n */\nSk.builtin.biginteger = function (a, b, c) {\n    if (a != null) {\n        if (\"number\" == typeof a) {\n            this.fromNumber(a, b, c);\n        } else if (b == null && \"string\" != typeof a) {\n            this.fromString(a, 256);\n        } else {\n            this.fromString(a, b);\n        }\n    }\n};\n\n// Bits per digit\n//Sk.builtin.biginteger.dbits;\n\n// JavaScript engine analysis\nSk.builtin.biginteger.canary = 0xdeadbeefcafe;\nSk.builtin.biginteger.j_lm = ((Sk.builtin.biginteger.canary & 0xffffff) == 0xefcafe);\n\n// return new, unset Sk.builtin.biginteger\nSk.builtin.biginteger.nbi = function () {\n    return new Sk.builtin.biginteger(null);\n};\n\n// am: Compute w_j += (x*this_i), propagate carries,\n// c is initial carry, returns final carry.\n// c < 3*dvalue, x < 2*dvalue, this_i < dvalue\n// We need to select the fastest one that works in this environment.\n\n// am1: use a single mult and divide to get the high bits,\n// max digit bits should be 26 because\n// max internal value = 2*dvalue^2-2*dvalue (< 2^53)\nSk.builtin.biginteger.prototype.am1 = function (i, x, w, j, c, n) {\n    var v;\n    while (--n >= 0) {\n        v = x * this[i++] + w[j] + c;\n        c = Math.floor(v / 0x4000000);\n        w[j++] = v & 0x3ffffff;\n    }\n    return c;\n};\n// am2 avoids a big mult-and-extract completely.\n// Max digit bits should be <= 30 because we do bitwise ops\n// on values up to 2*hdvalue^2-hdvalue-1 (< 2^31)\nSk.builtin.biginteger.prototype.am2 = function (i, x, w, j, c, n) {\n    var m;\n    var h;\n    var l;\n    var xl = x & 0x7fff, xh = x >> 15;\n    while (--n >= 0) {\n        l = this[i] & 0x7fff;\n        h = this[i++] >> 15;\n        m = xh * l + h * xl;\n        l = xl * l + ((m & 0x7fff) << 15) + w[j] + (c & 0x3fffffff);\n        c = (l >>> 30) + (m >>> 15) + xh * h + (c >>> 30);\n        w[j++] = l & 0x3fffffff;\n    }\n    return c;\n};\n// Alternately, set max digit bits to 28 since some\n// browsers slow down when dealing with 32-bit numbers.\nSk.builtin.biginteger.prototype.am3 = function (i, x, w, j, c, n) {\n    var m;\n    var h;\n    var l;\n    var xl = x & 0x3fff, xh = x >> 14;\n    while (--n >= 0) {\n        l = this[i] & 0x3fff;\n        h = this[i++] >> 14;\n        m = xh * l + h * xl;\n        l = xl * l + ((m & 0x3fff) << 14) + w[j] + c;\n        c = (l >> 28) + (m >> 14) + xh * h;\n        w[j++] = l & 0xfffffff;\n    }\n    return c;\n};\n\n// We need to select the fastest one that works in this environment.\n//if (Sk.builtin.biginteger.j_lm && (navigator.appName == \"Microsoft Internet Explorer\")) {\n//\tSk.builtin.biginteger.prototype.am = am2;\n//\tSk.builtin.biginteger.dbits = 30;\n//} else if (Sk.builtin.biginteger.j_lm && (navigator.appName != \"Netscape\")) {\n//\tSk.builtin.biginteger.prototype.am = am1;\n//\tSk.builtin.biginteger.dbits = 26;\n//} else { // Mozilla/Netscape seems to prefer am3\n//\tSk.builtin.biginteger.prototype.am = am3;\n//\tSk.builtin.biginteger.dbits = 28;\n//}\n\n// For node.js, we pick am3 with max Sk.builtin.biginteger.dbits to 28.\nSk.builtin.biginteger.prototype.am = Sk.builtin.biginteger.prototype.am3;\nSk.builtin.biginteger.dbits = 28;\n\nSk.builtin.biginteger.prototype.DB = Sk.builtin.biginteger.dbits;\nSk.builtin.biginteger.prototype.DM = ((1 << Sk.builtin.biginteger.dbits) - 1);\nSk.builtin.biginteger.prototype.DV = (1 << Sk.builtin.biginteger.dbits);\n\nSk.builtin.biginteger.BI_FP = 52;\nSk.builtin.biginteger.prototype.FV = Math.pow(2, Sk.builtin.biginteger.BI_FP);\nSk.builtin.biginteger.prototype.F1 = Sk.builtin.biginteger.BI_FP - Sk.builtin.biginteger.dbits;\nSk.builtin.biginteger.prototype.F2 = 2 * Sk.builtin.biginteger.dbits - Sk.builtin.biginteger.BI_FP;\n\n// Digit conversions\nSk.builtin.biginteger.BI_RM = \"0123456789abcdefghijklmnopqrstuvwxyz\";\nSk.builtin.biginteger.BI_RC = [];\nvar rr, vv;\nrr = \"0\".charCodeAt(0);\nfor (vv = 0; vv <= 9; ++vv) {\n    Sk.builtin.biginteger.BI_RC[rr++] = vv;\n}\nrr = \"a\".charCodeAt(0);\nfor (vv = 10; vv < 36; ++vv) {\n    Sk.builtin.biginteger.BI_RC[rr++] = vv;\n}\nrr = \"A\".charCodeAt(0);\nfor (vv = 10; vv < 36; ++vv) {\n    Sk.builtin.biginteger.BI_RC[rr++] = vv;\n}\n\nSk.builtin.biginteger.int2char = function (n) {\n    return Sk.builtin.biginteger.BI_RM.charAt(n);\n};\nSk.builtin.biginteger.intAt = function (s, i) {\n    var c = Sk.builtin.biginteger.BI_RC[s.charCodeAt(i)];\n    return (c == null) ? -1 : c;\n};\n\n// (protected) copy this to r\nSk.builtin.biginteger.prototype.bnpCopyTo = function (r) {\n    var i;\n    for (i = this.t - 1; i >= 0; --i) {\n        r[i] = this[i];\n    }\n    r.t = this.t;\n    r.s = this.s;\n};\n\n// (protected) set from integer value x, -DV <= x < DV\nSk.builtin.biginteger.prototype.bnpFromInt = function (x) {\n    this.t = 1;\n    this.s = (x < 0) ? -1 : 0;\n    if (x > 0) {\n        this[0] = x;\n    } else if (x < -1) {\n        this[0] = x + this.DV;\n    } else {\n        this.t = 0;\n    }\n};\n\n// return bigint initialized to value\nSk.builtin.biginteger.nbv = function (i) {\n    var r = new Sk.builtin.biginteger(null);\n    r.bnpFromInt(i);\n    return r;\n};\n\n// (protected) set from string and radix\nSk.builtin.biginteger.prototype.bnpFromString = function (s, b) {\n    var x;\n    var i, mi, sh;\n    var k;\n    if (b == 16) {\n        k = 4;\n    } else if (b == 8) {\n        k = 3;\n    } else if (b == 256) {\n        k = 8;\n    }  else if (b == 2) {\n        // byte array\n        k = 1;\n    } else if (b == 32) {\n        k = 5;\n    } else if (b == 4) {\n        k = 2;\n    } else {\n        this.fromRadix(s, b);\n        return;\n    }\n    this.t = 0;\n    this.s = 0;\n    i = s.length;\n    mi = false;\n    sh = 0;\n    while (--i >= 0) {\n        x = (k == 8) ? s[i] & 0xff : Sk.builtin.biginteger.intAt(s, i);\n        if (x < 0) {\n            if (s.charAt(i) == \"-\") {\n                mi = true;\n            }\n            continue;\n        }\n        mi = false;\n        if (sh === 0) {\n            this[this.t++] = x;\n        } else if (sh + k > this.DB) {\n            this[this.t - 1] |= (x & ((1 << (this.DB - sh)) - 1)) << sh;\n            this[this.t++] = (x >> (this.DB - sh));\n        } else {\n            this[this.t - 1] |= x << sh;\n        }\n        sh += k;\n        if (sh >= this.DB) {\n            sh -= this.DB;\n        }\n    }\n    if (k == 8 && (s[0] & 0x80) !== 0) {\n        this.s = -1;\n        if (sh > 0) {\n            this[this.t - 1] |= ((1 << (this.DB - sh)) - 1) << sh;\n        }\n    }\n    this.clamp();\n    if (mi) {\n        Sk.builtin.biginteger.ZERO.subTo(this, this);\n    }\n};\n\n// (protected) clamp off excess high words\nSk.builtin.biginteger.prototype.bnpClamp = function () {\n    var c = this.s & this.DM;\n    while (this.t > 0 && this[this.t - 1] == c) {\n        --this.t;\n    }\n};\n\n// (public) return string representation in given radix\nSk.builtin.biginteger.prototype.bnToString = function (b) {\n    var p;\n    var km, d, m, r, i;\n    var k;\n    if (this.s < 0) {\n        return \"-\" + this.negate().toString(b);\n    }\n    if (b == 16) {\n        k = 4;\n    } else if (b == 8) {\n        k = 3;\n    } else if (b == 2) {\n        k = 1;\n    } else if (b == 32) {\n        k = 5;\n    } else if (b == 4) {\n        k = 2;\n    } else {\n        return this.toRadix(b);\n    }\n    km = (1 << k) - 1, m = false, r = \"\", i = this.t;\n    p = this.DB - (i * this.DB) % k;\n    if (i-- > 0) {\n        if (p < this.DB && (d = this[i] >> p) > 0) {\n            m = true;\n            r = Sk.builtin.biginteger.int2char(d);\n        }\n        while (i >= 0) {\n            if (p < k) {\n                d = (this[i] & ((1 << p) - 1)) << (k - p);\n                d |= this[--i] >> (p += this.DB - k);\n            } else {\n                d = (this[i] >> (p -= k)) & km;\n                if (p <= 0) {\n                    p += this.DB;\n                    --i;\n                }\n            }\n            if (d > 0) {\n                m = true;\n            }\n            if (m) {\n                r += Sk.builtin.biginteger.int2char(d);\n            }\n        }\n    }\n    return m ? r : \"0\";\n};\n\n// (public) -this\nSk.builtin.biginteger.prototype.bnNegate = function () {\n    var r = Sk.builtin.biginteger.nbi();\n    Sk.builtin.biginteger.ZERO.subTo(this, r);\n    return r;\n};\n\n// (public) |this|\nSk.builtin.biginteger.prototype.bnAbs = function () {\n    return (this.s < 0) ? this.negate() : this;\n};\n\n// (public) return + if this > a, - if this < a, 0 if equal\nSk.builtin.biginteger.prototype.bnCompareTo = function (a) {\n    var i;\n    var r = this.s - a.s;\n    if (r !== 0) {\n        return r;\n    }\n    i = this.t;\n    r = i - a.t;\n    if (r !== 0) {\n        return (this.s < 0) ? -r : r;\n    }\n    while (--i >= 0) {\n        if ((r = this[i] - a[i]) !== 0) {\n            return r;\n        }\n    }\n    return 0;\n};\n\n// returns bit length of the integer x\nSk.builtin.biginteger.nbits = function (x) {\n    var r = 1, t;\n    if ((t = x >>> 16) !== 0) {\n        x = t;\n        r += 16;\n    }\n    if ((t = x >> 8) !== 0) {\n        x = t;\n        r += 8;\n    }\n    if ((t = x >> 4) !== 0) {\n        x = t;\n        r += 4;\n    }\n    if ((t = x >> 2) !== 0) {\n        x = t;\n        r += 2;\n    }\n    if ((t = x >> 1) !== 0) {\n        x = t;\n        r += 1;\n    }\n    return r;\n};\n\n// (public) return the number of bits in \"this\"\nSk.builtin.biginteger.prototype.bnBitLength = function () {\n    if (this.t <= 0) {\n        return 0;\n    }\n    return this.DB * (this.t - 1) + Sk.builtin.biginteger.nbits(this[this.t - 1] ^ (this.s & this.DM));\n};\n\n// (protected) r = this << n*DB\nSk.builtin.biginteger.prototype.bnpDLShiftTo = function (n, r) {\n    var i;\n    for (i = this.t - 1; i >= 0; --i) {\n        r[i + n] = this[i];\n    }\n    for (i = n - 1; i >= 0; --i) {\n        r[i] = 0;\n    }\n    r.t = this.t + n;\n    r.s = this.s;\n};\n\n// (protected) r = this >> n*DB\nSk.builtin.biginteger.prototype.bnpDRShiftTo = function (n, r) {\n    var i;\n    for (i = n; i < this.t; ++i) {\n        r[i - n] = this[i];\n    }\n    r.t = Math.max(this.t - n, 0);\n    r.s = this.s;\n};\n\n// (protected) r = this << n\nSk.builtin.biginteger.prototype.bnpLShiftTo = function (n, r) {\n    var bs = n % this.DB;\n    var cbs = this.DB - bs;\n    var bm = (1 << cbs) - 1;\n    var ds = Math.floor(n / this.DB), c = (this.s << bs) & this.DM, i;\n    for (i = this.t - 1; i >= 0; --i) {\n        r[i + ds + 1] = (this[i] >> cbs) | c;\n        c = (this[i] & bm) << bs;\n    }\n    for (i = ds - 1; i >= 0; --i) {\n        r[i] = 0;\n    }\n    r[ds] = c;\n    r.t = this.t + ds + 1;\n    r.s = this.s;\n    r.clamp();\n};\n\n// (protected) r = this >> n\nSk.builtin.biginteger.prototype.bnpRShiftTo = function (n, r) {\n    var i;\n    var bm;\n    var cbs;\n    var bs;\n    var ds;\n    r.s = this.s;\n    ds = Math.floor(n / this.DB);\n    if (ds >= this.t) {\n        r.t = 0;\n        return;\n    }\n    bs = n % this.DB;\n    cbs = this.DB - bs;\n    bm = (1 << bs) - 1;\n    r[0] = this[ds] >> bs;\n    for (i = ds + 1; i < this.t; ++i) {\n        r[i - ds - 1] |= (this[i] & bm) << cbs;\n        r[i - ds] = this[i] >> bs;\n    }\n    if (bs > 0) {\n        r[this.t - ds - 1] |= (this.s & bm) << cbs;\n    }\n    r.t = this.t - ds;\n    r.clamp();\n};\n\n// (protected) r = this - a\nSk.builtin.biginteger.prototype.bnpSubTo = function (a, r) {\n    var i = 0, c = 0, m = Math.min(a.t, this.t);\n    while (i < m) {\n        c += this[i] - a[i];\n        r[i++] = c & this.DM;\n        c >>= this.DB;\n    }\n    if (a.t < this.t) {\n        c -= a.s;\n        while (i < this.t) {\n            c += this[i];\n            r[i++] = c & this.DM;\n            c >>= this.DB;\n        }\n        c += this.s;\n    } else {\n        c += this.s;\n        while (i < a.t) {\n            c -= a[i];\n            r[i++] = c & this.DM;\n            c >>= this.DB;\n        }\n        c -= a.s;\n    }\n    r.s = (c < 0) ? -1 : 0;\n    if (c < -1) {\n        r[i++] = this.DV + c;\n    } else if (c > 0) {\n        r[i++] = c;\n    }\n    r.t = i;\n    r.clamp();\n};\n\n// (protected) r = this * a, r != this,a (HAC 14.12)\n// \"this\" should be the larger one if appropriate.\nSk.builtin.biginteger.prototype.bnpMultiplyTo = function (a, r) {\n    var x = this.abs(), y = a.abs();\n    var i = x.t;\n    r.t = i + y.t;\n    while (--i >= 0) {\n        r[i] = 0;\n    }\n    for (i = 0; i < y.t; ++i) {\n        r[i + x.t] = x.am(0, y[i], r, i, 0, x.t);\n    }\n    r.s = 0;\n    r.clamp();\n    if (this.s != a.s) {\n        Sk.builtin.biginteger.ZERO.subTo(r, r);\n    }\n};\n\n// (protected) r = this^2, r != this (HAC 14.16)\nSk.builtin.biginteger.prototype.bnpSquareTo = function (r) {\n    var c;\n    var x = this.abs();\n    var i = r.t = 2 * x.t;\n    while (--i >= 0) {\n        r[i] = 0;\n    }\n    for (i = 0; i < x.t - 1; ++i) {\n        c = x.am(i, x[i], r, 2 * i, 0, 1);\n        if ((r[i + x.t] += x.am(i + 1, 2 * x[i], r, 2 * i + 1, c, x.t - i - 1)) >= x.DV) {\n            r[i + x.t] -= x.DV;\n            r[i + x.t + 1] = 1;\n        }\n    }\n    if (r.t > 0) {\n        r[r.t - 1] += x.am(i, x[i], r, 2 * i, 0, 1);\n    }\n    r.s = 0;\n    r.clamp();\n};\n\n// (protected) divide this by m, quotient and remainder to q, r (HAC 14.20)\n// r != q, this != m.  q or r may be null.\nSk.builtin.biginteger.prototype.bnpDivRemTo = function (m, q, r) {\n    var qd;\n    var i, j, t;\n    var d1, d2, e;\n    var yt;\n    var y0;\n    var ys;\n    var nsh;\n    var y, ts, ms;\n    var pt;\n    var pm = m.abs();\n    if (pm.t <= 0) {\n        return;\n    }\n    pt = this.abs();\n    if (pt.t < pm.t) {\n        if (q != null) {\n            q.fromInt(0);\n        }\n        if (r != null) {\n            this.copyTo(r);\n        }\n        return;\n    }\n    if (r == null) {\n        r = Sk.builtin.biginteger.nbi();\n    }\n    y = Sk.builtin.biginteger.nbi();\n    ts = this.s;\n    ms = m.s;\n    nsh = this.DB - Sk.builtin.biginteger.nbits(pm[pm.t - 1]);\t// normalize modulus\n    if (nsh > 0) {\n        pm.lShiftTo(nsh, y);\n        pt.lShiftTo(nsh, r);\n    } else {\n        pm.copyTo(y);\n        pt.copyTo(r);\n    }\n    ys = y.t;\n    y0 = y[ys - 1];\n    if (y0 === 0) {\n        return;\n    }\n    yt = y0 * (1 << this.F1) + ((ys > 1) ? y[ys - 2] >> this.F2 : 0);\n    d1 = this.FV / yt, d2 = (1 << this.F1) / yt;\n    e = 1 << this.F2;\n    i = r.t, j = i - ys;\n    t = (q == null) ? Sk.builtin.biginteger.nbi() : q;\n    y.dlShiftTo(j, t);\n    if (r.compareTo(t) >= 0) {\n        r[r.t++] = 1;\n        r.subTo(t, r);\n    }\n    Sk.builtin.biginteger.ONE.dlShiftTo(ys, t);\n    t.subTo(y, y);\t// \"negative\" y so we can replace sub with am later\n    while (y.t < ys) {\n        y[y.t++] = 0;\n    }\n    while (--j >= 0) {\n        // Estimate quotient digit\n        qd = (r[--i] == y0) ? this.DM : Math.floor(r[i] * d1 + (r[i - 1] + e) * d2);\n        if ((r[i] += y.am(0, qd, r, j, 0, ys)) < qd) {\t// Try it out\n            y.dlShiftTo(j, t);\n            r.subTo(t, r);\n            while (r[i] < --qd) {\n                r.subTo(t, r);\n            }\n        }\n    }\n    if (q != null) {\n        r.drShiftTo(ys, q);\n        if (ts != ms) {\n            Sk.builtin.biginteger.ZERO.subTo(q, q);\n        }\n    }\n    r.t = ys;\n    r.clamp();\n    if (nsh > 0) {\n        r.rShiftTo(nsh, r);\n    }\t// Denormalize remainder\n    if (ts < 0) {\n        Sk.builtin.biginteger.ZERO.subTo(r, r);\n    }\n};\n\n// (public) this mod a\nSk.builtin.biginteger.prototype.bnMod = function (a) {\n    var r = Sk.builtin.biginteger.nbi();\n    this.abs().divRemTo(a, null, r);\n    if (this.s < 0 && r.compareTo(Sk.builtin.biginteger.ZERO) > 0) {\n        a.subTo(r, r);\n    }\n    return r;\n};\n\n// Modular reduction using \"classic\" algorithm\n/**\n * @constructor\n * @extends Sk.builtin.biginteger\n */\nSk.builtin.biginteger.Classic = function (m) {\n    this.m = m;\n};\nSk.builtin.biginteger.prototype.cConvert = function (x) {\n    if (x.s < 0 || x.compareTo(this.m) >= 0) {\n        return x.mod(this.m);\n    } else {\n        return x;\n    }\n};\nSk.builtin.biginteger.prototype.cRevert = function (x) {\n    return x;\n};\nSk.builtin.biginteger.prototype.cReduce = function (x) {\n    x.divRemTo(this.m, null, x);\n};\nSk.builtin.biginteger.prototype.cMulTo = function (x, y, r) {\n    x.multiplyTo(y, r);\n    this.reduce(r);\n};\nSk.builtin.biginteger.prototype.cSqrTo = function (x, r) {\n    x.squareTo(r);\n    this.reduce(r);\n};\n\nSk.builtin.biginteger.Classic.prototype.convert = Sk.builtin.biginteger.prototype.cConvert;\nSk.builtin.biginteger.Classic.prototype.revert = Sk.builtin.biginteger.prototype.cRevert;\nSk.builtin.biginteger.Classic.prototype.reduce = Sk.builtin.biginteger.prototype.cReduce;\nSk.builtin.biginteger.Classic.prototype.mulTo = Sk.builtin.biginteger.prototype.cMulTo;\nSk.builtin.biginteger.Classic.prototype.sqrTo = Sk.builtin.biginteger.prototype.cSqrTo;\n\n// (protected) return \"-1/this % 2^DB\"; useful for Mont. reduction\n// justification:\n//         xy == 1 (mod m)\n//         xy =  1+km\n//   xy(2-xy) = (1+km)(1-km)\n// x[y(2-xy)] = 1-k^2m^2\n// x[y(2-xy)] == 1 (mod m^2)\n// if y is 1/x mod m, then y(2-xy) is 1/x mod m^2\n// should reduce x and y(2-xy) by m^2 at each step to keep size bounded.\n// JS multiply \"overflows\" differently from C/C++, so care is needed here.\nSk.builtin.biginteger.prototype.bnpInvDigit = function () {\n    var y;\n    var x;\n    if (this.t < 1) {\n        return 0;\n    }\n    x = this[0];\n    if ((x & 1) === 0) {\n        return 0;\n    }\n    y = x & 3;\t\t// y == 1/x mod 2^2\n    y = (y * (2 - (x & 0xf) * y)) & 0xf;\t// y == 1/x mod 2^4\n    y = (y * (2 - (x & 0xff) * y)) & 0xff;\t// y == 1/x mod 2^8\n    y = (y * (2 - (((x & 0xffff) * y) & 0xffff))) & 0xffff;\t// y == 1/x mod 2^16\n    // last step - calculate inverse mod DV directly;\n    // assumes 16 < DB <= 32 and assumes ability to handle 48-bit ints\n    y = (y * (2 - x * y % this.DV)) % this.DV;\t\t// y == 1/x mod 2^Sk.builtin.biginteger.dbits\n    // we really want the negative inverse, and -DV < y < DV\n    return (y > 0) ? this.DV - y : -y;\n};\n\n// Sk.builtin.Montgomery reduction\n/**\n * @constructor\n * @extends Sk.builtin.biginteger\n */\nSk.builtin.biginteger.Montgomery = function (m) {\n    this.m = m;\n    this.mp = m.invDigit();\n    this.mpl = this.mp & 0x7fff;\n    this.mph = this.mp >> 15;\n    this.um = (1 << (m.DB - 15)) - 1;\n    this.mt2 = 2 * m.t;\n};\n\n// xR mod m\nSk.builtin.biginteger.prototype.montConvert = function (x) {\n    var r = Sk.builtin.biginteger.nbi();\n    x.abs().dlShiftTo(this.m.t, r);\n    r.divRemTo(this.m, null, r);\n    if (x.s < 0 && r.compareTo(Sk.builtin.biginteger.ZERO) > 0) {\n        this.m.subTo(r, r);\n    }\n    return r;\n};\n\n// x/R mod m\nSk.builtin.biginteger.prototype.montRevert = function (x) {\n    var r = Sk.builtin.biginteger.nbi();\n    x.copyTo(r);\n    this.reduce(r);\n    return r;\n};\n\n// x = x/R mod m (HAC 14.32)\nSk.builtin.biginteger.prototype.montReduce = function (x) {\n    var u0;\n    var j;\n    var i;\n    while (x.t <= this.mt2) {\n        // pad x so am has enough room later\n        x[x.t++] = 0;\n    }\n    for (i = 0; i < this.m.t; ++i) {\n        // faster way of calculating u0 = x[i]*mp mod DV\n        j = x[i] & 0x7fff;\n        u0 = (j * this.mpl + (((j * this.mph + (x[i] >> 15) * this.mpl) & this.um) << 15)) & x.DM;\n        // use am to combine the multiply-shift-add into one call\n        j = i + this.m.t;\n        x[j] += this.m.am(0, u0, x, i, 0, this.m.t);\n        // propagate carry\n        while (x[j] >= x.DV) {\n            x[j] -= x.DV;\n            x[++j]++;\n        }\n    }\n    x.clamp();\n    x.drShiftTo(this.m.t, x);\n    if (x.compareTo(this.m) >= 0) {\n        x.subTo(this.m, x);\n    }\n};\n\n// r = \"x^2/R mod m\"; x != r\nSk.builtin.biginteger.prototype.montSqrTo = function (x, r) {\n    x.squareTo(r);\n    this.reduce(r);\n};\n\n// r = \"xy/R mod m\"; x,y != r\nSk.builtin.biginteger.prototype.montMulTo = function (x, y, r) {\n    x.multiplyTo(y, r);\n    this.reduce(r);\n};\n\nSk.builtin.biginteger.Montgomery.prototype.convert = Sk.builtin.biginteger.prototype.montConvert;\nSk.builtin.biginteger.Montgomery.prototype.revert = Sk.builtin.biginteger.prototype.montRevert;\nSk.builtin.biginteger.Montgomery.prototype.reduce = Sk.builtin.biginteger.prototype.montReduce;\nSk.builtin.biginteger.Montgomery.prototype.mulTo = Sk.builtin.biginteger.prototype.montMulTo;\nSk.builtin.biginteger.Montgomery.prototype.sqrTo = Sk.builtin.biginteger.prototype.montSqrTo;\n\n// (protected) true iff this is even\nSk.builtin.biginteger.prototype.bnpIsEven = function () {\n    return ((this.t > 0) ? (this[0] & 1) : this.s) === 0;\n};\n\n// (protected) this^e, e < 2^32, doing sqr and mul with \"r\" (HAC 14.79)\nSk.builtin.biginteger.prototype.bnpExp = function (e, z) {\n    var t;\n    var r, r2, g, i;\n    if (e > 0xffffffff || e < 1) {\n        return Sk.builtin.biginteger.ONE;\n    }\n    r = Sk.builtin.biginteger.nbi();\n    r2 = Sk.builtin.biginteger.nbi();\n    g = z.convert(this);\n    i = Sk.builtin.biginteger.nbits(e) - 1;\n    g.copyTo(r);\n    while (--i >= 0) {\n        z.sqrTo(r, r2);\n        if ((e & (1 << i)) > 0) {\n            z.mulTo(r2, g, r);\n        } else {\n            t = r;\n            r = r2;\n            r2 = t;\n        }\n    }\n    return z.revert(r);\n};\n\n// (public) this^e % m, 0 <= e < 2^32\nSk.builtin.biginteger.prototype.bnModPowInt = function (e, m) {\n    var z;\n    if (e < 256 || m.isEven()) {\n        z = new Sk.builtin.biginteger.Classic(m);\n    } else {\n        z = new Sk.builtin.biginteger.Montgomery(m);\n    }\n    return this.exp(e, z);\n};\n\n// protected\nSk.builtin.biginteger.prototype.copyTo = Sk.builtin.biginteger.prototype.bnpCopyTo;\nSk.builtin.biginteger.prototype.fromInt = Sk.builtin.biginteger.prototype.bnpFromInt;\nSk.builtin.biginteger.prototype.fromString = Sk.builtin.biginteger.prototype.bnpFromString;\nSk.builtin.biginteger.prototype.clamp = Sk.builtin.biginteger.prototype.bnpClamp;\nSk.builtin.biginteger.prototype.dlShiftTo = Sk.builtin.biginteger.prototype.bnpDLShiftTo;\nSk.builtin.biginteger.prototype.drShiftTo = Sk.builtin.biginteger.prototype.bnpDRShiftTo;\nSk.builtin.biginteger.prototype.lShiftTo = Sk.builtin.biginteger.prototype.bnpLShiftTo;\nSk.builtin.biginteger.prototype.rShiftTo = Sk.builtin.biginteger.prototype.bnpRShiftTo;\nSk.builtin.biginteger.prototype.subTo = Sk.builtin.biginteger.prototype.bnpSubTo;\nSk.builtin.biginteger.prototype.multiplyTo = Sk.builtin.biginteger.prototype.bnpMultiplyTo;\nSk.builtin.biginteger.prototype.squareTo = Sk.builtin.biginteger.prototype.bnpSquareTo;\nSk.builtin.biginteger.prototype.divRemTo = Sk.builtin.biginteger.prototype.bnpDivRemTo;\nSk.builtin.biginteger.prototype.invDigit = Sk.builtin.biginteger.prototype.bnpInvDigit;\nSk.builtin.biginteger.prototype.isEven = Sk.builtin.biginteger.prototype.bnpIsEven;\nSk.builtin.biginteger.prototype.exp = Sk.builtin.biginteger.prototype.bnpExp;\n\n// public\nSk.builtin.biginteger.prototype.toString = Sk.builtin.biginteger.prototype.bnToString;\nSk.builtin.biginteger.prototype.negate = Sk.builtin.biginteger.prototype.bnNegate;\nSk.builtin.biginteger.prototype.abs = Sk.builtin.biginteger.prototype.bnAbs;\nSk.builtin.biginteger.prototype.compareTo = Sk.builtin.biginteger.prototype.bnCompareTo;\nSk.builtin.biginteger.prototype.bitLength = Sk.builtin.biginteger.prototype.bnBitLength;\nSk.builtin.biginteger.prototype.mod = Sk.builtin.biginteger.prototype.bnMod;\nSk.builtin.biginteger.prototype.modPowInt = Sk.builtin.biginteger.prototype.bnModPowInt;\n\n// \"constants\"\nSk.builtin.biginteger.ZERO = Sk.builtin.biginteger.nbv(0);\nSk.builtin.biginteger.ONE = Sk.builtin.biginteger.nbv(1);\n\n//Copyright (c) 2005-2009  Tom Wu\n//All Rights Reserved.\n//See \"LICENSE\" for details.\n\n//Extended JavaScript BN functions, required for RSA private ops.\n\n//Version 1.1: new Sk.builtin.biginteger(\"0\", 10) returns \"proper\" zero\n\n//(public)\nSk.builtin.biginteger.prototype.bnClone = function () {\n    var r = Sk.builtin.biginteger.nbi();\n    this.copyTo(r);\n    return r;\n};\n\n//(public) return value as integer\nSk.builtin.biginteger.prototype.bnIntValue = function () {\n    if (this.s < 0) {\n        if (this.t == 1) {\n            return this[0] - this.DV;\n        } else if (this.t === 0) {\n            return -1;\n        }\n    } else if (this.t == 1) {\n        return this[0];\n    } else if (this.t === 0) {\n        return 0;\n    }\n    return ((this[1] & ((1 << (32 - this.DB)) - 1)) << this.DB) | this[0];\n};\n\n//(public) return value as byte\nSk.builtin.biginteger.prototype.bnByteValue = function () {\n    return (this.t === 0) ? this.s : (this[0] << 24) >> 24;\n};\n\n//(public) return value as short (assumes DB>=16)\nSk.builtin.biginteger.prototype.bnShortValue = function () {\n    return (this.t === 0) ? this.s : (this[0] << 16) >> 16;\n};\n\n//(protected) return x s.t. r^x < DV\nSk.builtin.biginteger.prototype.bnpChunkSize = function (r) {\n    return Math.floor(Math.LN2 * this.DB / Math.log(r));\n};\n\n//(public) 0 if this == 0, 1 if this > 0\nSk.builtin.biginteger.prototype.bnSigNum = function () {\n    if (this.s < 0) {\n        return -1;\n    } else if (this.t <= 0 || (this.t == 1 && this[0] <= 0)) {\n        return 0;\n    } else {\n        return 1;\n    }\n};\n\n//(protected) convert to radix string\nSk.builtin.biginteger.prototype.bnpToRadix = function (b) {\n    var d, y, z, r;\n    var a;\n    var cs;\n    if (b == null) {\n        b = 10;\n    }\n    if (this.signum() === 0 || b < 2 || b > 36) {\n        return \"0\";\n    }\n    cs = this.chunkSize(b);\n    a = Math.pow(b, cs);\n    d = Sk.builtin.biginteger.nbv(a);\n    y = Sk.builtin.biginteger.nbi(); z = Sk.builtin.biginteger.nbi();\n    r = \"\";\n    this.divRemTo(d, y, z);\n    while (y.signum() > 0) {\n        r = (a + z.intValue()).toString(b).substr(1) + r;\n        y.divRemTo(d, y, z);\n    }\n    return z.intValue().toString(b) + r;\n};\n\n//(protected) convert from radix string\nSk.builtin.biginteger.prototype.bnpFromRadix = function (s, b) {\n    var x;\n    var i;\n    var d, mi, j, w;\n    var cs;\n    this.fromInt(0);\n    if (b == null) {\n        b = 10;\n    }\n    cs = this.chunkSize(b);\n    d = Math.pow(b, cs);\n    mi = false;\n    j = 0;\n    w = 0;\n    for (i = 0; i < s.length; ++i) {\n        x = Sk.builtin.biginteger.intAt(s, i);\n        if (x < 0) {\n            if (s.charAt(i) == \"-\" && this.signum() === 0) {\n                mi = true;\n            }\n            if (s.charAt(i) == \".\") {\n                break;\n            }\n            continue;\n        }\n        w = b * w + x;\n        if (++j >= cs) {\n            this.dMultiply(d);\n            this.dAddOffset(w, 0);\n            j = 0;\n            w = 0;\n        }\n    }\n    if (j > 0) {\n        this.dMultiply(Math.pow(b, j));\n        this.dAddOffset(w, 0);\n    }\n    if (mi) {\n        Sk.builtin.biginteger.ZERO.subTo(this, this);\n    }\n};\n\n//(protected) alternate constructor\nSk.builtin.biginteger.prototype.bnpFromNumber = function (a, b, c) {\n    if (\"number\" == typeof b) {\n        // new Sk.builtin.biginteger(int,int,RNG)\n        if (a < 2) {\n            this.fromInt(1);\n        } else {\n            this.fromNumber(a, c);\n            if (!this.testBit(a - 1))\t{\n                // force MSB set\n                this.bitwiseTo(Sk.builtin.biginteger.ONE.shiftLeft(a - 1), Sk.builtin.biginteger.op_or, this);\n            }\n            if (this.isEven()) {\n                this.dAddOffset(1, 0);\n            } // force odd\n            while (!this.isProbablePrime(b)) {\n                this.dAddOffset(2, 0);\n                if (this.bitLength() > a) {\n                    this.subTo(Sk.builtin.biginteger.ONE.shiftLeft(a - 1), this);\n                }\n            }\n        }\n    }\n    //\tConstructor to support Java BigInteger random generation.  Forget it.\n    this.fromString(a + \"\");\n};\n\n//(public) convert to bigendian byte array\nSk.builtin.biginteger.prototype.bnToByteArray = function () {\n    var p, d, k;\n    var i = this.t, r = [];\n    r[0] = this.s;\n    p = this.DB - (i * this.DB) % 8;\n    k = 0;\n    if (i-- > 0) {\n        if (p < this.DB && (d = this[i] >> p) != (this.s & this.DM) >> p) {\n            r[k++] = d | (this.s << (this.DB - p));\n        }\n        while (i >= 0) {\n            if (p < 8) {\n                d = (this[i] & ((1 << p) - 1)) << (8 - p);\n                d |= this[--i] >> (p += this.DB - 8);\n            } else {\n                d = (this[i] >> (p -= 8)) & 0xff;\n                if (p <= 0) {\n                    p += this.DB;\n                    --i;\n                }\n            }\n            if ((d & 0x80) !== 0) {\n                d |= -256;\n            }\n            if (k === 0 && (this.s & 0x80) != (d & 0x80)) {\n                ++k;\n            }\n            if (k > 0 || d != this.s) {\n                r[k++] = d;\n            }\n        }\n    }\n    return r;\n};\n\nSk.builtin.biginteger.prototype.bnEquals = function (a) {\n    return(this.compareTo(a) === 0);\n};\nSk.builtin.biginteger.prototype.bnMin = function (a) {\n    return(this.compareTo(a) < 0) ? this : a;\n};\nSk.builtin.biginteger.prototype.bnMax = function (a) {\n    return(this.compareTo(a) > 0) ? this : a;\n};\n\n//(protected) r = this op a (bitwise)\nSk.builtin.biginteger.prototype.bnpBitwiseTo = function (a, op, r) {\n    var i, f, m = Math.min(a.t, this.t);\n    for (i = 0; i < m; ++i) {\n        r[i] = op(this[i], a[i]);\n    }\n    if (a.t < this.t) {\n        f = a.s & this.DM;\n        for (i = m; i < this.t; ++i) {\n            r[i] = op(this[i], f);\n        }\n        r.t = this.t;\n    } else {\n        f = this.s & this.DM;\n        for (i = m; i < a.t; ++i) {\n            r[i] = op(f, a[i]);\n        }\n        r.t = a.t;\n    }\n    r.s = op(this.s, a.s);\n    r.clamp();\n};\n\n//(public) this & a\nSk.builtin.biginteger.op_and = function (x, y) {\n    return x & y;\n};\nSk.builtin.biginteger.prototype.bnAnd = function (a) {\n    var r = Sk.builtin.biginteger.nbi();\n    this.bitwiseTo(a, Sk.builtin.biginteger.op_and, r);\n    return r;\n};\n\n//(public) this | a\nSk.builtin.biginteger.op_or = function (x, y) {\n    return x | y;\n};\nSk.builtin.biginteger.prototype.bnOr = function (a) {\n    var r = Sk.builtin.biginteger.nbi();\n    this.bitwiseTo(a, Sk.builtin.biginteger.op_or, r);\n    return r;\n};\n\n//(public) this ^ a\nSk.builtin.biginteger.op_xor = function (x, y) {\n    return x ^ y;\n};\nSk.builtin.biginteger.prototype.bnXor = function (a) {\n    var r = Sk.builtin.biginteger.nbi();\n    this.bitwiseTo(a, Sk.builtin.biginteger.op_xor, r);\n    return r;\n};\n\n//(public) this & ~a\nSk.builtin.biginteger.op_andnot = function (x, y) {\n    return x & ~y;\n};\nSk.builtin.biginteger.prototype.bnAndNot = function (a) {\n    var r = Sk.builtin.biginteger.nbi();\n    this.bitwiseTo(a, Sk.builtin.biginteger.op_andnot, r);\n    return r;\n};\n\n//(public) ~this\nSk.builtin.biginteger.prototype.bnNot = function () {\n    var i;\n    var r = Sk.builtin.biginteger.nbi();\n    for (i = 0; i < this.t; ++i) {\n        r[i] = this.DM & ~this[i];\n    }\n    r.t = this.t;\n    r.s = ~this.s;\n    return r;\n};\n\n//(public) this << n\nSk.builtin.biginteger.prototype.bnShiftLeft = function (n) {\n    var r = Sk.builtin.biginteger.nbi();\n    if (n < 0) {\n        this.rShiftTo(-n, r);\n    } else {\n        this.lShiftTo(n, r);\n    }\n    return r;\n};\n\n//(public) this >> n\nSk.builtin.biginteger.prototype.bnShiftRight = function (n) {\n    var r = Sk.builtin.biginteger.nbi();\n    if (n < 0) {\n        this.lShiftTo(-n, r);\n    } else {\n        this.rShiftTo(n, r);\n    }\n    return r;\n};\n\n//return index of lowest 1-bit in x, x < 2^31\nSk.builtin.biginteger.lbit = function (x) {\n    var r;\n    if (x === 0) {\n        return -1;\n    }\n    r = 0;\n    if ((x & 0xffff) === 0) {\n        x >>= 16;\n        r += 16;\n    }\n    if ((x & 0xff) === 0) {\n        x >>= 8;\n        r += 8;\n    }\n    if ((x & 0xf) === 0) {\n        x >>= 4;\n        r += 4;\n    }\n    if ((x & 3) === 0) {\n        x >>= 2;\n        r += 2;\n    }\n    if ((x & 1) === 0) {\n        ++r;\n    }\n    return r;\n};\n\n//(public) returns index of lowest 1-bit (or -1 if none)\nSk.builtin.biginteger.prototype.bnGetLowestSetBit = function () {\n    var i;\n    for (i = 0; i < this.t; ++i) {\n        if (this[i] !== 0) {\n            return i * this.DB + Sk.builtin.biginteger.lbit(this[i]);\n        }\n    }\n    if (this.s < 0) {\n        return this.t * this.DB;\n    }\n    return -1;\n};\n\n//return number of 1 bits in x\nSk.builtin.biginteger.cbit = function (x) {\n    var r = 0;\n    while (x !== 0) {\n        x &= x - 1;\n        ++r;\n    }\n    return r;\n};\n\n//(public) return number of set bits\nSk.builtin.biginteger.prototype.bnBitCount = function () {\n    var i;\n    var r = 0, x = this.s & this.DM;\n    for (i = 0; i < this.t; ++i) {\n        r += Sk.builtin.biginteger.cbit(this[i] ^ x);\n    }\n    return r;\n};\n\n//(public) true iff nth bit is set\nSk.builtin.biginteger.prototype.bnTestBit = function (n) {\n    var j = Math.floor(n / this.DB);\n    if (j >= this.t) {\n        return(this.s !== 0);\n    }\n    return((this[j] & (1 << (n % this.DB))) !== 0);\n};\n\n//(protected) this op (1<<n)\nSk.builtin.biginteger.prototype.bnpChangeBit = function (n, op) {\n    var r = Sk.builtin.biginteger.ONE.shiftLeft(n);\n    this.bitwiseTo(r, op, r);\n    return r;\n};\n\n//(public) this | (1<<n)\nSk.builtin.biginteger.prototype.bnSetBit = function (n) {\n    return this.changeBit(n, Sk.builtin.biginteger.op_or);\n};\n\n//(public) this & ~(1<<n)\nSk.builtin.biginteger.prototype.bnClearBit = function (n) {\n    return this.changeBit(n, Sk.builtin.biginteger.op_andnot);\n};\n\n//(public) this ^ (1<<n)\nSk.builtin.biginteger.prototype.bnFlipBit = function (n) {\n    return this.changeBit(n, Sk.builtin.biginteger.op_xor);\n};\n\n//(protected) r = this + a\nSk.builtin.biginteger.prototype.bnpAddTo = function (a, r) {\n    var i = 0, c = 0, m = Math.min(a.t, this.t);\n    while (i < m) {\n        c += this[i] + a[i];\n        r[i++] = c & this.DM;\n        c >>= this.DB;\n    }\n    if (a.t < this.t) {\n        c += a.s;\n        while (i < this.t) {\n            c += this[i];\n            r[i++] = c & this.DM;\n            c >>= this.DB;\n        }\n        c += this.s;\n    } else {\n        c += this.s;\n        while (i < a.t) {\n            c += a[i];\n            r[i++] = c & this.DM;\n            c >>= this.DB;\n        }\n        c += a.s;\n    }\n    r.s = (c < 0) ? -1 : 0;\n    if (c > 0) {\n        r[i++] = c;\n    } else if (c < -1) {\n        r[i++] = this.DV + c;\n    }\n    r.t = i;\n    r.clamp();\n};\n\n//(public) this + a\nSk.builtin.biginteger.prototype.bnAdd = function (a) {\n    var r = Sk.builtin.biginteger.nbi();\n    this.addTo(a, r);\n    return r;\n};\n\n//(public) this - a\nSk.builtin.biginteger.prototype.bnSubtract = function (a) {\n    var r = Sk.builtin.biginteger.nbi();\n    this.subTo(a, r);\n    return r;\n};\n\n//(public) this * a\nSk.builtin.biginteger.prototype.bnMultiply = function (a) {\n    var r = Sk.builtin.biginteger.nbi();\n    this.multiplyTo(a, r);\n    return r;\n};\n\n//(public) this / a\nSk.builtin.biginteger.prototype.bnDivide = function (a) {\n    var r = Sk.builtin.biginteger.nbi();\n    this.divRemTo(a, r, null);\n    return r;\n};\n\n//(public) this % a\nSk.builtin.biginteger.prototype.bnRemainder = function (a) {\n    var r = Sk.builtin.biginteger.nbi();\n    this.divRemTo(a, null, r);\n    return r;\n};\n\n//(public) [this/a,this%a]\nSk.builtin.biginteger.prototype.bnDivideAndRemainder = function (a) {\n    var q = Sk.builtin.biginteger.nbi(), r = Sk.builtin.biginteger.nbi();\n    this.divRemTo(a, q, r);\n    return new Array(q, r);\n};\n\n//(protected) this *= n, this >= 0, 1 < n < DV\nSk.builtin.biginteger.prototype.bnpDMultiply = function (n) {\n    this[this.t] = this.am(0, n - 1, this, 0, 0, this.t);\n    ++this.t;\n    this.clamp();\n};\n\n//(protected) this += n << w words, this >= 0\nSk.builtin.biginteger.prototype.bnpDAddOffset = function (n, w) {\n    if (n === 0) {\n        return;\n    }\n    while (this.t <= w) {\n        this[this.t++] = 0;\n    }\n    this[w] += n;\n    while (this[w] >= this.DV) {\n        this[w] -= this.DV;\n        if (++w >= this.t) {\n            this[this.t++] = 0;\n        }\n        ++this[w];\n    }\n};\n\n//A \"null\" reducer\n/**\n * @constructor\n * @extends Sk.builtin.biginteger\n */\nSk.builtin.biginteger.NullExp = function () {\n};\nSk.builtin.biginteger.prototype.nNop = function (x) {\n    return x;\n};\nSk.builtin.biginteger.prototype.nMulTo = function (x, y, r) {\n    x.multiplyTo(y, r);\n};\nSk.builtin.biginteger.prototype.nSqrTo = function (x, r) {\n    x.squareTo(r);\n};\n\nSk.builtin.biginteger.NullExp.prototype.convert = Sk.builtin.biginteger.prototype.nNop;\nSk.builtin.biginteger.NullExp.prototype.revert = Sk.builtin.biginteger.prototype.nNop;\nSk.builtin.biginteger.NullExp.prototype.mulTo = Sk.builtin.biginteger.prototype.nMulTo;\nSk.builtin.biginteger.NullExp.prototype.sqrTo = Sk.builtin.biginteger.prototype.nSqrTo;\n\n//(public) this^e\nSk.builtin.biginteger.prototype.bnPow = function (e) {\n    return this.exp(e, new Sk.builtin.biginteger.NullExp());\n};\n\n//(protected) r = lower n words of \"this * a\", a.t <= n\n//\"this\" should be the larger one if appropriate.\nSk.builtin.biginteger.prototype.bnpMultiplyLowerTo = function (a, n, r) {\n    var j;\n    var i = Math.min(this.t + a.t, n);\n    r.s = 0; // assumes a,this >= 0\n    r.t = i;\n    while (i > 0) {\n        r[--i] = 0;\n    }\n    for (j = r.t - this.t; i < j; ++i) {\n        r[i + this.t] = this.am(0, a[i], r, i, 0, this.t);\n    }\n    for (j = Math.min(a.t, n); i < j; ++i) {\n        this.am(0, a[i], r, i, 0, n - i);\n    }\n    r.clamp();\n};\n\n//(protected) r = \"this * a\" without lower n words, n > 0\n//\"this\" should be the larger one if appropriate.\nSk.builtin.biginteger.prototype.bnpMultiplyUpperTo = function (a, n, r) {\n    var i;\n    --n;\n    i = r.t = this.t + a.t - n;\n    r.s = 0; // assumes a,this >= 0\n    while (--i >= 0) {\n        r[i] = 0;\n    }\n    for (i = Math.max(n - this.t, 0); i < a.t; ++i) {\n        r[this.t + i - n] = this.am(n - i, a[i], r, 0, 0, this.t + i - n);\n    }\n    r.clamp();\n    r.drShiftTo(1, r);\n};\n\n//Barrett modular reduction\n/**\n * @constructor\n * @extends Sk.builtin.biginteger\n */\nSk.builtin.biginteger.Barrett = function (m) {\n    this.r2 = Sk.builtin.biginteger.nbi();\n    this.q3 = Sk.builtin.biginteger.nbi();\n    Sk.builtin.biginteger.ONE.dlShiftTo(2 * m.t, this.r2);\n    this.mu = this.r2.divide(m);\n    this.m = m;\n};\n\nSk.builtin.biginteger.prototype.barrettConvert = function (x) {\n    var r;\n    if (x.s < 0 || x.t > 2 * this.m.t) {\n        return x.mod(this.m);\n    } else if (x.compareTo(this.m) < 0) {\n        return x;\n    } else {\n        r = Sk.builtin.biginteger.nbi();\n        x.copyTo(r);\n        this.reduce(r);\n        return r;\n    }\n};\n\nSk.builtin.biginteger.prototype.barrettRevert = function (x) {\n    return x;\n};\n\n//x = x mod m (HAC 14.42)\nSk.builtin.biginteger.prototype.barrettReduce = function (x) {\n    x.drShiftTo(this.m.t - 1, this.r2);\n    if (x.t > this.m.t + 1) {\n        x.t = this.m.t + 1;\n        x.clamp();\n    }\n    this.mu.multiplyUpperTo(this.r2, this.m.t + 1, this.q3);\n    this.m.multiplyLowerTo(this.q3, this.m.t + 1, this.r2);\n    while (x.compareTo(this.r2) < 0) {\n        x.dAddOffset(1, this.m.t + 1);\n    }\n    x.subTo(this.r2, x);\n    while (x.compareTo(this.m) >= 0) {\n        x.subTo(this.m, x);\n    }\n};\n\n//r = x^2 mod m; x != r\nSk.builtin.biginteger.prototype.barrettSqrTo = function (x, r) {\n    x.squareTo(r);\n    this.reduce(r);\n};\n\n//r = x*y mod m; x,y != r\nSk.builtin.biginteger.prototype.barrettMulTo = function (x, y, r) {\n    x.multiplyTo(y, r);\n    this.reduce(r);\n};\n\nSk.builtin.biginteger.Barrett.prototype.convert = Sk.builtin.biginteger.prototype.barrettConvert;\nSk.builtin.biginteger.Barrett.prototype.revert = Sk.builtin.biginteger.prototype.barrettRevert;\nSk.builtin.biginteger.Barrett.prototype.reduce = Sk.builtin.biginteger.prototype.barrettReduce;\nSk.builtin.biginteger.Barrett.prototype.mulTo = Sk.builtin.biginteger.prototype.barrettMulTo;\nSk.builtin.biginteger.Barrett.prototype.sqrTo = Sk.builtin.biginteger.prototype.barrettSqrTo;\n\n//(public) this^e % m (HAC 14.85)\nSk.builtin.biginteger.prototype.bnModPow = function (e, m) {\n    var j, w, is1, r2, t;\n    var g2;\n    var g, n, k1, km;\n    var i = e.bitLength(), k, r = Sk.builtin.biginteger.nbv(1), z;\n    if (i <= 0) {\n        return r;\n    } else if (i < 18) {\n        k = 1;\n    } else if (i < 48) {\n        k = 3;\n    } else if (i < 144) {\n        k = 4;\n    } else if (i < 768) {\n        k = 5;\n    } else {\n        k = 6;\n    }\n    if (i < 8) {\n        z = new Sk.builtin.biginteger.Classic(m);\n    } else if (m.isEven()) {\n        z = new Sk.builtin.biginteger.Barrett(m);\n    } else {\n        z = new Sk.builtin.biginteger.Montgomery(m);\n    }\n\n    g = [];\n    n = 3;\n    k1 = k - 1;\n    km = (1 << k) - 1;\n    g[1] = z.convert(this);\n    if (k > 1) {\n        g2 = Sk.builtin.biginteger.nbi();\n        z.sqrTo(g[1], g2);\n        while (n <= km) {\n            g[n] = Sk.builtin.biginteger.nbi();\n            z.mulTo(g2, g[n - 2], g[n]);\n            n += 2;\n        }\n    }\n\n    j = e.t - 1;\n    is1 = true;\n    r2 = Sk.builtin.biginteger.nbi();\n    i = Sk.builtin.biginteger.nbits(e[j]) - 1;\n    while (j >= 0) {\n        if (i >= k1) {\n            w = (e[j] >> (i - k1)) & km;\n        } else {\n            w = (e[j] & ((1 << (i + 1)) - 1)) << (k1 - i);\n            if (j > 0) {\n                w |= e[j - 1] >> (this.DB + i - k1);\n            }\n        }\n\n        n = k;\n        while ((w & 1) === 0) {\n            w >>= 1;\n            --n;\n        }\n        if ((i -= n) < 0) {\n            i += this.DB;\n            --j;\n        }\n        if (is1) {\t// ret == 1, don't bother squaring or multiplying it\n            g[w].copyTo(r);\n            is1 = false;\n        } else {\n            while (n > 1) {\n                z.sqrTo(r, r2);\n                z.sqrTo(r2, r);\n                n -= 2;\n            }\n            if (n > 0) {\n                z.sqrTo(r, r2);\n            } else {\n                t = r;\n                r = r2;\n                r2 = t;\n            }\n            z.mulTo(r2, g[w], r);\n        }\n\n        while (j >= 0 && (e[j] & (1 << i)) === 0) {\n            z.sqrTo(r, r2);\n            t = r;\n            r = r2;\n            r2 = t;\n            if (--i < 0) {\n                i = this.DB - 1;\n                --j;\n            }\n        }\n    }\n    return z.revert(r);\n};\n\n//(public) gcd(this,a) (HAC 14.54)\nSk.builtin.biginteger.prototype.bnGCD = function (a) {\n    var i, g;\n    var t;\n    var x = (this.s < 0) ? this.negate() : this.clone();\n    var y = (a.s < 0) ? a.negate() : a.clone();\n    if (x.compareTo(y) < 0) {\n        t = x;\n        x = y;\n        y = t;\n    }\n    i = x.getLowestSetBit();\n    g = y.getLowestSetBit();\n    if (g < 0) {\n        return x;\n    }\n    if (i < g) {\n        g = i;\n    }\n    if (g > 0) {\n        x.rShiftTo(g, x);\n        y.rShiftTo(g, y);\n    }\n    while (x.signum() > 0) {\n        if ((i = x.getLowestSetBit()) > 0) {\n            x.rShiftTo(i, x);\n        }\n        if ((i = y.getLowestSetBit()) > 0) {\n            y.rShiftTo(i, y);\n        }\n        if (x.compareTo(y) >= 0) {\n            x.subTo(y, x);\n            x.rShiftTo(1, x);\n        } else {\n            y.subTo(x, y);\n            y.rShiftTo(1, y);\n        }\n    }\n    if (g > 0) {\n        y.lShiftTo(g, y);\n    }\n    return y;\n};\n\n//(protected) this % n, n < 2^26\nSk.builtin.biginteger.prototype.bnpModInt = function (n) {\n    var i;\n    var d, r;\n    if (n <= 0) {\n        return 0;\n    }\n    d = this.DV % n;\n    r = (this.s < 0) ? n - 1 : 0;\n    if (this.t > 0) {\n        if (d === 0) {\n            r = this[0] % n;\n        } else {\n            for (i = this.t - 1; i >= 0; --i) {\n                r = (d * r + this[i]) % n;\n            }\n        }\n    }\n    return r;\n};\n\n//(public) 1/this % m (HAC 14.61)\nSk.builtin.biginteger.prototype.bnModInverse = function (m) {\n    var a, b, c, d;\n    var u, v;\n    var ac = m.isEven();\n    if ((this.isEven() && ac) || m.signum() === 0) {\n        return Sk.builtin.biginteger.ZERO;\n    }\n    u = m.clone();\n    v = this.clone();\n    a = Sk.builtin.biginteger.nbv(1);\n    b = Sk.builtin.biginteger.nbv(0);\n    c = Sk.builtin.biginteger.nbv(0);\n    d = Sk.builtin.biginteger.nbv(1);\n    while (u.signum() !== 0) {\n        while (u.isEven()) {\n            u.rShiftTo(1, u);\n            if (ac) {\n                if (!a.isEven() || !b.isEven()) {\n                    a.addTo(this, a);\n                    b.subTo(m, b);\n                }\n                a.rShiftTo(1, a);\n            } else if (!b.isEven()) {\n                b.subTo(m, b);\n            }\n            b.rShiftTo(1, b);\n        }\n        while (v.isEven()) {\n            v.rShiftTo(1, v);\n            if (ac) {\n                if (!c.isEven() || !d.isEven()) {\n                    c.addTo(this, c);\n                    d.subTo(m, d);\n                }\n                c.rShiftTo(1, c);\n            } else if (!d.isEven()) {\n                d.subTo(m, d);\n            }\n            d.rShiftTo(1, d);\n        }\n        if (u.compareTo(v) >= 0) {\n            u.subTo(v, u);\n            if (ac) {\n                a.subTo(c, a);\n            }\n            b.subTo(d, b);\n        } else {\n            v.subTo(u, v);\n            if (ac) {\n                c.subTo(a, c);\n            }\n            d.subTo(b, d);\n        }\n    }\n    if (v.compareTo(Sk.builtin.biginteger.ONE) !== 0) {\n        return Sk.builtin.biginteger.ZERO;\n    }\n    if (d.compareTo(m) >= 0) {\n        return d.subtract(m);\n    }\n    if (d.signum() < 0) {\n        d.addTo(m, d);\n    } else {\n        return d;\n    }\n    if (d.signum() < 0) {\n        return d.add(m);\n    } else {\n        return d;\n    }\n};\n\nSk.builtin.biginteger.lowprimes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509];\nSk.builtin.biginteger.lplim = (1 << 26) / Sk.builtin.biginteger.lowprimes[Sk.builtin.biginteger.lowprimes.length - 1];\n\n//(public) test primality with certainty >= 1-.5^t\nSk.builtin.biginteger.prototype.bnIsProbablePrime = function (t) {\n    var m, j;\n    var i, x = this.abs();\n    if (x.t == 1 && x[0] <= Sk.builtin.biginteger.lowprimes[Sk.builtin.biginteger.lowprimes.length - 1]) {\n        for (i = 0; i < Sk.builtin.biginteger.lowprimes.length; ++i) {\n            if (x[0] == Sk.builtin.biginteger.lowprimes[i]) {\n                return true;\n            }\n        }\n        return false;\n    }\n    if (x.isEven()) {\n        return false;\n    }\n    i = 1;\n    while (i < Sk.builtin.biginteger.lowprimes.length) {\n        m = Sk.builtin.biginteger.lowprimes[i];\n        j = i + 1;\n        while (j < Sk.builtin.biginteger.lowprimes.length && m < Sk.builtin.biginteger.lplim) {\n            m *= Sk.builtin.biginteger.lowprimes[j++];\n        }\n        m = x.modInt(m);\n        while (i < j) {\n            if (m % Sk.builtin.biginteger.lowprimes[i++] === 0) {\n                return false;\n            }\n        }\n    }\n    return x.millerRabin(t);\n};\n\n//(protected) true if probably prime (HAC 4.24, Miller-Rabin)\nSk.builtin.biginteger.prototype.bnpMillerRabin = function (t) {\n    var j;\n    var y;\n    var i;\n    var a;\n    var r;\n    var n1 = this.subtract(Sk.builtin.biginteger.ONE);\n    var k = n1.getLowestSetBit();\n    if (k <= 0) {\n        return false;\n    }\n    r = n1.shiftRight(k);\n    t = (t + 1) >> 1;\n    if (t > Sk.builtin.biginteger.lowprimes.length) {\n        t = Sk.builtin.biginteger.lowprimes.length;\n    }\n    a = Sk.builtin.biginteger.nbi();\n    for (i = 0; i < t; ++i) {\n        a.fromInt(Sk.builtin.biginteger.lowprimes[i]);\n        y = a.modPow(r, this);\n        if (y.compareTo(Sk.builtin.biginteger.ONE) !== 0 && y.compareTo(n1) !== 0) {\n            j = 1;\n            while (j++ < k && y.compareTo(n1) !== 0) {\n                y = y.modPowInt(2, this);\n                if (y.compareTo(Sk.builtin.biginteger.ONE) === 0) {\n                    return false;\n                }\n            }\n            if (y.compareTo(n1) !== 0) {\n                return false;\n            }\n        }\n    }\n    return true;\n};\n\nSk.builtin.biginteger.prototype.isnegative = function () {\n    return this.s < 0;\n};\nSk.builtin.biginteger.prototype.ispositive = function () {\n    return this.s >= 0;\n};\nSk.builtin.biginteger.prototype.trueCompare = function (a) {\n    if (this.s >= 0 && a.s < 0) {\n        return 1;\n    }\n    if (this.s < 0 && a.s >= 0) {\n        return -1;\n    }\n    return this.compare(a);\n};\n\n//protected\nSk.builtin.biginteger.prototype.chunkSize = Sk.builtin.biginteger.prototype.bnpChunkSize;\nSk.builtin.biginteger.prototype.toRadix = Sk.builtin.biginteger.prototype.bnpToRadix;\nSk.builtin.biginteger.prototype.fromRadix = Sk.builtin.biginteger.prototype.bnpFromRadix;\nSk.builtin.biginteger.prototype.fromNumber = Sk.builtin.biginteger.prototype.bnpFromNumber;\nSk.builtin.biginteger.prototype.bitwiseTo = Sk.builtin.biginteger.prototype.bnpBitwiseTo;\nSk.builtin.biginteger.prototype.changeBit = Sk.builtin.biginteger.prototype.bnpChangeBit;\nSk.builtin.biginteger.prototype.addTo = Sk.builtin.biginteger.prototype.bnpAddTo;\nSk.builtin.biginteger.prototype.dMultiply = Sk.builtin.biginteger.prototype.bnpDMultiply;\nSk.builtin.biginteger.prototype.dAddOffset = Sk.builtin.biginteger.prototype.bnpDAddOffset;\nSk.builtin.biginteger.prototype.multiplyLowerTo = Sk.builtin.biginteger.prototype.bnpMultiplyLowerTo;\nSk.builtin.biginteger.prototype.multiplyUpperTo = Sk.builtin.biginteger.prototype.bnpMultiplyUpperTo;\nSk.builtin.biginteger.prototype.modInt = Sk.builtin.biginteger.prototype.bnpModInt;\nSk.builtin.biginteger.prototype.millerRabin = Sk.builtin.biginteger.prototype.bnpMillerRabin;\n\n//public\nSk.builtin.biginteger.prototype.clone = Sk.builtin.biginteger.prototype.bnClone;\nSk.builtin.biginteger.prototype.intValue = Sk.builtin.biginteger.prototype.bnIntValue;\nSk.builtin.biginteger.prototype.byteValue = Sk.builtin.biginteger.prototype.bnByteValue;\nSk.builtin.biginteger.prototype.shortValue = Sk.builtin.biginteger.prototype.bnShortValue;\nSk.builtin.biginteger.prototype.signum = Sk.builtin.biginteger.prototype.bnSigNum;\nSk.builtin.biginteger.prototype.toByteArray = Sk.builtin.biginteger.prototype.bnToByteArray;\nSk.builtin.biginteger.prototype.equals = Sk.builtin.biginteger.prototype.bnEquals;\nSk.builtin.biginteger.prototype.compare = Sk.builtin.biginteger.prototype.compareTo;\nSk.builtin.biginteger.prototype.min = Sk.builtin.biginteger.prototype.bnMin;\nSk.builtin.biginteger.prototype.max = Sk.builtin.biginteger.prototype.bnMax;\nSk.builtin.biginteger.prototype.and = Sk.builtin.biginteger.prototype.bnAnd;\nSk.builtin.biginteger.prototype.or = Sk.builtin.biginteger.prototype.bnOr;\nSk.builtin.biginteger.prototype.xor = Sk.builtin.biginteger.prototype.bnXor;\nSk.builtin.biginteger.prototype.andNot = Sk.builtin.biginteger.prototype.bnAndNot;\nSk.builtin.biginteger.prototype.not = Sk.builtin.biginteger.prototype.bnNot;\nSk.builtin.biginteger.prototype.shiftLeft = Sk.builtin.biginteger.prototype.bnShiftLeft;\nSk.builtin.biginteger.prototype.shiftRight = Sk.builtin.biginteger.prototype.bnShiftRight;\nSk.builtin.biginteger.prototype.getLowestSetBit = Sk.builtin.biginteger.prototype.bnGetLowestSetBit;\nSk.builtin.biginteger.prototype.bitCount = Sk.builtin.biginteger.prototype.bnBitCount;\nSk.builtin.biginteger.prototype.testBit = Sk.builtin.biginteger.prototype.bnTestBit;\nSk.builtin.biginteger.prototype.setBit = Sk.builtin.biginteger.prototype.bnSetBit;\nSk.builtin.biginteger.prototype.clearBit = Sk.builtin.biginteger.prototype.bnClearBit;\nSk.builtin.biginteger.prototype.flipBit = Sk.builtin.biginteger.prototype.bnFlipBit;\nSk.builtin.biginteger.prototype.add = Sk.builtin.biginteger.prototype.bnAdd;\nSk.builtin.biginteger.prototype.subtract = Sk.builtin.biginteger.prototype.bnSubtract;\nSk.builtin.biginteger.prototype.multiply = Sk.builtin.biginteger.prototype.bnMultiply;\nSk.builtin.biginteger.prototype.divide = Sk.builtin.biginteger.prototype.bnDivide;\nSk.builtin.biginteger.prototype.remainder = Sk.builtin.biginteger.prototype.bnRemainder;\nSk.builtin.biginteger.prototype.divideAndRemainder = Sk.builtin.biginteger.prototype.bnDivideAndRemainder;\nSk.builtin.biginteger.prototype.modPow = Sk.builtin.biginteger.prototype.bnModPow;\nSk.builtin.biginteger.prototype.modInverse = Sk.builtin.biginteger.prototype.bnModInverse;\nSk.builtin.biginteger.prototype.pow = Sk.builtin.biginteger.prototype.bnPow;\nSk.builtin.biginteger.prototype.gcd = Sk.builtin.biginteger.prototype.bnGCD;\nSk.builtin.biginteger.prototype.isProbablePrime = Sk.builtin.biginteger.prototype.bnIsProbablePrime;\n//Sk.builtin.biginteger.int2char = int2char;\n\n//Sk.builtin.biginteger interfaces not implemented in jsbn:\n\n//Sk.builtin.biginteger(int signum, byte[] magnitude)\n//double doubleValue()\n//float floatValue()\n//int hashCode()\n//long longValue()\n//static Sk.builtin.biginteger valueOf(long val)\n\n//module.exports = Sk.builtin.biginteger;\n\n\n/***/ }),\n/* 26 */\n/***/ (function(module, exports) {\n\n/* jslint nomen: true, bitwise: true */\n/* global Sk: true */\n\n/**\n * @namespace Sk.builtin\n */\n\n/**\n * @constructor\n * Sk.builtin.int_\n *\n * @description\n * Constructor for Python int. If provided number is greater than integer threshold, will return a Python long instead.\n *\n * type int, all integers are created with this method, it is also used\n * for the builtin int()\n *\n * Takes also implemented `__int__` and `__trunc__` methods for x into account\n * and tries to use `__index__` and/or `__int__` if base is not a number\n *\n * @extends {Sk.builtin.numtype}\n *\n * @param  {!(Object|number)} x    Python object or Javascript number to convert to Python int\n * @param  {!(Object|number|Sk.builtin.none)=} base Optional base, can only be used when x is Sk.builtin.str\n * @return {(Sk.builtin.int_|Sk.builtin.lng)}      Python int (or long, if overflow)\n */\nSk.builtin.int_ = function (x, base) {\n    var val;\n    var func;\n    var ret; // return value\n    var magicName; // name of magic method\n\n    if (!(this instanceof Sk.builtin.int_)) {\n        return new Sk.builtin.int_(x, base);\n    }\n\n\n    if (this instanceof Sk.builtin.bool) {\n        return this;\n    }\n\n    if (x instanceof Sk.builtin.int_ && base === undefined) {\n        this.v = x.v;\n        return this;\n    }\n\n    // if base is not of type int, try calling .__index__\n    if(base !== Sk.builtin.none.none$ && base !== undefined && !Sk.builtin.checkInt(base)) {\n        if (Sk.builtin.checkFloat(base)) {\n            throw new Sk.builtin.TypeError(\"integer argument expected, got \" + Sk.abstr.typeName(base));\n        } else if (base.__index__) {\n            base = Sk.misceval.callsimArray(base.__index__, [base]);\n        } else if(base.__int__) {\n            base = Sk.misceval.callsimArray(base.__int__, [base]);\n        } else {\n            throw new Sk.builtin.AttributeError(Sk.abstr.typeName(base) + \" instance has no attribute '__index__' or '__int__'\");\n        }\n    }\n\n    if (x instanceof Sk.builtin.str) {\n        base = Sk.builtin.asnum$(base);\n        if (base === Sk.builtin.none.none$) {\n            base = 10;\n        }\n\n        val = Sk.str2number(x.v, base, parseInt, function (x) {\n            return -x;\n        }, \"int\");\n\n        if ((val > Sk.builtin.int_.threshold$) || (val < -Sk.builtin.int_.threshold$)) {\n            // Too big for int, convert to long\n            return new Sk.builtin.lng(x, base);\n        }\n\n        this.v = val;\n        return this;\n    }\n\n    if (base !== undefined && base !== Sk.builtin.none.none$) {\n        throw new Sk.builtin.TypeError(\"int() can't convert non-string with explicit base\");\n    }\n\n    if (x === undefined || x === Sk.builtin.none) {\n        x = 0;\n    }\n\n    /**\n     * try calling special methods:\n     *  1. __int__\n     *  2. __trunc__\n     */\n    if(x !== undefined && (x.tp$getattr && (func = x.tp$getattr(Sk.builtin.str.$int_)))) {\n        // calling a method which contains im_self and im_func\n        // causes skulpt to automatically map the im_self as first argument\n        ret = Sk.misceval.callsimArray(func);\n        magicName = \"__int__\";\n    } else if(x !== undefined && x.__int__) {\n        // required for internal types\n        // __int__ method is on prototype\n        ret = Sk.misceval.callsimArray(x.__int__, [x]);\n        magicName = \"__int__\";\n    } else if(x !== undefined && (x.tp$getattr && (func = x.tp$getattr(Sk.builtin.str.$trunc)))) {\n        ret = Sk.misceval.callsimArray(func);\n        magicName = \"__trunc__\";\n    } else if(x !== undefined && x.__trunc__) {\n        ret = Sk.misceval.callsimArray(x.__trunc__, [x]);\n        magicName = \"__trunc__\";\n    }\n\n    // check return type of magic methods\n    if(ret !== undefined && !Sk.builtin.checkInt(ret)) {\n        throw new Sk.builtin.TypeError(magicName + \" returned non-Integral (type \" + Sk.abstr.typeName(ret)+\")\");\n    } else if(ret !== undefined){\n        x = ret; // valid return value, proceed in function\n    }\n\n    // check type even without magic numbers\n    if(!Sk.builtin.checkNumber(x)) {\n        throw new Sk.builtin.TypeError(\"int() argument must be a string or a number, not '\" + Sk.abstr.typeName(x) + \"'\");\n    }\n\n    x = Sk.builtin.asnum$(x);\n    if (x > Sk.builtin.int_.threshold$ || x < -Sk.builtin.int_.threshold$) {\n        return new Sk.builtin.lng(x);\n    }\n    if ((x > -1) && (x < 1)) {\n        x = 0;\n    }\n\n    this.v = parseInt(x, base);\n    return this;\n};\n\nSk.builtin.int_.$shiftconsts = [0.5, 1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096, 8192, 16384, 32768, 65536, 131072, 262144, 524288, 1048576, 2097152, 4194304, 8388608, 16777216, 33554432, 67108864, 134217728, 268435456, 536870912, 1073741824, 2147483648, 4294967296, 8589934592, 17179869184, 34359738368, 68719476736, 137438953472, 274877906944, 549755813888, 1099511627776, 2199023255552, 4398046511104, 8796093022208, 17592186044416, 35184372088832, 70368744177664, 140737488355328, 281474976710656, 562949953421312, 1125899906842624, 2251799813685248, 4503599627370496, 9007199254740992];\n\nSk.abstr.setUpInheritance(\"int\", Sk.builtin.int_, Sk.builtin.numtype);\n\n/* NOTE: See constants used for kwargs in constants.js */\n\nSk.builtin.int_.prototype.nb$int_ = function () {\n    return this;\n};\n\nSk.builtin.int_.prototype.nb$float_ = function() {\n    return new Sk.builtin.float_(this.v);\n};\n\nSk.builtin.int_.prototype.nb$lng = function () {\n    return new Sk.builtin.lng(this.v);\n};\n\n/**\n * Python wrapper of `__trunc__` dunder method.\n *\n * @instance\n */\nSk.builtin.int_.prototype.__trunc__ = new Sk.builtin.func(function(self) {\n    return self;\n});\n\n/**\n * Python wrapper of `__index__` dunder method.\n *\n * @instance\n */\nSk.builtin.int_.prototype.__index__ = new Sk.builtin.func(function(self) {\n    return self;\n});\n\n/**\n * Python wrapper of `__complex__` dunder method.\n *\n * @instance\n */\nSk.builtin.int_.prototype.__complex__ = new Sk.builtin.func(function(self) {\n    return Sk.builtin.NotImplemented.NotImplemented$;\n});\n\n/**\n * Return this instance's Javascript value.\n *\n * Javascript function, returns Javascript object.\n *\n * @return {number} This instance's value.\n */\nSk.builtin.int_.prototype.tp$index = function () {\n    return this.v;\n};\n\n/** @override */\nSk.builtin.int_.prototype.tp$hash = function () {\n    //the hash of all numbers should be an int and since javascript doesn't really\n    //care every number can be an int.\n    return new Sk.builtin.int_(this.v);\n};\n\n/**\n * Threshold to determine when types should be converted to long.\n *\n * Note: be sure to check against threshold in both positive and negative directions.\n *\n * @type {number}\n */\nSk.builtin.int_.threshold$ = Math.pow(2, 53) - 1;\n\n/**\n * Returns a copy of this instance.\n *\n * Javascript function, returns Python object.\n *\n * @return {Sk.builtin.int_} The copy\n */\nSk.builtin.int_.prototype.clone = function () {\n    return new Sk.builtin.int_(this.v);\n};\n\n/** @override */\nSk.builtin.int_.prototype.nb$add = function (other) {\n    var thisAsLong, thisAsFloat;\n    var result;\n\n    if (other instanceof Sk.builtin.int_) {\n        result = this.v + other.v;\n        if (result > Sk.builtin.int_.threshold$ ||\n            result < -Sk.builtin.int_.threshold$) {\n            thisAsLong = new Sk.builtin.lng(this.v);\n            return thisAsLong.nb$add(other);\n        }\n        return new Sk.builtin.int_(result);\n    }\n\n    if (other instanceof Sk.builtin.lng) {\n        thisAsLong = new Sk.builtin.lng(this.v);\n        return thisAsLong.nb$add(other);\n    }\n\n    if (other instanceof Sk.builtin.float_) {\n        thisAsFloat = new Sk.builtin.float_(this.v);\n        return thisAsFloat.nb$add(other);\n    }\n\n    return Sk.builtin.NotImplemented.NotImplemented$;\n};\n\n/** @override */\nSk.builtin.int_.prototype.nb$reflected_add = function (other) {\n    // Should not automatically call this.nb$add, as nb$add may have\n    // been overridden by a subclass\n    return Sk.builtin.int_.prototype.nb$add.call(this, other);\n};\n\n/** @override */\nSk.builtin.int_.prototype.nb$subtract = function (other) {\n    var thisAsLong, thisAsFloat;\n    var result;\n\n    if (other instanceof Sk.builtin.int_) {\n        result = this.v - other.v;\n        if (result > Sk.builtin.int_.threshold$ ||\n            result < -Sk.builtin.int_.threshold$) {\n            thisAsLong = new Sk.builtin.lng(this.v);\n            return thisAsLong.nb$subtract(other);\n        }\n        return new Sk.builtin.int_(result);\n    }\n\n    if (other instanceof Sk.builtin.lng) {\n        thisAsLong = new Sk.builtin.lng(this.v);\n        return thisAsLong.nb$subtract(other);\n    }\n\n    if (other instanceof Sk.builtin.float_) {\n        thisAsFloat = new Sk.builtin.float_(this.v);\n        return thisAsFloat.nb$subtract(other);\n    }\n\n    return Sk.builtin.NotImplemented.NotImplemented$;\n};\n\n/** @override */\nSk.builtin.int_.prototype.nb$reflected_subtract = function (other) {\n    // Should not automatically call this.nb$add, as nb$add may have\n    // been overridden by a subclass\n    var negative_this = this.nb$negative();\n    return Sk.builtin.int_.prototype.nb$add.call(negative_this, other);\n};\n\n/** @override */\nSk.builtin.int_.prototype.nb$multiply = function (other) {\n    var product, thisAsLong, thisAsFloat;\n\n    if (other instanceof Sk.builtin.int_) {\n        product = this.v * other.v;\n\n        if (product > Sk.builtin.int_.threshold$ ||\n            product < -Sk.builtin.int_.threshold$) {\n            thisAsLong = new Sk.builtin.lng(this.v);\n            return thisAsLong.nb$multiply(other);\n        } else {\n            return new Sk.builtin.int_(product);\n        }\n    }\n\n    if (other instanceof Sk.builtin.lng) {\n        thisAsLong = new Sk.builtin.lng(this.v);\n        return thisAsLong.nb$multiply(other);\n    }\n\n    if (other instanceof Sk.builtin.float_) {\n        thisAsFloat = new Sk.builtin.float_(this.v);\n        return thisAsFloat.nb$multiply(other);\n    }\n\n    return Sk.builtin.NotImplemented.NotImplemented$;\n};\n\n/** @override */\nSk.builtin.int_.prototype.nb$reflected_multiply = function (other) {\n    // Should not automatically call this.nb$multiply, as nb$multiply may have\n    // been overridden by a subclass\n    return Sk.builtin.int_.prototype.nb$multiply.call(this, other);\n};\n\n/** @override */\nSk.builtin.int_.prototype.nb$divide = function (other) {\n    var thisAsLong, thisAsFloat;\n    if (Sk.__future__.division) {\n        thisAsFloat = new Sk.builtin.float_(this.v);\n        return thisAsFloat.nb$divide(other);\n    }\n\n    if (other instanceof Sk.builtin.int_) {\n        return this.nb$floor_divide(other);\n    }\n\n    if (other instanceof Sk.builtin.lng) {\n        thisAsLong = new Sk.builtin.lng(this.v);\n        return thisAsLong.nb$divide(other);\n    }\n\n    if (other instanceof Sk.builtin.float_) {\n        thisAsFloat = new Sk.builtin.float_(this.v);\n        return thisAsFloat.nb$divide(other);\n    }\n\n    return Sk.builtin.NotImplemented.NotImplemented$;\n};\n\n/** @override */\nSk.builtin.int_.prototype.nb$reflected_divide = function (other) {\n    return this.nb$reflected_floor_divide(other);\n};\n\n/** @override */\nSk.builtin.int_.prototype.nb$floor_divide = function (other) {\n    var thisAsLong, thisAsFloat;\n\n    if (other instanceof Sk.builtin.int_) {\n\n        if (other.v === 0) {\n            throw new Sk.builtin.ZeroDivisionError(\"integer division or modulo by zero\");\n        }\n\n        return new Sk.builtin.int_(Math.floor(this.v / other.v));\n    }\n\n    if (other instanceof Sk.builtin.lng) {\n        thisAsLong = new Sk.builtin.lng(this.v);\n        return thisAsLong.nb$floor_divide(other);\n    }\n\n    if (other instanceof Sk.builtin.float_) {\n        thisAsFloat = new Sk.builtin.float_(this.v);\n        return thisAsFloat.nb$floor_divide(other);\n    }\n\n    return Sk.builtin.NotImplemented.NotImplemented$;\n};\n\n/** @override */\nSk.builtin.int_.prototype.nb$reflected_floor_divide = function (other) {\n    if (other instanceof Sk.builtin.int_) {\n        return other.nb$divide(this);\n    }\n\n    return Sk.builtin.NotImplemented.NotImplemented$;\n};\n\n/** @override */\nSk.builtin.int_.prototype.nb$remainder = function (other) {\n    var thisAsLong, thisAsFloat;\n    var tmp;\n    var divResult;\n\n    if (other instanceof Sk.builtin.int_) {\n        //  Javacript logic on negatives doesn't work for Python... do this instead\n        divResult = Sk.abstr.numberBinOp(this, other, \"FloorDiv\");\n        tmp = Sk.abstr.numberBinOp(divResult, other, \"Mult\");\n        tmp = Sk.abstr.numberBinOp(this, tmp, \"Sub\");\n        tmp = tmp.v;\n\n        if (other.v < 0 && tmp === 0) {\n            tmp = -0.0; // otherwise the sign gets lost by javascript modulo\n        } else if (tmp === 0 && Infinity/tmp === -Infinity) {\n            tmp = 0.0;\n        }\n\n        return new Sk.builtin.int_(tmp);\n    }\n\n    if (other instanceof Sk.builtin.lng) {\n        thisAsLong = new Sk.builtin.lng(this.v);\n        return thisAsLong.nb$remainder(other);\n    }\n\n    if (other instanceof Sk.builtin.float_) {\n        thisAsFloat = new Sk.builtin.float_(this.v);\n        return thisAsFloat.nb$remainder(other);\n    }\n\n    return Sk.builtin.NotImplemented.NotImplemented$;\n};\n\n/** @override */\nSk.builtin.int_.prototype.nb$reflected_remainder = function (other) {\n    if (other instanceof Sk.builtin.int_) {\n        return other.nb$remainder(this);\n    }\n\n    return Sk.builtin.NotImplemented.NotImplemented$;\n};\n\n/** @override */\nSk.builtin.int_.prototype.nb$divmod = function (other) {\n    var thisAsLong, thisAsFloat;\n\n    if (other instanceof Sk.builtin.int_) {\n        return new Sk.builtin.tuple([\n            this.nb$floor_divide(other),\n            this.nb$remainder(other)\n        ]);\n    }\n\n    if (other instanceof Sk.builtin.lng) {\n        thisAsLong = new Sk.builtin.lng(this.v);\n        return thisAsLong.nb$divmod(other);\n    }\n\n    if (other instanceof Sk.builtin.float_) {\n        thisAsFloat = new Sk.builtin.float_(this.v);\n        return thisAsFloat.nb$divmod(other);\n    }\n\n    return Sk.builtin.NotImplemented.NotImplemented$;\n};\n\n/** @override */\nSk.builtin.int_.prototype.nb$reflected_divmod = function (other) {\n    if (other instanceof Sk.builtin.int_) {\n        return new Sk.builtin.tuple([\n            other.nb$floor_divide(this),\n            other.nb$remainder(this)\n        ]);\n    }\n\n    return Sk.builtin.NotImplemented.NotImplemented$;\n};\n\n/** @override */\nSk.builtin.int_.prototype.nb$power = function (other, mod) {\n    var power, ret, thisAsLong, thisAsFloat;\n\n    if (other instanceof Sk.builtin.int_ && (mod === undefined || mod instanceof Sk.builtin.int_)) {\n\n        power = Math.pow(this.v, other.v);\n\n        if (power > Sk.builtin.int_.threshold$ ||\n            power < -Sk.builtin.int_.threshold$) {\n            thisAsLong = new Sk.builtin.lng(this.v);\n            ret = thisAsLong.nb$power(other, mod);\n        } else if (other.v < 0) {\n            ret = new Sk.builtin.float_(power);\n        } else {\n            ret = new Sk.builtin.int_(power);\n        }\n\n        if (mod !== undefined) {\n            if (other.v < 0) {\n                throw new Sk.builtin.TypeError(\"pow() 2nd argument cannot be negative when 3rd argument specified\");\n            }\n\n            return ret.nb$remainder(mod);\n        } else {\n            return ret;\n        }\n    }\n\n    if (other instanceof Sk.builtin.lng) {\n        thisAsLong = new Sk.builtin.lng(this.v);\n        return thisAsLong.nb$power(other);\n    }\n\n    if (other instanceof Sk.builtin.float_) {\n        thisAsFloat = new Sk.builtin.float_(this.v);\n        return thisAsFloat.nb$power(other);\n    }\n\n    return Sk.builtin.NotImplemented.NotImplemented$;\n};\n\n/** @override */\nSk.builtin.int_.prototype.nb$reflected_power = function (other, mod) {\n    if (other instanceof Sk.builtin.int_) {\n        return other.nb$power(this, mod);\n    }\n\n    return Sk.builtin.NotImplemented.NotImplemented$;\n};\n\n/** @override */\nSk.builtin.int_.prototype.nb$abs = function () {\n    return new Sk.builtin.int_(Math.abs(this.v));\n};\n\n/**\n * Compute the bitwise AND of this instance and a Python object (i.e. this & other).\n *\n * Returns NotImplemented if bitwise AND operation between int and other type is unsupported.\n *\n * Javscript function, returns Python object.\n *\n * @param  {!Sk.builtin.object} other The Python object to AND with this one\n * @return {(Sk.builtin.int_|Sk.builtin.lng|Sk.builtin.NotImplemented)} The result of the conjunction\n */\nSk.builtin.int_.prototype.nb$and = function (other) {\n    var thisAsLong, thisAsFloat;\n\n    if (other instanceof Sk.builtin.int_) {\n        var tmp;\n        other = Sk.builtin.asnum$(other);\n        tmp = this.v & other;\n        if ((tmp !== undefined) && (tmp < 0)) {\n            tmp = tmp + 4294967296; // convert back to unsigned\n        }\n\n        if (tmp !== undefined) {\n            return new Sk.builtin.int_(tmp);\n        }\n    }\n\n    if (other instanceof Sk.builtin.lng) {\n        thisAsLong = new Sk.builtin.lng(this.v);\n        return thisAsLong.nb$and(other);\n    }\n\n    return Sk.builtin.NotImplemented.NotImplemented$;\n};\n\nSk.builtin.int_.prototype.nb$reflected_and = Sk.builtin.int_.prototype.nb$and;\n\n/**\n * Compute the bitwise OR of this instance and a Python object (i.e. this | other).\n *\n * Returns NotImplemented if bitwise OR operation between int and other type is unsupported.\n *\n * Javscript function, returns Python object.\n *\n * @param  {!Sk.builtin.object} other The Python object to OR with this one\n * @return {(Sk.builtin.int_|Sk.builtin.lng|Sk.builtin.NotImplemented)} The result of the disjunction\n */\nSk.builtin.int_.prototype.nb$or = function (other) {\n    var thisAsLong;\n\n    if (other instanceof Sk.builtin.int_) {\n        var tmp;\n        other = Sk.builtin.asnum$(other);\n        tmp = this.v | other;\n        if ((tmp !== undefined) && (tmp < 0)) {\n            tmp = tmp + 4294967296; // convert back to unsigned\n        }\n\n        if (tmp !== undefined) {\n            return new Sk.builtin.int_(tmp);\n        }\n    }\n\n    if (other instanceof Sk.builtin.lng) {\n        thisAsLong = new Sk.builtin.lng(this.v);\n        return thisAsLong.nb$and(other);\n    }\n\n    return Sk.builtin.NotImplemented.NotImplemented$;\n};\n\nSk.builtin.int_.prototype.nb$reflected_or = Sk.builtin.int_.prototype.nb$or;\n\n/**\n * Compute the bitwise XOR of this instance and a Python object (i.e. this ^ other).\n *\n * Returns NotImplemented if bitwise XOR operation between int and other type is unsupported.\n *\n * Javscript function, returns Python object.\n *\n * @param  {!Sk.builtin.object} other The Python object to XOR with this one\n * @return {(Sk.builtin.int_|Sk.builtin.lng|Sk.builtin.NotImplemented)} The result of the exclusive disjunction\n */\nSk.builtin.int_.prototype.nb$xor = function (other) {\n    var thisAsLong;\n\n    if (other instanceof Sk.builtin.int_) {\n        var tmp;\n        other = Sk.builtin.asnum$(other);\n        tmp = this.v ^ other;\n        if ((tmp !== undefined) && (tmp < 0)) {\n            tmp = tmp + 4294967296; // convert back to unsigned\n        }\n\n        if (tmp !== undefined) {\n            return new Sk.builtin.int_(tmp);\n        }\n    }\n\n    if (other instanceof Sk.builtin.lng) {\n        thisAsLong = new Sk.builtin.lng(this.v);\n        return thisAsLong.nb$xor(other);\n    }\n\n    return Sk.builtin.NotImplemented.NotImplemented$;\n};\n\nSk.builtin.int_.prototype.nb$reflected_xor = Sk.builtin.int_.prototype.nb$xor;\n\n/**\n * Compute the bitwise left shift of this instance by a Python object (i.e. this << other).\n *\n * Returns NotImplemented if bitwise left shift operation between int and other type is unsupported.\n *\n * Javscript function, returns Python object.\n *\n * @param  {!Sk.builtin.object} other The Python object by which to left shift\n * @return {(Sk.builtin.int_|Sk.builtin.lng|Sk.builtin.NotImplemented)} The result of the left shift\n */\nSk.builtin.int_.prototype.nb$lshift = function (other) {\n    var thisAsLong;\n\n    if (this.v === 0) {\n        return this;\n    }\n\n    if (other instanceof Sk.builtin.int_) {\n        var tmp;\n        var shift = Sk.builtin.asnum$(other);\n\n        if (shift !== undefined) {\n            if (shift < 0) {\n                throw new Sk.builtin.ValueError(\"negative shift count\");\n            }\n\n            if (shift > 53) {\n                return new Sk.builtin.lng(this.v).nb$lshift(new Sk.builtin.int_(shift));\n            }\n\n            tmp = this.v * 2 * Sk.builtin.int_.$shiftconsts[shift];\n            if (tmp > Sk.builtin.int_.threshold$ || tmp < -Sk.builtin.int_.threshold$) {\n                // Fail, recompute with longs\n                return new Sk.builtin.lng(tmp);\n            }\n        }\n\n        if (tmp !== undefined) {\n            tmp = /** @type {number} */ (tmp);\n            return new Sk.builtin.int_(tmp);\n        }\n    }\n\n    if (other instanceof Sk.builtin.lng) {\n        thisAsLong = new Sk.builtin.lng(this.v);\n        return thisAsLong.nb$lshift(other);\n    }\n\n    return Sk.builtin.NotImplemented.NotImplemented$;\n};\n\nSk.builtin.int_.prototype.nb$reflected_lshift = function (other) {\n    if (other instanceof Sk.builtin.int_) {\n        return other.nb$lshift(this);\n    }\n\n    return Sk.builtin.NotImplemented.NotImplemented$;\n};\n\n/**\n * Compute the bitwise right shift of this instance by a Python object (i.e. this >> other).\n *\n * Returns NotImplemented if bitwise right shift operation between int and other type is unsupported.\n *\n * Javscript function, returns Python object.\n *\n * @param  {!Sk.builtin.object} other The Python object by which to right shift\n * @return {(Sk.builtin.int_|Sk.builtin.lng|Sk.builtin.NotImplemented)} The result of the right shift\n */\nSk.builtin.int_.prototype.nb$rshift = function (other) {\n    var thisAsLong;\n\n    if (other instanceof Sk.builtin.int_) {\n        var tmp;\n        var shift = Sk.builtin.asnum$(other);\n\n        if (shift !== undefined) {\n            if (shift < 0) {\n                throw new Sk.builtin.ValueError(\"negative shift count\");\n            }\n            tmp = this.v >> shift;\n            if ((this.v > 0) && (tmp < 0)) {\n                // Fix incorrect sign extension\n                tmp = tmp & (Math.pow(2, 32 - shift) - 1);\n            }\n        }\n\n        if (tmp !== undefined) {\n            tmp = /** @type {number} */ (tmp);\n            return new Sk.builtin.int_(tmp);\n        }\n    }\n\n    if (other instanceof Sk.builtin.lng) {\n        thisAsLong = new Sk.builtin.lng(this.v);\n        return thisAsLong.nb$rshift(other);\n    }\n\n    return Sk.builtin.NotImplemented.NotImplemented$;\n};\n\nSk.builtin.int_.prototype.nb$reflected_rshift = function (other) {\n    if (other instanceof Sk.builtin.int_) {\n        return other.nb$rshift(this);\n    }\n\n    return Sk.builtin.NotImplemented.NotImplemented$;\n};\n\n/**\n * Compute the bitwise inverse of this instance (i.e. ~this).\n *\n * Javscript function, returns Python object.\n *\n * @return {Sk.builtin.int_} The result of the inversion\n */\nSk.builtin.int_.prototype.nb$invert = function () {\n    return new Sk.builtin.int_(~this.v);\n};\n\n/** @override */\nSk.builtin.int_.prototype.nb$inplace_add = Sk.builtin.int_.prototype.nb$add;\n\n/** @override */\nSk.builtin.int_.prototype.nb$inplace_subtract = Sk.builtin.int_.prototype.nb$subtract;\n\n/** @override */\nSk.builtin.int_.prototype.nb$inplace_multiply = Sk.builtin.int_.prototype.nb$multiply;\n\n/** @override */\nSk.builtin.int_.prototype.nb$inplace_divide = Sk.builtin.int_.prototype.nb$divide;\n\n/** @override */\nSk.builtin.int_.prototype.nb$inplace_remainder = Sk.builtin.int_.prototype.nb$remainder;\n\n/** @override */\nSk.builtin.int_.prototype.nb$inplace_floor_divide = Sk.builtin.int_.prototype.nb$floor_divide;\n\n/** @override */\nSk.builtin.int_.prototype.nb$inplace_power = Sk.builtin.int_.prototype.nb$power;\n\n/**\n * @function\n * @name  nb$inplace_and\n * @memberOf Sk.builtin.int_.prototype\n * @description\n * Compute the bitwise AND of this instance and a Python object (i.e. this &= other).\n *\n * Returns NotImplemented if inplace bitwise AND operation between int and other type is unsupported.\n *\n * Javscript function, returns Python object.\n *\n * @param  {!Sk.builtin.object} other The Python object to AND with this one\n * @return {(Sk.builtin.int_|Sk.builtin.lng|Sk.builtin.NotImplemented)} The result of the conjunction\n */\nSk.builtin.int_.prototype.nb$inplace_and = Sk.builtin.int_.prototype.nb$and;\n\n/**\n * @function\n * @name  nb$inplace_or\n * @memberOf Sk.builtin.int_.prototype\n * @description\n * Compute the bitwise OR of this instance and a Python object (i.e. this |= other).\n *\n * Returns NotImplemented if inplace bitwise OR operation between int and other type is unsupported.\n *\n * Javscript function, returns Python object.\n *\n * @param  {!Sk.builtin.object} other The Python object to OR with this one\n * @return {(Sk.builtin.int_|Sk.builtin.lng|Sk.builtin.NotImplemented)} The result of the disjunction\n */\nSk.builtin.int_.prototype.nb$inplace_or = Sk.builtin.int_.prototype.nb$or;\n\n/**\n * @function\n * @name  nb$inplace_xor\n * @memberOf Sk.builtin.int_.prototype\n * @description\n * Compute the bitwise XOR of this instance and a Python object (i.e. this ^= other).\n *\n * Returns NotImplemented if inplace bitwise XOR operation between int and other type is unsupported.\n *\n * Javscript function, returns Python object.\n *\n * @param  {!Sk.builtin.object} other The Python object to XOR with this one\n * @return {(Sk.builtin.int_|Sk.builtin.lng|Sk.builtin.NotImplemented)} The result of the exclusive disjunction\n */\nSk.builtin.int_.prototype.nb$inplace_xor = Sk.builtin.int_.prototype.nb$xor;\n\n/**\n * @function\n * @name  nb$inplace_lshift\n * @memberOf Sk.builtin.int_.prototype\n * @description\n * Compute the bitwise left shift of this instance by a Python object (i.e. this <<= other).\n *\n * Returns NotImplemented if inplace bitwise left shift operation between int and other type is unsupported.\n *\n * Javscript function, returns Python object.\n *\n * @param  {!Sk.builtin.object} other The Python object by which to left shift\n * @return {(Sk.builtin.int_|Sk.builtin.lng|Sk.builtin.NotImplemented)} The result of the left shift\n */\nSk.builtin.int_.prototype.nb$inplace_lshift = Sk.builtin.int_.prototype.nb$lshift;\n\n/**\n * @function\n * @name  nb$inplace_rshift\n * @memberOf Sk.builtin.int_.prototype\n * @description\n * Compute the bitwise right shift of this instance by a Python object (i.e. this >>= other).\n *\n * Returns NotImplemented if inplace bitwise right shift operation between int and other type is unsupported.\n *\n * Javscript function, returns Python object.\n *\n * @param  {!Sk.builtin.object} other The Python object by which to right shift\n * @return {(Sk.builtin.int_|Sk.builtin.lng|Sk.builtin.NotImplemented)} The result of the right shift\n */\nSk.builtin.int_.prototype.nb$inplace_rshift = Sk.builtin.int_.prototype.nb$rshift;\n\n/**\n * @override\n *\n * @return {Sk.builtin.int_} A copy of this instance with the value negated.\n */\nSk.builtin.int_.prototype.nb$negative = function () {\n    return new Sk.builtin.int_(-this.v);\n};\n\n/** @override */\nSk.builtin.int_.prototype.nb$positive = function () {\n    return this.clone();\n};\n\n/** @override */\nSk.builtin.int_.prototype.nb$nonzero = function () {\n    return this.v !== 0;\n};\n\n/** @override */\nSk.builtin.int_.prototype.nb$isnegative = function () {\n    return this.v < 0;\n};\n\n/** @override */\nSk.builtin.int_.prototype.nb$ispositive = function () {\n    return this.v >= 0;\n};\n\n/**\n * Compare this instance's value to another Python object's value.\n *\n * Returns NotImplemented if comparison between int and other type is unsupported.\n *\n * Javscript function, returns Javascript object or Sk.builtin.NotImplemented.\n *\n * @return {(number|Sk.builtin.NotImplemented)} negative if this < other, zero if this == other, positive if this > other\n */\nSk.builtin.int_.prototype.numberCompare = function (other) {\n    if (other instanceof Sk.builtin.int_) {\n        return this.v - other.v;\n    }\n\n    if (other instanceof Sk.builtin.lng) {\n        return -other.longCompare(this);\n    }\n\n    if (other instanceof Sk.builtin.float_) {\n        return -other.numberCompare(this);\n    }\n\n    return Sk.builtin.NotImplemented.NotImplemented$;\n};\n\n// Despite what jshint may want us to do, these two  functions need to remain\n// as == and !=  Unless you modify the logic of numberCompare do not change\n// these.\n\n/** @override */\nSk.builtin.int_.prototype.ob$eq = function (other) {\n    if (other instanceof Sk.builtin.int_ || other instanceof Sk.builtin.lng ||\n        other instanceof Sk.builtin.float_) {\n        return new Sk.builtin.bool(this.numberCompare(other) == 0); //jshint ignore:line\n    } else if (other instanceof Sk.builtin.none) {\n        return Sk.builtin.bool.false$;\n    } else {\n        return Sk.builtin.NotImplemented.NotImplemented$;\n    }\n};\n\n/** @override */\nSk.builtin.int_.prototype.ob$ne = function (other) {\n    if (other instanceof Sk.builtin.int_ || other instanceof Sk.builtin.lng ||\n        other instanceof Sk.builtin.float_) {\n        return new Sk.builtin.bool(this.numberCompare(other) != 0); //jshint ignore:line\n    } else if (other instanceof Sk.builtin.none) {\n        return Sk.builtin.bool.true$;\n    } else {\n        return Sk.builtin.NotImplemented.NotImplemented$;\n    }\n};\n\n/** @override */\nSk.builtin.int_.prototype.ob$lt = function (other) {\n    if (other instanceof Sk.builtin.int_ || other instanceof Sk.builtin.lng ||\n        other instanceof Sk.builtin.float_) {\n        return new Sk.builtin.bool(this.numberCompare(other) < 0);\n    } else {\n        return Sk.builtin.NotImplemented.NotImplemented$;\n    }\n};\n\n/** @override */\nSk.builtin.int_.prototype.ob$le = function (other) {\n    if (other instanceof Sk.builtin.int_ || other instanceof Sk.builtin.lng ||\n        other instanceof Sk.builtin.float_) {\n        return new Sk.builtin.bool(this.numberCompare(other) <= 0);\n    } else {\n        return Sk.builtin.NotImplemented.NotImplemented$;\n    }\n};\n\n/** @override */\nSk.builtin.int_.prototype.ob$gt = function (other) {\n    if (other instanceof Sk.builtin.int_ || other instanceof Sk.builtin.lng ||\n        other instanceof Sk.builtin.float_) {\n        return new Sk.builtin.bool(this.numberCompare(other) > 0);\n    } else {\n        return Sk.builtin.NotImplemented.NotImplemented$;\n    }\n};\n\n/** @override */\nSk.builtin.int_.prototype.ob$ge = function (other) {\n    if (other instanceof Sk.builtin.int_ || other instanceof Sk.builtin.lng ||\n        other instanceof Sk.builtin.float_) {\n        return new Sk.builtin.bool(this.numberCompare(other) >= 0);\n    } else {\n        return Sk.builtin.NotImplemented.NotImplemented$;\n    }\n};\n\n/**\n * Round this instance to a given number of digits, or zero if omitted.\n *\n * Implements `__round__` dunder method.\n *\n * Javascript function, returns Python object.\n *\n * @param  {Sk.builtin.int_} self This instance.\n * @param  {Object|number=} ndigits The number of digits after the decimal point to which to round.\n * @return {Sk.builtin.int_} The rounded integer.\n */\nSk.builtin.int_.prototype.round$ = function (self, ndigits) {\n    Sk.builtin.pyCheckArgsLen(\"__round__\", arguments.length, 1, 2);\n\n    var result, multiplier, number, num10, rounded, bankRound, ndigs;\n\n    if ((ndigits !== undefined) && !Sk.misceval.isIndex(ndigits)) {\n        throw new Sk.builtin.TypeError(\"'\" + Sk.abstr.typeName(ndigits) + \"' object cannot be interpreted as an index\");\n    }\n\n    number = Sk.builtin.asnum$(self);\n    if (ndigits === undefined) {\n        ndigs = 0;\n    } else {\n        ndigs = Sk.misceval.asIndex(ndigits);\n    }\n\n    if (Sk.__future__.bankers_rounding) {\n        num10 = number * Math.pow(10, ndigs);\n        rounded = Math.round(num10);\n        bankRound = (((((num10>0)?num10:(-num10))%1)===0.5)?(((0===(rounded%2)))?rounded:(rounded-1)):rounded);\n        result = bankRound / Math.pow(10, ndigs);\n        return new Sk.builtin.int_(result);\n    } else {\n        multiplier = Math.pow(10, ndigs);\n        result = Math.round(number * multiplier) / multiplier;\n\n        return new Sk.builtin.int_(result);\n    }\n};\n\nSk.builtin.int_.prototype.__format__= function (obj, format_spec) {\n    var formatstr;\n    Sk.builtin.pyCheckArgsLen(\"__format__\", arguments.length, 2, 2);\n\n    if (!Sk.builtin.checkString(format_spec)) {\n        if (Sk.__future__.exceptions) {\n            throw new Sk.builtin.TypeError(\"format() argument 2 must be str, not \" + Sk.abstr.typeName(format_spec));\n        } else {\n            throw new Sk.builtin.TypeError(\"format expects arg 2 to be string or unicode, not \" + Sk.abstr.typeName(format_spec));\n        }\n    } else {\n        formatstr = Sk.ffi.remapToJs(format_spec);\n        if (formatstr !== \"\") {\n            throw new Sk.builtin.NotImplementedError(\"format spec is not yet implemented\");\n        }\n    }\n\n    return new Sk.builtin.str(obj);\n};\n\nSk.builtin.int_.prototype.conjugate = new Sk.builtin.func(function (self) {\n    return new Sk.builtin.int_(self.v);\n});\n\n/** @override */\nSk.builtin.int_.prototype[\"$r\"] = function () {\n    return new Sk.builtin.str(this.str$(10, true));\n};\n\n/**\n * Return the string representation of this instance.\n *\n * Javascript function, returns Python object.\n *\n * @return {Sk.builtin.str} The Python string representation of this instance.\n */\nSk.builtin.int_.prototype.tp$str = function () {\n    return new Sk.builtin.str(this.str$(10, true));\n};\n\n/**\n * Convert this instance's value to a Javascript string.\n *\n * Javascript function, returns Javascript object.\n *\n * @param {number} base The base of the value.\n * @param {boolean} sign true if the value should be signed, false otherwise.\n * @return {string} The Javascript string representation of this instance.\n */\nSk.builtin.int_.prototype.str$ = function (base, sign) {\n    var tmp;\n    var work;\n\n    if (sign === undefined) {\n        sign = true;\n    }\n\n    work = sign ? this.v : Math.abs(this.v);\n\n    if (base === undefined || base === 10) {\n        tmp = work.toString();\n    } else {\n        tmp = work.toString(base);\n    }\n\n    return tmp;\n};\n\n/**\n * Takes a JavaScript string and returns a number using the parser and negater\n *  functions (for int/long right now)\n * @param  {string} s       Javascript string to convert to a number.\n * @param  {(number)} base    The base of the number.\n * @param  {function(*, (number|undefined)): number} parser  Function which should take\n *  a string that is a postive number which only contains characters that are\n *  valid in the given base and a base and return a number.\n * @param  {function((number|Sk.builtin.biginteger)): number} negater Function which should take a\n *  number and return its negation\n * @param  {string} fname   The name of the calling function, to be used in error messages\n * @return {number}         The number equivalent of the string in the given base\n */\nSk.str2number = function (s, base, parser, negater, fname) {\n    var origs = s,\n        neg = false,\n        i,\n        ch,\n        val;\n\n    // strip whitespace from ends\n    // s = s.trim();\n    s = s.replace(/^\\s+|\\s+$/g, \"\");\n\n    // check for minus sign\n    if (s.charAt(0) === \"-\") {\n        neg = true;\n        s = s.substring(1);\n    }\n\n    // check for plus sign\n    if (s.charAt(0) === \"+\") {\n        s = s.substring(1);\n    }\n\n    if (base === null || base === undefined) {\n        base = 10;\n    } // default radix is 10, not dwim\n\n    if (base < 2 || base > 36) {\n        if (base !== 0) {\n            throw new Sk.builtin.ValueError(fname + \"() base must be >= 2 and <= 36\");\n        }\n    }\n\n    if (s.substring(0, 2).toLowerCase() === \"0x\") {\n        if (base === 16 || base === 0) {\n            s = s.substring(2);\n            base = 16;\n        } else if (base < 34) {\n            throw new Sk.builtin.ValueError(\"invalid literal for \" + fname + \"() with base \" + base + \": '\" + origs + \"'\");\n        }\n    } else if (s.substring(0, 2).toLowerCase() === \"0b\") {\n        if (base === 2 || base === 0) {\n            s = s.substring(2);\n            base = 2;\n        } else if (base < 12) {\n            throw new Sk.builtin.ValueError(\"invalid literal for \" + fname + \"() with base \" + base + \": '\" + origs + \"'\");\n        }\n    } else if (s.substring(0, 2).toLowerCase() === \"0o\") {\n        if (base === 8 || base === 0) {\n            s = s.substring(2);\n            base = 8;\n        } else if (base < 25) {\n            throw new Sk.builtin.ValueError(\"invalid literal for \" + fname + \"() with base \" + base + \": '\" + origs + \"'\");\n        }\n    } else if (s.charAt(0) === \"0\") {\n        if (s === \"0\") {\n            return 0;\n        }\n        if (base === 8 || base === 0) {\n            base = 8;\n        }\n    }\n\n    if (base === 0) {\n        base = 10;\n    }\n\n    if (s.length === 0) {\n        throw new Sk.builtin.ValueError(\"invalid literal for \" + fname + \"() with base \" + base + \": '\" + origs + \"'\");\n    }\n\n    // check all characters are valid\n    for (i = 0; i < s.length; i = i + 1) {\n        ch = s.charCodeAt(i);\n        val = base;\n        if ((ch >= 48) && (ch <= 57)) {\n            // 0-9\n            val = ch - 48;\n        } else if ((ch >= 65) && (ch <= 90)) {\n            // A-Z\n            val = ch - 65 + 10;\n        } else if ((ch >= 97) && (ch <= 122)) {\n            // a-z\n            val = ch - 97 + 10;\n        }\n\n        if (val >= base) {\n            throw new Sk.builtin.ValueError(\"invalid literal for \" + fname + \"() with base \" + base + \": '\" + origs + \"'\");\n        }\n    }\n\n    // parse number\n    val = parser(s, base);\n    if (neg) {\n        val = negater(val);\n    }\n    return val;\n};\n\nSk.exportSymbol(\"Sk.builtin.int_\", Sk.builtin.int_);\n\n\n/***/ }),\n/* 27 */\n/***/ (function(module, exports) {\n\n/**\n * @constructor\n * Sk.builtin.bool\n *\n * @description\n * Constructor for Python bool. Also used for builtin bool() function.\n *\n * Where possible, do not create a new instance but use the constants \n * Sk.builtin.bool.true$ or Sk.builtin.bool.false$. These are defined in src/constant.js\n *\n * @extends {Sk.builtin.object}\n * \n * @param  {(Object|number|boolean)} x Value to evaluate as true or false\n * @return {Sk.builtin.bool} Sk.builtin.bool.true$ if x is true, Sk.builtin.bool.false$ otherwise\n */\nSk.builtin.bool = function (x) {\n    Sk.builtin.pyCheckArgsLen(\"bool\", arguments.length, 1);\n    if (Sk.misceval.isTrue(x)) {\n        return Sk.builtin.bool.true$;\n    } else {\n        return Sk.builtin.bool.false$;\n    }\n};\n\nSk.abstr.setUpInheritance(\"bool\", Sk.builtin.bool, Sk.builtin.int_);\n\nSk.builtin.bool.prototype[\"$r\"] = function () {\n    if (this.v) {\n        return new Sk.builtin.str(\"True\");\n    }\n    return new Sk.builtin.str(\"False\");\n};\n\nSk.builtin.bool.prototype.tp$hash = function () {\n    return new Sk.builtin.int_(this.v);\n};\n\nSk.builtin.bool.prototype.__int__ = new Sk.builtin.func(function(self) {\n    var v = Sk.builtin.asnum$(self);\n\n    return new Sk.builtin.int_(v);\n});\n\nSk.builtin.bool.prototype.__float__ = new Sk.builtin.func(function(self) {\n    return new Sk.builtin.float_(Sk.ffi.remapToJs(self));\n});\n\nSk.exportSymbol(\"Sk.builtin.bool\", Sk.builtin.bool);\n\n\n/***/ }),\n/* 28 */\n/***/ (function(module, exports) {\n\n/**\n * @namespace Sk.builtin\n */\n\n/**\n * @constructor\n * Sk.builtin.float_\n *\n * @description\n * Constructor for Python float. Also used for builtin float().\n *\n * @extends {Sk.builtin.numtype}\n *\n * @param {!(Object|number|string)} x Object or number to convert to Python float.\n * @return {Sk.builtin.float_} Python float\n */\nSk.builtin.float_ = function (x) {\n    var tmp;\n    if (x === undefined) {\n        return new Sk.builtin.float_(0.0);\n    }\n\n    if (!(this instanceof Sk.builtin.float_)) {\n        return new Sk.builtin.float_(x);\n    }\n\n\n    if (x instanceof Sk.builtin.str) {\n        return Sk.builtin._str_to_float(x.v);\n    }\n\n    // Floats are just numbers\n    if (typeof x === \"number\" || x instanceof Sk.builtin.int_ || x instanceof Sk.builtin.lng || x instanceof Sk.builtin.float_) {\n        tmp = Sk.builtin.asnum$(x);\n        if (typeof tmp === \"string\") {\n            return Sk.builtin._str_to_float(tmp);\n        }\n        this.v = tmp;\n        return this;\n    }\n\n    // Convert booleans\n    if (x instanceof Sk.builtin.bool) {\n        this.v = Sk.builtin.asnum$(x);\n        return this;\n    }\n\n    // this is a special internal case\n    if(typeof x === \"boolean\") {\n        this.v = x ? 1.0 : 0.0;\n        return this;\n    }\n\n    if (typeof x === \"string\") {\n        this.v = parseFloat(x);\n        return this;\n    }\n\n    // try calling __float__\n    var special = Sk.abstr.lookupSpecial(x, Sk.builtin.str.$float_);\n    if (special != null) {\n        // method on builtin, provide this arg\n        return Sk.misceval.callsimArray(special, [x]);\n    }\n\n    throw new Sk.builtin.TypeError(\"float() argument must be a string or a number\");\n};\n\nSk.abstr.setUpInheritance(\"float\", Sk.builtin.float_, Sk.builtin.numtype);\n\nSk.builtin._str_to_float = function (str) {\n    var tmp;\n\n    if (str.match(/^-inf$/i)) {\n        tmp = -Infinity;\n    } else if (str.match(/^[+]?inf$/i)) {\n        tmp = Infinity;\n    } else if (str.match(/^[-+]?nan$/i)) {\n        tmp = NaN;\n    } else if (!isNaN(str)) {\n        tmp = parseFloat(str);\n    } else {\n        throw new Sk.builtin.ValueError(\"float: Argument: \" + str + \" is not number\");\n    }\n    return new Sk.builtin.float_(tmp);\n};\n\nSk.builtin.float_.prototype.nb$int_ = function () {\n    var v = this.v;\n\n    if (v < 0) {\n        v = Math.ceil(v);\n    } else {\n        v = Math.floor(v);\n    }\n\n    // this should take care of int/long fitting\n    return new Sk.builtin.int_(v);\n};\n\nSk.builtin.float_.prototype.nb$float_ = function() {\n    return this;\n};\n\nSk.builtin.float_.prototype.nb$lng = function () {\n    return new Sk.builtin.lng(this.v);\n};\n\n/**\n * Checks for float subtypes, though skulpt does not allow to\n * extend them for now.\n *\n * Javascript function, returns Javascript object.\n * @param {Object} op The object to check as subtype.\n * @return {boolean} true if op is a subtype of Sk.builtin.float_, false otherwise\n */\nSk.builtin.float_.PyFloat_Check = function (op) {\n    if (op === undefined) {\n        return false;\n    }\n\n    // this is a little bit hacky\n    // ToDo: subclassable builtins do not require this\n    if (Sk.builtin.checkNumber(op)) {\n        return true;\n    }\n\n    if (Sk.builtin.checkFloat(op)) {\n        return true;\n    }\n\n    if (Sk.builtin.issubclass(op.ob$type, Sk.builtin.float_)) {\n        return true;\n    }\n\n    return false;\n};\n\n/**\n * Checks if ob is a Python float.\n *\n * This method is just a wrapper, but uses the correct cpython API name.\n *\n * Javascript function, returns Javascript object.\n * @param {Object} op The object to check.\n * @return {boolean} true if op is an instance of Sk.builtin.float_, false otherwise\n */\nSk.builtin.float_.PyFloat_Check_Exact = function (op) {\n    return Sk.builtin.checkFloat(op);\n};\n\nSk.builtin.float_.PyFloat_AsDouble = function (op) {\n    var f; // nb_float;\n    var fo; // PyFloatObject *fo;\n    var val;\n\n    // it is a subclass or direct float\n    if (op && Sk.builtin.float_.PyFloat_Check(op)) {\n        return Sk.ffi.remapToJs(op);\n    }\n\n    if (op == null) {\n        throw new Error(\"bad argument for internal PyFloat_AsDouble function\");\n    }\n\n    // check if special method exists (nb_float is not implemented in skulpt, hence we use __float__)\n    f = Sk.builtin.type.typeLookup(op.ob$type, Sk.builtin.str.$float_);\n    if (f == null) {\n        throw new Sk.builtin.TypeError(\"a float is required\");\n    }\n\n    // call internal float method\n    fo = Sk.misceval.callsimArray(f, [op]);\n\n    // return value of __float__ must be a python float\n    if (!Sk.builtin.float_.PyFloat_Check(fo)) {\n        throw new Sk.builtin.TypeError(\"nb_float should return float object\");\n    }\n\n    val = Sk.ffi.remapToJs(fo);\n\n    return val;\n};\n\n/**\n * Return this instance's Javascript value.\n *\n * Javascript function, returns Javascript object.\n *\n * @return {number} This instance's value.\n */\nSk.builtin.float_.prototype.tp$index = function () {\n    return this.v;\n};\n\n/** @override */\nSk.builtin.float_.prototype.tp$hash = function () {\n    //the hash of all numbers should be an int and since javascript doesn't really\n    //care every number can be an int.\n    return this.nb$int_();\n};\n\n\n/**\n * Returns a copy of this instance.\n *\n * Javascript function, returns Python object.\n *\n * @return {Sk.builtin.float_} The copy\n */\nSk.builtin.float_.prototype.clone = function () {\n    return new Sk.builtin.float_(this.v);\n};\n\n/**\n * Returns this instance's value as a string formatted using fixed-point notation.\n *\n * Javascript function, returns Javascript object.\n *\n * @param  {Object|number} x The numer of digits to appear after the decimal point.\n * @return {string}   The string representation of this instance's value.\n */\nSk.builtin.float_.prototype.toFixed = function (x) {\n    x = Sk.builtin.asnum$(x);\n    return this.v.toFixed(x);\n};\n\n/** @override */\nSk.builtin.float_.prototype.nb$add = function (other) {\n    if (other instanceof Sk.builtin.int_ || other instanceof Sk.builtin.float_) {\n        return new Sk.builtin.float_(this.v + other.v);\n    } else if (other instanceof Sk.builtin.lng) {\n        return new Sk.builtin.float_(this.v + parseFloat(other.str$(10, true)));\n    }\n\n    return Sk.builtin.NotImplemented.NotImplemented$;\n};\n\n/** @override */\nSk.builtin.float_.prototype.nb$reflected_add = function (other) {\n    // Should not automatically call this.nb$add, as nb$add may have\n    // been overridden by a subclass\n    return Sk.builtin.float_.prototype.nb$add.call(this, other);\n};\n\n/** @override */\nSk.builtin.float_.prototype.nb$subtract = function (other) {\n    if (other instanceof Sk.builtin.int_ || other instanceof Sk.builtin.float_) {\n        return new Sk.builtin.float_(this.v - other.v);\n    } else if (other instanceof Sk.builtin.lng) {\n        return new Sk.builtin.float_(this.v - parseFloat(other.str$(10, true)));\n    }\n\n    return Sk.builtin.NotImplemented.NotImplemented$;\n};\n\n/** @override */\nSk.builtin.float_.prototype.nb$reflected_subtract = function (other) {\n    // Should not automatically call this.nb$add, as nb$add may have\n    // been overridden by a subclass\n    var negative_this = this.nb$negative();\n    return Sk.builtin.float_.prototype.nb$add.call(negative_this, other);\n};\n\n/** @override */\nSk.builtin.float_.prototype.nb$multiply = function (other) {\n    if (other instanceof Sk.builtin.int_ || other instanceof Sk.builtin.float_) {\n        return new Sk.builtin.float_(this.v * other.v);\n    } else if (other instanceof Sk.builtin.lng) {\n        return new Sk.builtin.float_(this.v * parseFloat(other.str$(10, true)));\n    }\n\n    return Sk.builtin.NotImplemented.NotImplemented$;\n};\n\n/** @override */\nSk.builtin.float_.prototype.nb$reflected_multiply = function (other) {\n    // Should not automatically call this.nb$multiply, as nb$multiply may have\n    // been overridden by a subclass\n    return Sk.builtin.float_.prototype.nb$multiply.call(this, other);\n};\n\n/** @override */\nSk.builtin.float_.prototype.nb$divide = function (other) {\n    if (other instanceof Sk.builtin.int_ || other instanceof Sk.builtin.float_) {\n\n        if (other.v === 0) {\n            throw new Sk.builtin.ZeroDivisionError(\"integer division or modulo by zero\");\n        }\n\n        if (this.v === Infinity) {\n            if (other.v === Infinity || other.v === -Infinity) {\n                return new Sk.builtin.float_(NaN);\n            } else if (other.nb$isnegative()) {\n                return new Sk.builtin.float_(-Infinity);\n            } else {\n                return new Sk.builtin.float_(Infinity);\n            }\n        }\n        if (this.v === -Infinity) {\n            if (other.v === Infinity || other.v === -Infinity) {\n                return new Sk.builtin.float_(NaN);\n            } else if (other.nb$isnegative()) {\n                return new Sk.builtin.float_(Infinity);\n            } else {\n                return new Sk.builtin.float_(-Infinity);\n            }\n        }\n\n        return new Sk.builtin.float_(this.v / other.v);\n    }\n\n    if (other instanceof Sk.builtin.lng) {\n        if (other.longCompare(Sk.builtin.biginteger.ZERO) === 0) {\n            throw new Sk.builtin.ZeroDivisionError(\"integer division or modulo by zero\");\n        }\n\n        if (this.v === Infinity) {\n            if (other.nb$isnegative()) {\n                return new Sk.builtin.float_(-Infinity);\n            } else {\n                return new Sk.builtin.float_(Infinity);\n            }\n        }\n        if (this.v === -Infinity) {\n            if (other.nb$isnegative()) {\n                return new Sk.builtin.float_(Infinity);\n            } else {\n                return new Sk.builtin.float_(-Infinity);\n            }\n        }\n\n        return new Sk.builtin.float_(this.v / parseFloat(other.str$(10, true)));\n    }\n\n    return Sk.builtin.NotImplemented.NotImplemented$;\n};\n\n/** @override */\nSk.builtin.float_.prototype.nb$reflected_divide = function (other) {\n    if (other instanceof Sk.builtin.int_ ||\n        other instanceof Sk.builtin.lng) {\n        other = new Sk.builtin.float_(other);\n    }\n\n    if (other instanceof Sk.builtin.float_) {\n        return other.nb$divide(this);\n    }\n\n    return Sk.builtin.NotImplemented.NotImplemented$;\n};\n\n/** @override */\nSk.builtin.float_.prototype.nb$floor_divide = function (other) {\n\n    if (other instanceof Sk.builtin.int_ || other instanceof Sk.builtin.float_) {\n\n        if (this.v === Infinity || this.v === -Infinity) {\n            return new Sk.builtin.float_(NaN);\n        }\n\n        if (other.v === 0) {\n            throw new Sk.builtin.ZeroDivisionError(\"integer division or modulo by zero\");\n        }\n\n        if (other.v === Infinity) {\n            if (this.nb$isnegative()) {\n                return new Sk.builtin.float_(-1);\n            } else {\n                return new Sk.builtin.float_(0);\n            }\n        }\n        if (other.v === -Infinity) {\n            if (this.nb$isnegative() || !this.nb$nonzero()) {\n                return new Sk.builtin.float_(0);\n            } else {\n                return new Sk.builtin.float_(-1);\n            }\n        }\n\n        return new Sk.builtin.float_(Math.floor(this.v / other.v));\n    }\n\n    if (other instanceof Sk.builtin.lng) {\n        if (other.longCompare(Sk.builtin.biginteger.ZERO) === 0) {\n            throw new Sk.builtin.ZeroDivisionError(\"integer division or modulo by zero\");\n        }\n\n        if (this.v === Infinity || this.v === -Infinity) {\n            return new Sk.builtin.float_(NaN);\n        }\n\n        return new Sk.builtin.float_(Math.floor(this.v / parseFloat(other.str$(10, true))));\n    }\n\n    return Sk.builtin.NotImplemented.NotImplemented$;\n};\n\n/** @override */\nSk.builtin.float_.prototype.nb$reflected_floor_divide = function (other) {\n    if (other instanceof Sk.builtin.int_ ||\n        other instanceof Sk.builtin.lng) {\n        other = new Sk.builtin.float_(other);\n    }\n\n    if (other instanceof Sk.builtin.float_) {\n        return other.nb$floor_divide(this);\n    }\n\n    return Sk.builtin.NotImplemented.NotImplemented$;\n};\n\n/** @override */\nSk.builtin.float_.prototype.nb$remainder = function (other) {\n    var thisAsLong;\n    var op2;\n    var tmp;\n    var result;\n\n    if (other instanceof Sk.builtin.int_ || other instanceof Sk.builtin.float_) {\n\n        if (other.v === 0) {\n            throw new Sk.builtin.ZeroDivisionError(\"integer division or modulo by zero\");\n        }\n\n        if (this.v === 0) {\n            return new Sk.builtin.float_(0);\n        }\n\n        if (other.v === Infinity) {\n            if (this.v === Infinity || this.v === -Infinity) {\n                return new Sk.builtin.float_(NaN);\n            } else if (this.nb$ispositive()) {\n                return new Sk.builtin.float_(this.v);\n            } else {\n                return new Sk.builtin.float_(Infinity);\n            }\n        }\n\n        //  Javacript logic on negatives doesn't work for Python... do this instead\n        tmp = this.v % other.v;\n\n        if (this.v < 0) {\n            if (other.v > 0 && tmp < 0) {\n                tmp = tmp + other.v;\n            }\n        } else {\n            if (other.v < 0 && tmp !== 0) {\n                tmp = tmp + other.v;\n            }\n        }\n\n        if (other.v < 0 && tmp === 0) {\n            tmp = -0.0; // otherwise the sign gets lost by javascript modulo\n        } else if (tmp === 0 && Infinity/tmp === -Infinity) {\n            tmp = 0.0;\n        }\n\n        return new Sk.builtin.float_(tmp);\n    }\n\n    if (other instanceof Sk.builtin.lng) {\n        if (other.longCompare(Sk.builtin.biginteger.ZERO) === 0) {\n            throw new Sk.builtin.ZeroDivisionError(\"integer division or modulo by zero\");\n        }\n\n        if (this.v === 0) {\n            return new Sk.builtin.float_(0);\n        }\n\n        op2 = parseFloat(other.str$(10, true));\n        tmp = this.v % op2;\n\n        if (tmp < 0) {\n            if (op2 > 0 && tmp !== 0) {\n                tmp = tmp + op2;\n            }\n        } else {\n            if (op2 < 0 && tmp !== 0) {\n                tmp = tmp + op2;\n            }\n        }\n\n        if (other.nb$isnegative() && tmp === 0) {\n            tmp = -0.0; // otherwise the sign gets lost by javascript modulo\n        } else if (tmp === 0 && Infinity/tmp === -Infinity) {\n            tmp = 0.0;\n        }\n\n        return new Sk.builtin.float_(tmp);\n    }\n\n    return Sk.builtin.NotImplemented.NotImplemented$;\n};\n\n/** @override */\nSk.builtin.float_.prototype.nb$reflected_remainder = function (other) {\n    if (other instanceof Sk.builtin.int_ ||\n        other instanceof Sk.builtin.lng) {\n        other = new Sk.builtin.float_(other);\n    }\n\n    if (other instanceof Sk.builtin.float_) {\n        return other.nb$remainder(this);\n    }\n\n    return Sk.builtin.NotImplemented.NotImplemented$;\n};\n\n/** @override */\nSk.builtin.float_.prototype.nb$divmod = function (other) {\n    if (other instanceof Sk.builtin.int_ ||\n        other instanceof Sk.builtin.lng) {\n        other = new Sk.builtin.float_(other);\n    }\n\n    if (other instanceof Sk.builtin.float_) {\n        return new Sk.builtin.tuple([\n            this.nb$floor_divide(other),\n            this.nb$remainder(other)\n        ]);\n    }\n\n    return Sk.builtin.NotImplemented.NotImplemented$;\n};\n\n/** @override */\nSk.builtin.float_.prototype.nb$reflected_divmod = function (other) {\n    if (other instanceof Sk.builtin.int_ ||\n        other instanceof Sk.builtin.lng) {\n        other = new Sk.builtin.float_(other);\n    }\n\n    if (other instanceof Sk.builtin.float_) {\n        return new Sk.builtin.tuple([\n            other.nb$floor_divide(this),\n            other.nb$remainder(this)\n        ]);\n    }\n\n    return Sk.builtin.NotImplemented.NotImplemented$;\n};\n\n/** @override */\nSk.builtin.float_.prototype.nb$power = function (other, mod) {\n    var thisAsLong;\n    var result;\n\n    if (other instanceof Sk.builtin.int_ || other instanceof Sk.builtin.float_) {\n        if (this.v < 0 && other.v % 1 !== 0) {\n            throw new Sk.builtin.NegativePowerError(\"cannot raise a negative number to a fractional power\");\n        }\n        if (this.v === 0 && other.v < 0) {\n            throw new Sk.builtin.NegativePowerError(\"cannot raise zero to a negative power\");\n        }\n\n        result = new Sk.builtin.float_(Math.pow(this.v, other.v));\n\n        if ((Math.abs(result.v) === Infinity) &&\n            (Math.abs(this.v) !== Infinity) &&\n            (Math.abs(other.v) !== Infinity)) {\n            throw new Sk.builtin.OverflowError(\"Numerical result out of range\");\n        }\n        return result;\n    }\n\n    if (other instanceof Sk.builtin.lng) {\n        if (this.v === 0 && other.longCompare(Sk.builtin.biginteger.ZERO) < 0) {\n            throw new Sk.builtin.NegativePowerError(\"cannot raise zero to a negative power\");\n        }\n\n        return new Sk.builtin.float_(Math.pow(this.v, parseFloat(other.str$(10, true))));\n    }\n\n    return Sk.builtin.NotImplemented.NotImplemented$;\n};\n\n/** @override */\nSk.builtin.float_.prototype.nb$reflected_power = function (n, mod) {\n    if (n instanceof Sk.builtin.int_ ||\n        n instanceof Sk.builtin.lng) {\n        n = new Sk.builtin.float_(n);\n    }\n\n    if (n instanceof Sk.builtin.float_) {\n        return n.nb$power(this, mod);\n    }\n\n    return Sk.builtin.NotImplemented.NotImplemented$;\n};\n\n/** @override */\nSk.builtin.float_.prototype.nb$abs = function () {\n    return new Sk.builtin.float_(Math.abs(this.v));\n};\n\n/** @override */\nSk.builtin.float_.prototype.nb$inplace_add = Sk.builtin.float_.prototype.nb$add;\n\n/** @override */\nSk.builtin.float_.prototype.nb$inplace_subtract = Sk.builtin.float_.prototype.nb$subtract;\n\n/** @override */\nSk.builtin.float_.prototype.nb$inplace_multiply = Sk.builtin.float_.prototype.nb$multiply;\n\n/** @override */\nSk.builtin.float_.prototype.nb$inplace_divide = Sk.builtin.float_.prototype.nb$divide;\n\n/** @override */\nSk.builtin.float_.prototype.nb$inplace_remainder = Sk.builtin.float_.prototype.nb$remainder;\n\n/** @override */\nSk.builtin.float_.prototype.nb$inplace_floor_divide = Sk.builtin.float_.prototype.nb$floor_divide;\n\n/** @override */\nSk.builtin.float_.prototype.nb$inplace_power = Sk.builtin.float_.prototype.nb$power;\n\n/**\n * @override\n *\n * @return {Sk.builtin.float_} A copy of this instance with the value negated.\n */\nSk.builtin.float_.prototype.nb$negative = function () {\n    return new Sk.builtin.float_(-this.v);\n};\n\n/** @override */\nSk.builtin.float_.prototype.nb$positive = function () {\n    return this.clone();\n};\n\n/** @override */\nSk.builtin.float_.prototype.nb$nonzero = function () {\n    return this.v !== 0;\n};\n\n/** @override */\nSk.builtin.float_.prototype.nb$isnegative = function () {\n    return this.v < 0;\n};\n\n/** @override */\nSk.builtin.float_.prototype.nb$ispositive = function () {\n    return this.v >= 0;\n};\n\n/**\n * Compare this instance's value to another Python object's value.\n *\n * Returns NotImplemented if comparison between float and other type is unsupported.\n *\n * Javscript function, returns Javascript object or Sk.builtin.NotImplemented.\n *\n * @return {(number|Sk.builtin.NotImplemented)} negative if this < other, zero if this == other, positive if this > other\n */\nSk.builtin.float_.prototype.numberCompare = function (other) {\n    var diff;\n    var tmp;\n    var thisAsLong;\n\n    if (other instanceof Sk.builtin.int_ || other instanceof Sk.builtin.float_) {\n        if (this.v == Infinity && other.v == Infinity) {\n            return 0;\n        }\n        if (this.v == -Infinity && other.v == -Infinity) {\n            return 0;\n        }\n        return this.v - other.v;\n    }\n\n    if (other instanceof Sk.builtin.lng) {\n        if (this.v % 1 === 0) {\n            thisAsLong = new Sk.builtin.lng(this.v);\n            tmp = thisAsLong.longCompare(other);\n            return tmp;\n        }\n        diff = this.nb$subtract(other);\n        if (diff instanceof Sk.builtin.float_) {\n            return diff.v;\n        } else if (diff instanceof Sk.builtin.lng) {\n            return diff.longCompare(Sk.builtin.biginteger.ZERO);\n        }\n    }\n\n    return Sk.builtin.NotImplemented.NotImplemented$;\n};\n\n// Despite what jshint may want us to do, these two  functions need to remain\n// as == and !=  Unless you modify the logic of numberCompare do not change\n// these.\n\n/** @override */\nSk.builtin.float_.prototype.ob$eq = function (other) {\n    if (other instanceof Sk.builtin.int_ ||\n        other instanceof Sk.builtin.lng ||\n        other instanceof Sk.builtin.float_) {\n        return new Sk.builtin.bool(this.numberCompare(other) == 0); //jshint ignore:line\n    } else if (other instanceof Sk.builtin.none) {\n        return Sk.builtin.bool.false$;\n    } else {\n        return Sk.builtin.NotImplemented.NotImplemented$;\n    }\n};\n\n/** @override */\nSk.builtin.float_.prototype.ob$ne = function (other) {\n    if (other instanceof Sk.builtin.int_ ||\n        other instanceof Sk.builtin.lng ||\n        other instanceof Sk.builtin.float_) {\n        return new Sk.builtin.bool(this.numberCompare(other) != 0); //jshint ignore:line\n    } else if (other instanceof Sk.builtin.none) {\n        return Sk.builtin.bool.true$;\n    } else {\n        return Sk.builtin.NotImplemented.NotImplemented$;\n    }\n};\n\n/** @override */\nSk.builtin.float_.prototype.ob$lt = function (other) {\n    if (other instanceof Sk.builtin.int_ ||\n        other instanceof Sk.builtin.lng ||\n        other instanceof Sk.builtin.float_) {\n        return new Sk.builtin.bool(this.numberCompare(other) < 0);\n    } else {\n        return Sk.builtin.NotImplemented.NotImplemented$;\n    }\n};\n\n/** @override */\nSk.builtin.float_.prototype.ob$le = function (other) {\n    if (other instanceof Sk.builtin.int_ ||\n        other instanceof Sk.builtin.lng ||\n        other instanceof Sk.builtin.float_) {\n        return new Sk.builtin.bool(this.numberCompare(other) <= 0);\n    } else {\n        return Sk.builtin.NotImplemented.NotImplemented$;\n    }\n};\n\n/** @override */\nSk.builtin.float_.prototype.ob$gt = function (other) {\n    if (other instanceof Sk.builtin.int_ ||\n        other instanceof Sk.builtin.lng ||\n        other instanceof Sk.builtin.float_) {\n        return new Sk.builtin.bool(this.numberCompare(other) > 0);\n    } else {\n        return Sk.builtin.NotImplemented.NotImplemented$;\n    }\n};\n\n/** @override */\nSk.builtin.float_.prototype.ob$ge = function (other) {\n    if (other instanceof Sk.builtin.int_ ||\n        other instanceof Sk.builtin.lng ||\n        other instanceof Sk.builtin.float_) {\n        return new Sk.builtin.bool(this.numberCompare(other) >= 0);\n    } else {\n        return Sk.builtin.NotImplemented.NotImplemented$;\n    }\n};\n\n/**\n * Round this instance to a given number of digits, or zero if omitted.\n *\n * Implements `__round__` dunder method.\n *\n * Javascript function, returns Python object.\n *\n * @param  {Sk.builtin.int_} self This instance.\n * @param  {Object|number=} ndigits The number of digits after the decimal point to which to round.\n * @return {Sk.builtin.float_|Sk.builtin.int_} The rounded float.\n */\nSk.builtin.float_.prototype.round$ = function (self, ndigits) {\n    Sk.builtin.pyCheckArgsLen(\"__round__\", arguments.length, 1, 2);\n\n    var result, multiplier, number, num10, rounded, bankRound, ndigs;\n\n    if ((ndigits !== undefined) && !Sk.misceval.isIndex(ndigits)) {\n        throw new Sk.builtin.TypeError(\"'\" + Sk.abstr.typeName(ndigits) + \"' object cannot be interpreted as an index\");\n    }\n\n    number = Sk.builtin.asnum$(self);\n    if (ndigits === undefined) {\n        ndigs = 0;\n    } else {\n        ndigs = Sk.misceval.asIndex(ndigits);\n    }\n\n    if (Sk.__future__.bankers_rounding) {\n        num10 = number * Math.pow(10, ndigs);\n        rounded = Math.round(num10);\n        bankRound = (((((num10>0)?num10:(-num10))%1)===0.5)?(((0===(rounded%2)))?rounded:(rounded-1)):rounded);\n        result = bankRound / Math.pow(10, ndigs);\n        if (ndigits === undefined) {\n            return new Sk.builtin.int_(result);\n        } else {\n            return new Sk.builtin.float_(result);\n        }\n    } else {\n        multiplier = Math.pow(10, ndigs);\n        result = Math.round(number * multiplier) / multiplier;\n\n        return new Sk.builtin.float_(result);\n    }\n};\n\nSk.builtin.float_.prototype.__format__= function (obj, format_spec) {\n    var formatstr;\n    Sk.builtin.pyCheckArgsLen(\"__format__\", arguments.length, 2, 2);\n\n    if (!Sk.builtin.checkString(format_spec)) {\n        if (Sk.__future__.exceptions) {\n            throw new Sk.builtin.TypeError(\"format() argument 2 must be str, not \" + Sk.abstr.typeName(format_spec));\n        } else {\n            throw new Sk.builtin.TypeError(\"format expects arg 2 to be string or unicode, not \" + Sk.abstr.typeName(format_spec));\n        }\n    } else {\n        formatstr = Sk.ffi.remapToJs(format_spec);\n        if (formatstr !== \"\") {\n            throw new Sk.builtin.NotImplementedError(\"format spec is not yet implemented\");\n        }\n    }\n\n    return new Sk.builtin.str(obj);\n};\n\n\nSk.builtin.float_.prototype.conjugate = new Sk.builtin.func(function (self) {\n    return new Sk.builtin.float_(self.v);\n});\n\n/** @override */\nSk.builtin.float_.prototype[\"$r\"] = function () {\n    return new Sk.builtin.str(this.str$(10, true));\n};\n\n/**\n * Return the string representation of this instance.\n *\n * Javascript function, returns Python object.\n *\n * @return {Sk.builtin.str} The Python string representation of this instance.\n */\nSk.builtin.float_.prototype.tp$str = function () {\n    return new Sk.builtin.str(this.str$(10, true));\n};\n\n/**\n * Convert this instance's value to a Javascript string.\n *\n * Javascript function, returns Javascript object.\n *\n * @param {number} base The base of the value.\n * @param {boolean} sign true if the value should be signed, false otherwise.\n * @return {string} The Javascript string representation of this instance.\n */\nSk.builtin.float_.prototype.str$ = function (base, sign) {\n    var post;\n    var pre;\n    var idx;\n    var tmp;\n    var work;\n\n    if (isNaN(this.v)) {\n        return \"nan\";\n    }\n\n    if (sign === undefined) {\n        sign = true;\n    }\n\n    if (this.v == Infinity) {\n        return \"inf\";\n    }\n    if (this.v == -Infinity && sign) {\n        return \"-inf\";\n    }\n    if (this.v == -Infinity && !sign) {\n        return \"inf\";\n    }\n\n    work = sign ? this.v : Math.abs(this.v);\n\n\n    if (base === undefined || base === 10) {\n        tmp = work.toPrecision(12);\n\n        // transform fractions with 4 or more leading zeroes into exponents\n        idx = tmp.indexOf(\".\");\n        pre = work.toString().slice(0, idx);\n        post = work.toString().slice(idx);\n\n        if (pre.match(/^-?0$/) && post.slice(1).match(/^0{4,}/)) {\n            if (tmp.length < 12) {\n                tmp = work.toExponential();\n            } else {\n                tmp = work.toExponential(11);\n            }\n        }\n\n        if (tmp.indexOf(\"e\") < 0 && tmp.indexOf(\".\") >= 0) {\n            while (tmp.charAt(tmp.length-1) == \"0\") {\n                tmp = tmp.substring(0,tmp.length-1);\n            }\n            if (tmp.charAt(tmp.length-1) == \".\") {\n                tmp = tmp + \"0\";\n            }\n        }\n\n        tmp = tmp.replace(new RegExp(\"\\\\.0+e\"), \"e\", \"i\");\n        // make exponent two digits instead of one (ie e+09 not e+9)\n        tmp = tmp.replace(/(e[-+])([1-9])$/, \"$10$2\");\n        // remove trailing zeroes before the exponent\n        tmp = tmp.replace(/0+(e.*)/, \"$1\");\n    } else {\n        tmp = work.toString(base);\n    }\n\n    // restore negative zero sign\n    if(this.v === 0 && 1/this.v === -Infinity) {\n        tmp = \"-\" + tmp;\n    }\n\n    if (tmp.indexOf(\".\") < 0 && tmp.indexOf(\"E\") < 0 && tmp.indexOf(\"e\") < 0) {\n        tmp = tmp + \".0\";\n    }\n\n    return tmp;\n};\n\n\n/***/ }),\n/* 29 */\n/***/ (function(module, exports) {\n\nvar deprecatedError = new Sk.builtin.ExternalError(\"Sk.builtin.nmber is deprecated.\");\n\n/**\n * @deprecated Please use Sk.builtin.int_ or Sk.builtin.float_ constructors instead.\n * If you do not know at complile time which type of number, use Sk.builtin.assk$.\n */\nSk.builtin.nmber = function (x, skType)    /* number is a reserved word */ {\n    throw new Sk.builtin.ExternalError(\"Sk.builtin.nmber is deprecated. Please replace with Sk.builtin.int_, Sk.builtin.float_, or Sk.builtin.assk$.\");\n};\n\n/**\n * @deprecated Please use Sk.builtin.int_ or Sk.builtin.float_ instead.\n */\nSk.builtin.nmber.prototype.tp$index = function () {\n    return this.v;\n};\n\n/**\n * @deprecated Please use Sk.builtin.int_ or Sk.builtin.float_ instead.\n */\nSk.builtin.nmber.prototype.tp$hash = function () {\n    throw deprecatedError;\n};\n\n/**\n * @deprecated Please use Sk.builtin.int_ or Sk.builtin.float_ instead.\n */\nSk.builtin.nmber.fromInt$ = function (ival) {\n    throw deprecatedError;\n};\n\n/**\n * @deprecated Please use Sk.builtin.int_ or Sk.builtin.float_ instead.\n */\nSk.builtin.nmber.prototype.clone = function () {\n    throw deprecatedError;\n};\n\n/**\n * @deprecated Please use Sk.builtin.int_ or Sk.builtin.float_ instead.\n */\nSk.builtin.nmber.prototype.toFixed = function (x) {\n    throw deprecatedError;\n};\n\n/**\n * @deprecated Please use Sk.builtin.int_ or Sk.builtin.float_ instead.\n */\nSk.builtin.nmber.prototype.nb$add = function (other) {\n    throw deprecatedError;\n};\n\n/**\n * @deprecated Please use Sk.builtin.int_ or Sk.builtin.float_ instead.\n */\nSk.builtin.nmber.prototype.nb$subtract = function (other) {\n    throw deprecatedError;\n};\n\n/**\n * @deprecated Please use Sk.builtin.int_ or Sk.builtin.float_ instead.\n */\nSk.builtin.nmber.prototype.nb$multiply = function (other) {\n    throw deprecatedError;\n};\n\n/**\n * @deprecated Please use Sk.builtin.int_ or Sk.builtin.float_ instead.\n */\nSk.builtin.nmber.prototype.nb$divide = function (other) {\n    throw deprecatedError;\n};\n\n/**\n * @deprecated Please use Sk.builtin.int_ or Sk.builtin.float_ instead.\n */\nSk.builtin.nmber.prototype.nb$floor_divide = function (other) {\n    throw deprecatedError;\n};\n\n/**\n * @deprecated Please use Sk.builtin.int_ or Sk.builtin.float_ instead.\n */\nSk.builtin.nmber.prototype.nb$remainder = function (other) {\n    throw deprecatedError;\n};\n\n/**\n * @deprecated Please use Sk.builtin.int_ or Sk.builtin.float_ instead.\n */\nSk.builtin.nmber.prototype.nb$divmod = function (other) {\n    throw deprecatedError;\n\n};\n\n/**\n * @deprecated Please use Sk.builtin.int_ or Sk.builtin.float_ instead.\n */\nSk.builtin.nmber.prototype.nb$power = function (other) {\n    throw deprecatedError;\n};\n\n/**\n * @deprecated Please use Sk.builtin.int_ or Sk.builtin.float_ instead.\n */\nSk.builtin.nmber.prototype.nb$and = function (other) {\n    throw deprecatedError;\n};\n\n/**\n * @deprecated Please use Sk.builtin.int_ or Sk.builtin.float_ instead.\n */\nSk.builtin.nmber.prototype.nb$or = function (other) {\n    throw deprecatedError;\n};\n\n/**\n * @deprecated Please use Sk.builtin.int_ or Sk.builtin.float_ instead.\n */\nSk.builtin.nmber.prototype.nb$xor = function (other) {\n    throw deprecatedError;\n};\n\n/**\n * @deprecated Please use Sk.builtin.int_ or Sk.builtin.float_ instead.\n */\nSk.builtin.nmber.prototype.nb$lshift = function (other) {\n    throw deprecatedError;\n};\n\n/**\n * @deprecated Please use Sk.builtin.int_ or Sk.builtin.float_ instead.\n */\nSk.builtin.nmber.prototype.nb$rshift = function (other) {\n    throw deprecatedError;\n};\n\n/**\n * @deprecated Please use Sk.builtin.int_ or Sk.builtin.float_ instead.\n */\nSk.builtin.nmber.prototype.nb$inplace_add = Sk.builtin.nmber.prototype.nb$add;\n\n/**\n * @deprecated Please use Sk.builtin.int_ or Sk.builtin.float_ instead.\n */\nSk.builtin.nmber.prototype.nb$inplace_subtract = Sk.builtin.nmber.prototype.nb$subtract;\n\n/**\n * @deprecated Please use Sk.builtin.int_ or Sk.builtin.float_ instead.\n */\nSk.builtin.nmber.prototype.nb$inplace_multiply = Sk.builtin.nmber.prototype.nb$multiply;\n\n/**\n * @deprecated Please use Sk.builtin.int_ or Sk.builtin.float_ instead.\n */\nSk.builtin.nmber.prototype.nb$inplace_divide = Sk.builtin.nmber.prototype.nb$divide;\n\n/**\n * @deprecated Please use Sk.builtin.int_ or Sk.builtin.float_ instead.\n */\nSk.builtin.nmber.prototype.nb$inplace_remainder = Sk.builtin.nmber.prototype.nb$remainder;\n\n/**\n * @deprecated Please use Sk.builtin.int_ or Sk.builtin.float_ instead.\n */\nSk.builtin.nmber.prototype.nb$inplace_floor_divide = Sk.builtin.nmber.prototype.nb$floor_divide;\n\n/**\n * @deprecated Please use Sk.builtin.int_ or Sk.builtin.float_ instead.\n */\nSk.builtin.nmber.prototype.nb$inplace_power = Sk.builtin.nmber.prototype.nb$power;\n\n/**\n * @deprecated Please use Sk.builtin.int_ or Sk.builtin.float_ instead.\n */\nSk.builtin.nmber.prototype.nb$inplace_and = Sk.builtin.nmber.prototype.nb$and;\n\n/**\n * @deprecated Please use Sk.builtin.int_ or Sk.builtin.float_ instead.\n */\nSk.builtin.nmber.prototype.nb$inplace_or = Sk.builtin.nmber.prototype.nb$or;\n\n/**\n * @deprecated Please use Sk.builtin.int_ or Sk.builtin.float_ instead.\n */\nSk.builtin.nmber.prototype.nb$inplace_xor = Sk.builtin.nmber.prototype.nb$xor;\n\n/**\n * @deprecated Please use Sk.builtin.int_ or Sk.builtin.float_ instead.\n */\nSk.builtin.nmber.prototype.nb$inplace_lshift = Sk.builtin.nmber.prototype.nb$lshift;\n\n/**\n * @deprecated Please use Sk.builtin.int_ or Sk.builtin.float_ instead.\n */\nSk.builtin.nmber.prototype.nb$inplace_rshift = Sk.builtin.nmber.prototype.nb$rshift;\n\n/**\n * @deprecated Please use Sk.builtin.int_ or Sk.builtin.float_ instead.\n */\nSk.builtin.nmber.prototype.nb$negative = function () {\n    throw deprecatedError;\n};\n\n/**\n * @deprecated Please use Sk.builtin.int_ or Sk.builtin.float_ instead.\n */\nSk.builtin.nmber.prototype.nb$positive = function () {\n    throw deprecatedError;\n};\n\n/**\n * @deprecated Please use Sk.builtin.int_ or Sk.builtin.float_ instead.\n */\nSk.builtin.nmber.prototype.nb$nonzero = function () {\n    throw deprecatedError;\n};\n\n/**\n * @deprecated Please use Sk.builtin.int_ or Sk.builtin.float_ instead.\n */\nSk.builtin.nmber.prototype.nb$isnegative = function () {\n    throw deprecatedError;\n};\n\n/**\n * @deprecated Please use Sk.builtin.int_ or Sk.builtin.float_ instead.\n */\nSk.builtin.nmber.prototype.nb$ispositive = function () {\n    throw deprecatedError;\n};\n\n/**\n * @deprecated Please use Sk.builtin.int_ or Sk.builtin.float_ instead.\n */\nSk.builtin.nmber.prototype.numberCompare = function (other) {\n    throw deprecatedError;\n};\n\n/**\n * @deprecated Please use Sk.builtin.int_ or Sk.builtin.float_ instead.\n */\nSk.builtin.nmber.prototype.__eq__ = function (me, other) {\n    throw deprecatedError;\n};\n\n/**\n * @deprecated Please use Sk.builtin.int_ or Sk.builtin.float_ instead.\n */\nSk.builtin.nmber.prototype.__ne__ = function (me, other) {\n    throw deprecatedError;\n};\n\n/**\n * @deprecated Please use Sk.builtin.int_ or Sk.builtin.float_ instead.\n */\nSk.builtin.nmber.prototype.__lt__ = function (me, other) {\n    throw deprecatedError;\n};\n\n/**\n * @deprecated Please use Sk.builtin.int_ or Sk.builtin.float_ instead.\n */\nSk.builtin.nmber.prototype.__le__ = function (me, other) {\n    throw deprecatedError;\n};\n\n/**\n * @deprecated Please use Sk.builtin.int_ or Sk.builtin.float_ instead.\n */\nSk.builtin.nmber.prototype.__gt__ = function (me, other) {\n    throw deprecatedError;\n};\n\n/**\n * @deprecated Please use Sk.builtin.int_ or Sk.builtin.float_ instead.\n */\nSk.builtin.nmber.prototype.__ge__ = function (me, other) {\n    throw deprecatedError;\n};\n\n/**\n * @deprecated Please use Sk.builtin.int_ or Sk.builtin.float_ instead.\n */\nSk.builtin.nmber.prototype.round$ = function (self, ndigits) {\n    throw deprecatedError;\n};\n\n/**\n * @deprecated Please use Sk.builtin.int_ or Sk.builtin.float_ instead.\n */\nSk.builtin.nmber.prototype[\"$r\"] = function () {\n    throw deprecatedError;\n};\n\n/**\n * @deprecated Please use Sk.builtin.int_ or Sk.builtin.float_ instead.\n */\nSk.builtin.nmber.prototype.tp$str = function () {\n    throw deprecatedError;\n};\n\n/**\n * @deprecated Please use Sk.builtin.int_ or Sk.builtin.float_ instead.\n */\nSk.builtin.nmber.prototype.str$ = function (base, sign) {\n    throw deprecatedError;\n};\n\nSk.exportSymbol(\"Sk.builtin.nmber\", Sk.builtin.nmber);\n\n\n/***/ }),\n/* 30 */\n/***/ (function(module, exports) {\n\n/* global Sk: true, goog:true */\n\n// long aka \"bignumber\" implementation\n//\n//  Using javascript BigInteger by Tom Wu\n/**\n * @constructor\n * Sk.builtin.lng\n *\n * @description\n * Constructor for Python long. Also used for builtin long().\n *\n * @extends {Sk.builtin.numtype}\n *\n * @param {*} x Object or number to convert to Python long.\n * @param {number=} base Optional base.\n * @return {Sk.builtin.lng} Python long\n */\nSk.builtin.lng = function (x, base) {   /* long is a reserved word */\n    base = Sk.builtin.asnum$(base);\n    if (!(this instanceof Sk.builtin.lng)) {\n        return new Sk.builtin.lng(x, base);\n    }\n\n\n    if (x === undefined) {\n        this.biginteger = new Sk.builtin.biginteger(0);\n        return this;\n    }\n    if (x instanceof Sk.builtin.lng) {\n        this.biginteger = x.biginteger.clone();\n        return this;\n    }\n    if (x instanceof Sk.builtin.biginteger) {\n        this.biginteger = x;\n        return this;\n    }\n    if (x instanceof String || typeof x === \"string\") {\n        return Sk.longFromStr(x, base);\n    }\n    if (x instanceof Sk.builtin.str) {\n        return Sk.longFromStr(x.v, base);\n    }\n\n    if ((x !== undefined) && (!Sk.builtin.checkString(x) && !Sk.builtin.checkNumber(x))) {\n        if (x === true) {\n            x = 1;\n        } else if (x === false) {\n            x = 0;\n        } else {\n            throw new Sk.builtin.TypeError(\"long() argument must be a string or a number, not '\" + Sk.abstr.typeName(x) + \"'\");\n        }\n    }\n\n    x = Sk.builtin.asnum$nofloat(x);\n    this.biginteger = new Sk.builtin.biginteger(x);\n    return this;\n};\n\nSk.abstr.setUpInheritance(\"long\", Sk.builtin.lng, Sk.builtin.numtype);\n\n/* NOTE: See constants used for kwargs in constants.js */\n\nSk.builtin.lng.prototype.tp$index = function () {\n    return parseInt(this.str$(10, true), 10);\n};\n\nSk.builtin.lng.prototype.tp$hash = function () {\n    return new Sk.builtin.int_(this.tp$index());\n};\n\nSk.builtin.lng.prototype.nb$int_ = function() {\n    if (this.cantBeInt()) {\n        return new Sk.builtin.lng(this);\n    }\n\n    return new Sk.builtin.int_(this.toInt$());\n};\n\nSk.builtin.lng.prototype.__format__= function (obj, format_spec) {\n    var formatstr;\n    Sk.builtin.pyCheckArgsLen(\"__format__\", arguments.length, 2, 2);\n\n    if (!Sk.builtin.checkString(format_spec)) {\n        if (Sk.__future__.exceptions) {\n            throw new Sk.builtin.TypeError(\"format() argument 2 must be str, not \" + Sk.abstr.typeName(format_spec));\n        } else {\n            throw new Sk.builtin.TypeError(\"format expects arg 2 to be string or unicode, not \" + Sk.abstr.typeName(format_spec));\n        }\n    } else {\n        formatstr = Sk.ffi.remapToJs(format_spec);\n        if (formatstr !== \"\") {\n            throw new Sk.builtin.NotImplementedError(\"format spec is not yet implemented\");\n        }\n    }\n\n    return new Sk.builtin.str(obj);\n};\n\nSk.builtin.lng.prototype.round$ = function (self, ndigits) {\n    Sk.builtin.pyCheckArgsLen(\"__round__\", arguments.length, 1, 2);\n\n    var result, multiplier, number, num10, rounded, bankRound, ndigs;\n\n    if ((ndigits !== undefined) && !Sk.misceval.isIndex(ndigits)) {\n        throw new Sk.builtin.TypeError(\"'\" + Sk.abstr.typeName(ndigits) + \"' object cannot be interpreted as an index\");\n    }\n\n    number = Sk.builtin.asnum$(self);\n    if (ndigits === undefined) {\n        ndigs = 0;\n    } else {\n        ndigs = Sk.misceval.asIndex(ndigits);\n    }\n\n    if (Sk.__future__.bankers_rounding) {\n        num10 = number * Math.pow(10, ndigs);\n        rounded = Math.round(num10);\n        bankRound = (((((num10>0)?num10:(-num10))%1)===0.5)?(((0===(rounded%2)))?rounded:(rounded-1)):rounded);\n        result = bankRound / Math.pow(10, ndigs);\n        return new Sk.builtin.lng(result);\n    } else {\n        multiplier = Math.pow(10, ndigs);\n        result = Math.round(number * multiplier) / multiplier;\n\n        return new Sk.builtin.lng(result);\n    }\n};\n\nSk.builtin.lng.prototype.__index__ = new Sk.builtin.func(function(self) {\n    return self.nb$int_(self);\n});\n\nSk.builtin.lng.prototype.nb$lng_ = function () {\n    return this;\n};\n\nSk.builtin.lng.prototype.nb$float_ = function() {\n    return new Sk.builtin.float_(Sk.ffi.remapToJs(this));\n};\n\n//    Threshold to determine when types should be converted to long\n//Sk.builtin.lng.threshold$ = Sk.builtin.int_.threshold$;\n\nSk.builtin.lng.MAX_INT$ = new Sk.builtin.lng(Sk.builtin.int_.threshold$);\nSk.builtin.lng.MIN_INT$ = new Sk.builtin.lng(-Sk.builtin.int_.threshold$);\n\nSk.builtin.lng.prototype.cantBeInt = function () {\n    return (this.longCompare(Sk.builtin.lng.MAX_INT$) > 0) || (this.longCompare(Sk.builtin.lng.MIN_INT$) < 0);\n};\n\nSk.builtin.lng.fromInt$ = function (ival) {\n    return new Sk.builtin.lng(ival);\n};\n\n// js string (not Sk.builtin.str) -> long. used to create longs in transformer, respects\n// 0x, 0o, 0b, etc.\nSk.longFromStr = function (s, base) {\n    // l/L are valid digits with base >= 22\n    // Sk.asserts.assert(s.charAt(s.length - 1) !== \"L\" && s.charAt(s.length - 1) !== 'l', \"L suffix should be removed before here\");\n\n    var parser = function (s, base) {\n            if (base === 10) {\n                return new Sk.builtin.biginteger(s);\n            }\n            return new Sk.builtin.biginteger(s, base);\n        },\n        biginteger = Sk.str2number(s, base, parser, function (x) {\n            return x.negate();\n        }, \"long\");\n\n    return new Sk.builtin.lng(biginteger);\n};\nSk.exportSymbol(\"Sk.longFromStr\", Sk.longFromStr);\n\nSk.builtin.lng.prototype.toInt$ = function () {\n    return this.biginteger.intValue();\n};\n\nSk.builtin.lng.prototype.clone = function () {\n    return new Sk.builtin.lng(this);\n};\n\nSk.builtin.lng.prototype.conjugate = new Sk.builtin.func(function (self) {\n    return self.clone();\n});\n\nSk.builtin.lng.prototype.nb$add = function (other) {\n    var thisAsFloat;\n\n    if (other instanceof Sk.builtin.float_) {\n        thisAsFloat = new Sk.builtin.float_(this.str$(10, true));\n        return thisAsFloat.nb$add(other);\n    }\n\n    if (other instanceof Sk.builtin.int_) {\n        //    Promote an int to long\n        other = new Sk.builtin.lng(other.v);\n    }\n\n    if (other instanceof Sk.builtin.lng) {\n        return new Sk.builtin.lng(this.biginteger.add(other.biginteger));\n    }\n\n    if (other instanceof Sk.builtin.biginteger) {\n        return new Sk.builtin.lng(this.biginteger.add(other));\n    }\n\n    return Sk.builtin.NotImplemented.NotImplemented$;\n};\n\n/** @override */\nSk.builtin.lng.prototype.nb$reflected_add = function (other) {\n    // Should not automatically call this.nb$add, as nb$add may have\n    // been overridden by a subclass\n    return Sk.builtin.lng.prototype.nb$add.call(this, other);\n};\n\nSk.builtin.lng.prototype.nb$inplace_add = Sk.builtin.lng.prototype.nb$add;\n\nSk.builtin.lng.prototype.nb$subtract = function (other) {\n    var thisAsFloat;\n\n    if (other instanceof Sk.builtin.float_) {\n        thisAsFloat = new Sk.builtin.float_(this.str$(10, true));\n        return thisAsFloat.nb$subtract(other);\n    }\n\n    if (other instanceof Sk.builtin.int_) {\n        //    Promote an int to long\n        other = new Sk.builtin.lng(other.v);\n    }\n\n    if (other instanceof Sk.builtin.lng) {\n        return new Sk.builtin.lng(this.biginteger.subtract(other.biginteger));\n    }\n\n    if (other instanceof Sk.builtin.biginteger) {\n        return new Sk.builtin.lng(this.biginteger.subtract(other));\n    }\n\n    return Sk.builtin.NotImplemented.NotImplemented$;\n};\n\n/** @override */\nSk.builtin.lng.prototype.nb$reflected_subtract = function (other) {\n    // Should not automatically call this.nb$add, as nb$add may have\n    // been overridden by a subclass\n    var negative_this = this.nb$negative();\n    return Sk.builtin.lng.prototype.nb$add.call(negative_this, other);\n};\n\nSk.builtin.lng.prototype.nb$inplace_subtract = Sk.builtin.lng.prototype.nb$subtract;\n\nSk.builtin.lng.prototype.nb$multiply = function (other) {\n    var thisAsFloat;\n\n    if (other instanceof Sk.builtin.float_) {\n        thisAsFloat = new Sk.builtin.float_(this.str$(10, true));\n        return thisAsFloat.nb$multiply(other);\n    }\n\n    if (other instanceof Sk.builtin.int_) {\n        other = new Sk.builtin.lng(other.v);\n    }\n\n    if (other instanceof Sk.builtin.lng) {\n        return new Sk.builtin.lng(this.biginteger.multiply(other.biginteger));\n    }\n\n    if (other instanceof Sk.builtin.biginteger) {\n        return new Sk.builtin.lng(this.biginteger.multiply(other));\n    }\n\n    return Sk.builtin.NotImplemented.NotImplemented$;\n};\n\n/** @override */\nSk.builtin.lng.prototype.nb$reflected_multiply = function (other) {\n    // Should not automatically call this.nb$multiply, as nb$multiply may have\n    // been overridden by a subclass\n    return Sk.builtin.lng.prototype.nb$multiply.call(this, other);\n};\n\nSk.builtin.lng.prototype.nb$inplace_multiply = Sk.builtin.lng.prototype.nb$multiply;\n\nSk.builtin.lng.prototype.nb$divide = function (other) {\n    var thisAsFloat, thisneg, otherneg, result;\n\n    if (other instanceof Sk.builtin.float_) {\n        thisAsFloat = new Sk.builtin.float_(this.str$(10, true));\n        return thisAsFloat.nb$divide(other);\n    }\n\n    if (other instanceof Sk.builtin.int_) {\n        //    Promote an int to long\n        other = new Sk.builtin.lng(other.v);\n    }\n\n    //    Standard, long result mode\n\n    if (other instanceof Sk.builtin.lng) {\n        //    Special logic to round DOWN towards negative infinity for negative results\n        thisneg = this.nb$isnegative();\n        otherneg = other.nb$isnegative();\n        if ((thisneg && !otherneg) || (otherneg && !thisneg)) {\n            result = this.biginteger.divideAndRemainder(other.biginteger);\n            //    If remainder is zero or positive, just return division result\n            if (result[1].trueCompare(Sk.builtin.biginteger.ZERO) === 0) {\n                //    No remainder, just return result\n                return new Sk.builtin.lng(result[0]);\n            }\n            //    Reminder... subtract 1 from the result (like rounding to neg infinity)\n            result = result[0].subtract(Sk.builtin.biginteger.ONE);\n            return new Sk.builtin.lng(result);\n        }\n        return new Sk.builtin.lng(this.biginteger.divide(other.biginteger));\n    }\n\n    return Sk.builtin.NotImplemented.NotImplemented$;\n};\n\nSk.builtin.lng.prototype.nb$reflected_divide = function (other) {\n    var thisneg, otherneg, result;\n\n    if (other instanceof Sk.builtin.int_) {\n        //  Promote an int to long\n        other = new Sk.builtin.lng(other.v);\n    }\n\n    //    Standard, long result mode\n    if (other instanceof Sk.builtin.lng) {\n        return other.nb$divide(this);\n    }\n\n    return Sk.builtin.NotImplemented.NotImplemented$;\n};\n\nSk.builtin.lng.prototype.nb$floor_divide = function (other) {\n    var thisAsFloat;\n\n    if (other instanceof Sk.builtin.float_) {\n        thisAsFloat = new Sk.builtin.float_(this.str$(10, true));\n        return thisAsFloat.nb$floor_divide(other);\n    }\n\n    if (other instanceof Sk.builtin.int_) {\n        //  Promote an int to long\n        other = new Sk.builtin.lng(other.v);\n    }\n\n    //    Standard, long result mode\n    if (other instanceof Sk.builtin.lng) {\n        return other.nb$divide(this);\n    }\n\n    return Sk.builtin.NotImplemented.NotImplemented$;\n};\n\nSk.builtin.lng.prototype.nb$divmod = function (other) {\n    if (other instanceof Sk.builtin.int_) {\n        // Promote an int to long\n        other = new Sk.builtin.lng(other.v);\n    }\n\n    if (other instanceof Sk.builtin.lng) {\n        return new Sk.builtin.tuple([\n            this.nb$floor_divide(other),\n            this.nb$remainder(other)\n        ]);\n    }\n\n    return Sk.builtin.NotImplemented.NotImplemented$;\n};\n\nSk.builtin.lng.prototype.nb$reflected_divmod = function (other) {\n    if (other instanceof Sk.builtin.int_) {\n        // Promote an int to long\n        other = new Sk.builtin.lng(other.v);\n    }\n\n    if (other instanceof Sk.builtin.lng) {\n        return new Sk.builtin.tuple([\n            other.nb$floor_divide(this),\n            other.nb$remainder(this)\n        ]);\n    }\n\n    return Sk.builtin.NotImplemented.NotImplemented$;\n};\n\nSk.builtin.lng.prototype.nb$inplace_divide = Sk.builtin.lng.prototype.nb$divide;\n\nSk.builtin.lng.prototype.nb$floor_divide = Sk.builtin.lng.prototype.nb$divide;\n\nSk.builtin.lng.prototype.nb$reflected_floor_divide = Sk.builtin.lng.prototype.nb$reflected_divide;\n\nSk.builtin.lng.prototype.nb$inplace_floor_divide = Sk.builtin.lng.prototype.nb$floor_divide;\n\nSk.builtin.lng.prototype.nb$remainder = function (other) {\n    var thisAsFloat, tmp;\n\n    if (this.biginteger.trueCompare(Sk.builtin.biginteger.ZERO) === 0) {\n        if (other instanceof Sk.builtin.float_) {\n            return new Sk.builtin.float_(0);\n        }\n        return new Sk.builtin.lng(0);\n    }\n\n    if (other instanceof Sk.builtin.float_) {\n        thisAsFloat = new Sk.builtin.float_(this.str$(10, true));\n        return thisAsFloat.nb$remainder(other);\n    }\n\n    if (other instanceof Sk.builtin.int_) {\n        //    Promote an int to long\n        other = new Sk.builtin.lng(other.v);\n    }\n\n    if (other instanceof Sk.builtin.lng) {\n\n        tmp = new Sk.builtin.lng(this.biginteger.remainder(other.biginteger));\n        if (this.nb$isnegative()) {\n            if (other.nb$ispositive() && tmp.nb$nonzero()) {\n                tmp = tmp.nb$add(other).nb$remainder(other);\n            }\n        } else {\n            if (other.nb$isnegative() && tmp.nb$nonzero()) {\n                tmp = tmp.nb$add(other);\n            }\n        }\n        return tmp;\n    }\n\n    return Sk.builtin.NotImplemented.NotImplemented$;\n};\n\nSk.builtin.lng.prototype.nb$reflected_remainder = function (other) {\n    if (other instanceof Sk.builtin.int_) {\n        other = new Sk.builtin.lng(other.v);\n    }\n\n    if (other instanceof Sk.builtin.lng) {\n        return other.nb$remainder(this);\n    }\n\n    return Sk.builtin.NotImplemented.NotImplemented$;\n};\n\nSk.builtin.lng.prototype.nb$inplace_remainder = Sk.builtin.lng.prototype.nb$remainder;\n\nSk.builtin.lng.prototype.nb$divmod = function (other) {\n    var thisAsFloat;\n\n    if (other === Sk.builtin.bool.true$) {\n        other = new Sk.builtin.lng(1);\n    }\n\n    if (other === Sk.builtin.bool.false$) {\n        other = new Sk.builtin.lng(0);\n    }\n\n    if (other instanceof Sk.builtin.int_) {\n        other = new Sk.builtin.lng(other.v);\n    }\n\n    if (other instanceof Sk.builtin.lng) {\n        return new Sk.builtin.tuple([\n            this.nb$floor_divide(other),\n            this.nb$remainder(other)\n        ]);\n    }\n\n    if (other instanceof Sk.builtin.float_) {\n        thisAsFloat = new Sk.builtin.float_(this.str$(10, true));\n        return thisAsFloat.nb$divmod(other);\n    }\n\n    return Sk.builtin.NotImplemented.NotImplemented$;\n};\n\n/**\n * @param {number|Object} n\n * @param {number|Object=} mod\n * @suppress {checkTypes}\n */\nSk.builtin.lng.prototype.nb$power = function (n, mod) {\n    var thisAsFloat;\n    if (mod !== undefined) {\n        n = new Sk.builtin.biginteger(Sk.builtin.asnum$(n));\n        mod = new Sk.builtin.biginteger(Sk.builtin.asnum$(mod));\n\n        return new Sk.builtin.lng(this.biginteger.modPowInt(n, mod));\n    }\n\n    if (n instanceof Sk.builtin.float_ ||\n        (n instanceof Sk.builtin.int_ && n.v < 0)) {\n        thisAsFloat = new Sk.builtin.float_(this.str$(10, true));\n        return thisAsFloat.nb$power(n);\n    }\n\n    if (n instanceof Sk.builtin.int_) {\n        //    Promote an int to long\n        n = new Sk.builtin.lng(n.v);\n    }\n\n    if (n instanceof Sk.builtin.lng) {\n        if (mod !== undefined) {\n            n = new Sk.builtin.biginteger(Sk.builtin.asnum$(n));\n            mod = new Sk.builtin.biginteger(Sk.builtin.asnum$(mod));\n\n            return new Sk.builtin.lng(this.biginteger.modPowInt(n, mod));\n        }\n\n        if (n.nb$isnegative()) {\n            thisAsFloat = new Sk.builtin.float_(this.str$(10, true));\n            return thisAsFloat.nb$power(n);\n        }\n        return new Sk.builtin.lng(this.biginteger.pow(n.biginteger));\n    }\n\n    if (n instanceof Sk.builtin.biginteger) {\n        if (mod !== undefined) {\n            mod = new Sk.builtin.biginteger(Sk.builtin.asnum$(mod));\n\n            return new Sk.builtin.lng(this.biginteger.modPowInt(n, mod));\n        }\n\n        if (n.isnegative()) {\n            thisAsFloat = new Sk.builtin.float_(this.str$(10, true));\n            return thisAsFloat.nb$power(n);\n        }\n        return new Sk.builtin.lng(this.biginteger.pow(n));\n    }\n\n    return Sk.builtin.NotImplemented.NotImplemented$;\n};\n\nSk.builtin.lng.prototype.nb$reflected_power = function (n, mod) {\n    if (n instanceof Sk.builtin.int_) {\n        // Promote an int to long\n        n = new Sk.builtin.lng(n.v);\n    }\n\n    if (n instanceof Sk.builtin.lng) {\n        return n.nb$power(this, mod);\n    }\n\n    return Sk.builtin.NotImplemented.NotImplemented$;\n};\n\nSk.builtin.lng.prototype.nb$inplace_power = Sk.builtin.lng.prototype.nb$power;\n\n/**\n * Compute the absolute value of this instance and return.\n *\n * Javascript function, returns Python object.\n *\n * @return {Sk.builtin.lng} The absolute value\n */\nSk.builtin.lng.prototype.nb$abs = function () {\n    return new Sk.builtin.lng(this.biginteger.bnAbs());\n};\n\nSk.builtin.lng.prototype.nb$lshift = function (other) {\n\n    if (other instanceof Sk.builtin.int_) {\n        //  Promote an int to long\n        other = new Sk.builtin.lng(other.v);\n    }\n\n    if (other instanceof Sk.builtin.lng) {\n        if (other.biginteger.signum() < 0) {\n            throw new Sk.builtin.ValueError(\"negative shift count\");\n        }\n        return new Sk.builtin.lng(this.biginteger.shiftLeft(other.biginteger));\n    }\n    if (other instanceof Sk.builtin.biginteger) {\n        if (other.signum() < 0) {\n            throw new Sk.builtin.ValueError(\"negative shift count\");\n        }\n        return new Sk.builtin.lng(this.biginteger.shiftLeft(other));\n    }\n\n    return Sk.builtin.NotImplemented.NotImplemented$;\n};\n\nSk.builtin.lng.prototype.nb$reflected_lshift = function (other) {\n    if (other instanceof Sk.builtin.int_) {\n        // Promote an int to long\n        other = new Sk.builtin.lng(other.v);\n    }\n\n    if (other instanceof Sk.builtin.lng) {\n        return other.nb$lshift(this);\n    }\n\n    return Sk.builtin.NotImplemented.NotImplemented$;\n};\n\nSk.builtin.lng.prototype.nb$inplace_lshift = Sk.builtin.lng.prototype.nb$lshift;\n\nSk.builtin.lng.prototype.nb$rshift = function (other) {\n    if (other instanceof Sk.builtin.int_) {\n        //  Promote an int to long\n        other = new Sk.builtin.lng(other.v);\n    }\n\n    if (other instanceof Sk.builtin.lng) {\n        if (other.biginteger.signum() < 0) {\n            throw new Sk.builtin.ValueError(\"negative shift count\");\n        }\n        return new Sk.builtin.lng(this.biginteger.shiftRight(other.biginteger));\n    }\n    if (other instanceof Sk.builtin.biginteger) {\n        if (other.signum() < 0) {\n            throw new Sk.builtin.ValueError(\"negative shift count\");\n        }\n        return new Sk.builtin.lng(this.biginteger.shiftRight(other));\n    }\n\n    return Sk.builtin.NotImplemented.NotImplemented$;\n};\n\nSk.builtin.lng.prototype.nb$reflected_rshift = function (other) {\n    if (other instanceof Sk.builtin.int_) {\n        // Promote an int to long\n        other = new Sk.builtin.lng(other.v);\n    }\n\n    if (other instanceof Sk.builtin.lng) {\n        return other.nb$rshift(this);\n    }\n\n    return Sk.builtin.NotImplemented.NotImplemented$;\n};\n\nSk.builtin.lng.prototype.nb$inplace_rshift = Sk.builtin.lng.prototype.nb$rshift;\n\nSk.builtin.lng.prototype.nb$and = function (other) {\n    if (other instanceof Sk.builtin.int_) {\n        //  Promote an int to long\n        other = new Sk.builtin.lng(other.v);\n    }\n\n    if (other instanceof Sk.builtin.lng) {\n        return new Sk.builtin.lng(this.biginteger.and(other.biginteger));\n    }\n    if (other instanceof Sk.builtin.biginteger) {\n        return new Sk.builtin.lng(this.biginteger.and(other));\n    }\n\n    return Sk.builtin.NotImplemented.NotImplemented$;\n};\n\nSk.builtin.lng.prototype.nb$reflected_and = Sk.builtin.lng.prototype.nb$and;\n\nSk.builtin.lng.prototype.nb$inplace_and = Sk.builtin.lng.prototype.nb$and;\n\nSk.builtin.lng.prototype.nb$or = function (other) {\n    if (other instanceof Sk.builtin.int_) {\n        //  Promote an int to long\n        other = new Sk.builtin.lng(other.v);\n    }\n\n    if (other instanceof Sk.builtin.lng) {\n        return new Sk.builtin.lng(this.biginteger.or(other.biginteger));\n    }\n    if (other instanceof Sk.builtin.biginteger) {\n        return new Sk.builtin.lng(this.biginteger.or(other));\n    }\n\n    return Sk.builtin.NotImplemented.NotImplemented$;\n};\n\n\nSk.builtin.lng.prototype.nb$reflected_or = Sk.builtin.lng.prototype.nb$or;\n\nSk.builtin.lng.prototype.nb$inplace_or = Sk.builtin.lng.prototype.nb$or;\n\nSk.builtin.lng.prototype.nb$xor = function (other) {\n    if (other instanceof Sk.builtin.int_) {\n        //  Promote an int to long\n        other = new Sk.builtin.lng(other.v);\n    }\n\n    if (other instanceof Sk.builtin.lng) {\n        return new Sk.builtin.lng(this.biginteger.xor(other.biginteger));\n    }\n    if (other instanceof Sk.builtin.biginteger) {\n        return new Sk.builtin.lng(this.biginteger.xor(other));\n    }\n\n    return Sk.builtin.NotImplemented.NotImplemented$;\n};\n\nSk.builtin.lng.prototype.nb$reflected_xor = Sk.builtin.lng.prototype.nb$xor;\n\nSk.builtin.lng.prototype.nb$inplace_xor = Sk.builtin.lng.prototype.nb$xor;\n\n/**\n * @override\n *\n * @return {Sk.builtin.lng} A copy of this instance with the value negated.\n */\nSk.builtin.lng.prototype.nb$negative = function () {\n    return new Sk.builtin.lng(this.biginteger.negate());\n};\n\nSk.builtin.lng.prototype.nb$invert = function () {\n    return new Sk.builtin.lng(this.biginteger.not());\n};\n\nSk.builtin.lng.prototype.nb$positive = function () {\n    return this.clone();\n};\n\nSk.builtin.lng.prototype.nb$nonzero = function () {\n    return this.biginteger.trueCompare(Sk.builtin.biginteger.ZERO) !== 0;\n};\n\nSk.builtin.lng.prototype.nb$isnegative = function () {\n    return this.biginteger.isnegative();\n};\n\nSk.builtin.lng.prototype.nb$ispositive = function () {\n    return !this.biginteger.isnegative();\n};\n\nSk.builtin.lng.prototype.longCompare = function (other) {\n    var otherAsLong, thisAsFloat;\n\n    if (typeof other === \"number\") {\n        other = new Sk.builtin.lng(other);\n    }\n\n    if (other instanceof Sk.builtin.int_ ||\n        (other instanceof Sk.builtin.float_ && other.v % 1 === 0)) {\n        otherAsLong = new Sk.builtin.lng(other.v);\n        return this.longCompare(otherAsLong);\n    }\n\n    if (other instanceof Sk.builtin.float_) {\n        thisAsFloat = new Sk.builtin.float_(this);\n        return thisAsFloat.numberCompare(other);\n    }\n\n    if (other instanceof Sk.builtin.lng) {\n        return this.biginteger.subtract(other.biginteger);\n    } else if (other instanceof Sk.builtin.biginteger) {\n        return this.biginteger.subtract(other);\n    }\n\n    return Sk.builtin.NotImplemented.NotImplemented$;\n};\n\n//tests fail if ===\nSk.builtin.lng.prototype.ob$eq = function (other) {\n    if (other instanceof Sk.builtin.int_ || other instanceof Sk.builtin.lng ||\n        other instanceof Sk.builtin.float_) {\n        return new Sk.builtin.bool(this.longCompare(other) == 0); //jshint ignore:line\n    } else if (other instanceof Sk.builtin.none) {\n        return Sk.builtin.bool.false$;\n    } else {\n        return Sk.builtin.NotImplemented.NotImplemented$;\n    }\n};\n\nSk.builtin.lng.prototype.ob$ne = function (other) {\n    if (other instanceof Sk.builtin.int_ || other instanceof Sk.builtin.lng ||\n        other instanceof Sk.builtin.float_) {\n        return new Sk.builtin.bool(this.longCompare(other) != 0); //jshint ignore:line\n    } else if (other instanceof Sk.builtin.none) {\n        return Sk.builtin.bool.true$;\n    } else {\n        return Sk.builtin.NotImplemented.NotImplemented$;\n    }\n};\n\nSk.builtin.lng.prototype.ob$lt = function (other) {\n    if (other instanceof Sk.builtin.int_ || other instanceof Sk.builtin.lng ||\n        other instanceof Sk.builtin.float_) {\n        return new Sk.builtin.bool(this.longCompare(other) < 0);\n    } else {\n        return Sk.builtin.NotImplemented.NotImplemented$;\n    }\n};\n\nSk.builtin.lng.prototype.ob$le = function (other) {\n    if (other instanceof Sk.builtin.int_ || other instanceof Sk.builtin.lng ||\n        other instanceof Sk.builtin.float_) {\n        return new Sk.builtin.bool(this.longCompare(other) <= 0);\n    } else {\n        return Sk.builtin.NotImplemented.NotImplemented$;\n    }\n};\n\nSk.builtin.lng.prototype.ob$gt = function (other) {\n    if (other instanceof Sk.builtin.int_ || other instanceof Sk.builtin.lng ||\n        other instanceof Sk.builtin.float_) {\n        return new Sk.builtin.bool(this.longCompare(other) > 0);\n    } else {\n        return Sk.builtin.NotImplemented.NotImplemented$;\n    }\n};\n\nSk.builtin.lng.prototype.ob$ge = function (other) {\n    if (other instanceof Sk.builtin.int_ || other instanceof Sk.builtin.lng ||\n        other instanceof Sk.builtin.float_) {\n        return new Sk.builtin.bool(this.longCompare(other) >= 0);\n    } else {\n        return Sk.builtin.NotImplemented.NotImplemented$;\n    }\n};\n\nSk.builtin.lng.prototype.$r = function () {\n    return new Sk.builtin.str(this.str$(10, true) + \"L\");\n};\n\nSk.builtin.lng.prototype.tp$str = function () {\n    return new Sk.builtin.str(this.str$(10, true));\n};\n\nSk.builtin.lng.prototype.str$ = function (base, sign) {\n    var work;\n    if (sign === undefined) {\n        sign = true;\n    }\n\n    work = sign ? this.biginteger : this.biginteger.abs();\n\n    if (base === undefined || base === 10) {\n        return work.toString();\n    }\n\n    //    Another base... convert...\n    return work.toString(base);\n};\n\n\n/***/ }),\n/* 31 */\n/***/ (function(module, exports) {\n\n/**\n * hypot is a ESCMA6 function and maybe not available across all browsers\n */\nMath.hypot = Math.hypot || function() {\n    var y = 0;\n    var length = arguments.length;\n\n    for (var i = 0; i < length; i++) {\n        if (arguments[i] === Infinity || arguments[i] === -Infinity) {\n            return Infinity;\n        }\n        y += arguments[i] * arguments[i];\n    }\n    return Math.sqrt(y);\n};\n\n/**\n * complex_new see https://hg.python.org/cpython/file/f0e2caad4200/Objects/complexobject.c#l911\n * @constructor\n * @param {Object} real part of the complex number\n * @param {?Object=} imag part of the complex number\n * @this {Sk.builtin.object}\n *\n * Prefering here == instead of ===, otherwise also undefined has to be matched explicitly\n *\n * FIXME: it seems that we somehow need to call __float__/__int__ if arguments provide those methods\n *\n */\nSk.builtin.complex = function (real, imag) {\n    Sk.builtin.pyCheckArgsLen(\"complex\", arguments.length, 0, 2);\n\n    var r, i, tmp; // PyObject\n    var nbr, nbi; // real, imag as numbers\n    var own_r = false;\n    var cr = {}; // PyComplexObject\n    var ci = {}; // PyComplexObject\n    var cr_is_complex = false;\n    var ci_is_complex = false;\n\n    // not sure why this is required\n    if (!(this instanceof Sk.builtin.complex)) {\n        return new Sk.builtin.complex(real, imag);\n    }\n\n\n    // check if kwargs\n    // ToDo: this is only a temporary replacement\n    r = real == null ? Sk.builtin.bool.false$ : real; // r = Py_False;\n    i = imag;\n\n    // handle case if passed in arguments are of type complex\n    if (r instanceof Sk.builtin.complex && i == null) {\n        return real;\n    }\n\n    if (r != null && Sk.builtin.checkString(r)) {\n        if(i != null) {\n            throw new Sk.builtin.TypeError(\"complex() can't take second arg if first is a string\");\n        }\n\n        return Sk.builtin.complex.complex_subtype_from_string(r);\n    }\n\n    if (i != null && Sk.builtin.checkString(i)) {\n        throw new Sk.builtin.TypeError(\"complex() second arg can't be a string\");\n    }\n\n\n    // try_complex_special_method\n    tmp = Sk.builtin.complex.try_complex_special_method(r);\n    if (tmp != null && tmp !== Sk.builtin.NotImplemented.NotImplemented$) {\n        if (!Sk.builtin.checkComplex(tmp)) {\n            throw new Sk.builtin.TypeError(\"__complex__ should return a complex object\");\n        }\n\n        r = tmp;\n    }\n\n    // this check either returns a javascript number or the passed object\n    // but it actually, should check for r->ob_type->tp_as_number\n    // this check is useless\n    nbr = Sk.builtin.asnum$(r);\n    if (i != null) {\n        nbi = Sk.builtin.asnum$(i);\n    }\n\n    // this function mimics the tp_as_number->nb_float check in cpython\n    var nb_float = function(op) {\n        if(Sk.builtin.checkNumber(op)) {\n            return true;\n        }\n\n        if(Sk.builtin.type.typeLookup(op.ob$type, Sk.builtin.str.$float_) !== undefined) {\n            return true;\n        }\n    };\n\n    // check for valid arguments\n    if (nbr == null || (!nb_float(r) && !Sk.builtin.checkComplex(r)) || ((i != null) && (nbi == null || (!nb_float(i) && !Sk.builtin.checkComplex(i))))) {\n        throw new Sk.builtin.TypeError(\"complex() argument must be a string or number\");\n    }\n\n    /* If we get this far, then the \"real\" and \"imag\" parts should\n       both be treated as numbers, and the constructor should return a\n       complex number equal to (real + imag*1j).\n\n       Note that we do NOT assume the input to already be in canonical\n       form; the \"real\" and \"imag\" parts might themselves be complex\n       numbers, which slightly complicates the code below. */\n\n    if (Sk.builtin.complex._complex_check(r)) {\n        /* Note that if r is of a complex subtype, we're only\n        retaining its real & imag parts here, and the return\n        value is (properly) of the builtin complex type. */\n        cr.real = r.real.v;\n        cr.imag = r.imag.v;\n        cr_is_complex = true;\n    } else {\n        /* The \"real\" part really is entirely real, and contributes\n        nothing in the imaginary direction.\n        Just treat it as a double. */\n        tmp = Sk.builtin.float_.PyFloat_AsDouble(r); // tmp = PyNumber_Float(r);\n\n        if (tmp == null) {\n            return null;\n        }\n\n        cr.real = tmp;\n        cr.imag = 0.0;\n    }\n\n    if (i == null) {\n        ci.real = 0.0;\n    } else if (Sk.builtin.complex._complex_check(i)) {\n        ci.real = i.real.v;\n        ci.imag = i.imag.v;\n        ci_is_complex = true;\n    } else {\n        /* The \"imag\" part really is entirely imaginary, and\n        contributes nothing in the real direction.\n        Just treat it as a double. */\n        tmp = Sk.builtin.float_.PyFloat_AsDouble(i);\n\n        if (tmp == null) {\n            return null;\n        }\n\n        ci.real = tmp;\n        ci.imag = 0.0;\n    }\n\n    /*  If the input was in canonical form, then the \"real\" and \"imag\"\n    parts are real numbers, so that ci.imag and cr.imag are zero.\n    We need this correction in case they were not real numbers. */\n\n    if (ci_is_complex === true) {\n        cr.real -= ci.imag;\n    }\n\n    if (cr_is_complex === true) {\n        ci.real += cr.imag;\n    }\n\n    // adjust for negated imaginary literal\n    if (cr.real === 0 && (ci.real < 0 || Sk.builtin.complex._isNegativeZero(ci.real))) {\n        cr.real = -0;\n    }\n\n    // save them as properties\n    this.real = new Sk.builtin.float_(cr.real);\n    this.imag = new Sk.builtin.float_(ci.real);\n\n    return this;\n};\n\nSk.abstr.setUpInheritance(\"complex\", Sk.builtin.complex, Sk.builtin.numtype);\n//Sk.builtin.complex.co_kwargs = true;\n\nSk.builtin.complex.prototype.__class__ = Sk.builtin.complex;\n\nSk.builtin.complex.prototype.nb$int_ = function () {\n    throw new Sk.builtin.TypeError(\"can't convert complex to int\");\n};\n\nSk.builtin.complex.prototype.nb$float_ = function() {\n    throw new Sk.builtin.TypeError(\"can't convert complex to float\");\n};\n\nSk.builtin.complex.prototype.nb$lng = function () {\n    throw new Sk.builtin.TypeError(\"can't convert complex to long\");\n};\n\nSk.builtin.complex.prototype.__doc__ = new Sk.builtin.str(\"complex(real[, imag]) -> complex number\\n\\nCreate a complex number from a real part and an optional imaginary part.\\nThis is equivalent to (real + imag*1j) where imag defaults to 0.\");\n\nSk.builtin.complex._isNegativeZero = function (val) {\n    if (val !== 0) {\n        return false;\n    }\n\n    return 1/val === -Infinity;\n};\n\n/**\n * Internal method to check if op has __complex__\n */\nSk.builtin.complex.try_complex_special_method = function (op) {\n    var f; // PyObject\n    var res;\n\n    // return early\n    if (op == null) {\n        return null;\n    }\n\n    // the lookup special method does already all the magic\n    f = Sk.abstr.lookupSpecial(op, Sk.builtin.str.$complex);\n\n    if (f != null) {\n        // method on builtin, provide this arg\n        res = Sk.misceval.callsimArray(f, [op]);\n\n        return res;\n    }\n\n    return null;\n};\n\n/**\n    Check if given argument is number or complex and always\n    returns complex type.\n */\nSk.builtin.complex.check_number_or_complex = function (other) {\n    /* exit early */\n    if (!Sk.builtin.checkNumber(other) && other.tp$name !== \"complex\") {\n        throw new Sk.builtin.TypeError(\"unsupported operand type(s) for +: 'complex' and '\" + Sk.abstr.typeName(other) + \"'\");\n    }\n\n    /* converting to complex allows us to use always only one formula */\n    if (Sk.builtin.checkNumber(other)) {\n        other = new Sk.builtin.complex(other); // create complex\n    }\n\n    return other;\n};\n\n/**\n    Parses a string repr of a complex number\n */\nSk.builtin.complex.complex_subtype_from_string = function (val) {\n    var index;\n    var start;\n    var val_wws;              // val with removed beginning ws and (\n    var x = 0.0, y = 0.0;     // real, imag parts\n    var got_bracket = false;  // flag for braces\n    var len;                  // total length of val\n    var match;                // regex result\n\n    // first check if val is javascript string or python string\n    if (Sk.builtin.checkString(val)) {\n        val = Sk.ffi.remapToJs(val);\n    } else if (typeof val !== \"string\") {\n        throw new TypeError(\"provided unsupported string-alike argument\");\n    }\n\n    /* This is an python specific error, this does not do any harm in js, but we want\n     * to be as close to the orginial impl. as possible.\n     *\n     * Check also for empty strings. They are not allowed.\n     */\n    if (val.indexOf(\"\\0\") !== -1 || val.length === 0 || val === \"\") {\n        throw new Sk.builtin.ValueError(\"complex() arg is a malformed string\");\n    }\n\n    // transform to unicode\n    // ToDo: do we need this?\n    index = 0; // first char\n\n    // do some replacements for javascript floats\n    val = val.replace(/inf|infinity/gi, \"Infinity\");\n    val = val.replace(/nan/gi, \"NaN\");\n\n    /* position on first nonblank */\n    start = 0;\n    while (val[index] === \" \") {\n        index++;\n    }\n\n    if (val[index] === \"(\") {\n        /* skip over possible bracket from repr(). */\n        got_bracket = true;\n        index++;\n        while (val[index] === \" \") {\n            index++;\n        }\n    }\n\n    /* a valid complex string usually takes one of the three forms:\n\n        <float>                - real part only\n        <float>j               - imaginary part only\n        <float><signed-float>j - real and imaginary parts\n\n        where <float> represents any numeric string that's accepted by the\n        float constructor (including 'nan', 'inf', 'infinity', etc.), and\n        <signed-float> is any string of the form <float> whose first character\n        is '+' or '-'.\n\n        For backwards compatibility, the extra forms\n\n          <float><sign>j\n          <sign>j\n          j\n\n        are also accepted, though support for these forms my be removed from\n        a future version of Python.\n     *      This is a complete regular expression for matching any valid python floats, e.g.:\n     *          - 1.0\n     *          - 0.\n     *          - .1\n     *          - nan/inf/infinity\n     *          - +-1.0\n     *          - +3.E-3\n     *\n     *      In order to work, this pattern requires only lower case characters\n     *      There is case insensitive group option in js.\n     *\n     *      the [eE] could be refactored to soley e\n     */\n    var float_regex2 = /^(?:[+-]?(?:(?:(?:\\d*\\.\\d+)|(?:\\d+\\.?))(?:[eE][+-]?\\d+)?|NaN|Infinity))/;\n    val_wws = val.substr(index); // val with removed whitespace and \"(\"\n\n    /* first try to match a float at the beginning */\n    match = val_wws.match(float_regex2);\n    if (match !== null) {\n        // one of the first 4 cases\n        index += match[0].length;\n\n        /* <float>j */\n        if (val[index] === \"j\" || val[index] === \"J\") {\n            y = parseFloat(match[0]);\n            index++;\n        } else if(val[index] === \"+\" || val[index] === \"-\") {\n            /* <float><signed-float>j | <float><sign>j */\n            x = parseFloat(match[0]);\n\n            match = val.substr(index).match(float_regex2);\n            if (match !== null) {\n                /* <float><signed-float>j */\n                y = parseFloat(match[0]);\n                index += match[0].length;\n            } else {\n                /* <float><sign>j */\n                y = val[index] === \"+\" ? 1.0 : -1.0;\n                index++;\n            }\n\n            if (val[index] !== \"j\" && val[index] !== \"J\") {\n                throw new Sk.builtin.ValueError(\"complex() arg is malformed string\");\n            }\n\n            index++;\n        } else {\n            /* <float> */\n            x = parseFloat(match[0]);\n        }\n    } else {\n        // maybe <sign>j or j\n        match = match = val_wws.match(/^([+-]?[jJ])/);\n        if (match !== null) {\n            if (match[0].length === 1) {\n                y = 1.0; // must be j\n            } else {\n                y = match[0][0] === \"+\" ? 1.0 : -1.0;\n            }\n\n            index += match[0].length;\n        }\n    }\n\n    while (val[index] === \" \") {\n        index++;\n    }\n\n    if (got_bracket) {\n        /* if there was an opening parenthesis, then the corresponding\n           closing parenthesis should be right here */\n        if (val[index] !== \")\") {\n            throw new Sk.builtin.ValueError(\"complex() arg is malformed string\");\n        }\n\n        index++;\n\n        while (val[index] === \" \") {\n            index++;\n        }\n    }\n\n    /* we should now be at the end of the string */\n    if (val.length !== index) {\n        throw new Sk.builtin.ValueError(\"complex() arg is malformed string\");\n    }\n\n    // return here complex number parts\n    return new Sk.builtin.complex(new Sk.builtin.float_(x), new Sk.builtin.float_(y));\n};\n\n/**\n    _PyHASH_IMAG refers to _PyHASH_MULTIPLIER which refers to 1000003\n */\nSk.builtin.complex.prototype.tp$hash = function () {\n    return new Sk.builtin.int_(this.tp$getattr(Sk.builtin.str.$imag).v * 1000003 + this.tp$getattr(Sk.builtin.str.$real).v);\n};\n\nSk.builtin.complex.prototype.nb$add = function (other) {\n    var real;\n    var imag;\n\n    other = Sk.builtin.complex.check_number_or_complex(other);\n\n    real = this.tp$getattr(Sk.builtin.str.$real).v + other.tp$getattr(Sk.builtin.str.$real).v;\n    imag = this.tp$getattr(Sk.builtin.str.$imag).v + other.tp$getattr(Sk.builtin.str.$imag).v;\n\n    return new Sk.builtin.complex(new Sk.builtin.float_(real), new Sk.builtin.float_(imag));\n};\n\n/* internal subtract/diff function that calls internal float diff */\nSk.builtin.complex._c_diff = function (a, b) {\n    var r, i; // Py_Float\n    r = a.real.nb$subtract.call(a.real, b.real);\n    i = a.imag.nb$subtract.call(a.imag, b.imag);\n\n    return new Sk.builtin.complex(r, i);\n};\n\nSk.builtin.complex.prototype.nb$subtract = function (other) {\n    var result; // Py_complex\n    var a, b; // Py_complex\n\n    a = Sk.builtin.complex.check_number_or_complex(this);\n    b = Sk.builtin.complex.check_number_or_complex(other);\n\n    result = Sk.builtin.complex._c_diff(a, b);\n\n    return result;\n};\n\nSk.builtin.complex.prototype.nb$multiply = function (other) {\n    var real;\n    var imag;\n    var a, b; // Py_complex\n\n    a = this;\n    b = Sk.builtin.complex.check_number_or_complex(other);\n\n    real = a.real.v * b.real.v - a.imag.v * b.imag.v;\n    imag = a.real.v * b.imag.v + a.imag.v * b.real.v;\n\n    return new Sk.builtin.complex(new Sk.builtin.float_(real), new Sk.builtin.float_(imag));\n};\n\n/**\n * Otherwise google closure complains about ZeroDivisionError not being\n * defined\n * @suppress {missingProperties}\n *\n * implementation based on complexobject.c:c_quot\n */\nSk.builtin.complex.prototype.nb$divide = function (other) {\n    var real;\n    var imag;\n\n    other = Sk.builtin.complex.check_number_or_complex(other);\n\n    var ratio;\n    var denom;\n\n    // other == b\n    var breal = other.real.v;\n    var bimag = other.imag.v;\n    // this == a\n    var areal = this.real.v;\n    var aimag = this.imag.v;\n\n    var abs_breal = Math.abs(breal);\n    var abs_bimag = Math.abs(bimag);\n\n    if (abs_breal >= abs_bimag) {\n        // divide tops and bottom by breal\n        if (abs_breal === 0.0) {\n            throw new Sk.builtin.ZeroDivisionError(\"complex division by zero\");\n        } else {\n            ratio = bimag / breal;\n            denom = breal + bimag * ratio;\n            real = (areal + aimag * ratio) / denom;\n            imag = (aimag - areal * ratio) / denom;\n        }\n    } else if (abs_bimag >= abs_breal) {\n        // divide tops and bottom by b.imag\n        ratio = breal / bimag;\n        denom = breal * ratio + bimag;\n        Sk.asserts.assert(bimag !== 0.0);\n        real = (areal * ratio + aimag) / denom;\n        imag = (aimag * ratio - areal) / denom;\n    } else {\n        // At least one of b.real or b.imag is a NaN\n        real = NaN;\n        imag = NaN;\n    }\n\n    return new Sk.builtin.complex(new Sk.builtin.float_(real), new Sk.builtin.float_(imag));\n};\n\nSk.builtin.complex.prototype.nb$floor_divide = function (other) {\n    throw new Sk.builtin.TypeError(\"can't take floor of complex number.\");\n};\n\nSk.builtin.complex.prototype.nb$remainder = function (other) {\n    throw new Sk.builtin.TypeError(\"can't mod complex numbers.\");\n};\n\n/**\n * @param {?Object=} z, modulo operation\n */\nSk.builtin.complex.prototype.nb$power = function (other, z) {\n    var p;\n    var exponent;\n    var int_exponent;\n    var a, b;\n\n    // none is allowed\n    if (z != null && !Sk.builtin.checkNone(z)) {\n        throw new Sk.builtin.ValueError(\"complex modulo\");\n    }\n\n    a = this;\n    b = Sk.builtin.complex.check_number_or_complex(other);\n\n    exponent = b;\n    int_exponent = b.real.v | 0; // js convert to int\n    if (exponent.imag.v === 0.0 && exponent.real.v === int_exponent) {\n        p = Sk.builtin.complex.c_powi(a, int_exponent);\n    } else {\n        p = Sk.builtin.complex.c_pow(a, exponent);\n    }\n\n    return p;\n};\n\n// power of complex a and complex exponent b\nSk.builtin.complex.c_pow = function (a, b) {\n    var real, imag; // Py_complex\n\n    var vabs;\n    var len;\n    var at;\n    var phase;\n\n    // other == b\n    var breal = b.real.v;\n    var bimag = b.imag.v;\n    // this == a\n    var areal = a.real.v;\n    var aimag = a.imag.v;\n\n    if (breal === 0.0 && bimag === 0.0) {\n        real = 1.0;\n        imag = 0.0;\n    } else if (areal === 0.0 && aimag === 0.0) {\n        if(bimag !== 0.0 || breal < 0.0) {\n            throw new Sk.builtin.ZeroDivisionError(\"complex division by zero\");\n        }\n\n        real = 0.0;\n        imag = 0.0;\n    } else {\n        vabs = Math.hypot(areal, aimag);\n        len = Math.pow(vabs, breal);\n        at = Math.atan2(aimag, areal);\n        phase = at * breal;\n\n        if(bimag !== 0.0) {\n            len /= Math.exp(at * bimag);\n            phase += bimag * Math.log(vabs);\n        }\n\n        real = len * Math.cos(phase);\n        imag = len * Math.sin(phase);\n    }\n\n    return new Sk.builtin.complex(new Sk.builtin.float_(real), new Sk.builtin.float_(imag));\n};\n\n// power of complex x and integer exponent n\nSk.builtin.complex.c_powi = function (x, n) {\n    var cn; // Py_complex\n    var c1;\n\n    if (n > 100 || n < -100) {\n        cn = new Sk.builtin.complex(new Sk.builtin.float_(n), new Sk.builtin.float_(0.0));\n        return Sk.builtin.complex.c_pow(x, cn);\n    } else if (n > 0) {\n        return Sk.builtin.complex.c_powu(x, n);\n    } else {\n        //  return c_quot(c_1,c_powu(x,-n));\n        c1 = new Sk.builtin.complex(new Sk.builtin.float_(1.0), new Sk.builtin.float_(0.0));\n        return c1.nb$divide(Sk.builtin.complex.c_powu(x,-n));\n    }\n};\n\nSk.builtin.complex.c_powu = function (x, n) {\n    var r, p; // Py_complex\n    var mask = 1;\n    r = new Sk.builtin.complex(new Sk.builtin.float_(1.0), new Sk.builtin.float_(0.0));\n    p = x;\n\n    while (mask > 0 && n >= mask) {\n        if (n & mask) {\n            r = r.nb$multiply(p);\n        }\n\n        mask <<= 1;\n        p = p.nb$multiply(p);\n    }\n\n    return r;\n};\n\n\nSk.builtin.complex.prototype.nb$inplace_add = Sk.builtin.complex.prototype.nb$add;\n\nSk.builtin.complex.prototype.nb$inplace_subtract = Sk.builtin.complex.prototype.nb$subtract;\n\nSk.builtin.complex.prototype.nb$inplace_multiply = Sk.builtin.complex.prototype.nb$multiply;\n\nSk.builtin.complex.prototype.nb$inplace_divide = Sk.builtin.complex.prototype.nb$divide;\n\nSk.builtin.complex.prototype.nb$inplace_remainder = Sk.builtin.complex.prototype.nb$remainder;\n\nSk.builtin.complex.prototype.nb$inplace_floor_divide = Sk.builtin.complex.prototype.nb$floor_divide;\n\nSk.builtin.complex.prototype.nb$inplace_power = Sk.builtin.complex.prototype.nb$power;\n\nSk.builtin.complex.prototype.nb$negative = function () {\n    var real;\n    var imag;\n    // this == a\n    var areal = this.real.v;\n    var aimag = this.imag.v;\n\n    real = -areal;\n    imag = -aimag;\n\n    return new Sk.builtin.complex(new Sk.builtin.float_(real), new Sk.builtin.float_(imag));\n};\n\nSk.builtin.complex.prototype.nb$positive = function () {\n    return Sk.builtin.complex.check_number_or_complex(this);\n};\n\n/**\n *  check if op is instance of complex or a sub-type\n */\nSk.builtin.complex._complex_check = function (op) {\n    if (op === undefined) {\n        return false;\n    }\n\n    if (op instanceof Sk.builtin.complex || (op.tp$name && op.tp$name === \"complex\")) {\n        return true;\n    }\n\n    // check if type of ob is a subclass\n    if (Sk.builtin.issubclass(new Sk.builtin.type(op), Sk.builtin.complex)) {\n        return true;\n    }\n\n    return false;\n};\n\nSk.builtin.complex.prototype.tp$richcompare = function (w, op) {\n    var result;\n    var equal;\n    var i;\n\n    if (op !== \"Eq\" && op !== \"NotEq\") {\n        if(Sk.builtin.checkNumber(w) || Sk.builtin.complex._complex_check(w)) {\n            throw new Sk.builtin.TypeError(\"no ordering relation is defined for complex numbers\");\n        }\n\n        return Sk.builtin.NotImplemented.NotImplemented$;\n    }\n\n    // assert(PyComplex_Check(v)));\n    i = Sk.builtin.complex.check_number_or_complex(this);\n    var _real = i.tp$getattr(Sk.builtin.str.$real).v;\n    var _imag = i.tp$getattr(Sk.builtin.str.$imag).v;\n\n    if (Sk.builtin.checkInt(w)) {\n        /* Check for 0.0 imaginary part first to avoid the rich\n         * comparison when possible.\n         */\n\n        // if true, the complex number has just a real part\n        if (_imag === 0.0) {\n            equal = Sk.misceval.richCompareBool(new Sk.builtin.float_(_real), w, op);\n            result = new Sk.builtin.bool(equal);\n            return result;\n        } else {\n            equal = false;\n        }\n    } else if (Sk.builtin.checkFloat(w)) {\n        equal = (_real === Sk.builtin.float_.PyFloat_AsDouble(w) && _imag === 0.0);\n    } else if (Sk.builtin.complex._complex_check(w)) {\n        // ToDo: figure if we need to call to_complex\n        var w_real = w.tp$getattr(Sk.builtin.str.$real).v;\n        var w_imag = w.tp$getattr(Sk.builtin.str.$imag).v;\n        equal = _real === w_real && _imag === w_imag;\n    } else {\n        return Sk.builtin.NotImplemented.NotImplemented$;\n    }\n\n    // invert result if op == NotEq\n    if(op === \"NotEq\") {\n        equal = !equal;\n    }\n\n    // wrap as bool\n    result = new Sk.builtin.bool(equal);\n\n    return result;\n};\n\n// Despite what jshint may want us to do, these two  functions need to remain\n// as == and !=  Unless you modify the logic of numberCompare do not change\n// these.\nSk.builtin.complex.prototype.__eq__ = function (me, other) {\n    return Sk.builtin.complex.prototype.tp$richcompare.call(me, other, \"Eq\");\n};\n\nSk.builtin.complex.prototype.__ne__ = function (me, other) {\n    return Sk.builtin.complex.prototype.tp$richcompare.call(me, other, \"NotEq\");\n};\n\n/**\n * Do we really need to implement those? Otherwise I can't find in Sk.abstr a place where this particular\n * expcetion is thrown.git co\n */\nSk.builtin.complex.prototype.__lt__ = function (me, other) {\n    throw new Sk.builtin.TypeError(\"unorderable types: \" + Sk.abstr.typeName(me) + \" < \" + Sk.abstr.typeName(other));\n};\n\nSk.builtin.complex.prototype.__le__ = function (me, other) {\n    throw new Sk.builtin.TypeError(\"unorderable types: \" + Sk.abstr.typeName(me) + \" <= \" + Sk.abstr.typeName(other));\n};\n\nSk.builtin.complex.prototype.__gt__ = function (me, other) {\n    throw new Sk.builtin.TypeError(\"unorderable types: \" + Sk.abstr.typeName(me) + \" > \" + Sk.abstr.typeName(other));\n};\n\nSk.builtin.complex.prototype.__ge__ = function (me, other) {\n    throw new Sk.builtin.TypeError(\"unorderable types: \" + Sk.abstr.typeName(me) + \" >= \" + Sk.abstr.typeName(other));\n};\n\nSk.builtin.complex.prototype.__float__ = function (self) {\n    throw new Sk.builtin.TypeError(\"can't convert complex to float\");\n};\n\nSk.builtin.complex.prototype.__int__ = function (self) {\n    throw new Sk.builtin.TypeError(\"can't convert complex to int\");\n};\n\n\nSk.builtin.complex.prototype._internalGenericGetAttr = Sk.builtin.object.prototype.GenericGetAttr;\n\n/**\n * Custom getattr impl. to get the c.real and c.imag to work. Though we should\n * consider to implement tp$members that always are attributs on the class and\n * will be used in the genericgetattr method.\n * Would be super easy to implement the readonly stuff too.\n *\n */\nSk.builtin.complex.prototype.tp$getattr = function (name) {\n    if (name != null && (Sk.builtin.checkString(name) || typeof name === \"string\")) {\n        var _name = name;\n\n        // get javascript string\n        if (Sk.builtin.checkString(name)) {\n            _name = Sk.ffi.remapToJs(name);\n        }\n\n        if (_name === \"real\" || _name === \"imag\") {\n            return this[_name];\n        }\n    }\n\n    // if we have not returned yet, try the genericgetattr\n    return this._internalGenericGetAttr(name);\n};\n\n\nSk.builtin.complex.prototype.tp$setattr = function (name, value) {\n    if (name != null && (Sk.builtin.checkString(name) || typeof name === \"string\")) {\n        var _name = name;\n\n        // get javascript string\n        if (Sk.builtin.checkString(name)) {\n            _name = Sk.ffi.remapToJs(name);\n        }\n\n        if (_name === \"real\" || _name === \"imag\") {\n            throw new Sk.builtin.AttributeError(\"readonly attribute\");\n        }\n    }\n\n    // builtin: --> all is readonly (I am not happy with this)\n    throw new Sk.builtin.AttributeError(\"'complex' object attribute '\" + name + \"' is readonly\");\n};\n\n/**\n * Internal format function for repr and str\n * It is not intended for __format__ calls\n *\n * This functions assumes, that v is always instance of Sk.builtin.complex\n */\nSk.builtin.complex.complex_format = function (v, precision, format_code){\n    function copysign (a, b) {\n        return b < 0 ? -Math.abs(a) : Math.abs(a);\n    }\n\n    if (v == null || !Sk.builtin.complex._complex_check(v)) {\n        throw new Error(\"Invalid internal method call: Sk.complex.complex_format() called with invalid value type.\");\n    }\n\n    var result; // PyObject\n\n    var pre = \"\";\n    var im = \"\";\n    var re = null;\n    var lead = \"\";\n    var tail = \"\";\n\n    if (v.real.v === 0.0 && copysign(1.0, v.real.v) == 1.0) {\n        re = \"\";\n        im = Sk.builtin.complex.PyOS_double_to_string(v.imag.v, format_code, precision, 0, null);\n        // im = v.imag.v;\n    } else {\n        /* Format imaginary part with sign, real part without */\n        pre = Sk.builtin.complex.PyOS_double_to_string(v.real.v, format_code, precision, 0, null);\n        re = pre;\n\n        im = Sk.builtin.complex.PyOS_double_to_string(v.imag.v, format_code, precision, Sk.builtin.complex.PyOS_double_to_string.Py_DTSF_SIGN, null);\n\n        if (v.imag.v === 0 && 1/v.imag.v === -Infinity && im && im[0] !== \"-\"){\n            im = \"-\" + im; // force negative zero sign\n        }\n\n        lead = \"(\";\n        tail = \")\";\n    }\n\n    result = \"\" + lead + re + im + \"j\" + tail; // concat all parts\n\n    return new Sk.builtin.str(result);\n};\n\nSk.builtin.complex.prototype[\"$r\"] = function () {\n    return Sk.builtin.complex.complex_format(this, 0, \"r\");\n};\n\nSk.builtin.complex.prototype.tp$str = function () {\n    return Sk.builtin.complex.complex_format(this, null, \"g\"); // g, 12 == Py_Float_STR_PRECISION\n};\n\n/**\n * https://hg.python.org/cpython/file/3cf2990d19ab/Objects/complexobject.c#l907\n * also see _PyComplex_FormatAdvanced\n *\n * We currently use the signature (self, format_spec) instead of (self, args). So we do\n * not need to unwrap the args.\n */\nSk.builtin.complex.prototype.int$format = function __format__(self, format_spec){\n    var result; // PyObject\n\n    if (format_spec == null) {\n        return null;\n    }\n\n    if (Sk.builtin.checkString(format_spec)) {\n        result = Sk.builtin.complex._PyComplex_FormatAdvanced(self, format_spec);\n\n        return result;\n    }\n\n\n    throw new Sk.builtin.TypeError(\"__format__ requires str or unicode\");\n};\nSk.builtin.complex.prototype.int$format.co_name = new Sk.builtin.str(\"__format__\");\nSk.builtin.complex.prototype.__format__ = new Sk.builtin.func(Sk.builtin.complex.prototype.int$format);\n\nSk.builtin.complex._PyComplex_FormatAdvanced = function(self, format_spec) {\n    throw new Sk.builtin.NotImplementedError(\"__format__ is not implemented for complex type.\");\n};\n\n/**\n    Return true if float or double are is neither infinite nor NAN, else false\n    Value is already a Javascript object\n */\nSk.builtin.complex._is_finite = function (val) {\n    return !isNaN(val) && val !== Infinity && val !== -Infinity;\n};\n\nSk.builtin.complex._is_infinity = function (val) {\n    return val === Infinity || val === -Infinity;\n};\n\n/**\n * @suppress {missingProperties}\n */\nSk.builtin.complex.prototype.int$abs = function __abs__(self) {\n    var result;\n    var _real = self.real.v;\n    var _imag = self.imag.v;\n\n    if (!Sk.builtin.complex._is_finite(_real) || !Sk.builtin.complex._is_finite(_imag)) {\n        /* C99 rules: if either the real or the imaginary part is an\n           infinity, return infinity, even if the other part is a\n           NaN.\n        */\n\n        if (Sk.builtin.complex._is_infinity(_real)) {\n            result = Math.abs(_real);\n            return new Sk.builtin.float_(result);\n        }\n\n        if (Sk.builtin.complex._is_infinity(_imag)) {\n            result = Math.abs(_imag);\n            return new Sk.builtin.float_(result);\n        }\n\n        /* either the real or imaginary part is a NaN,\n           and neither is infinite. Result should be NaN. */\n\n        return new Sk.builtin.float_(NaN);\n    }\n\n    result = Math.hypot(_real, _imag);\n\n    if (!Sk.builtin.complex._is_finite(result)) {\n        throw new Sk.builtin.OverflowError(\"absolute value too large\");\n    }\n\n    return new Sk.builtin.float_(result);\n};\nSk.builtin.complex.prototype.int$abs.co_name = new Sk.builtin.str(\"__abs__\");\nSk.builtin.complex.prototype.__abs__ = new Sk.builtin.func(Sk.builtin.complex.prototype.int$abs);\n\nSk.builtin.complex.prototype.int$bool = function __bool__(self) {\n    return new Sk.builtin.bool(self.tp$getattr(Sk.builtin.str.$real).v || self.tp$getattr(Sk.builtin.str.$real).v);\n};\nSk.builtin.complex.prototype.int$bool.co_name = new Sk.builtin.str(\"__bool__\");\nSk.builtin.complex.prototype.__bool__ = new Sk.builtin.func(Sk.builtin.complex.prototype.int$bool);\n\nSk.builtin.complex.prototype.int$truediv = function __truediv__(self, other){\n    Sk.builtin.pyCheckArgsLen(\"__truediv__\", arguments.length, 1, 1, true);\n    return self.nb$divide.call(self, other);\n};\nSk.builtin.complex.prototype.int$truediv.co_name = new Sk.builtin.str(\"__truediv__\");\nSk.builtin.complex.prototype.__truediv__ = new Sk.builtin.func(Sk.builtin.complex.prototype.int$truediv);\n\nSk.builtin.complex.prototype.int$hash = function __hash__(self){\n    Sk.builtin.pyCheckArgsLen(\"__hash__\", arguments.length, 0, 0, true);\n\n    return self.tp$hash.call(self);\n};\nSk.builtin.complex.prototype.int$hash.co_name = new Sk.builtin.str(\"__hash__\");\nSk.builtin.complex.prototype.__hash__ = new Sk.builtin.func(Sk.builtin.complex.prototype.int$hash);\n\nSk.builtin.complex.prototype.int$add = function __add__(self, other){\n    Sk.builtin.pyCheckArgsLen(\"__add__\", arguments.length, 1, 1, true);\n    return self.nb$add.call(self, other);\n};\nSk.builtin.complex.prototype.int$add.co_name = new Sk.builtin.str(\"__add__\");\nSk.builtin.complex.prototype.__add__ = new Sk.builtin.func(Sk.builtin.complex.prototype.int$add);\n\n\nSk.builtin.complex.prototype.int$repr = function __repr__(self){\n    Sk.builtin.pyCheckArgsLen(\"__repr__\", arguments.length, 0, 0, true);\n\n    return self[\"r$\"].call(self);\n};\nSk.builtin.complex.prototype.int$repr.co_name = new Sk.builtin.str(\"__repr__\");\nSk.builtin.complex.prototype.__repr__ = new Sk.builtin.func(Sk.builtin.complex.prototype.int$repr);\n\nSk.builtin.complex.prototype.int$str = function __str__(self){\n    Sk.builtin.pyCheckArgsLen(\"__str__\", arguments.length, 0, 0, true);\n\n    return self.tp$str.call(self);\n};\nSk.builtin.complex.prototype.int$str.co_name = new Sk.builtin.str(\"__str__\");\nSk.builtin.complex.prototype.__str__ = new Sk.builtin.func(Sk.builtin.complex.prototype.int$str);\n\nSk.builtin.complex.prototype.int$sub = function __sub__(self, other){\n    Sk.builtin.pyCheckArgsLen(\"__sub__\", arguments.length, 1, 1, true);\n    return self.nb$subtract.call(self, other);\n};\nSk.builtin.complex.prototype.int$sub.co_name = new Sk.builtin.str(\"__sub__\");\nSk.builtin.complex.prototype.__sub__ = new Sk.builtin.func(Sk.builtin.complex.prototype.int$sub);\n\nSk.builtin.complex.prototype.int$mul = function __mul__(self, other){\n    Sk.builtin.pyCheckArgsLen(\"__mul__\", arguments.length, 1, 1, true);\n    return self.nb$multiply.call(self, other);\n};\nSk.builtin.complex.prototype.int$mul.co_name = new Sk.builtin.str(\"__mul__\");\nSk.builtin.complex.prototype.__mul__ = new Sk.builtin.func(Sk.builtin.complex.prototype.int$mul);\n\nSk.builtin.complex.prototype.int$div = function __div__(self, other){\n    Sk.builtin.pyCheckArgsLen(\"__div__\", arguments.length, 1, 1, true);\n    return self.nb$divide.call(self, other);\n};\nSk.builtin.complex.prototype.int$div.co_name = new Sk.builtin.str(\"__div__\");\nSk.builtin.complex.prototype.__div__ = new Sk.builtin.func(Sk.builtin.complex.prototype.int$div);\n\nSk.builtin.complex.prototype.int$floordiv = function __floordiv__(self, other){\n    Sk.builtin.pyCheckArgsLen(\"__floordiv__\", arguments.length, 1, 1, true);\n    return self.nb$floor_divide.call(self, other);\n};\nSk.builtin.complex.prototype.int$floordiv.co_name = new Sk.builtin.str(\"__floordiv__\");\nSk.builtin.complex.prototype.__floordiv__ = new Sk.builtin.func(Sk.builtin.complex.prototype.int$floordiv);\n\nSk.builtin.complex.prototype.int$mod = function __mod__(self, other){\n    Sk.builtin.pyCheckArgsLen(\"__mod__\", arguments.length, 1, 1, true);\n    return self.nb$remainder.call(self, other);\n};\nSk.builtin.complex.prototype.int$mod.co_name = new Sk.builtin.str(\"__mod__\");\nSk.builtin.complex.prototype.__mod__ = new Sk.builtin.func(Sk.builtin.complex.prototype.int$mod);\n\nSk.builtin.complex.prototype.int$pow = function __pow__(self, other, z){\n    Sk.builtin.pyCheckArgsLen(\"__pow__\", arguments.length, 1, 2, true);\n    return self.nb$power.call(self, other, z);\n};\nSk.builtin.complex.prototype.int$pow.co_name = new Sk.builtin.str(\"__pow__\");\nSk.builtin.complex.prototype.__pow__ = new Sk.builtin.func(Sk.builtin.complex.prototype.int$pow);\n\nSk.builtin.complex.prototype.int$neg = function __neg__(self){\n    Sk.builtin.pyCheckArgsLen(\"__neg__\", arguments.length, 0, 0, true);\n    return self.nb$negative.call(self);\n};\nSk.builtin.complex.prototype.__neg__ = new Sk.builtin.func(Sk.builtin.complex.prototype.int$neg);\n\nSk.builtin.complex.prototype.int$pos = function __pos__(self){\n    Sk.builtin.pyCheckArgsLen(\"__pos__\", arguments.length, 0, 0, true);\n    return self.nb$positive.call(self);\n};\nSk.builtin.complex.prototype.int$pos.co_name = new Sk.builtin.str(\"__pos__\");\nSk.builtin.complex.prototype.__pos__ = new Sk.builtin.func(Sk.builtin.complex.prototype.int$pos);\n\nSk.builtin.complex.prototype.int$conjugate = function conjugate(self){\n    Sk.builtin.pyCheckArgsLen(\"conjugate\", arguments.length, 0, 0, true);\n    var _imag = self.imag.v;\n    _imag = -_imag;\n\n    return new Sk.builtin.complex(self.real, new Sk.builtin.float_(_imag));\n};\nSk.builtin.complex.prototype.int$conjugate.co_name = new Sk.builtin.str(\"conjugate\");\nSk.builtin.complex.prototype.conjugate = new Sk.builtin.func(Sk.builtin.complex.prototype.int$conjugate);\n\n// deprecated\nSk.builtin.complex.prototype.int$divmod = function __divmod__(self, other){\n    Sk.builtin.pyCheckArgsLen(\"__divmod__\", arguments.length, 1, 1, true);\n\n    var div, mod; // Py_complex\n    var d, m, z; // PyObject\n    var a, b; // Py_complex\n    a = Sk.builtin.complex.check_number_or_complex(self);\n    b = Sk.builtin.complex.check_number_or_complex(other);\n\n    div = a.nb$divide.call(a, b); // the raw divisor value\n\n    div.real = new Sk.builtin.float_(Math.floor(div.real.v));\n    div.imag = new Sk.builtin.float_(0.0);\n\n    mod = a.nb$subtract.call(a, b.nb$multiply.call(b, div));\n\n    z = new Sk.builtin.tuple([div, mod]);\n\n    return z;\n};\nSk.builtin.complex.prototype.int$divmod.co_name = new Sk.builtin.str(\"__divmod__\");\nSk.builtin.complex.prototype.__divmod__ = new Sk.builtin.func(Sk.builtin.complex.prototype.int$divmod);\n\nSk.builtin.complex.prototype.int$getnewargs = function __getnewargs__(self){\n    Sk.builtin.pyCheckArgsLen(\"__getnewargs__\", arguments.length, 0, 0, true);\n\n    return new Sk.builtin.tuple([self.real, self.imag]);\n};\nSk.builtin.complex.prototype.int$getnewargs.co_name = new Sk.builtin.str(\"__getnewargs__\");\nSk.builtin.complex.prototype.__getnewargs__ = new Sk.builtin.func(Sk.builtin.complex.prototype.int$getnewargs);\n\nSk.builtin.complex.prototype.int$nonzero = function __nonzero__(self){\n    Sk.builtin.pyCheckArgsLen(\"__nonzero__\", arguments.length, 0, 0, true);\n\n    if(self.real.v !== 0.0 || self.imag.v !== 0.0) {\n        return Sk.builtin.bool.true$;\n    } else {\n        return Sk.builtin.bool.false$;\n    }\n};\nSk.builtin.complex.prototype.int$nonzero.co_name = new Sk.builtin.str(\"__nonzero__\");\nSk.builtin.complex.prototype.__nonzero__ = new Sk.builtin.func(Sk.builtin.complex.prototype.int$nonzero);\n\n\n// ToDo: think about inplace methods too\nSk.exportSymbol(\"Sk.builtin.complex\", Sk.builtin.complex);\n\n\n/**\n * Convert a double val to a string using supplied format_code, precision, and flags.\n *\n * format_code must be one of 'e', 'E', 'f', 'F', 'g', 'G' or 'r'. For 'r', the supplied precision must be 0 and is ignored. The 'r' format code specifies the standard repr() format.\n *\n * flags can be zero or more of the values Py_DTSF_SIGN, Py_DTSF_ADD_DOT_0, or Py_DTSF_ALT, or-ed together:\n *\n * Py_DTSF_SIGN means to always precede the returned string with a sign character, even if val is non-negative.\n * Py_DTSF_ADD_DOT_0 means to ensure that the returned string will not look like an integer.\n * Py_DTSF_ALT means to apply alternate formatting rules. See the documentation for the PyOS_snprintf() '#' specifier for details.\n * If ptype is non-NULL, then the value it points to will be set to one of Py_DTST_FINITE, Py_DTST_INFINITE, or Py_DTST_NAN, signifying that val is a finite number, an\n * infinite number, or not a number, respectively.\n */\nSk.builtin.complex.PyOS_double_to_string = function(val, format_code, precision, flags, type) {\n    var format;\n    var buf;\n    var t;\n    var exp;\n    var upper = false;\n\n    // Validate format code, and map upper and lower case\n    switch(format_code) {\n        case \"e\": /* exponent */\n        case \"f\": /* fixed */\n        case \"g\": /* general */\n            break;\n        case \"E\":\n            upper = true;\n            format_code = \"e\";\n            break;\n        case \"F\":\n            upper = true;\n            format_code = \"f\";\n            break;\n        case \"r\": /* repr format */\n            // Supplied precision is unused, must be 0.\n            if(precision !== 0) {\n                throw new Error(\"Bad internall call\"); // only happens when somebody messes up calling this in js\n            }\n\n            // repr() precision is 17 significant decimal digits\n            precision = 17;\n            format_code = \"g\";\n            break;\n        default:\n            throw new Error(\"Bad internall call\");\n    }\n\n    // no need for buffer size calculation like in cpython\n\n    // Handle nan and inf\n    if(isNaN(val)) {\n        buf = \"nan\";\n        t = Sk.builtin.complex.PyOS_double_to_string.Py_DTST_NAN;\n    } else if (val === Infinity) {\n        buf = \"inf\";\n        t = Sk.builtin.complex.PyOS_double_to_string.Py_DTST_INFINITE;\n    } else if (val === -Infinity) {\n        buf = \"-inf\";\n        t = Sk.builtin.complex.PyOS_double_to_string.Py_DTST_INFINITE;\n    } else {\n        t = Sk.builtin.complex.PyOS_double_to_string.Py_DTST_FINITE;\n        if(flags & Sk.builtin.complex.PyOS_double_to_string.Py_DTSF_ADD_DOT_0) {\n            format_code = \"g\"; // \"Z\"; _PyOS_ascii_formatd converts \"Z\" to \"g\"\n        }\n\n        // ToDo: call snprintf here\n        // ToDo: call ascii_formatd\n        var format_str = \"%\";\n        format_str += flags & Sk.builtin.complex.PyOS_double_to_string.Py_DTSF_ALT ? \"#\" : \"\";\n\n        if(precision != null) {\n            format_str += \".\";\n            format_str += precision;\n        }\n\n        format_str += format_code;\n        format_str = new Sk.builtin.str(format_str);\n\n        /**\n         * We cann call nb$remainder with val, because it gets unwrapped and it doesn't matter if it is\n         * already a javascript number. If we do not pass a float, we can't distinguish between ints and floats\n         * and therefore we can't adjust the sign of the zero accordingly\n         */\n        buf = format_str.nb$remainder(new Sk.builtin.float_(val));\n        buf = buf.v; // get javascript string\n    }\n\n    /**\n     * Add sign when requested. It's convenient (esp. when formatting complex numbers) to\n     * include sign even for inf and nan.\n     */\n    if(flags & Sk.builtin.complex.PyOS_double_to_string.Py_DTSF_SIGN && buf[0] !== \"-\") {\n        buf = \"+\" + buf;\n    }\n\n    if(upper) {\n        // Convert to upper case\n        buf = buf.toUpperCase();\n    }\n\n    return buf;\n};\n\n/* PyOS_double_to_string's \"flags\" parameter can be set to 0 or more of: */\nSk.builtin.complex.PyOS_double_to_string.Py_DTSF_SIGN = 0x01; // always add the sign\nSk.builtin.complex.PyOS_double_to_string.Py_DTSF_ADD_DOT_0 = 0x02; // if the result is an integer add \".0\"\nSk.builtin.complex.PyOS_double_to_string.Py_DTSF_ALT = 0x04; // \"alternate\" formatting. it's format_code specific\n\n/* PyOS_double_to_string's \"type\", if non-NULL, will be set to one of: */\nSk.builtin.complex.PyOS_double_to_string.Py_DTST_FINITE = 0;\nSk.builtin.complex.PyOS_double_to_string.Py_DTST_INFINITE = 1;\nSk.builtin.complex.PyOS_double_to_string.Py_DTST_NAN = 2;\n\n\n/***/ }),\n/* 32 */\n/***/ (function(module, exports) {\n\n/**\n * @constructor\n * @param {Object} start\n * @param {Object=} stop\n * @param {Object=} step\n */\nSk.builtin.slice = function slice (start, stop, step) {\n    Sk.builtin.pyCheckArgsLen(\"slice\", arguments.length, 1, 3, false, false);\n\n    if ((step !== undefined) && Sk.misceval.isIndex(step) && (Sk.misceval.asIndex(step) === 0)) {\n        throw new Sk.builtin.ValueError(\"slice step cannot be zero\");\n    }\n\n    if (!(this instanceof Sk.builtin.slice)) {\n        return new Sk.builtin.slice(start, stop, step);\n    }\n\n\n    if (stop === undefined && step === undefined) {\n        stop = start;\n        start = Sk.builtin.none.none$;\n    }\n    if (stop === undefined) {\n        stop = Sk.builtin.none.none$;\n    }\n    if (step === undefined) {\n        step = Sk.builtin.none.none$;\n    }\n    this.start = start;\n    this.stop = stop;\n    this.step = step;\n\n    this.__class__ = Sk.builtin.slice;\n\n    this[\"$d\"] = new Sk.builtin.dict([Sk.builtin.slice$start, this.start,\n                                      Sk.builtin.slice$stop, this.stop,\n                                      Sk.builtin.slice$step, this.step]);\n\n    return this;\n};\n\nSk.abstr.setUpInheritance(\"slice\", Sk.builtin.slice, Sk.builtin.object);\n\nSk.builtin.slice.prototype[\"$r\"] = function () {\n    var a = Sk.builtin.repr(this.start).v;\n    var b = Sk.builtin.repr(this.stop).v;\n    var c = Sk.builtin.repr(this.step).v;\n    return new Sk.builtin.str(\"slice(\" + a + \", \" + b + \", \" + c + \")\");\n};\n\nSk.builtin.slice.prototype.tp$richcompare = function (w, op) {\n    // w not a slice\n    var t1, t2;\n    if (!w.__class__ || w.__class__ != Sk.builtin.slice) {\n        // shortcuts for eq/not\n        if (op === \"Eq\") {\n            return false;\n        }\n        if (op === \"NotEq\") {\n            return true;\n        }\n\n        // todo; other types should have an arbitrary order\n        return false;\n    }\n\n    // This is how CPython does it\n    t1 = new Sk.builtin.tuple([this.start, this.stop, this.step]);\n    t2 = new Sk.builtin.tuple([w.start, w.stop, w.step]);\n\n    return t1.tp$richcompare(t2, op);\n};\n\n/* Internal indices function */\nSk.builtin.slice.prototype.slice_indices_ = function (length) {\n    var start, stop, step;\n\n    if (Sk.builtin.checkNone(this.start)) {\n        start = null;\n    } else if (Sk.misceval.isIndex(this.start)) {\n        start = Sk.misceval.asIndex(this.start);\n    } else {\n        throw new Sk.builtin.TypeError(\"slice indices must be integers or None\");\n    }\n\n    if (Sk.builtin.checkNone(this.stop)) {\n        stop = null;\n    } else if (Sk.misceval.isIndex(this.stop)) {\n        stop = Sk.misceval.asIndex(this.stop);\n    } else {\n        throw new Sk.builtin.TypeError(\"slice indices must be integers or None\");\n    }\n\n    if (Sk.builtin.checkNone(this.step)) {\n        step = null;\n    } else if (Sk.misceval.isIndex(this.step)) {\n        step = Sk.misceval.asIndex(this.step);\n    } else {\n        throw new Sk.builtin.TypeError(\"slice indices must be integers or None\");\n    }\n\n    // this seems ugly, better way?\n    if (step === null) {\n        step = 1;\n    }\n    if (step > 0) {\n        if (start === null) {\n            start = 0;\n        }\n        if (stop === null) {\n            stop = length;\n        }\n        if (stop > length) {\n            stop = length;\n        }\n        if (start < 0) {\n            start = length + start;\n            if (start < 0) {\n                start = 0;\n            }\n        }\n        if (stop < 0) {\n            stop = length + stop;\n        }\n    } else {\n        if (start === null) {\n            start = length - 1;\n        }\n        if (start >= length) {\n            start = length - 1;\n        }\n        if (stop === null) {\n            stop = -1;\n        } else if (stop < 0) {\n            stop = length + stop;\n            if (stop < 0) {\n                stop = -1;\n            }\n        }\n        if (start < 0) {\n            start = length + start;\n        }\n    }\n\n    return [start, stop, step];\n};\n\nSk.builtin.slice.prototype[\"indices\"] = new Sk.builtin.func(function (self, length) {\n    Sk.builtin.pyCheckArgsLen(\"indices\", arguments.length, 2, 2, false, false);\n\n    length = Sk.builtin.asnum$(length);\n    var sss = self.slice_indices_(length);\n\n    return new Sk.builtin.tuple([\n        new Sk.builtin.int_(sss[0]), \n        new Sk.builtin.int_(sss[1]), \n        new Sk.builtin.int_(sss[2])\n    ]);\n});\n\nSk.builtin.slice.prototype.sssiter$ = function (wrt, f) {\n    var i;\n    var wrtv = Sk.builtin.asnum$(wrt);\n    var sss = this.slice_indices_(typeof wrtv === \"number\" ? wrtv : wrt.v.length);\n    if (sss[2] > 0) {\n        for (i = sss[0]; i < sss[1]; i += sss[2]) {\n            if (f(i, wrtv) === false) {\n                return;\n            }\n        }\t//\twrt or wrtv? RNL\n    } else {\n        for (i = sss[0]; i > sss[1]; i += sss[2]) {\n            if (f(i, wrtv) === false) {\n                return;\n            }\n        }\t//\twrt or wrtv? RNL\n\n    }\n};\n\nSk.builtin.slice$start = new Sk.builtin.str(\"start\");\nSk.builtin.slice$stop = new Sk.builtin.str(\"stop\");\nSk.builtin.slice$step = new Sk.builtin.str(\"step\");\n\n\n/***/ }),\n/* 33 */\n/***/ (function(module, exports) {\n\n/**\n * @constructor\n * @param {Array.<Object>} S\n */\nSk.builtin.set = function (S) {\n    var it, i;\n    var S_list;\n    if (!(this instanceof Sk.builtin.set)) {\n        Sk.builtin.pyCheckArgsLen(\"set\", arguments.length, 0, 1);\n        return new Sk.builtin.set(S);\n    }\n\n\n    if (typeof(S) === \"undefined\") {\n        S = [];\n    }\n\n    this.set_reset_();\n    S_list = new Sk.builtin.list(S);\n    // python sorts sets on init, but not thereafter.\n    // Skulpt seems to init a new set each time you add/remove something\n    //Sk.builtin.list.prototype['sort'].func_code(S);\n    for (it = Sk.abstr.iter(S_list), i = it.tp$iternext(); i !== undefined; i = it.tp$iternext()) {\n        Sk.builtin.set.prototype[\"add\"].func_code(this, i);\n    }\n\n    this.__class__ = Sk.builtin.set;\n\n    this[\"v\"] = this.v;\n    return this;\n};\nSk.abstr.setUpInheritance(\"set\", Sk.builtin.set, Sk.builtin.object);\nSk.abstr.markUnhashable(Sk.builtin.set);\n\nSk.builtin.set.prototype.set_reset_ = function () {\n    this.v = new Sk.builtin.dict([]);\n};\n\nSk.builtin.set.prototype[\"$r\"] = function () {\n    var it, i;\n    var ret = [];\n    for (it = Sk.abstr.iter(this), i = it.tp$iternext(); i !== undefined; i = it.tp$iternext()) {\n        ret.push(Sk.misceval.objectRepr(i).v);\n    }\n\n    if(Sk.__future__.set_repr) {\n        if (ret.length === 0) {\n            return new Sk.builtin.str(\"set()\");\n        } else {\n            return new Sk.builtin.str(\"{\" + ret.join(\", \") + \"}\");\n        }\n    } else {\n        return new Sk.builtin.str(\"set([\" + ret.join(\", \") + \"])\");\n    }\n};\n\nSk.builtin.set.prototype.ob$eq = function (other) {\n\n    if (this === other) {\n        return Sk.builtin.bool.true$;\n    }\n\n    if (!(other instanceof Sk.builtin.set)) {\n        return Sk.builtin.bool.false$;\n    }\n\n    if (Sk.builtin.set.prototype.sq$length.call(this) !==\n        Sk.builtin.set.prototype.sq$length.call(other)) {\n        return Sk.builtin.bool.false$;\n    }\n\n    return this[\"issubset\"].func_code(this, other);\n};\n\nSk.builtin.set.prototype.ob$ne = function (other) {\n\n    if (this === other) {\n        return Sk.builtin.bool.false$;\n    }\n\n    if (!(other instanceof Sk.builtin.set)) {\n        return Sk.builtin.bool.true$;\n    }\n\n    if (Sk.builtin.set.prototype.sq$length.call(this) !==\n        Sk.builtin.set.prototype.sq$length.call(other)) {\n        return Sk.builtin.bool.true$;\n    }\n\n    if (this[\"issubset\"].func_code(this, other).v) {\n        return Sk.builtin.bool.false$;\n    } else {\n        return Sk.builtin.bool.true$;\n    }\n};\n\nSk.builtin.set.prototype.ob$lt = function (other) {\n\n    if (this === other) {\n        return Sk.builtin.bool.false$;\n    }\n\n    if (Sk.builtin.set.prototype.sq$length.call(this) >=\n        Sk.builtin.set.prototype.sq$length.call(other)) {\n        return Sk.builtin.bool.false$;\n    }\n\n    return this[\"issubset\"].func_code(this, other);\n};\n\nSk.builtin.set.prototype.ob$le = function (other) {\n\n    if (this === other) {\n        return Sk.builtin.bool.true$;\n    }\n\n    if (Sk.builtin.set.prototype.sq$length.call(this) >\n        Sk.builtin.set.prototype.sq$length.call(other)) {\n        return Sk.builtin.bool.false$;\n    }\n\n    return this[\"issubset\"].func_code(this, other);\n};\n\nSk.builtin.set.prototype.ob$gt = function (other) {\n\n    if (this === other) {\n        return Sk.builtin.bool.false$;\n    }\n\n    if (Sk.builtin.set.prototype.sq$length.call(this) <=\n        Sk.builtin.set.prototype.sq$length.call(other)) {\n        return Sk.builtin.bool.false$;\n    }\n\n    return this[\"issuperset\"].func_code(this, other);\n};\n\nSk.builtin.set.prototype.ob$ge = function (other) {\n\n    if (this === other) {\n        return Sk.builtin.bool.true$;\n    }\n\n    if (Sk.builtin.set.prototype.sq$length.call(this) <\n        Sk.builtin.set.prototype.sq$length.call(other)) {\n        return Sk.builtin.bool.false$;\n    }\n\n    return this[\"issuperset\"].func_code(this, other);\n};\n\nSk.builtin.set.prototype.nb$and = function(other){\n    return this[\"intersection\"].func_code(this, other);\n};\n\nSk.builtin.set.prototype.nb$or = function(other){\n    return this[\"union\"].func_code(this, other);\n};\n\nSk.builtin.set.prototype.nb$xor = function(other){\n    return this[\"symmetric_difference\"].func_code(this, other);\n};\n\nSk.builtin.set.prototype.nb$subtract = function(other){\n    return this[\"difference\"].func_code(this, other);\n};\n\nSk.builtin.set.prototype[\"__iter__\"] = new Sk.builtin.func(function (self) {\n    Sk.builtin.pyCheckArgsLen(\"__iter__\", arguments.length, 0, 0, false, true);\n    return new Sk.builtin.set_iter_(self);\n});\n\nSk.builtin.set.prototype.tp$iter = function () {\n    return new Sk.builtin.set_iter_(this);\n};\n\nSk.builtin.set.prototype.sq$length = function () {\n    return this[\"v\"].mp$length();\n};\n\nSk.builtin.set.prototype.sq$contains = function(ob) {\n    return this[\"v\"].sq$contains(ob);\n};\n\nSk.builtin.set.prototype[\"isdisjoint\"] = new Sk.builtin.func(function (self, other) {\n    // requires all items in self to not be in other\n    var isIn;\n    var it, item;\n\n    Sk.builtin.pyCheckArgsLen(\"isdisjoint\", arguments.length, 2, 2);\n    if (!Sk.builtin.checkIterable(other)) {\n        throw new Sk.builtin.TypeError(\"'\" + Sk.abstr.typeName(other) + \"' object is not iterable\");\n    }\n\n    for (it = Sk.abstr.iter(self), item = it.tp$iternext(); item !== undefined; item = it.tp$iternext()) {\n        isIn = Sk.abstr.sequenceContains(other, item);\n        if (isIn) {\n            return Sk.builtin.bool.false$;\n        }\n    }\n    return Sk.builtin.bool.true$;\n});\n\nSk.builtin.set.prototype[\"issubset\"] = new Sk.builtin.func(function (self, other) {\n    var isIn;\n    var it, item;\n    var selfLength, otherLength;\n\n    Sk.builtin.pyCheckArgsLen(\"issubset\", arguments.length, 2, 2);\n    if (!Sk.builtin.checkIterable(other)) {\n        throw new Sk.builtin.TypeError(\"'\" + Sk.abstr.typeName(other) + \"' object is not iterable\");\n    }\n\n    selfLength = self.sq$length();\n    otherLength = other.sq$length();\n\n    if (selfLength > otherLength) {\n        // every item in this set can't be in other if it's shorter!\n        return Sk.builtin.bool.false$;\n    }\n    for (it = Sk.abstr.iter(self), item = it.tp$iternext(); item !== undefined; item = it.tp$iternext()) {\n        isIn = Sk.abstr.sequenceContains(other, item);\n        if (!isIn) {\n            return Sk.builtin.bool.false$;\n        }\n    }\n    return Sk.builtin.bool.true$;\n});\n\nSk.builtin.set.prototype[\"issuperset\"] = new Sk.builtin.func(function (self, other) {\n    Sk.builtin.pyCheckArgsLen(\"issuperset\", arguments.length, 2, 2);\n    return Sk.builtin.set.prototype[\"issubset\"].func_code(other, self);\n});\n\nSk.builtin.set.prototype[\"union\"] = new Sk.builtin.func(function (self) {\n    var S, i, new_args;\n\n    Sk.builtin.pyCheckArgsLen(\"union\", arguments.length, 1);\n\n    S = Sk.builtin.set.prototype[\"copy\"].func_code(self);\n    new_args = [S];\n    for (i = 1; i < arguments.length; i++) {\n        new_args.push(arguments[i]);\n    }\n\n    Sk.builtin.set.prototype[\"update\"].func_code.apply(null, new_args);\n    return S;\n});\n\nSk.builtin.set.prototype[\"intersection\"] = new Sk.builtin.func(function (self) {\n    var S, i, new_args;\n\n    Sk.builtin.pyCheckArgsLen(\"intersection\", arguments.length, 1);\n\n    S = Sk.builtin.set.prototype[\"copy\"].func_code(self);\n    new_args = [S];\n    for (i = 1; i < arguments.length; i++) {\n        new_args.push(arguments[i]);\n    }\n\n    Sk.builtin.set.prototype[\"intersection_update\"].func_code.apply(null, new_args);\n    return S;\n});\n\nSk.builtin.set.prototype[\"difference\"] = new Sk.builtin.func(function (self, other) {\n    var S, i, new_args;\n\n    Sk.builtin.pyCheckArgsLen(\"difference\", arguments.length, 2);\n\n    S = Sk.builtin.set.prototype[\"copy\"].func_code(self);\n    new_args = [S];\n    for (i = 1; i < arguments.length; i++) {\n        new_args.push(arguments[i]);\n    }\n\n    Sk.builtin.set.prototype[\"difference_update\"].func_code.apply(null, new_args);\n    return S;\n});\n\nSk.builtin.set.prototype[\"symmetric_difference\"] = new Sk.builtin.func(function (self, other) {\n    var it, item, S;\n\n    Sk.builtin.pyCheckArgsLen(\"symmetric_difference\", arguments.length, 2, 2);\n\n    S = Sk.builtin.set.prototype[\"union\"].func_code(self, other);\n    for (it = Sk.abstr.iter(S), item = it.tp$iternext(); item !== undefined; item = it.tp$iternext()) {\n        if (Sk.abstr.sequenceContains(self, item) && Sk.abstr.sequenceContains(other, item)) {\n            Sk.builtin.set.prototype[\"discard\"].func_code(S, item);\n        }\n    }\n    return S;\n});\n\nSk.builtin.set.prototype[\"copy\"] = new Sk.builtin.func(function (self) {\n    Sk.builtin.pyCheckArgsLen(\"copy\", arguments.length, 1, 1);\n    return new Sk.builtin.set(self);\n});\n\nSk.builtin.set.prototype[\"update\"] = new Sk.builtin.func(function (self, other) {\n    var i, it, item, arg;\n\n    Sk.builtin.pyCheckArgsLen(\"update\", arguments.length, 2);\n\n    for (i = 1; i < arguments.length; i++) {\n        arg = arguments[i];\n        if (!Sk.builtin.checkIterable(arg)) {\n            throw new Sk.builtin.TypeError(\"'\" + Sk.abstr.typeName(arg) + \"' object is not iterable\");\n        }\n        for (it = Sk.abstr.iter(arg), item = it.tp$iternext();\n            item !== undefined;\n            item = it.tp$iternext()) {\n            Sk.builtin.set.prototype[\"add\"].func_code(self, item);\n        }\n    }\n\n    return Sk.builtin.none.none$;\n});\n\nSk.builtin.set.prototype[\"intersection_update\"] = new Sk.builtin.func(function (self, other) {\n    var i, it, item;\n\n    Sk.builtin.pyCheckArgsLen(\"intersection_update\", arguments.length, 2);\n    for (i = 1; i < arguments.length; i++) {\n        if (!Sk.builtin.checkIterable(arguments[i])) {\n            throw new Sk.builtin.TypeError(\"'\" + Sk.abstr.typeName(arguments[i]) +\n                                           \"' object is not iterable\");\n        }\n    }\n\n    for (it = Sk.abstr.iter(self), item = it.tp$iternext(); item !== undefined; item = it.tp$iternext()) {\n        for (i = 1; i < arguments.length; i++) {\n            if (!Sk.abstr.sequenceContains(arguments[i], item)) {\n                Sk.builtin.set.prototype[\"discard\"].func_code(self, item);\n                break;\n            }\n        }\n    }\n    return Sk.builtin.none.none$;\n});\n\nSk.builtin.set.prototype[\"difference_update\"] = new Sk.builtin.func(function (self, other) {\n    var i, it, item;\n\n    Sk.builtin.pyCheckArgsLen(\"difference_update\", arguments.length, 2);\n    for (i = 1; i < arguments.length; i++) {\n        if (!Sk.builtin.checkIterable(arguments[i])) {\n            throw new Sk.builtin.TypeError(\"'\" + Sk.abstr.typeName(arguments[i]) +\n                                           \"' object is not iterable\");\n        }\n    }\n\n    for (it = Sk.abstr.iter(self), item = it.tp$iternext(); item !== undefined; item = it.tp$iternext()) {\n        for (i = 1; i < arguments.length; i++) {\n            if (Sk.abstr.sequenceContains(arguments[i], item)) {\n                Sk.builtin.set.prototype[\"discard\"].func_code(self, item);\n                break;\n            }\n        }\n    }\n    return Sk.builtin.none.none$;\n});\n\nSk.builtin.set.prototype[\"symmetric_difference_update\"] = new Sk.builtin.func(function (self, other) {\n    Sk.builtin.pyCheckArgsLen(\"symmetric_difference_update\", arguments.length, 2, 2);\n\n    var sd = Sk.builtin.set.prototype[\"symmetric_difference\"].func_code(self, other);\n    self.set_reset_();\n    Sk.builtin.set.prototype[\"update\"].func_code(self, sd);\n    return Sk.builtin.none.none$;\n});\n\n\nSk.builtin.set.prototype[\"add\"] = new Sk.builtin.func(function (self, item) {\n    Sk.builtin.pyCheckArgsLen(\"add\", arguments.length, 2, 2);\n\n    self.v.mp$ass_subscript(item, true);\n    return Sk.builtin.none.none$;\n});\n\nSk.builtin.set.prototype[\"discard\"] = new Sk.builtin.func(function (self, item) {\n    Sk.builtin.pyCheckArgsLen(\"discard\", arguments.length, 2, 2);\n\n    Sk.builtin.dict.prototype[\"pop\"].func_code(self.v, item,\n                                               Sk.builtin.none.none$);\n    return Sk.builtin.none.none$;\n});\n\nSk.builtin.set.prototype[\"pop\"] = new Sk.builtin.func(function (self) {\n    var it, item;\n\n    Sk.builtin.pyCheckArgsLen(\"pop\", arguments.length, 1, 1);\n\n    if (self.sq$length() === 0) {\n        throw new Sk.builtin.KeyError(\"pop from an empty set\");\n    }\n\n    it = Sk.abstr.iter(self);\n    item = it.tp$iternext();\n    Sk.builtin.set.prototype[\"discard\"].func_code(self, item);\n    return item;\n});\n\nSk.builtin.set.prototype[\"remove\"] = new Sk.builtin.func(function (self, item) {\n    Sk.builtin.pyCheckArgsLen(\"remove\", arguments.length, 2, 2);\n\n    self.v.mp$del_subscript(item);\n    return Sk.builtin.none.none$;\n});\n\nSk.exportSymbol(\"Sk.builtin.set\", Sk.builtin.set);\n\n/**\n * @constructor\n * @param {Object} obj\n */\nSk.builtin.set_iter_ = function (obj) {\n    var allkeys, k, i, bucket, buckets;\n    if (!(this instanceof Sk.builtin.set_iter_)) {\n        return new Sk.builtin.set_iter_(obj);\n    }\n    this.$obj = obj;\n    this.tp$iter = this;\n    allkeys = [];\n    buckets = obj.v.buckets;\n    for (k in buckets) {\n        if (buckets.hasOwnProperty(k)) {\n            bucket = buckets[k];\n            if (bucket && bucket.$hash !== undefined && bucket.items !== undefined) {\n                // skip internal stuff. todo; merge pyobj and this\n                for (i = 0; i < bucket.items.length; i++) {\n                    allkeys.push(bucket.items[i].lhs);\n                }\n            }\n        }\n    }\n    this.$index = 0;\n    this.$keys = allkeys;\n    this.tp$iternext = function () {\n        if (this.$index >= this.$keys.length) {\n            return undefined;\n        }\n        return this.$keys[this.$index++];\n    };\n    this.$r = function () {\n        return new Sk.builtin.str(\"setiterator\");\n    };\n    return this;\n};\n\nSk.abstr.setUpInheritance(\"setiterator\", Sk.builtin.set_iter_, Sk.builtin.object);\n\nSk.builtin.set_iter_.prototype.__class__ = Sk.builtin.set_iter_;\n\nSk.builtin.set_iter_.prototype.__iter__ = new Sk.builtin.func(function (self) {\n    Sk.builtin.pyCheckArgsLen(\"__iter__\", arguments.length, 0, 0, true, false);\n    return self;\n});\n\nSk.builtin.set_iter_.prototype.next$ = function (self) {\n    var ret = self.tp$iternext();\n    if (ret === undefined) {\n        throw new Sk.builtin.StopIteration();\n    }\n    return ret;\n};\n\n\n/***/ }),\n/* 34 */\n/***/ (function(module, exports) {\n\n/*\n\tImplementation of the Python3 print version. Due to Python2 grammar we have\n\tto mimic the named keywords after *args as kwargs. Though this does not change\n\tanything for the internal implementation\n\n*/\nvar print_f = function function_print(kwa) {\n    Sk.builtin.pyCheckArgsLen(\"print\", arguments.length, 0, Infinity, true, false);\n    var args = Array.prototype.slice.call(arguments, 1);\n    var kwargs = new Sk.builtins.dict(kwa);\n    var _kwargs = Sk.ffi.remapToJs(kwargs);\n\n    // defaults, null for None\n    var kw_list = {\n        \"sep\": \" \",\n        \"end\": \"\\n\",\n        \"file\": null\n    };\n\n    var remap_val;\n    var is_none;\n\n    // check for sep; string or None\n    remap_val = kwargs.mp$lookup(new Sk.builtin.str(\"sep\"));\n    if(remap_val !== undefined) {\n        is_none = Sk.builtin.checkNone(remap_val);\n        if(Sk.builtin.checkString(remap_val) || is_none) {\n            kw_list[\"sep\"] = is_none ? kw_list[\"sep\"] : Sk.ffi.remapToJs(remap_val); // only reassign for string\n        } else {\n            throw new Sk.builtin.TypeError(\"sep must be None or a string, not \" + Sk.abstr.typeName(remap_val));\n        }\n    }\n\n    // check for end; string or None\n    remap_val = kwargs.mp$lookup(new Sk.builtin.str(\"end\"));\n    if(remap_val !== undefined) {\n        is_none = Sk.builtin.checkNone(remap_val);\n        if(Sk.builtin.checkString(remap_val) || is_none) {\n            kw_list[\"end\"] = is_none ? kw_list[\"end\"] : Sk.ffi.remapToJs(remap_val); // only reassign for string\n        } else {\n            throw new Sk.builtin.TypeError(\"end must be None or a string, not \" + Sk.abstr.typeName(remap_val));\n        }\n    }\n\n    // check for file\n    // allow None, though just keep null or check if value has attribute write\n    remap_val = kwargs.mp$lookup(new Sk.builtin.str(\"file\"));\n    if(remap_val !== undefined) {\n        is_none = Sk.builtin.checkNone(remap_val);\n        if(is_none || remap_val.tp$getattr(\"write\") !== undefined) {\n            kw_list[\"file\"] = is_none ? kw_list[\"file\"] : remap_val;\n        } else {\n            throw new Sk.builtin.AttributeError(\"'\" + Sk.abstr.typeName(remap_val) + \"' object has no attribute 'write'\");\n        }\n    }\n\n    // loop through outputs and create output string\n    var s = \"\";\n    var i;\n    for(i = 0; i < args.length; i++) {\n        s += (new Sk.builtin.str(args[i])).v; // get str repr\n        s += kw_list.sep;\n    }\n\n    if(args.length > 0 && kw_list.sep.length > 0) {\n        s = s.substring(0, s.length-kw_list.sep.length);\n    }\n\n    s += kw_list.end;\n\n    if(kw_list.file !== null) {\n        // currently not tested, though it seems that we need to see how we should access the write function in a correct manner\n        Sk.misceval.callsimArray(kw_list.file.write, [kw_list.file, new Sk.builtin.str(s)]); // callsim to write function\n    } else {\n        return Sk.misceval.chain(Sk.importModule(\"sys\", false, true), function(sys) {\n            return Sk.misceval.apply(sys[\"$d\"][\"stdout\"][\"write\"], undefined, undefined, undefined, [sys[\"$d\"][\"stdout\"], new Sk.builtin.str(s)]);\n        });\n    }\n    // ToDo:\n    // cpython print function may receive another flush kwarg that flushes the output stream immediatelly\n};\n\nprint_f.co_kwargs = true;\nSk.builtin.print = new Sk.builtin.func(print_f);\n\nSk.builtin.print.__doc__ = new Sk.builtin.str(\"print(value, ..., sep=' ', end='\\\\n', file=sys.stdout, flush=False)\\n\\nPrints the values to a stream, or to sys.stdout by default.\\nOptional keyword arguments:\\nfile:  a file-like object (stream); defaults to the current sys.stdout.\\nsep:   string inserted between values, default a space.\\nend:   string appended after the last value, default a newline.\\nflush: whether to forcibly flush the stream.\");\n\n\n/***/ }),\n/* 35 */\n/***/ (function(module, exports) {\n\n/**\n * @constructor\n */\nSk.builtin.module = function module () {\n};\nSk.exportSymbol(\"Sk.builtin.module\", Sk.builtin.module);\n\nSk.builtin.module.prototype.ob$type = Sk.builtin.type.makeIntoTypeObj(\"module\", Sk.builtin.module);\nSk.builtin.module.prototype.tp$getattr = Sk.builtin.object.prototype.GenericGetAttr;\nSk.builtin.module.prototype.tp$setattr = Sk.builtin.object.prototype.GenericSetAttr;\nSk.builtin.module.prototype.tp$name = \"module\";\n\n\n/***/ }),\n/* 36 */\n/***/ (function(module, exports) {\n\nSk.builtin.structseq_types = {};\n\nSk.builtin.make_structseq = function (module, name, fields, doc) {\n    var nm = module + \".\" + name;\n    var flds = [];\n    var docs = [];\n    var i;\n    for (var key in fields) {\n        flds.push(key);\n        docs.push(fields[key]);\n    }\n\n    /**\n     * @constructor\n     * @extends Sk.builtin.tuple\n     * @param {!Array<Object>|Object} arg\n     */\n    var cons = function structseq_constructor(arg) {\n        Sk.builtin.pyCheckArgsLen(nm, arguments.length, 1, 1);\n        var o;\n        var it, i, /** @type {!Array<Object>} */v;\n        if (!(this instanceof Sk.builtin.structseq_types[nm])) {\n            o = Object.create(Sk.builtin.structseq_types[nm].prototype);\n            o.constructor.apply(o, arguments);\n            return o;\n        }\n\n        if (Array.isArray(arg)) {\n            v = arg;\n        } else {\n            v = [];\n            for (it = Sk.abstr.iter(arg), i = it.tp$iternext(); i !== undefined; i = it.tp$iternext()) {\n                v.push(i);\n            }\n            if (v.length != flds.length) {\n                throw new Sk.builtin.TypeError(nm + \"() takes a \" + flds.length + \"-sequence (\" + v.length + \"-sequence given)\");\n            }\n        }\n\n        Sk.builtin.tuple.call(this, v);\n\n        this.__class__ = Sk.builtin.structseq_types[nm];\n    };\n\n    Sk.builtin.structseq_types[nm] = cons;\n\n    Sk.abstr.inherits(cons, Sk.builtin.tuple);\n    if (doc) {\n        cons.prototype.__doc__ = doc;\n    }\n    cons.prototype.tp$name = nm;\n    cons.prototype.ob$type = Sk.builtin.type.makeIntoTypeObj(nm, Sk.builtin.structseq_types[nm]);\n    cons.prototype.ob$type[\"$d\"] = new Sk.builtin.dict([]);\n    cons.prototype.ob$type[\"$d\"].mp$ass_subscript(Sk.builtin.type.basesStr_, new Sk.builtin.tuple([Sk.builtin.tuple]));\n    //var mro = Sk.builtin.type.buildMRO(cons.prototype.ob$type);\n    //cons.prototype.ob$type[\"$d\"].mp$ass_subscript(Sk.builtin.type.mroStr_, mro);\n    //cons.prototype.ob$type.tp$mro = mro;\n    cons.prototype.__getitem__ = new Sk.builtin.func(function (self, index) {\n        return Sk.builtin.tuple.prototype.mp$subscript.call(self, index);\n    });\n    cons.prototype.__reduce__ = new Sk.builtin.func(function (self) {\n        throw new Sk.builtin.Exception(\"__reduce__ is not implemented\");\n    });\n\n    cons.prototype[\"$r\"] = function () {\n        var ret;\n        var i;\n        var bits;\n        if (this.v.length === 0) {\n            return new Sk.builtin.str(nm + \"()\");\n        }\n        bits = [];\n        for (i = 0; i < this.v.length; ++i) {\n            bits[i] = flds[i] + \"=\" + Sk.misceval.objectRepr(this.v[i]).v;\n        }\n        ret = bits.join(\", \");\n        if (this.v.length === 1) {\n            ret += \",\";\n        }\n        return new Sk.builtin.str(nm + \"(\" + ret + \")\");\n    };\n    cons.prototype.tp$setattr = function (pyName, value) {\n        throw new Sk.builtin.AttributeError(\"readonly property\");\n    };\n\n    cons.prototype.tp$getattr = function (pyName) {\n        var jsName = pyName.$jsstr();\n        var i = flds.indexOf(jsName);\n        if (i >= 0) {\n            return this.v[i];\n        } else {\n            return  Sk.builtin.object.prototype.GenericGetAttr(pyName);\n        }\n    };\n\n    return cons;\n};\nSk.exportSymbol(\"Sk.builtin.make_structseq\", Sk.builtin.make_structseq);\n\n\n/***/ }),\n/* 37 */\n/***/ (function(module, exports) {\n\n/**\n * @constructor\n * @param {Function} code javascript code object for the function\n * @param {Object} globals where this function was defined\n * @param {Object} args arguments to the original call (stored into locals for\n * the generator to reenter)\n * @param {Object=} closure dict of free variables\n * @param {Object=} closure2 another dict of free variables that will be\n * merged into 'closure'. there's 2 to simplify generated code (one is $free,\n * the other is $cell)\n *\n * co_varnames and co_name come from generated code, must access as dict.\n */\nSk.builtin.generator = function (code, globals, args, closure, closure2) {\n    var k;\n    var i;\n    if (!code) {\n        return;\n    } // ctor hack\n\n    if (!(this instanceof Sk.builtin.generator)) {\n        return new Sk.builtin.generator(code, globals, args, closure, closure2);\n    }\n\n\n    this.func_code = code;\n    this.func_globals = globals || null;\n    this[\"gi$running\"] = false;\n    this[\"gi$resumeat\"] = 0;\n    this[\"gi$sentvalue\"] = undefined;\n    this[\"gi$locals\"] = {};\n    this[\"gi$cells\"] = {};\n    if (args.length > 0) {\n        // store arguments into locals because they have to be maintained\n        // too. 'fast' var lookups are locals in generator functions.\n        for (i = 0; i < code[\"co_varnames\"].length; ++i) {\n            this[\"gi$locals\"][code[\"co_varnames\"][i]] = args[i];\n        }\n    }\n    if (closure2 !== undefined) {\n        // todo; confirm that modification here can't cause problems\n        for (k in closure2) {\n            closure[k] = closure2[k];\n        }\n    }\n    //print(JSON.stringify(closure));\n    this.func_closure = closure;\n    return this;\n};\nSk.exportSymbol(\"Sk.builtin.generator\", Sk.builtin.generator);\n\nSk.abstr.setUpInheritance(\"generator\", Sk.builtin.generator, Sk.builtin.object);\n\n\nSk.builtin.generator.prototype.tp$iter = function () {\n    return this;\n};\n\nSk.builtin.generator.prototype.tp$iternext = function (canSuspend, yielded) {\n    var ret;\n    var args;\n    var self = this;\n    this[\"gi$running\"] = true;\n    if (yielded === undefined) {\n        yielded = null;\n    }\n    this[\"gi$sentvalue\"] = yielded;\n\n    // note: functions expect 'this' to be globals to avoid having to\n    // slice/unshift onto the main args\n    args = [ this ];\n    if (this.func_closure) {\n        args.push(this.func_closure);\n    }\n    ret = this.func_code.apply(this.func_globals, args);\n    return (function finishIteration(ret) {\n        if (ret instanceof Sk.misceval.Suspension) {\n            if (canSuspend) {\n                return new Sk.misceval.Suspension(finishIteration, ret);\n            } else {\n                ret = Sk.misceval.retryOptionalSuspensionOrThrow(ret);\n            }\n        }\n        //print(\"ret\", JSON.stringify(ret));\n        self[\"gi$running\"] = false;\n        Sk.asserts.assert(ret !== undefined);\n        if (ret !== Sk.builtin.none.none$) {\n            // returns a pair: resume target and yielded value\n            self[\"gi$resumeat\"] = ret[0];\n            ret = ret[1];\n        } else {\n            // todo; StopIteration\n            return undefined;\n        }\n        //print(\"returning:\", JSON.stringify(ret));\n        return ret;\n    })(ret);\n};\n\nSk.builtin.generator.prototype.next$ = function (self) {\n    return self.tp$iternext(true);\n};\n\nSk.builtin.generator.prototype[\"$r\"] = function () {\n    return new Sk.builtin.str(\"<generator object \" + this.func_code[\"co_name\"].v + \">\");\n};\n\nSk.builtin.generator.prototype[\"send\"] = new Sk.builtin.func(function (self, value) {\n    return self.tp$iternext(true, value);\n});\n\n/**\n * Creates a generator with the specified next function and additional\n * instance data. Useful in Javascript-implemented modules to implement\n * the __iter__ method.\n */\nSk.builtin.makeGenerator = function (next, data) {\n    var key;\n    var gen = new Sk.builtin.generator(null, null, null);\n    gen.tp$iternext = next;\n\n    for (key in data) {\n        if (data.hasOwnProperty(key)) {\n            gen[key] = data[key];\n        }\n    }\n\n    return gen;\n};\nSk.exportSymbol(\"Sk.builtin.makeGenerator\", Sk.builtin.makeGenerator);\n\n\n/***/ }),\n/* 38 */\n/***/ (function(module, exports) {\n\n/**\n * @constructor\n * @param {Sk.builtin.str} name\n * @param {Sk.builtin.str} mode\n * @param {Object} buffering\n */\nSk.builtin.file = function (name, mode, buffering) {\n    var i;\n    var elem;\n\n    if (!(this instanceof Sk.builtin.file)) {\n        return new Sk.builtin.file(name, mode, buffering);\n    }\n\n    this.mode = mode;\n    this.name = Sk.ffi.remapToJs(name);\n    this.closed = false;\n\n    if (this.name === \"/dev/stdout\") {\n        this.data$ = Sk.builtin.none.none$;\n        this.fileno = 1;\n    } else if (this.name === \"/dev/stdin\") {\n        this.fileno = 0;\n    } else if (this.name === \"/dev/stderr\") {\n        this.fileno = 2;\n    } else {\n        if (Sk.inBrowser) {  // todo:  Maybe provide a replaceable function for non-import files\n            this.fileno = 10;\n            elem = document.getElementById(name.v);\n            if (elem == null) {\n                if (mode.v == \"w\" || mode.v == \"a\") {\n                    this.data$ = \"\";\n                } else {\n                    throw new Sk.builtin.IOError(\"[Errno 2] No such file or directory: '\" + name.v + \"'\");\n                }\n            } else {\n                if (elem.nodeName.toLowerCase() == \"textarea\") {\n                    this.data$ = elem.value;\n                } else {\n                    this.data$ = elem.textContent;\n                }\n            }\n        } else {\n            this.fileno = 11;\n            this.data$ = Sk.read(name.v);\n        }\n\n        this.lineList = this.data$.split(\"\\n\");\n        this.lineList = this.lineList.slice(0, -1);\n\n        for (i in this.lineList) {\n            this.lineList[i] = this.lineList[i] + \"\\n\";\n        }\n        this.currentLine = 0;\n    }\n    this.pos$ = 0;\n\n    this.__class__ = Sk.builtin.file;\n\n    if (Sk.fileopen && this.fileno >= 10) {\n        Sk.fileopen(this);\n    }\n\n    return this;\n};\n\nSk.abstr.setUpInheritance(\"file\", Sk.builtin.file, Sk.builtin.object);\n\nSk.builtin.file.prototype[\"$r\"] = function () {\n    return new Sk.builtin.str(\"<\" +\n        (this.closed ? \"closed\" : \"open\") +\n        \"file '\" +\n        this.name +\n        \"', mode '\" +\n        Sk.ffi.remapToJs(this.mode) +\n        \"'>\");\n};\n\nSk.builtin.file.prototype[\"__enter__\"] = new Sk.builtin.func(function __enter__(self) {\n    return self;\n});\n\nSk.builtin.file.prototype[\"__exit__\"] = new Sk.builtin.func(function __exit__(self) {\n    return Sk.misceval.callsimArray(Sk.builtin.file.prototype[\"close\"], [self]);\n});\n\nSk.builtin.file.prototype.tp$iter = function () {\n    var allLines = this.lineList;\n    var currentLine = this.currentLine;\n\n    var ret =\n    {\n        tp$iter    : function () {\n            return ret;\n        },\n        $obj       : this,\n        $index     : currentLine,\n        $lines     : allLines,\n        tp$iternext: function () {\n            if (ret.$index >= ret.$lines.length) {\n                return undefined;\n            }\n            return new Sk.builtin.str(ret.$lines[ret.$index++]);\n        }\n    };\n    return ret;\n};\n\nSk.builtin.file.prototype[\"close\"] = new Sk.builtin.func(function close(self) {\n    self.closed = true;\n    return Sk.builtin.none.none$;\n});\n\nSk.builtin.file.prototype[\"flush\"] = new Sk.builtin.func(function flush(self) {\n});\n\nSk.builtin.file.prototype[\"fileno\"] = new Sk.builtin.func(function fileno(self) {\n    return this.fileno;\n}); // > 0, not 1/2/3\n\nSk.builtin.file.prototype[\"isatty\"] = new Sk.builtin.func(function isatty(self) {\n    return false;\n});\n\nSk.builtin.file.prototype[\"read\"] = new Sk.builtin.func(function read(self, size) {\n    var ret;\n    var len = self.data$.length;\n    var l_size;\n    if (self.closed) {\n        throw new Sk.builtin.ValueError(\"I/O operation on closed file\");\n    }\n\n    if (size === undefined) {\n        l_size = len;\n    } else {\n        l_size = Sk.ffi.remapToJs(size);\n    }\n\n    ret = new Sk.builtin.str(self.data$.substr(self.pos$, l_size));\n    if(size === undefined){\n        self.pos$ = len;\n    }else{\n        self.pos$ += Sk.ffi.remapToJs(size);\n    }\n    if (self.pos$ >= len) {\n        self.pos$ = len;\n    }\n\n    return ret;\n});\n\nSk.builtin.file.$readline = function (self, size, prompt) {\n    if (self.fileno === 0) {\n        var x, susp;\n\n        var lprompt = Sk.ffi.remapToJs(prompt);\n\n        lprompt = lprompt ? lprompt : \"\";\n\n        x = Sk.inputfun(lprompt);\n\n        if (x instanceof Promise) {\n            susp = new Sk.misceval.Suspension();\n\n            susp.resume = function() {\n                if (susp.data.error) {\n                    throw susp.data.error;\n                }\n\n                return new Sk.builtin.str(susp.data.result);\n            };\n\n            susp.data = {\n                type: \"Sk.promise\",\n                promise: x\n            };\n\n            return susp;\n        } else {\n            return new Sk.builtin.str(x);\n        }\n    } else {\n        var line = \"\";\n        if (self.currentLine < self.lineList.length) {\n            line = self.lineList[self.currentLine];\n            self.currentLine++;\n        }\n        return new Sk.builtin.str(line);\n    }\n};\n\nSk.builtin.file.prototype[\"readline\"] = new Sk.builtin.func(function readline(self, size) {\n    return Sk.builtin.file.$readline(self, size, undefined);\n});\n\nSk.builtin.file.prototype[\"readlines\"] = new Sk.builtin.func(function readlines(self, sizehint) {\n    if (self.fileno === 0) {\n        return new Sk.builtin.NotImplementedError(\"readlines ins't implemented because the web doesn't support Ctrl+D\");\n    }\n\n    var i;\n    var arr = [];\n    for (i = self.currentLine; i < self.lineList.length; i++) {\n        arr.push(new Sk.builtin.str(self.lineList[i]));\n    }\n    return new Sk.builtin.list(arr);\n});\n\nSk.builtin.file.prototype[\"seek\"] = new Sk.builtin.func(function seek(self, offset, whence) {\n    var l_offset =  Sk.ffi.remapToJs(offset);\n\n    if (whence === undefined) {\n        whence = 0;\n    }\n    if (whence === 0) {\n        self.pos$ = l_offset;\n    } else if (whence == 1) {\n        self.pos$ = self.data$.length + l_offset;\n    } else if (whence == 2) {\n        self.pos$ = self.data$.length + l_offset;\n    }\n\n    return Sk.builtin.none.none$;\n});\n\nSk.builtin.file.prototype[\"tell\"] = new Sk.builtin.func(function tell(self) {\n    return Sk.ffi.remapToPy(self.pos$);\n});\n\nSk.builtin.file.prototype[\"truncate\"] = new Sk.builtin.func(function truncate(self, size) {\n    Sk.asserts.fail();\n});\n\nSk.builtin.file.prototype[\"write\"] = new Sk.builtin.func(function write(self, str) {\n    var mode = Sk.ffi.remapToJs(self.mode);\n    if (mode === \"w\" || mode === \"wb\" || mode === \"a\" || mode === \"ab\") {\n        if (Sk.filewrite) {\n            if (self.closed) {\n                throw new Sk.builtin.ValueError(\"I/O operation on closed file\");\n            }\n\n            if (self.fileno === 1) {\n                Sk.output(Sk.ffi.remapToJs(str));\n            } else {\n                Sk.filewrite(self, str);\n            }\n        } else {\n            if (self.fileno === 1) {\n                Sk.output(Sk.ffi.remapToJs(str));\n            } else {\n                Sk.asserts.fail();\n            }\n        }\n    } else {\n        throw new Sk.builtin.IOError(\"File not open for writing\");\n    }\n});\n\n\nSk.exportSymbol(\"Sk.builtin.file\", Sk.builtin.file);\n\n\n/***/ }),\n/* 39 */\n/***/ (function(module, exports) {\n\n/**\n * @namespace Sk.ffi\n *\n */\n\nSk.ffi = Sk.ffi || {};\n\n/**\n * maps from Javascript Object/Array/string to Python dict/list/str.\n *\n * only works on basic objects that are being used as storage, doesn't handle\n * functions, etc.\n */\nSk.ffi.remapToPy = function (obj) {\n    var k;\n    var kvs;\n    var i;\n    var arr;\n\n    if (obj === null || typeof obj === \"undefined\") {\n        return Sk.builtin.none.none$;\n    }\n\n    if (obj.ob$type) {\n        return obj;\n    }\n\n    if (obj instanceof Sk.misceval.Suspension) {\n        return obj;\n    }\n\n    if (Object.prototype.toString.call(obj) === \"[object Array]\") {\n        arr = [];\n        for (i = 0; i < obj.length; ++i) {\n            arr.push(Sk.ffi.remapToPy(obj[i]));\n        }\n        return new Sk.builtin.list(arr);\n    }\n\n    if (typeof obj === \"object\") {\n        kvs = [];\n        for (k in obj) {\n            kvs.push(Sk.ffi.remapToPy(k));\n            kvs.push(Sk.ffi.remapToPy(obj[k]));\n        }\n        return new Sk.builtin.dict(kvs);\n    }\n\n    if (typeof obj === \"string\") {\n        return new Sk.builtin.str(obj);\n    }\n\n    if (typeof obj === \"number\") {\n        return Sk.builtin.assk$(obj);\n    }\n\n    if (typeof obj === \"boolean\") {\n        return new Sk.builtin.bool(obj);\n    } else if (typeof obj === \"undefined\") {\n        return Sk.builtin.none.none$;\n    }\n\n    if (typeof obj === \"function\") {\n        return new Sk.builtin.func(obj);\n    }\n\n    Sk.asserts.fail(\"unhandled remap type \" + typeof(obj));\n};\nSk.exportSymbol(\"Sk.ffi.remapToPy\", Sk.ffi.remapToPy);\n\n/**\n * Maps from Python dict/list/str/number to Javascript Object/Array/string/number.\n *\n * If obj is a\n *\n * @param obj {Object}  Any Python object (except a function)\n *\n */\nSk.ffi.remapToJs = function (obj) {\n    var i;\n    var kAsJs;\n    var v;\n    var iter, k;\n    var ret;\n    if (obj instanceof Sk.builtin.dict) {\n        ret = {};\n        for (iter = obj.tp$iter(), k = iter.tp$iternext();\n            k !== undefined;\n            k = iter.tp$iternext()) {\n            v = obj.mp$subscript(k);\n            if (v === undefined) {\n                v = null;\n            }\n            kAsJs = Sk.ffi.remapToJs(k);\n            // todo; assert that this is a reasonble lhs?\n            ret[kAsJs] = Sk.ffi.remapToJs(v);\n        }\n        return ret;\n    } else if (obj instanceof Sk.builtin.list || obj instanceof Sk.builtin.tuple) {\n        ret = [];\n        for (i = 0; i < obj.v.length; ++i) {\n            ret.push(Sk.ffi.remapToJs(obj.v[i]));\n        }\n        return ret;\n    } else if (obj instanceof Sk.builtin.bool) {\n        return obj.v ? true : false;\n    } else if (obj instanceof Sk.builtin.int_) {\n        return Sk.builtin.asnum$(obj);\n    } else if (obj instanceof Sk.builtin.float_) {\n        return Sk.builtin.asnum$(obj);\n    } else if (obj instanceof Sk.builtin.lng) {\n        return Sk.builtin.asnum$(obj);\n    } else if (typeof obj === \"number\" || typeof obj === \"boolean\" || typeof obj === \"string\") {\n        return obj;\n    } else if (obj === undefined) {\n        return undefined;\n    } else {\n        return obj.v;\n    }\n};\nSk.exportSymbol(\"Sk.ffi.remapToJs\", Sk.ffi.remapToJs);\n\nSk.ffi.callback = function (fn) {\n    if (fn === undefined) {\n        return fn;\n    }\n    return function () {\n        return Sk.misceval.apply(fn, undefined, undefined, undefined, Array.prototype.slice.call(arguments, 0));\n    };\n};\nSk.exportSymbol(\"Sk.ffi.callback\", Sk.ffi.callback);\n\nSk.ffi.stdwrap = function (type, towrap) {\n    var inst = new type();\n    inst[\"v\"] = towrap;\n    return inst;\n};\nSk.exportSymbol(\"Sk.ffi.stdwrap\", Sk.ffi.stdwrap);\n\n/**\n * for when the return type might be one of a variety of basic types.\n * number|string, etc.\n */\nSk.ffi.basicwrap = function (obj) {\n    if (obj instanceof Sk.builtin.int_) {\n        return Sk.builtin.asnum$(obj);\n    }\n    if (obj instanceof Sk.builtin.float_) {\n        return Sk.builtin.asnum$(obj);\n    }\n    if (obj instanceof Sk.builtin.lng) {\n        return Sk.builtin.asnum$(obj);\n    }\n    if (typeof obj === \"number\" || typeof obj === \"boolean\") {\n        return obj;\n    }\n    if (typeof obj === \"string\") {\n        return new Sk.builtin.str(obj);\n    }\n    Sk.asserts.fail(\"unexpected type for basicwrap\");\n};\nSk.exportSymbol(\"Sk.ffi.basicwrap\", Sk.ffi.basicwrap);\n\nSk.ffi.unwrapo = function (obj) {\n    if (obj === undefined) {\n        return undefined;\n    }\n    return obj[\"v\"];\n};\nSk.exportSymbol(\"Sk.ffi.unwrapo\", Sk.ffi.unwrapo);\n\nSk.ffi.unwrapn = function (obj) {\n    if (obj === null) {\n        return null;\n    }\n    return obj[\"v\"];\n};\nSk.exportSymbol(\"Sk.ffi.unwrapn\", Sk.ffi.unwrapn);\n\n\n/***/ }),\n/* 40 */\n/***/ (function(module, exports) {\n\n/**\n  * Builds an iterator that outputs the items from the inputted object\n  * @constructor\n  * @param {*} obj must support iter protocol (has __iter__ and next methods), if sentinel defined:\n  * obj must be callable\n  * @param {*=} sentinel optional if defined returns an object that makes a call to obj until\n  * sentinel is reached\n  * @extends Sk.builtin.object\n  *\n  * @description\n  * Constructor for Python iterator.\n  *\n  */\nSk.builtin.iterator = function (obj, sentinel) {\n    var objit;\n    if (obj instanceof Sk.builtin.generator) {\n        return obj;\n    }\n    objit = Sk.abstr.lookupSpecial(obj, Sk.builtin.str.$iter);\n    if (objit) {\n        return Sk.misceval.callsimArray(objit, [obj]);\n    }\n    this.sentinel = sentinel;\n    this.flag = false;\n    this.idx = 0;\n    this.obj = obj;\n    if (sentinel === undefined) {\n        this.getitem = Sk.abstr.lookupSpecial(obj, Sk.builtin.str.$getitem);\n        this.$r = function () {\n            return new Sk.builtin.str(\"<iterator object>\");\n        };\n    } else {\n        this.call = Sk.abstr.lookupSpecial(obj, Sk.builtin.str.$call);\n        this.$r = function () {\n            return new Sk.builtin.str(\"<callable-iterator object>\");\n        };\n    }\n    return this;\n};\n\nSk.abstr.setUpInheritance(\"iterator\", Sk.builtin.iterator, Sk.builtin.object);\n\nSk.builtin.iterator.prototype.__class__ = Sk.builtin.iterator;\n\nSk.builtin.iterator.prototype.__iter__ = new Sk.builtin.func(function (self) {\n    return self.tp$iter();\n});\n\nSk.builtin.iterator.prototype.tp$iter =  function () {\n    return this;\n};\n\nSk.builtin.iterator.prototype.tp$iternext = function (canSuspend) {\n    var r;\n    var self = this;\n\n    if (this.flag === true) {\n        // Iterator has already completed\n        return undefined;\n    }\n\n    if (this.getitem) {\n        r = Sk.misceval.tryCatch(function() {\n            return Sk.misceval.callsimOrSuspendArray(self.getitem, [self.obj, Sk.ffi.remapToPy(self.idx++)]);\n        }, function(e) {\n            if (e instanceof Sk.builtin.StopIteration || e instanceof Sk.builtin.IndexError) {\n                return undefined;\n            } else {\n                throw e;\n            }\n        });\n        return canSuspend ? r : Sk.misceval.retryOptionalSuspensionOrThrow(r);\n    }\n\n    var checkSentinel = function (ret) {\n        // Iteration is complete if ret value is the sentinel\n        if (Sk.misceval.richCompareBool(ret, self.sentinel, \"Eq\")) {\n            self.flag = true;\n            return undefined;\n        }\n        return ret;\n    };\n\n    if (this.call) {\n        r = Sk.misceval.chain(Sk.misceval.callsimOrSuspendArray(this.call, [this.obj]), checkSentinel);\n    } else {\n        var obj = /** @type {Object} */ (this.obj);\n        r = Sk.misceval.chain(Sk.misceval.callsimOrSuspendArray(obj), checkSentinel);\n    }\n\n    return canSuspend ? r : Sk.misceval.retryOptionalSuspensionOrThrow(r);\n};\n\nSk.builtin.iterator.prototype.next$ = function (self) {\n    var ret = self.tp$iternext();\n    if (!ret) {\n        throw new Sk.builtin.StopIteration();\n    }\n    return ret;\n};\n\nSk.exportSymbol(\"Sk.builtin.iterator\", Sk.builtin.iterator);\n\n\n/***/ }),\n/* 41 */\n/***/ (function(module, exports) {\n\n/**\n * @constructor\n * @param {Object} iterable\n * @param {number=} start\n * @extends Sk.builtin.object\n */\nSk.builtin.enumerate = function (iterable, start) {\n    var it;\n    if (!(this instanceof Sk.builtin.enumerate)) {\n        return new Sk.builtin.enumerate(iterable, start);\n    }\n\n\n    Sk.builtin.pyCheckArgsLen(\"enumerate\", arguments.length, 1, 2);\n    if (!Sk.builtin.checkIterable(iterable)) {\n        throw new Sk.builtin.TypeError(\"'\" + Sk.abstr.typeName(iterable) + \"' object is not iterable\");\n    }\n    if (start !== undefined) {\n        if (!Sk.misceval.isIndex(start)) {\n            throw new Sk.builtin.TypeError(\"'\" + Sk.abstr.typeName(start) + \"' object cannot be interpreted as an index\");\n        } else {\n            start = Sk.misceval.asIndex(start);\n        }\n    } else {\n        start = 0;\n    }\n\n    it = iterable.tp$iter();\n\n    this.tp$iter = function () {\n        return this;\n    };\n    this.$index = start;\n    this.tp$iternext = function () {\n        // todo; StopIteration\n        var idx;\n        var next = it.tp$iternext();\n        if (next === undefined) {\n            return undefined;\n        }\n        idx = new Sk.builtin.int_(this.$index++);\n        return new Sk.builtin.tuple([idx, next]);\n    };\n\n    this.__class__ = Sk.builtin.enumerate;\n\n    return this;\n};\n\nSk.abstr.setUpInheritance(\"enumerate\", Sk.builtin.enumerate, Sk.builtin.object);\n\nSk.builtin.enumerate.prototype[\"__iter__\"] = new Sk.builtin.func(function (self) {\n    return self.tp$iter();\n});\n\nSk.builtin.enumerate.prototype.next$ = function (self) {\n    return self.tp$iternext();\n};\n\nSk.builtin.enumerate.prototype[\"$r\"] = function () {\n    return new Sk.builtin.str(\"<enumerate object>\");\n};\n\n\n/***/ }),\n/* 42 */\n/***/ (function(module, exports) {\n\n//\"\"\"Token constants (from somewhere).\"\"\"\n\nvar __all__ = [\"tok_name\", \"ISTERMINAL\", \"ISNONTERMINAL\", \"ISEOF\"];\n\n// #  This file is automatically generated; please don't muck it up!\n// #\n// #  To update the symbols in this file, 'cd' to the top directory of\n// #  the python source tree after building the interpreter and run:\n// #\n// #    ./python Lib/token.py\n\n// #--start constants--\nvar tokens = {\n    T_ENDMARKER: 0,\n    T_NAME: 1,\n    T_NUMBER: 2,\n    T_STRING: 3,\n    T_NEWLINE: 4,\n    T_INDENT: 5,\n    T_DEDENT: 6,\n    T_LPAR: 7,\n    T_RPAR: 8,\n    T_LSQB: 9,\n    T_RSQB: 10,\n    T_COLON: 11,\n    T_COMMA: 12,\n    T_SEMI: 13,\n    T_PLUS: 14,\n    T_MINUS: 15,\n    T_STAR: 16,\n    T_SLASH: 17,\n    T_VBAR: 18,\n    T_AMPER: 19,\n    T_LESS: 20,\n    T_GREATER: 21,\n    T_EQUAL: 22,\n    T_DOT: 23,\n    T_PERCENT: 24,\n    T_LBRACE: 25,\n    T_RBRACE: 26,\n    T_EQEQUAL: 27,\n    T_NOTEQUAL: 28,\n    T_LESSEQUAL: 29,\n    T_GREATEREQUAL: 30,\n    T_TILDE: 31,\n    T_CIRCUMFLEX: 32,\n    T_LEFTSHIFT: 33,\n    T_RIGHTSHIFT: 34,\n    T_DOUBLESTAR: 35,\n    T_PLUSEQUAL: 36,\n    T_MINEQUAL: 37,\n    T_STAREQUAL: 38,\n    T_SLASHEQUAL: 39,\n    T_PERCENTEQUAL: 40,\n    T_AMPEREQUAL: 41,\n    T_VBAREQUAL: 42,\n    T_CIRCUMFLEXEQUAL: 43,\n    T_LEFTSHIFTEQUAL: 44,\n    T_RIGHTSHIFTEQUAL: 45,\n    T_DOUBLESTAREQUAL: 46,\n    T_DOUBLESLASH: 47,\n    T_DOUBLESLASHEQUAL: 48,\n    T_AT: 49,\n    T_ATEQUAL: 50,\n    T_RARROW: 51,\n    T_ELLIPSIS: 52,\n    T_OP: 53,\n    T_AWAIT: 54,\n    T_ASYNC: 55,\n    T_ERRORTOKEN: 56,\n\n    //special cases\n    T_NT_OFFSET: 256,\n    T_N_TOKENS: 60,\n\n    //taken from tokenize.py\n    T_COMMENT: 57,\n    T_NL: 58,\n    T_ENCODING: 59\n};\n// #--end constants--\n\nvar EXACT_TOKEN_TYPES = {\n    \"!=\": tokens.NOTEQUAL,\n    \"%\": tokens.PERCENT,\n    \"%=\": tokens.PERCENTEQUAL,\n    \"&\": tokens.AMPER,\n    \"&=\": tokens.AMPEREQUAL,\n    \"(\": tokens.LPAR,\n    \")\": tokens.RPAR,\n    \"*\": tokens.STAR,\n    \"**\": tokens.DOUBLESTAR,\n    \"**=\": tokens.DOUBLESTAREQUAL,\n    \"*=\": tokens.STAREQUAL,\n    \"+\": tokens.PLUS,\n    \"+=\": tokens.PLUSEQUAL,\n    \",\": tokens.COMMA,\n    \"-\": tokens.MINUS,\n    \"-=\": tokens.MINEQUAL,\n    \"->\": tokens.RARROW,\n    \".\": tokens.DOT,\n    \"...\": tokens.ELLIPSIS,\n    \"/\": tokens.SLASH,\n    \"//\": tokens.DOUBLESLASH,\n    \"//=\": tokens.DOUBLESLASHEQUAL,\n    \"/=\": tokens.SLASHEQUAL,\n    \":\": tokens.COLON,\n    \":=\": tokens.COLONEQUAL,\n    \";\": tokens.SEMI,\n    \"<\": tokens.LESS,\n    \"<<\": tokens.LEFTSHIFT,\n    \"<<=\": tokens.LEFTSHIFTEQUAL,\n    \"<=\": tokens.LESSEQUAL,\n    \"=\": tokens.EQUAL,\n    \"==\": tokens.EQEQUAL,\n    \">\": tokens.GREATER,\n    \">=\": tokens.GREATEREQUAL,\n    \">>\": tokens.RIGHTSHIFT,\n    \">>=\": tokens.RIGHTSHIFTEQUAL,\n    \"@\": tokens.AT,\n    \"@=\": tokens.ATEQUAL,\n    \"[\": tokens.LSQB,\n    \"]\": tokens.RSQB,\n    \"^\": tokens.CIRCUMFLEX,\n    \"^=\": tokens.CIRCUMFLEXEQUAL,\n    \"{\": tokens.LBRACE,\n    \"|\": tokens.VBAR,\n    \"|=\": tokens.VBAREQUAL,\n    \"}\": tokens.RBRACE,\n    \"~\": tokens.TILDE,\n};\n\nvar tok_name = {};\n(function() {\n    for (var i in tokens) {\n        tok_name[tokens[i]] = i;\n    }\n})();\n\n__all__.concat(Object.keys(tok_name).map(function (k) { return tok_name[k]; }));\n\nfunction ISTERMINAL(x) {\n    return x < tokens.T_NT_OFFSET;\n}\n\nfunction ISNONTERMINAL(x) {\n    return x >= tokens.T_NT_OFFSET;\n}\n\nfunction ISEOF(x) {\n    return x == tokens.T_ENDMARKER;\n}\n\nSk.token = {};\nSk.token.tokens = tokens;\nSk.token.tok_name = tok_name;\nSk.token.EXACT_TOKEN_TYPES = EXACT_TOKEN_TYPES;\nSk.token.ISTERMINAL = ISTERMINAL;\nSk.token.ISNONTERMINAL = ISNONTERMINAL;\nSk.token.ISEOF = ISEOF;\n\nSk.exportSymbol(\"Sk.token\", Sk.token);\nSk.exportSymbol(\"Sk.token.tokens\", Sk.token.tokens);\nSk.exportSymbol(\"Sk.token.tok_name\", Sk.token.tok_name);\nSk.exportSymbol(\"Sk.token.EXACT_TOKEN_TYPES\");\nSk.exportSymbol(\"Sk.token.ISTERMINAL\", Sk.token.ISTERMINAL);\nSk.exportSymbol(\"Sk.token.ISNONTERMINAL\", Sk.token.ISNONTERMINAL);\nSk.exportSymbol(\"Sk.token.ISEOF\", Sk.token.ISEOF);\n\n\n/***/ }),\n/* 43 */\n/***/ (function(module, exports) {\n\nvar tokens = Sk.token.tokens\n\nconst TokenError = Error;\nconst IndentationError = Error;\n\n/**\n *\n * @constructor\n * @param {number} type\n * @param {string} string\n * @param {Array<number>} start\n * @param {Array<number>} end\n * @param {string} line\n */\nfunction TokenInfo(type, string, start, end, line) {\n    this.type = type;\n    this.string = string;\n    this.start = start;\n    this.end = end;\n    this.line = line;\n}\n\nTokenInfo.prototype.exact_type = function() {\n    if (this.type == tokens.T_OP && this.string in Sk.token.EXACT_TOKEN_TYPES) {\n    return Sk.token.EXACT_TOKEN_TYPES[this.string]\n    } else {\n        return this.type\n    }\n}\n\n/** @param {...*} x */\nfunction group (x) {\n    var args = Array.prototype.slice.call(arguments);\n    return \"(\" + args.join(\"|\") + \")\";\n}\n\n/** @param {...*} x */\nfunction any (x) {\n    return group.apply(null, arguments) + \"*\";\n}\n\n/** @param {...*} x */\nfunction maybe (x) {\n    return group.apply(null, arguments) + \"?\";\n}\n\nvar reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g,\n    reHasRegExpChar = RegExp(reRegExpChar.source);\n\nfunction regexEscape(string) {\n    return (string && reHasRegExpChar.test(string))\n        ? string.replace(reRegExpChar, '\\\\$&')\n        : string;\n}\n\n/**\n * Iterable contains\n * @template T\n * @param {Iterable<T>} a\n * @param {T} obj\n */\nfunction contains (a, obj) {\n    var i = a.length;\n    while (i--) {\n        if (a[i] === obj) {\n            return true;\n        }\n    }\n    return false;\n}\n\nfunction rstrip (input, what) {\n    var i;\n    for (i = input.length; i > 0; --i) {\n        if (what.indexOf(input.charAt(i - 1)) === -1) {\n            break;\n        }\n    }\n    return input.substring(0, i);\n}\n\n/**\n * test if string is an identifier\n *\n * @param {str} string\n * @returns {boolean}\n */\nfunction isidentifier(str) {\n    var normalized = str.normalize('NFKC');\n    var the_underscore = '_';\n    var Lu = '[A-Z]';\n    var Ll = '[a-z]';\n    var Lt = '[\\\\u{10B99}-\\\\u{10B9C}\\\\u{112A9}\\\\u{115DC}-\\\\u{115DD}\\\\u034F\\\\u115F-\\\\u1160\\\\u17B4-\\\\u17B5\\\\u2065\\\\u3164\\\\uFFA0\\\\uFFF0-\\\\uFFF8\\\\u{E0000}\\\\u{E0002}-\\\\u{E001F}\\\\u{E0080}-\\\\u{E00FF}\\\\u{E01F0}-\\\\u{E0FFF}\\\\u{112A9}\\\\u00D7]';\n    var Lm = '[\\\\u02B0-\\\\u02C1\\\\u02C6-\\\\u02D1\\\\u02E0-\\\\u02E4\\\\u02EC\\\\u02EE\\\\u0374\\\\u037A\\\\u0559\\\\u06E5-\\\\u06E6\\\\u07F4-\\\\u07F5\\\\u0971\\\\u1C78-\\\\u1C7D\\\\u1D2C-\\\\u1D6A\\\\u1DFD-\\\\u1DFF\\\\u2E2F\\\\u30FC\\\\uA67F\\\\uA69C-\\\\uA69D\\\\uA717-\\\\uA71F\\\\uA788\\\\uA7F8-\\\\uA7F9\\\\uAB5C-\\\\uAB5F\\\\uFF70\\\\uFF9E-\\\\uFF9F\\\\u{16F93}-\\\\u{16F9F}\\\\u02D0-\\\\u02D1\\\\u0640\\\\u07FA\\\\u0E46\\\\u0EC6\\\\u1843\\\\u1AA7\\\\u1C7B\\\\u3005\\\\u3031-\\\\u3035\\\\u309D-\\\\u309E\\\\u30FC-\\\\u30FE\\\\uA015\\\\uA60C\\\\uA9CF\\\\uA9E6\\\\uAA70\\\\uAADD\\\\uAAF3-\\\\uAAF4\\\\uFF70\\\\u{16B42}-\\\\u{16B43}\\\\u{16FE0}-\\\\u{16FE1}\\\\u02B0-\\\\u02B8\\\\u02C0-\\\\u02C1\\\\u02E0-\\\\u02E4\\\\u037A\\\\u1D2C-\\\\u1D6A\\\\u1D78\\\\u1D9B-\\\\u1DBF\\\\u2071\\\\u207F\\\\u2090-\\\\u209C\\\\u2C7C-\\\\u2C7D\\\\uA69C-\\\\uA69D\\\\uA770\\\\uA7F8-\\\\uA7F9\\\\uAB5C-\\\\uAB5F\\\\uFF9E-\\\\uFF9F\\\\u02B2\\\\u1D62\\\\u1DA4\\\\u1DA8\\\\u2071\\\\u2C7C\\\\u2E18-\\\\u2E19\\\\u2E2F]';\n    var Lo = '[\\\\u2135-\\\\u2138\\\\u{1EE00}-\\\\u{1EE03}\\\\u{1EE05}-\\\\u{1EE1F}\\\\u{1EE21}-\\\\u{1EE22}\\\\u{1EE24}\\\\u{1EE27}\\\\u{1EE29}-\\\\u{1EE32}\\\\u{1EE34}-\\\\u{1EE37}\\\\u{1EE39}\\\\u{1EE3B}\\\\u{1EE42}\\\\u{1EE47}\\\\u{1EE49}\\\\u{1EE4B}\\\\u{1EE4D}-\\\\u{1EE4F}\\\\u{1EE51}-\\\\u{1EE52}\\\\u{1EE54}\\\\u{1EE57}\\\\u{1EE59}\\\\u{1EE5B}\\\\u{1EE5D}\\\\u{1EE5F}\\\\u{1EE61}-\\\\u{1EE62}\\\\u{1EE64}\\\\u{1EE67}-\\\\u{1EE6A}\\\\u{1EE6C}-\\\\u{1EE72}\\\\u{1EE74}-\\\\u{1EE77}\\\\u{1EE79}-\\\\u{1EE7C}\\\\u{1EE7E}\\\\u{1EE80}-\\\\u{1EE89}\\\\u{1EE8B}-\\\\u{1EE9B}\\\\u{1EEA1}-\\\\u{1EEA3}\\\\u{1EEA5}-\\\\u{1EEA9}\\\\u{1EEAB}-\\\\u{1EEBB}\\\\u3006\\\\u3400-\\\\u4DB5\\\\u4E00-\\\\u9FEF\\\\uF900-\\\\uFA6D\\\\uFA70-\\\\uFAD9\\\\u{17000}-\\\\u{187F1}\\\\u{18800}-\\\\u{18AF2}\\\\u{1B170}-\\\\u{1B2FB}\\\\u{20000}-\\\\u{2A6D6}\\\\u{2A700}-\\\\u{2B734}\\\\u{2B740}-\\\\u{2B81D}\\\\u{2B820}-\\\\u{2CEA1}\\\\u{2CEB0}-\\\\u{2EBE0}\\\\u{2F800}-\\\\u{2FA1D}\\\\uAAC0\\\\uAAC2\\\\uFE20-\\\\uFE2F\\\\u{10D22}-\\\\u{10D23}\\\\u{1135D}\\\\u00AA\\\\u00BA\\\\u3400-\\\\u4DB5\\\\u4E00-\\\\u9FEF\\\\uFA0E-\\\\uFA0F\\\\uFA11\\\\uFA13-\\\\uFA14\\\\uFA1F\\\\uFA21\\\\uFA23-\\\\uFA24\\\\uFA27-\\\\uFA29\\\\u{20000}-\\\\u{2A6D6}\\\\u{2A700}-\\\\u{2B734}\\\\u{2B740}-\\\\u{2B81D}\\\\u{2B820}-\\\\u{2CEA1}\\\\u{2CEB0}-\\\\u{2EBE0}\\\\u115F-\\\\u1160\\\\u3164\\\\uFFA0\\\\u0673\\\\u17A3-\\\\u17A4\\\\u0E40-\\\\u0E44\\\\u0EC0-\\\\u0EC4\\\\u19B5-\\\\u19B7\\\\u19BA\\\\uAAB5-\\\\uAAB6\\\\uAAB9\\\\uAABB-\\\\uAABC]';\n    var Nl = '[\\\\u3007\\\\u3021-\\\\u3029\\\\u3038-\\\\u303A\\\\u2170-\\\\u217F\\\\u2160-\\\\u216F]';\n    var Mn = '[\\\\u104A-\\\\u104B\\\\u102B-\\\\u102C\\\\u102D-\\\\u1030\\\\u1031\\\\u1032-\\\\u1036\\\\u1038\\\\u103B-\\\\u103C\\\\u103D-\\\\u103E\\\\u1056-\\\\u1057\\\\u1058-\\\\u1059\\\\u105E-\\\\u1060\\\\u1062\\\\u1067-\\\\u1068\\\\u1071-\\\\u1074\\\\u1082\\\\u1083-\\\\u1084\\\\u1085-\\\\u1086\\\\u109C\\\\u109D\\\\u1037\\\\u1039-\\\\u103A\\\\u1087-\\\\u108C\\\\u108D\\\\u108F\\\\u109A-\\\\u109B\\\\uA9E5\\\\uAA7B\\\\uAA7C\\\\uAA7D\\\\uA9E6\\\\uAA70\\\\u104A-\\\\u104B]';\n    var Mc = '[\\\\u0903\\\\u093B\\\\u093E-\\\\u0940\\\\u0949-\\\\u094C\\\\u094E-\\\\u094F\\\\u0982-\\\\u0983\\\\u09BE-\\\\u09C0\\\\u09C7-\\\\u09C8\\\\u09CB-\\\\u09CC\\\\u09D7\\\\u0A03\\\\u0A3E-\\\\u0A40\\\\u0A83\\\\u0ABE-\\\\u0AC0\\\\u0AC9\\\\u0ACB-\\\\u0ACC\\\\u0B02-\\\\u0B03\\\\u0B3E\\\\u0B40\\\\u0B47-\\\\u0B48\\\\u0B4B-\\\\u0B4C\\\\u0B57\\\\u0BBE-\\\\u0BBF\\\\u0BC1-\\\\u0BC2\\\\u0BC6-\\\\u0BC8\\\\u0BCA-\\\\u0BCC\\\\u0BD7\\\\u0C01-\\\\u0C03\\\\u0C41-\\\\u0C44\\\\u0C82-\\\\u0C83\\\\u0CBE\\\\u0CC0-\\\\u0CC4\\\\u0CC7-\\\\u0CC8\\\\u0CCA-\\\\u0CCB\\\\u0CD5-\\\\u0CD6\\\\u0D02-\\\\u0D03\\\\u0D3E-\\\\u0D40\\\\u0D46-\\\\u0D48\\\\u0D4A-\\\\u0D4C\\\\u0D57\\\\u0D82-\\\\u0D83\\\\u0DCF-\\\\u0DD1\\\\u0DD8-\\\\u0DDF\\\\u0DF2-\\\\u0DF3\\\\u0F7F\\\\u102B-\\\\u102C\\\\u1031\\\\u1038\\\\u103B-\\\\u103C\\\\u1056-\\\\u1057\\\\u1062\\\\u1067-\\\\u1068\\\\u1083-\\\\u1084\\\\u109C\\\\u17B6\\\\u17BE-\\\\u17C5\\\\u17C7-\\\\u17C8\\\\u1923-\\\\u1926\\\\u1929-\\\\u192B\\\\u1930-\\\\u1931\\\\u1933-\\\\u1938\\\\u1A19-\\\\u1A1A\\\\u1A55\\\\u1A57\\\\u1A61\\\\u1A63-\\\\u1A64\\\\u1A6D-\\\\u1A72\\\\u1B04\\\\u1B35\\\\u1B3B\\\\u1B3D-\\\\u1B41\\\\u1B43\\\\u1B82\\\\u1BA1\\\\u1BA6-\\\\u1BA7\\\\u1BE7\\\\u1BEA-\\\\u1BEC\\\\u1BEE\\\\u1C24-\\\\u1C2B\\\\u1C34-\\\\u1C35\\\\u1CF2-\\\\u1CF3\\\\uA823-\\\\uA824\\\\uA827\\\\uA880-\\\\uA881\\\\uA8B4-\\\\uA8C3\\\\uA952\\\\uA983\\\\uA9B4-\\\\uA9B5\\\\uA9BA-\\\\uA9BB\\\\uA9BD-\\\\uA9BF\\\\uAA2F-\\\\uAA30\\\\uAA33-\\\\uAA34\\\\uAA4D\\\\uAAEB\\\\uAAEE-\\\\uAAEF\\\\uAAF5\\\\uABE3-\\\\uABE4\\\\uABE6-\\\\uABE7\\\\uABE9-\\\\uABEA\\\\u{11000}\\\\u{11002}\\\\u{11082}\\\\u{110B0}-\\\\u{110B2}\\\\u{110B7}-\\\\u{110B8}\\\\u{1112C}\\\\u{11145}-\\\\u{11146}\\\\u{11182}\\\\u{111B3}-\\\\u{111B5}\\\\u{111BF}\\\\u{1122C}-\\\\u{1122E}\\\\u{11232}-\\\\u{11233}\\\\u{112E0}-\\\\u{112E2}\\\\u{11302}-\\\\u{11303}\\\\u{1133E}-\\\\u{1133F}\\\\u{11341}-\\\\u{11344}\\\\u{11347}-\\\\u{11348}\\\\u{1134B}-\\\\u{1134C}\\\\u{11357}\\\\u{11362}-\\\\u{11363}\\\\u{11435}-\\\\u{11437}\\\\u{11440}-\\\\u{11441}\\\\u{11445}\\\\u{114B0}-\\\\u{114B2}\\\\u{114B9}\\\\u{114BB}-\\\\u{114BE}\\\\u{114C1}\\\\u{115AF}-\\\\u{115B1}\\\\u{115B8}-\\\\u{115BB}\\\\u{115BE}\\\\u{11630}-\\\\u{11632}\\\\u{1163B}-\\\\u{1163C}\\\\u{1163E}\\\\u{116AC}\\\\u{116AE}-\\\\u{116AF}\\\\u{11720}-\\\\u{11721}\\\\u{11726}\\\\u{1182C}-\\\\u{1182E}\\\\u{11838}\\\\u{11A39}\\\\u{11A57}-\\\\u{11A58}\\\\u{11A97}\\\\u{11C2F}\\\\u{11C3E}\\\\u{11CA9}\\\\u{11CB1}\\\\u{11CB4}\\\\u{11D8A}-\\\\u{11D8E}\\\\u{11D93}-\\\\u{11D94}\\\\u{11D96}\\\\u{11EF5}-\\\\u{11EF6}\\\\u{16F51}-\\\\u{16F7E}\\\\u0F3E-\\\\u0F3F\\\\u1087-\\\\u108C\\\\u108F\\\\u109A-\\\\u109B\\\\u1B44\\\\u1BAA\\\\u1CE1\\\\u1CF7\\\\u302E-\\\\u302F\\\\uA953\\\\uA9C0\\\\uAA7B\\\\uAA7D\\\\uABEC\\\\u{111C0}\\\\u{11235}\\\\u{1134D}\\\\u{116B6}\\\\u{1D16D}-\\\\u{1D172}\\\\u09BE\\\\u09D7\\\\u0B3E\\\\u0B57\\\\u0BBE\\\\u0BD7\\\\u0CC2\\\\u0CD5-\\\\u0CD6\\\\u0D3E\\\\u0D57\\\\u0DCF\\\\u0DDF\\\\u302E-\\\\u302F\\\\u{1133E}\\\\u{11357}\\\\u{114B0}\\\\u{114BD}\\\\u{115AF}\\\\u{1D165}\\\\u{1D16E}-\\\\u{1D172}]';\n    var Nd = '[\\\\u{1D7CE}-\\\\u{1D7FF}\\\\uFF10-\\\\uFF19]';\n    var Pc = '\\\\u2040';\n    var Other_ID_Start = '[\\\\u1885-\\\\u1886\\\\u2118\\\\u212E\\\\u309B-\\\\u309C]';\n    var Other_ID_Continue = '[\\\\u00B7\\\\u0387\\\\u1369-\\\\u1371\\\\u19DA]';\n    var id_start = group(Lu, Ll,Lt, Lm, Lo, Nl, the_underscore, Other_ID_Start);\n    var id_continue = group(id_start, Mn, Mc, Nd, Pc, Other_ID_Continue);\n    var r;\n    // Fall back if we don't support unicode\n    if (RegExp().unicode === false) {\n        r = new RegExp('^' + id_start + '+' + id_continue + '*$', 'u');\n    } else {\n        id_start = group(Lu, Ll, the_underscore);\n        id_continue = group(id_start, '[0-9]');\n        r = new RegExp('^' + id_start + '+' + id_continue + '*$');\n    }\n    return r.test(normalized);\n}\n\n/* we have to use string and ctor to be able to build patterns up. + on /.../\n * does something strange.\n * Note: we use unicode matching for names (\"\\w\") but ascii matching for\n * number literals.\n *\n * I don't know if the comment above is still actually correct */\nvar Whitespace = \"[ \\\\f\\\\t]*\";\nvar Comment_ = \"#[^\\\\r\\\\n]*\";\nvar Ignore = Whitespace + any('\\\\\\\\\\\\r?\\\\n' + Whitespace) + maybe(Comment_)\nvar Name = \"\\\\w+\";\n\n\nvar Exponent = \"[eE][-+]?[0-9](?:_?[0-9])*\";\nvar Pointfloat = group('[0-9](?:_?[0-9])*\\\\.(?:[0-9](?:_?[0-9])*)?',\n                       '\\\\.[0-9](?:_?[0-9])*') + maybe(Exponent)\nvar Expfloat = \"[0-9](?:_?[0-9])*\" + Exponent;\nvar Floatnumber = group(Pointfloat, Expfloat);\nvar Imagnumber = group(\"[0-9](?:_?[0-9])*[jJ]\", Floatnumber + \"[jJ]\");\n\n// Return the empty string, plus all of the valid string prefixes.\nfunction _all_string_prefixes() {\n    return [\n        '', 'FR', 'RF', 'Br', 'BR', 'Fr', 'r', 'B', 'R', 'b', 'bR',\n        'f', 'rb', 'rB', 'F', 'Rf', 'U', 'rF', 'u', 'RB', 'br', 'fR',\n        'fr', 'rf', 'Rb'];\n}\n\n// Note that since _all_string_prefixes includes the empty string,\n//  StringPrefix can be the empty string (making it optional).\nvar StringPrefix = group.apply(null, _all_string_prefixes())\n\n// these regexes differ from python because .exec doesn't do the\n// same thing as .match in python. It's more like .search.\n// .match matches from the start of the string.\n// to get the same behaviour we can add a ^ to the start of the\n// regex\n// Tail end of ' string.\nvar Single = \"^[^'\\\\\\\\]*(?:\\\\\\\\.[^'\\\\\\\\]*)*'\";\n// Tail end of \" string.\nvar Double = '^[^\"\\\\\\\\]*(?:\\\\\\\\.[^\"\\\\\\\\]*)*\"';\n// Tail end of ''' string.\nvar Single3 = \"^[^'\\\\\\\\]*(?:(?:\\\\\\\\.|'(?!''))[^'\\\\\\\\]*)*'''\";\n// Tail end of \"\"\" string.\nvar Double3 = '^[^\"\\\\\\\\]*(?:(?:\\\\\\\\.|\"(?!\"\"))[^\"\\\\\\\\]*)*\"\"\"';\nvar Triple = group(StringPrefix + \"'''\", StringPrefix + '\"\"\"');\n// Single-line ' or \" string.\nvar String_ = group(StringPrefix + \"'[^\\\\n'\\\\\\\\]*(?:\\\\\\\\.[^\\\\n'\\\\\\\\]*)*'\",\n                    StringPrefix + '\"[^\\\\n\"\\\\\\\\]*(?:\\\\\\\\.[^\\\\n\"\\\\\\\\]*)*\"');\n\n// Sorting in reverse order puts the long operators before their prefixes.\n// Otherwise if = came before ==, == would get recognized as two instances\n// of =.\nvar EXACT_TOKENS_SORTED = Object.keys(Sk.token.EXACT_TOKEN_TYPES).sort();\nvar Special = group.apply(this, EXACT_TOKENS_SORTED.reverse().map(function (t) { return regexEscape(t); }));\nvar Funny = group('\\\\r?\\\\n', Special);\n\n// these aren't actually used\n// var PlainToken = group(Number_, Funny, String_, Name);\n// var Token = Ignore + PlainToken;\n\n// First (or only) line of ' or \" string.\nvar ContStr = group(StringPrefix + \"'[^\\\\n'\\\\\\\\]*(?:\\\\\\\\.[^\\\\n'\\\\\\\\]*)*\" +\n                group(\"'\", '\\\\\\\\\\\\r?\\\\n'),\n                StringPrefix + '\"[^\\\\n\"\\\\\\\\]*(?:\\\\\\\\.[^\\\\n\"\\\\\\\\]*)*' +\n                group('\"', '\\\\\\\\\\\\r?\\\\n'))\nvar PseudoExtras = group('\\\\\\\\\\\\r?\\\\n|$', Comment_, Triple);\n\n// For a given string prefix plus quotes, endpats maps it to a regex\n//  to match the remainder of that string. _prefix can be empty, for\n//  a normal single or triple quoted string (with no prefix).\nvar endpats = {}\nvar prefixes = _all_string_prefixes();\nfor (let _prefix of prefixes) {\n    endpats[_prefix + \"'\"] = Single\n    endpats[_prefix + '\"'] = Double\n    endpats[_prefix + \"'''\"] = Single3\n    endpats[_prefix + '\"\"\"'] = Double3\n}\n\n// A set of all of the single and triple quoted string prefixes,\n//  including the opening quotes.\nlet single_quoted = []\nlet triple_quoted = []\nfor (let t of prefixes) {\n    single_quoted.push(t + '\"');\n    single_quoted.push(t + \"'\");\n    triple_quoted.push(t + '\"\"\"');\n    triple_quoted.push(t + \"'''\");\n}\n\nvar tabsize = 8\n\n/**\n * internal tokenize function\n *\n * @param {function(): string} readline\n * @param {string} encoding\n * @param {function(TokenInfo): void} yield_\n */\nfunction _tokenize(readline, encoding, yield_) {\n    // we make these regexes here because they can\n    // be changed by the configuration.\n    var LSuffix = Sk.__future__.l_suffix ? '(?:L?)' : '';\n    var Hexnumber = '0[xX](?:_?[0-9a-fA-F])+' + LSuffix;\n    var Binnumber = '0[bB](?:_?[01])+' + LSuffix;\n    var Octnumber = '0([oO])(?:_?[0-7])+' + LSuffix;\n    var SilentOctnumber = '0([oO]?)(?:_?[0-7])+' + LSuffix;\n    var Decnumber = '(?:0(?:_?0)*|[1-9](?:_?[0-9])*)' + LSuffix;\n    var Intnumber = group(Hexnumber, Binnumber,\n                          (Sk.__future__.silent_octal_literal ? SilentOctnumber : Octnumber), Decnumber);\n    var Number_ = group(Imagnumber, Floatnumber, Intnumber);\n    var PseudoToken = Whitespace + group(PseudoExtras, Number_, Funny, ContStr, Name);\n\n    var lnum = 0,\n        parenlev = 0,\n        continued = 0,\n        numchars = '0123456789',\n        contstr = '',\n        needcont = 0,\n        contline = null,\n        indents = [0],\n        capos = null,\n        endprog = undefined,\n        strstart = undefined,\n        end = undefined,\n        pseudomatch = undefined;\n\n    if (encoding !== undefined) {\n        if (encoding == \"utf-8-sig\") {\n            // BOM will already have been stripped.\n            encoding = \"utf-8\";\n        }\n\n        yield_(new TokenInfo(tokens.T_ENCODING, encoding, [0, 0], [0, 0], ''));\n    }\n\n    var last_line = '';\n    var line = '';\n    while (true) {                                // loop over lines in stream\n        try {\n            // We capture the value of the line variable here because\n            // readline uses the empty string '' to signal end of input,\n            // hence `line` itself will always be overwritten at the end\n            // of this loop.\n            last_line = line;\n            line = readline();\n        } catch (Exception) {\n            line = '';\n        }\n\n        // lets pretend this doesn't exist for now.\n        // if encoding is not None:\n        //     line = line.decode(encoding)\n        lnum += 1;\n        var pos = 0;\n        var max = line.length;\n\n        if (contstr) {                       // continued string\n            if (!line) {\n                throw new TokenError(\"EOF in multi-line string\", strstart);\n            }\n            endprog.lastIndex = 0;\n            var endmatch = endprog.exec(line);\n            if (endmatch) {\n                pos = end = endmatch[0].length;\n                yield_(new TokenInfo(tokens.T_STRING, contstr + line.substring(0, end),\n                       strstart, [lnum, end], contline + line));\n                contstr = '';\n                needcont = 0;\n                contline = null;\n            } else if (needcont && line.substring(line.length - 2) !== \"\\\\\\n\" && line.substring(line.length - 3) !== \"\\\\\\r\\n\") {\n                yield_(new TokenInfo(tokens.T_ERRORTOKEN, contstr + line,\n                           strstart, [lnum, line.length], contline));\n                contstr = '';\n                contline = null;\n                continue;\n            } else {\n                contstr = contstr + line;\n                contline = contline + line;\n                continue;\n            }\n        } else if (parenlev == 0 && !continued) {  // new statement\n            if (!line) { break; }\n            var column = 0;\n            while (pos < max) {              // measure leading whitespace\n                if (line[pos] == ' ') {\n                    column += 1\n                } else if (line[pos] == '\\t') {\n                    column = Math.floor(column/tabsize + 1) * tabsize;\n                } else if (line[pos] == '\\f') {\n                    column = 0\n                } else {\n                    break;\n                };\n                pos += 1\n            }\n\n            if (pos == max) {\n                break;\n            }\n\n            if (contains('#\\r\\n', line[pos])) {       // skip comments or blank lines\n                if (line[pos] == '#') {\n                    var comment_token = rstrip(line.substring(pos), '\\r\\n');\n                    yield_(new TokenInfo(tokens.T_COMMENT, comment_token,\n                           [lnum, pos], [lnum, pos + comment_token.length], line));\n                    pos += comment_token.length;\n                }\n\n                yield_(new TokenInfo(tokens.T_NL, line.substring(pos),\n                           [lnum, pos], [lnum, line.length], line));\n                continue;\n            }\n\n            if (column > indents[indents.length - 1]) {           // count indents or dedents\n                indents.push(column);\n                yield_(new TokenInfo(tokens.T_INDENT, line.substring(pos), [lnum, 0], [lnum, pos], line));\n            }\n\n            while (column < indents[indents.length - 1]) {\n                if (!contains(indents, column)) {\n                    throw new IndentationError(\n                        \"unindent does not match any outer indentation level\",\n                        [\"<tokenize>\", lnum, pos, line]);\n                }\n\n                indents = indents.slice(0, -1);\n\n                yield_(new TokenInfo(tokens.T_DEDENT, '', [lnum, pos], [lnum, pos], line));\n            }\n        } else {                                  // continued statement\n            if (!line) {\n                throw new TokenError(\"EOF in multi-line statement\", [lnum, 0]);\n            }\n            continued = 0;\n        }\n\n        while (pos < max) {\n            //console.log(\"pos:\"+pos+\":\"+max);\n            // js regexes don't return any info about matches, other than the\n            // content. we'd like to put a \\w+ before pseudomatch, but then we\n            // can't get any data\n            capos = line.charAt(pos);\n            while (capos === ' ' || capos === '\\f' || capos === '\\t') {\n                pos += 1;\n                capos = line.charAt(pos);\n            }\n\n            pseudomatch = RegExp(PseudoToken).exec(line.substring(pos))\n            if (pseudomatch) {                                // scan for tokens\n                var start = pos;\n                var end = start + pseudomatch[1].length;\n                var spos = [lnum, start];\n                var epos = [lnum, end];\n                var pos = end;\n                if (start == end) {\n                    continue;\n                }\n\n                var token = line.substring(start, end);\n                var initial = line[start];\n                //console.log(\"token:\",token, \"initial:\",initial, start, end);\n                if (contains(numchars, initial) ||                 // ordinary number\n                    (initial == '.' && token != '.' && token != '...')) {\n                    yield_(new TokenInfo(tokens.T_NUMBER, token, spos, epos, line));\n                } else if (contains('\\r\\n', initial)) {\n                    if (parenlev > 0) {\n                        yield_(new TokenInfo(tokens.T_NL, token, spos, epos, line));\n                    } else {\n                        yield_(new TokenInfo(tokens.T_NEWLINE, token, spos, epos, line));\n                    }\n                } else if (initial == '#') {\n                    //assert not token.endswith(\"\\n\")\n                    yield_(new TokenInfo(tokens.T_COMMENT, token, spos, epos, line));\n                } else if (contains(triple_quoted, token)) {\n                    endprog = RegExp(endpats[token]);\n                    endmatch = endprog.exec(line.substring(pos));\n                    if (endmatch) {                       // all on one line\n                        pos = endmatch[0].length + pos;\n                        token = line.substring(start, pos);\n                        yield_(new TokenInfo(tokens.T_STRING, token, spos, [lnum, pos], line));\n                    } else {\n                        strstart = [lnum, start];           // multiple lines\n                        contstr = line.substring(start);\n                        contline = line;\n                        break;\n                    }\n                // Check up to the first 3 chars of the token to see if\n                //  they're in the single_quoted set. If so, they start\n                //  a string.\n                // We're using the first 3, because we're looking for\n                //  \"rb'\" (for example) at the start of the token. If\n                //  we switch to longer prefixes, this needs to be\n                //  adjusted.\n                // Note that initial == token[:1].\n                // Also note that single quote checking must come after\n                //  triple quote checking (above).\n                } else if (contains(single_quoted, initial) ||\n                           contains(single_quoted, token.substring(0, 2)) ||\n                           contains(single_quoted, token.substring(0, 3))) {\n                    if (token[token.length - 1] == '\\n') {                // continued string\n                        strstart = [lnum, start];\n                        // Again, using the first 3 chars of the\n                        //  token. This is looking for the matching end\n                        //  regex for the correct type of quote\n                        //  character. So it's really looking for\n                        //  endpats[\"'\"] or endpats['\"'], by trying to\n                        //  skip string prefix characters, if any.\n                        endprog = RegExp(endpats[initial] ||\n                                           endpats[token[1]] ||\n                                           endpats[token[2]]);\n                        contstr = line.substring(start);\n                        needcont = 1;\n                        contline = line;\n                        break;\n                    } else {                                  // ordinary string\n                        yield_(new TokenInfo(tokens.T_STRING, token, spos, epos, line));\n                    }\n\n                } else if (isidentifier(initial)) {              // ordinary name\n                    yield_(new TokenInfo(tokens.T_NAME, token, spos, epos, line));\n                } else if (initial == '\\\\') {                  // continued stmt\n                    continued = 1\n                } else {\n                    if (contains('([{', initial)) {\n                        parenlev += 1\n                    } else if (contains(')]}', initial)) {\n                        parenlev -= 1\n                    }\n                    yield_(new TokenInfo(tokens.T_OP, token, spos, epos, line));\n                }\n            } else {\n                yield_(new TokenInfo(tokens.T_ERRORTOKEN, line[pos],\n                           [lnum, pos], [lnum, pos+1], line));\n                pos += 1;\n            }\n        }\n    }\n\n    // Add an implicit NEWLINE if the input doesn't end in one\n    if (last_line && !contains('\\r\\n', last_line[last_line.length - 1])) {\n        yield_(new TokenInfo(tokens.T_NEWLINE, '', [lnum - 1, last_line.length], [lnum - 1, last_line.length + 1], ''));\n    }\n    for (var i in indents.slice(1)) {                 // pop remaining indent levels\n        yield_(new TokenInfo(tokens.T_DEDENT, '', [lnum, 0], [lnum, 0], ''));\n    }\n\n    yield_(new TokenInfo(tokens.T_ENDMARKER, '', [lnum, 0], [lnum, 0], ''));\n}\n\nSk._tokenize = _tokenize;\n\nSk.exportSymbol(\"Sk._tokenize\", Sk._tokenize);\n\n/***/ }),\n/* 44 */\n/***/ (function(module, exports) {\n\n// generated by pgen/main.py\nSk.OpMap = {\n\"(\": Sk.token.tokens.T_LPAR,\n\")\": Sk.token.tokens.T_RPAR,\n\"[\": Sk.token.tokens.T_LSQB,\n\"]\": Sk.token.tokens.T_RSQB,\n\":\": Sk.token.tokens.T_COLON,\n\",\": Sk.token.tokens.T_COMMA,\n\";\": Sk.token.tokens.T_SEMI,\n\"+\": Sk.token.tokens.T_PLUS,\n\"-\": Sk.token.tokens.T_MINUS,\n\"*\": Sk.token.tokens.T_STAR,\n\"/\": Sk.token.tokens.T_SLASH,\n\"|\": Sk.token.tokens.T_VBAR,\n\"&\": Sk.token.tokens.T_AMPER,\n\"<\": Sk.token.tokens.T_LESS,\n\">\": Sk.token.tokens.T_GREATER,\n\"=\": Sk.token.tokens.T_EQUAL,\n\".\": Sk.token.tokens.T_DOT,\n\"%\": Sk.token.tokens.T_PERCENT,\n\"`\": Sk.token.tokens.T_BACKQUOTE,\n\"{\": Sk.token.tokens.T_LBRACE,\n\"}\": Sk.token.tokens.T_RBRACE,\n\"@\": Sk.token.tokens.T_AT,\n\"==\": Sk.token.tokens.T_EQEQUAL,\n\"!=\": Sk.token.tokens.T_NOTEQUAL,\n\"<>\": Sk.token.tokens.T_NOTEQUAL,\n\"<=\": Sk.token.tokens.T_LESSEQUAL,\n\">=\": Sk.token.tokens.T_GREATEREQUAL,\n\"~\": Sk.token.tokens.T_TILDE,\n\"^\": Sk.token.tokens.T_CIRCUMFLEX,\n\"<<\": Sk.token.tokens.T_LEFTSHIFT,\n\">>\": Sk.token.tokens.T_RIGHTSHIFT,\n\"**\": Sk.token.tokens.T_DOUBLESTAR,\n\"+=\": Sk.token.tokens.T_PLUSEQUAL,\n\"-=\": Sk.token.tokens.T_MINEQUAL,\n\"*=\": Sk.token.tokens.T_STAREQUAL,\n\"/=\": Sk.token.tokens.T_SLASHEQUAL,\n\"%=\": Sk.token.tokens.T_PERCENTEQUAL,\n\"&=\": Sk.token.tokens.T_AMPEREQUAL,\n\"|=\": Sk.token.tokens.T_VBAREQUAL,\n\"^=\": Sk.token.tokens.T_CIRCUMFLEXEQUAL,\n\"<<=\": Sk.token.tokens.T_LEFTSHIFTEQUAL,\n\">>=\": Sk.token.tokens.T_RIGHTSHIFTEQUAL,\n\"**=\": Sk.token.tokens.T_DOUBLESTAREQUAL,\n\"//\": Sk.token.tokens.T_DOUBLESLASH,\n\"//=\": Sk.token.tokens.T_DOUBLESLASHEQUAL,\n\"->\": Sk.token.tokens.T_RARROW\n};\nSk.ParseTables = {\nsym:\n{and_expr: 257,\n and_test: 258,\n annassign: 259,\n arglist: 260,\n argument: 261,\n arith_expr: 262,\n assert_stmt: 263,\n async_funcdef: 264,\n async_stmt: 265,\n atom: 266,\n atom_expr: 267,\n augassign: 268,\n break_stmt: 269,\n classdef: 270,\n comp_for: 271,\n comp_if: 272,\n comp_iter: 273,\n comp_op: 274,\n comparison: 275,\n compound_stmt: 276,\n continue_stmt: 277,\n debugger_stmt: 278,\n decorated: 279,\n decorator: 280,\n decorators: 281,\n del_stmt: 282,\n dictorsetmaker: 283,\n dotted_as_name: 284,\n dotted_as_names: 285,\n dotted_name: 286,\n encoding_decl: 287,\n eval_input: 288,\n except_clause: 289,\n expr: 290,\n expr_stmt: 291,\n exprlist: 292,\n factor: 293,\n file_input: 294,\n flow_stmt: 295,\n for_stmt: 296,\n funcdef: 297,\n global_stmt: 298,\n if_stmt: 299,\n import_as_name: 300,\n import_as_names: 301,\n import_from: 302,\n import_name: 303,\n import_stmt: 304,\n lambdef: 305,\n lambdef_nocond: 306,\n nonlocal_stmt: 307,\n not_test: 308,\n or_test: 309,\n parameters: 310,\n pass_stmt: 311,\n power: 312,\n print_stmt: 313,\n raise_stmt: 314,\n return_stmt: 315,\n shift_expr: 316,\n simple_stmt: 317,\n single_input: 256,\n sliceop: 318,\n small_stmt: 319,\n star_expr: 320,\n stmt: 321,\n subscript: 322,\n subscriptlist: 323,\n suite: 324,\n term: 325,\n test: 326,\n test_nocond: 327,\n testlist: 328,\n testlist_comp: 329,\n testlist_star_expr: 330,\n tfpdef: 331,\n trailer: 332,\n try_stmt: 333,\n typedargslist: 334,\n varargslist: 335,\n vfpdef: 336,\n while_stmt: 337,\n with_item: 338,\n with_stmt: 339,\n xor_expr: 340,\n yield_arg: 341,\n yield_expr: 342,\n yield_stmt: 343},\nnumber2symbol:\n{256: 'single_input',\n 257: 'and_expr',\n 258: 'and_test',\n 259: 'annassign',\n 260: 'arglist',\n 261: 'argument',\n 262: 'arith_expr',\n 263: 'assert_stmt',\n 264: 'async_funcdef',\n 265: 'async_stmt',\n 266: 'atom',\n 267: 'atom_expr',\n 268: 'augassign',\n 269: 'break_stmt',\n 270: 'classdef',\n 271: 'comp_for',\n 272: 'comp_if',\n 273: 'comp_iter',\n 274: 'comp_op',\n 275: 'comparison',\n 276: 'compound_stmt',\n 277: 'continue_stmt',\n 278: 'debugger_stmt',\n 279: 'decorated',\n 280: 'decorator',\n 281: 'decorators',\n 282: 'del_stmt',\n 283: 'dictorsetmaker',\n 284: 'dotted_as_name',\n 285: 'dotted_as_names',\n 286: 'dotted_name',\n 287: 'encoding_decl',\n 288: 'eval_input',\n 289: 'except_clause',\n 290: 'expr',\n 291: 'expr_stmt',\n 292: 'exprlist',\n 293: 'factor',\n 294: 'file_input',\n 295: 'flow_stmt',\n 296: 'for_stmt',\n 297: 'funcdef',\n 298: 'global_stmt',\n 299: 'if_stmt',\n 300: 'import_as_name',\n 301: 'import_as_names',\n 302: 'import_from',\n 303: 'import_name',\n 304: 'import_stmt',\n 305: 'lambdef',\n 306: 'lambdef_nocond',\n 307: 'nonlocal_stmt',\n 308: 'not_test',\n 309: 'or_test',\n 310: 'parameters',\n 311: 'pass_stmt',\n 312: 'power',\n 313: 'print_stmt',\n 314: 'raise_stmt',\n 315: 'return_stmt',\n 316: 'shift_expr',\n 317: 'simple_stmt',\n 318: 'sliceop',\n 319: 'small_stmt',\n 320: 'star_expr',\n 321: 'stmt',\n 322: 'subscript',\n 323: 'subscriptlist',\n 324: 'suite',\n 325: 'term',\n 326: 'test',\n 327: 'test_nocond',\n 328: 'testlist',\n 329: 'testlist_comp',\n 330: 'testlist_star_expr',\n 331: 'tfpdef',\n 332: 'trailer',\n 333: 'try_stmt',\n 334: 'typedargslist',\n 335: 'varargslist',\n 336: 'vfpdef',\n 337: 'while_stmt',\n 338: 'with_item',\n 339: 'with_stmt',\n 340: 'xor_expr',\n 341: 'yield_arg',\n 342: 'yield_expr',\n 343: 'yield_stmt'},\ndfas:\n{256: [[[[1, 1], [2, 1], [3, 2]], [[0, 1]], [[2, 1]]],\n       {2: 1,\n        4: 1,\n        5: 1,\n        6: 1,\n        7: 1,\n        8: 1,\n        9: 1,\n        10: 1,\n        11: 1,\n        12: 1,\n        13: 1,\n        14: 1,\n        15: 1,\n        16: 1,\n        17: 1,\n        18: 1,\n        19: 1,\n        20: 1,\n        21: 1,\n        22: 1,\n        23: 1,\n        24: 1,\n        25: 1,\n        26: 1,\n        27: 1,\n        28: 1,\n        29: 1,\n        30: 1,\n        31: 1,\n        32: 1,\n        33: 1,\n        34: 1,\n        35: 1,\n        36: 1,\n        37: 1,\n        38: 1,\n        39: 1,\n        40: 1,\n        41: 1,\n        42: 1,\n        43: 1}],\n 257: [[[[44, 1]], [[45, 0], [0, 1]]],\n       {6: 1,\n        7: 1,\n        9: 1,\n        11: 1,\n        12: 1,\n        20: 1,\n        23: 1,\n        26: 1,\n        27: 1,\n        30: 1,\n        34: 1,\n        37: 1,\n        38: 1,\n        43: 1}],\n 258: [[[[46, 1]], [[47, 0], [0, 1]]],\n       {6: 1,\n        7: 1,\n        8: 1,\n        9: 1,\n        11: 1,\n        12: 1,\n        20: 1,\n        23: 1,\n        26: 1,\n        27: 1,\n        30: 1,\n        34: 1,\n        37: 1,\n        38: 1,\n        43: 1}],\n 259: [[[[48, 1]], [[49, 2]], [[50, 3], [0, 2]], [[49, 4]], [[0, 4]]],\n       {48: 1}],\n 260: [[[[51, 1]], [[52, 2], [0, 1]], [[51, 1], [0, 2]]],\n       {6: 1,\n        7: 1,\n        8: 1,\n        9: 1,\n        11: 1,\n        12: 1,\n        15: 1,\n        16: 1,\n        20: 1,\n        23: 1,\n        26: 1,\n        27: 1,\n        30: 1,\n        34: 1,\n        37: 1,\n        38: 1,\n        43: 1,\n        53: 1}],\n 261: [[[[49, 1], [16, 2], [53, 2]],\n        [[50, 2], [54, 3], [0, 1]],\n        [[49, 3]],\n        [[0, 3]]],\n       {6: 1,\n        7: 1,\n        8: 1,\n        9: 1,\n        11: 1,\n        12: 1,\n        15: 1,\n        16: 1,\n        20: 1,\n        23: 1,\n        26: 1,\n        27: 1,\n        30: 1,\n        34: 1,\n        37: 1,\n        38: 1,\n        43: 1,\n        53: 1}],\n 262: [[[[55, 1]], [[30, 0], [43, 0], [0, 1]]],\n       {6: 1,\n        7: 1,\n        9: 1,\n        11: 1,\n        12: 1,\n        20: 1,\n        23: 1,\n        26: 1,\n        27: 1,\n        30: 1,\n        34: 1,\n        37: 1,\n        38: 1,\n        43: 1}],\n 263: [[[[25, 1]], [[49, 2]], [[52, 3], [0, 2]], [[49, 4]], [[0, 4]]],\n       {25: 1}],\n 264: [[[[10, 1]], [[56, 2]], [[0, 2]]], {10: 1}],\n 265: [[[[10, 1]], [[57, 2], [56, 2], [58, 2]], [[0, 2]]], {10: 1}],\n 266: [[[[6, 1],\n         [7, 2],\n         [27, 1],\n         [9, 1],\n         [11, 1],\n         [12, 3],\n         [34, 4],\n         [37, 5],\n         [20, 1],\n         [26, 1]],\n        [[0, 1]],\n        [[7, 2], [0, 2]],\n        [[59, 1], [60, 6]],\n        [[61, 1], [62, 7], [63, 7]],\n        [[64, 1], [63, 8]],\n        [[59, 1]],\n        [[61, 1]],\n        [[64, 1]]],\n       {6: 1, 7: 1, 9: 1, 11: 1, 12: 1, 20: 1, 26: 1, 27: 1, 34: 1, 37: 1}],\n 267: [[[[38, 1], [65, 2]], [[65, 2]], [[66, 2], [0, 2]]],\n       {6: 1,\n        7: 1,\n        9: 1,\n        11: 1,\n        12: 1,\n        20: 1,\n        26: 1,\n        27: 1,\n        34: 1,\n        37: 1,\n        38: 1}],\n 268: [[[[67, 1],\n         [68, 1],\n         [69, 1],\n         [70, 1],\n         [71, 1],\n         [72, 1],\n         [73, 1],\n         [74, 1],\n         [75, 1],\n         [76, 1],\n         [77, 1],\n         [78, 1],\n         [79, 1]],\n        [[0, 1]]],\n       {67: 1,\n        68: 1,\n        69: 1,\n        70: 1,\n        71: 1,\n        72: 1,\n        73: 1,\n        74: 1,\n        75: 1,\n        76: 1,\n        77: 1,\n        78: 1,\n        79: 1}],\n 269: [[[[14, 1]], [[0, 1]]], {14: 1}],\n 270: [[[[13, 1]],\n        [[26, 2]],\n        [[48, 3], [34, 4]],\n        [[80, 5]],\n        [[61, 6], [81, 7]],\n        [[0, 5]],\n        [[48, 3]],\n        [[61, 6]]],\n       {13: 1}],\n 271: [[[[10, 1], [33, 2]],\n        [[33, 2]],\n        [[82, 3]],\n        [[83, 4]],\n        [[84, 5]],\n        [[85, 6], [0, 5]],\n        [[0, 6]]],\n       {10: 1, 33: 1}],\n 272: [[[[36, 1]], [[86, 2]], [[85, 3], [0, 2]], [[0, 3]]], {36: 1}],\n 273: [[[[87, 1], [54, 1]], [[0, 1]]], {10: 1, 33: 1, 36: 1}],\n 274: [[[[88, 1],\n         [89, 1],\n         [8, 2],\n         [90, 1],\n         [88, 1],\n         [83, 1],\n         [91, 1],\n         [92, 3],\n         [93, 1],\n         [94, 1]],\n        [[0, 1]],\n        [[83, 1]],\n        [[8, 1], [0, 3]]],\n       {8: 1, 83: 1, 88: 1, 89: 1, 90: 1, 91: 1, 92: 1, 93: 1, 94: 1}],\n 275: [[[[95, 1]], [[96, 0], [0, 1]]],\n       {6: 1,\n        7: 1,\n        9: 1,\n        11: 1,\n        12: 1,\n        20: 1,\n        23: 1,\n        26: 1,\n        27: 1,\n        30: 1,\n        34: 1,\n        37: 1,\n        38: 1,\n        43: 1}],\n 276: [[[[97, 1],\n         [98, 1],\n         [58, 1],\n         [99, 1],\n         [57, 1],\n         [100, 1],\n         [56, 1],\n         [101, 1],\n         [102, 1]],\n        [[0, 1]]],\n       {4: 1, 10: 1, 13: 1, 21: 1, 22: 1, 33: 1, 36: 1, 41: 1, 42: 1}],\n 277: [[[[40, 1]], [[0, 1]]], {40: 1}],\n 278: [[[[18, 1]], [[0, 1]]], {18: 1}],\n 279: [[[[103, 1]], [[56, 2], [104, 2], [99, 2]], [[0, 2]]], {41: 1}],\n 280: [[[[41, 1]],\n        [[105, 2]],\n        [[34, 4], [2, 3]],\n        [[0, 3]],\n        [[61, 5], [81, 6]],\n        [[2, 3]],\n        [[61, 5]]],\n       {41: 1}],\n 281: [[[[106, 1]], [[106, 1], [0, 1]]], {41: 1}],\n 282: [[[[39, 1]], [[82, 2]], [[0, 2]]], {39: 1}],\n 283: [[[[49, 1], [107, 2], [53, 3]],\n        [[48, 4], [54, 5], [52, 6], [0, 1]],\n        [[54, 5], [52, 6], [0, 2]],\n        [[95, 7]],\n        [[49, 7]],\n        [[0, 5]],\n        [[49, 8], [107, 8], [0, 6]],\n        [[54, 5], [52, 9], [0, 7]],\n        [[52, 6], [0, 8]],\n        [[49, 10], [53, 11], [0, 9]],\n        [[48, 12]],\n        [[95, 13]],\n        [[49, 13]],\n        [[52, 9], [0, 13]]],\n       {6: 1,\n        7: 1,\n        8: 1,\n        9: 1,\n        11: 1,\n        12: 1,\n        15: 1,\n        16: 1,\n        20: 1,\n        23: 1,\n        26: 1,\n        27: 1,\n        30: 1,\n        34: 1,\n        37: 1,\n        38: 1,\n        43: 1,\n        53: 1}],\n 284: [[[[105, 1]], [[108, 2], [0, 1]], [[26, 3]], [[0, 3]]], {26: 1}],\n 285: [[[[109, 1]], [[52, 0], [0, 1]]], {26: 1}],\n 286: [[[[26, 1]], [[110, 0], [0, 1]]], {26: 1}],\n 287: [[[[26, 1]], [[0, 1]]], {26: 1}],\n 288: [[[[111, 1]], [[2, 1], [112, 2]], [[0, 2]]],\n       {6: 1,\n        7: 1,\n        8: 1,\n        9: 1,\n        11: 1,\n        12: 1,\n        15: 1,\n        20: 1,\n        23: 1,\n        26: 1,\n        27: 1,\n        30: 1,\n        34: 1,\n        37: 1,\n        38: 1,\n        43: 1}],\n 289: [[[[113, 1]],\n        [[49, 2], [0, 1]],\n        [[108, 3], [52, 3], [0, 2]],\n        [[49, 4]],\n        [[0, 4]]],\n       {113: 1}],\n 290: [[[[114, 1]], [[115, 0], [0, 1]]],\n       {6: 1,\n        7: 1,\n        9: 1,\n        11: 1,\n        12: 1,\n        20: 1,\n        23: 1,\n        26: 1,\n        27: 1,\n        30: 1,\n        34: 1,\n        37: 1,\n        38: 1,\n        43: 1}],\n 291: [[[[116, 1]],\n        [[117, 2], [50, 3], [118, 4], [0, 1]],\n        [[111, 4], [62, 4]],\n        [[116, 5], [62, 5]],\n        [[0, 4]],\n        [[50, 3], [0, 5]]],\n       {6: 1,\n        7: 1,\n        8: 1,\n        9: 1,\n        11: 1,\n        12: 1,\n        15: 1,\n        16: 1,\n        20: 1,\n        23: 1,\n        26: 1,\n        27: 1,\n        30: 1,\n        34: 1,\n        37: 1,\n        38: 1,\n        43: 1}],\n 292: [[[[95, 1], [107, 1]], [[52, 2], [0, 1]], [[95, 1], [107, 1], [0, 2]]],\n       {6: 1,\n        7: 1,\n        9: 1,\n        11: 1,\n        12: 1,\n        16: 1,\n        20: 1,\n        23: 1,\n        26: 1,\n        27: 1,\n        30: 1,\n        34: 1,\n        37: 1,\n        38: 1,\n        43: 1}],\n 293: [[[[119, 2], [30, 1], [23, 1], [43, 1]], [[120, 2]], [[0, 2]]],\n       {6: 1,\n        7: 1,\n        9: 1,\n        11: 1,\n        12: 1,\n        20: 1,\n        23: 1,\n        26: 1,\n        27: 1,\n        30: 1,\n        34: 1,\n        37: 1,\n        38: 1,\n        43: 1}],\n 294: [[[[2, 0], [112, 1], [121, 0]], [[0, 1]]],\n       {2: 1,\n        4: 1,\n        5: 1,\n        6: 1,\n        7: 1,\n        8: 1,\n        9: 1,\n        10: 1,\n        11: 1,\n        12: 1,\n        13: 1,\n        14: 1,\n        15: 1,\n        16: 1,\n        17: 1,\n        18: 1,\n        19: 1,\n        20: 1,\n        21: 1,\n        22: 1,\n        23: 1,\n        24: 1,\n        25: 1,\n        26: 1,\n        27: 1,\n        28: 1,\n        29: 1,\n        30: 1,\n        31: 1,\n        32: 1,\n        33: 1,\n        34: 1,\n        35: 1,\n        36: 1,\n        37: 1,\n        38: 1,\n        39: 1,\n        40: 1,\n        41: 1,\n        42: 1,\n        43: 1,\n        112: 1}],\n 295: [[[[122, 1], [123, 1], [124, 1], [125, 1], [126, 1]], [[0, 1]]],\n       {5: 1, 14: 1, 24: 1, 31: 1, 40: 1}],\n 296: [[[[33, 1]],\n        [[82, 2]],\n        [[83, 3]],\n        [[111, 4]],\n        [[48, 5]],\n        [[80, 6]],\n        [[127, 7], [0, 6]],\n        [[48, 8]],\n        [[80, 9]],\n        [[0, 9]]],\n       {33: 1}],\n 297: [[[[4, 1]],\n        [[26, 2]],\n        [[128, 3]],\n        [[129, 4], [48, 5]],\n        [[49, 6]],\n        [[80, 7]],\n        [[48, 5]],\n        [[0, 7]]],\n       {4: 1}],\n 298: [[[[32, 1]], [[26, 2]], [[52, 1], [0, 2]]], {32: 1}],\n 299: [[[[36, 1]],\n        [[49, 2]],\n        [[48, 3]],\n        [[80, 4]],\n        [[127, 5], [130, 1], [0, 4]],\n        [[48, 6]],\n        [[80, 7]],\n        [[0, 7]]],\n       {36: 1}],\n 300: [[[[26, 1]], [[108, 2], [0, 1]], [[26, 3]], [[0, 3]]], {26: 1}],\n 301: [[[[131, 1]], [[52, 2], [0, 1]], [[131, 1], [0, 2]]], {26: 1}],\n 302: [[[[35, 1]],\n        [[105, 2], [20, 3], [110, 3]],\n        [[29, 4]],\n        [[105, 2], [20, 3], [29, 4], [110, 3]],\n        [[132, 5], [16, 5], [34, 6]],\n        [[0, 5]],\n        [[132, 7]],\n        [[61, 5]]],\n       {35: 1}],\n 303: [[[[29, 1]], [[133, 2]], [[0, 2]]], {29: 1}],\n 304: [[[[134, 1], [135, 1]], [[0, 1]]], {29: 1, 35: 1}],\n 305: [[[[15, 1]], [[48, 2], [136, 3]], [[49, 4]], [[48, 2]], [[0, 4]]],\n       {15: 1}],\n 306: [[[[15, 1]], [[48, 2], [136, 3]], [[86, 4]], [[48, 2]], [[0, 4]]],\n       {15: 1}],\n 307: [[[[19, 1]], [[26, 2]], [[52, 1], [0, 2]]], {19: 1}],\n 308: [[[[8, 1], [137, 2]], [[46, 2]], [[0, 2]]],\n       {6: 1,\n        7: 1,\n        8: 1,\n        9: 1,\n        11: 1,\n        12: 1,\n        20: 1,\n        23: 1,\n        26: 1,\n        27: 1,\n        30: 1,\n        34: 1,\n        37: 1,\n        38: 1,\n        43: 1}],\n 309: [[[[138, 1]], [[139, 0], [0, 1]]],\n       {6: 1,\n        7: 1,\n        8: 1,\n        9: 1,\n        11: 1,\n        12: 1,\n        20: 1,\n        23: 1,\n        26: 1,\n        27: 1,\n        30: 1,\n        34: 1,\n        37: 1,\n        38: 1,\n        43: 1}],\n 310: [[[[34, 1]], [[61, 2], [140, 3]], [[0, 2]], [[61, 2]]], {34: 1}],\n 311: [[[[28, 1]], [[0, 1]]], {28: 1}],\n 312: [[[[141, 1]], [[53, 2], [0, 1]], [[120, 3]], [[0, 3]]],\n       {6: 1,\n        7: 1,\n        9: 1,\n        11: 1,\n        12: 1,\n        20: 1,\n        26: 1,\n        27: 1,\n        34: 1,\n        37: 1,\n        38: 1}],\n 313: [[[[17, 1]],\n        [[49, 2], [142, 3], [0, 1]],\n        [[52, 4], [0, 2]],\n        [[49, 5]],\n        [[49, 2], [0, 4]],\n        [[52, 6], [0, 5]],\n        [[49, 7]],\n        [[52, 8], [0, 7]],\n        [[49, 7], [0, 8]]],\n       {17: 1}],\n 314: [[[[5, 1]],\n        [[49, 2], [0, 1]],\n        [[35, 3], [52, 3], [0, 2]],\n        [[49, 4]],\n        [[52, 5], [0, 4]],\n        [[49, 6]],\n        [[0, 6]]],\n       {5: 1}],\n 315: [[[[24, 1]], [[111, 2], [0, 1]], [[0, 2]]], {24: 1}],\n 316: [[[[143, 1]], [[142, 0], [144, 0], [0, 1]]],\n       {6: 1,\n        7: 1,\n        9: 1,\n        11: 1,\n        12: 1,\n        20: 1,\n        23: 1,\n        26: 1,\n        27: 1,\n        30: 1,\n        34: 1,\n        37: 1,\n        38: 1,\n        43: 1}],\n 317: [[[[145, 1]], [[2, 2], [146, 3]], [[0, 2]], [[145, 1], [2, 2]]],\n       {5: 1,\n        6: 1,\n        7: 1,\n        8: 1,\n        9: 1,\n        11: 1,\n        12: 1,\n        14: 1,\n        15: 1,\n        16: 1,\n        17: 1,\n        18: 1,\n        19: 1,\n        20: 1,\n        23: 1,\n        24: 1,\n        25: 1,\n        26: 1,\n        27: 1,\n        28: 1,\n        29: 1,\n        30: 1,\n        31: 1,\n        32: 1,\n        34: 1,\n        35: 1,\n        37: 1,\n        38: 1,\n        39: 1,\n        40: 1,\n        43: 1}],\n 318: [[[[48, 1]], [[49, 2], [0, 1]], [[0, 2]]], {48: 1}],\n 319: [[[[147, 1],\n         [148, 1],\n         [149, 1],\n         [150, 1],\n         [151, 1],\n         [152, 1],\n         [153, 1],\n         [154, 1],\n         [155, 1],\n         [156, 1]],\n        [[0, 1]]],\n       {5: 1,\n        6: 1,\n        7: 1,\n        8: 1,\n        9: 1,\n        11: 1,\n        12: 1,\n        14: 1,\n        15: 1,\n        16: 1,\n        17: 1,\n        18: 1,\n        19: 1,\n        20: 1,\n        23: 1,\n        24: 1,\n        25: 1,\n        26: 1,\n        27: 1,\n        28: 1,\n        29: 1,\n        30: 1,\n        31: 1,\n        32: 1,\n        34: 1,\n        35: 1,\n        37: 1,\n        38: 1,\n        39: 1,\n        40: 1,\n        43: 1}],\n 320: [[[[16, 1]], [[95, 2]], [[0, 2]]], {16: 1}],\n 321: [[[[1, 1], [3, 1]], [[0, 1]]],\n       {4: 1,\n        5: 1,\n        6: 1,\n        7: 1,\n        8: 1,\n        9: 1,\n        10: 1,\n        11: 1,\n        12: 1,\n        13: 1,\n        14: 1,\n        15: 1,\n        16: 1,\n        17: 1,\n        18: 1,\n        19: 1,\n        20: 1,\n        21: 1,\n        22: 1,\n        23: 1,\n        24: 1,\n        25: 1,\n        26: 1,\n        27: 1,\n        28: 1,\n        29: 1,\n        30: 1,\n        31: 1,\n        32: 1,\n        33: 1,\n        34: 1,\n        35: 1,\n        36: 1,\n        37: 1,\n        38: 1,\n        39: 1,\n        40: 1,\n        41: 1,\n        42: 1,\n        43: 1}],\n 322: [[[[49, 1], [48, 2]],\n        [[48, 2], [0, 1]],\n        [[49, 3], [157, 4], [0, 2]],\n        [[157, 4], [0, 3]],\n        [[0, 4]]],\n       {6: 1,\n        7: 1,\n        8: 1,\n        9: 1,\n        11: 1,\n        12: 1,\n        15: 1,\n        20: 1,\n        23: 1,\n        26: 1,\n        27: 1,\n        30: 1,\n        34: 1,\n        37: 1,\n        38: 1,\n        43: 1,\n        48: 1}],\n 323: [[[[158, 1]], [[52, 2], [0, 1]], [[158, 1], [0, 2]]],\n       {6: 1,\n        7: 1,\n        8: 1,\n        9: 1,\n        11: 1,\n        12: 1,\n        15: 1,\n        20: 1,\n        23: 1,\n        26: 1,\n        27: 1,\n        30: 1,\n        34: 1,\n        37: 1,\n        38: 1,\n        43: 1,\n        48: 1}],\n 324: [[[[1, 1], [2, 2]],\n        [[0, 1]],\n        [[159, 3]],\n        [[121, 4]],\n        [[160, 1], [121, 4]]],\n       {2: 1,\n        5: 1,\n        6: 1,\n        7: 1,\n        8: 1,\n        9: 1,\n        11: 1,\n        12: 1,\n        14: 1,\n        15: 1,\n        16: 1,\n        17: 1,\n        18: 1,\n        19: 1,\n        20: 1,\n        23: 1,\n        24: 1,\n        25: 1,\n        26: 1,\n        27: 1,\n        28: 1,\n        29: 1,\n        30: 1,\n        31: 1,\n        32: 1,\n        34: 1,\n        35: 1,\n        37: 1,\n        38: 1,\n        39: 1,\n        40: 1,\n        43: 1}],\n 325: [[[[120, 1]], [[161, 0], [16, 0], [162, 0], [41, 0], [163, 0], [0, 1]]],\n       {6: 1,\n        7: 1,\n        9: 1,\n        11: 1,\n        12: 1,\n        20: 1,\n        23: 1,\n        26: 1,\n        27: 1,\n        30: 1,\n        34: 1,\n        37: 1,\n        38: 1,\n        43: 1}],\n 326: [[[[84, 1], [164, 2]],\n        [[36, 3], [0, 1]],\n        [[0, 2]],\n        [[84, 4]],\n        [[127, 5]],\n        [[49, 2]]],\n       {6: 1,\n        7: 1,\n        8: 1,\n        9: 1,\n        11: 1,\n        12: 1,\n        15: 1,\n        20: 1,\n        23: 1,\n        26: 1,\n        27: 1,\n        30: 1,\n        34: 1,\n        37: 1,\n        38: 1,\n        43: 1}],\n 327: [[[[165, 1], [84, 1]], [[0, 1]]],\n       {6: 1,\n        7: 1,\n        8: 1,\n        9: 1,\n        11: 1,\n        12: 1,\n        15: 1,\n        20: 1,\n        23: 1,\n        26: 1,\n        27: 1,\n        30: 1,\n        34: 1,\n        37: 1,\n        38: 1,\n        43: 1}],\n 328: [[[[49, 1]], [[52, 2], [0, 1]], [[49, 1], [0, 2]]],\n       {6: 1,\n        7: 1,\n        8: 1,\n        9: 1,\n        11: 1,\n        12: 1,\n        15: 1,\n        20: 1,\n        23: 1,\n        26: 1,\n        27: 1,\n        30: 1,\n        34: 1,\n        37: 1,\n        38: 1,\n        43: 1}],\n 329: [[[[49, 1], [107, 1]],\n        [[54, 2], [52, 3], [0, 1]],\n        [[0, 2]],\n        [[49, 4], [107, 4], [0, 3]],\n        [[52, 3], [0, 4]]],\n       {6: 1,\n        7: 1,\n        8: 1,\n        9: 1,\n        11: 1,\n        12: 1,\n        15: 1,\n        16: 1,\n        20: 1,\n        23: 1,\n        26: 1,\n        27: 1,\n        30: 1,\n        34: 1,\n        37: 1,\n        38: 1,\n        43: 1}],\n 330: [[[[49, 1], [107, 1]], [[52, 2], [0, 1]], [[49, 1], [107, 1], [0, 2]]],\n       {6: 1,\n        7: 1,\n        8: 1,\n        9: 1,\n        11: 1,\n        12: 1,\n        15: 1,\n        16: 1,\n        20: 1,\n        23: 1,\n        26: 1,\n        27: 1,\n        30: 1,\n        34: 1,\n        37: 1,\n        38: 1,\n        43: 1}],\n 331: [[[[26, 1]], [[48, 2], [0, 1]], [[49, 3]], [[0, 3]]], {26: 1}],\n 332: [[[[34, 1], [110, 2], [37, 3]],\n        [[61, 4], [81, 5]],\n        [[26, 4]],\n        [[166, 6]],\n        [[0, 4]],\n        [[61, 4]],\n        [[64, 4]]],\n       {34: 1, 37: 1, 110: 1}],\n 333: [[[[21, 1]],\n        [[48, 2]],\n        [[80, 3]],\n        [[167, 4], [168, 5]],\n        [[48, 6]],\n        [[48, 7]],\n        [[80, 8]],\n        [[80, 9]],\n        [[167, 4], [127, 10], [168, 5], [0, 8]],\n        [[0, 9]],\n        [[48, 11]],\n        [[80, 12]],\n        [[168, 5], [0, 12]]],\n       {21: 1}],\n 334: [[[[16, 1], [169, 2], [53, 3]],\n        [[169, 4], [52, 5], [0, 1]],\n        [[50, 6], [52, 7], [0, 2]],\n        [[169, 8]],\n        [[52, 5], [0, 4]],\n        [[169, 9], [53, 3], [0, 5]],\n        [[49, 10]],\n        [[16, 11], [169, 2], [53, 3], [0, 7]],\n        [[52, 12], [0, 8]],\n        [[50, 13], [52, 5], [0, 9]],\n        [[52, 7], [0, 10]],\n        [[169, 14], [52, 15], [0, 11]],\n        [[0, 12]],\n        [[49, 4]],\n        [[52, 15], [0, 14]],\n        [[169, 16], [53, 3], [0, 15]],\n        [[50, 17], [52, 15], [0, 16]],\n        [[49, 14]]],\n       {16: 1, 26: 1, 53: 1}],\n 335: [[[[16, 1], [53, 2], [170, 3]],\n        [[170, 5], [52, 4], [0, 1]],\n        [[170, 6]],\n        [[50, 7], [52, 8], [0, 3]],\n        [[53, 2], [170, 9], [0, 4]],\n        [[52, 4], [0, 5]],\n        [[52, 10], [0, 6]],\n        [[49, 11]],\n        [[16, 12], [53, 2], [170, 3], [0, 8]],\n        [[50, 13], [52, 4], [0, 9]],\n        [[0, 10]],\n        [[52, 8], [0, 11]],\n        [[52, 15], [170, 14], [0, 12]],\n        [[49, 5]],\n        [[52, 15], [0, 14]],\n        [[53, 2], [170, 16], [0, 15]],\n        [[50, 17], [52, 15], [0, 16]],\n        [[49, 14]]],\n       {16: 1, 26: 1, 53: 1}],\n 336: [[[[26, 1]], [[0, 1]]], {26: 1}],\n 337: [[[[22, 1]],\n        [[49, 2]],\n        [[48, 3]],\n        [[80, 4]],\n        [[127, 5], [0, 4]],\n        [[48, 6]],\n        [[80, 7]],\n        [[0, 7]]],\n       {22: 1}],\n 338: [[[[49, 1]], [[108, 2], [0, 1]], [[95, 3]], [[0, 3]]],\n       {6: 1,\n        7: 1,\n        8: 1,\n        9: 1,\n        11: 1,\n        12: 1,\n        15: 1,\n        20: 1,\n        23: 1,\n        26: 1,\n        27: 1,\n        30: 1,\n        34: 1,\n        37: 1,\n        38: 1,\n        43: 1}],\n 339: [[[[42, 1]], [[171, 2]], [[48, 3], [52, 1]], [[80, 4]], [[0, 4]]],\n       {42: 1}],\n 340: [[[[172, 1]], [[173, 0], [0, 1]]],\n       {6: 1,\n        7: 1,\n        9: 1,\n        11: 1,\n        12: 1,\n        20: 1,\n        23: 1,\n        26: 1,\n        27: 1,\n        30: 1,\n        34: 1,\n        37: 1,\n        38: 1,\n        43: 1}],\n 341: [[[[111, 2], [35, 1]], [[49, 2]], [[0, 2]]],\n       {6: 1,\n        7: 1,\n        8: 1,\n        9: 1,\n        11: 1,\n        12: 1,\n        15: 1,\n        20: 1,\n        23: 1,\n        26: 1,\n        27: 1,\n        30: 1,\n        34: 1,\n        35: 1,\n        37: 1,\n        38: 1,\n        43: 1}],\n 342: [[[[31, 1]], [[174, 2], [0, 1]], [[0, 2]]], {31: 1}],\n 343: [[[[62, 1]], [[0, 1]]], {31: 1}]},\nstates:\n[[[[1, 1], [2, 1], [3, 2]], [[0, 1]], [[2, 1]]],\n [[[44, 1]], [[45, 0], [0, 1]]],\n [[[46, 1]], [[47, 0], [0, 1]]],\n [[[48, 1]], [[49, 2]], [[50, 3], [0, 2]], [[49, 4]], [[0, 4]]],\n [[[51, 1]], [[52, 2], [0, 1]], [[51, 1], [0, 2]]],\n [[[49, 1], [16, 2], [53, 2]],\n  [[50, 2], [54, 3], [0, 1]],\n  [[49, 3]],\n  [[0, 3]]],\n [[[55, 1]], [[30, 0], [43, 0], [0, 1]]],\n [[[25, 1]], [[49, 2]], [[52, 3], [0, 2]], [[49, 4]], [[0, 4]]],\n [[[10, 1]], [[56, 2]], [[0, 2]]],\n [[[10, 1]], [[57, 2], [56, 2], [58, 2]], [[0, 2]]],\n [[[6, 1],\n   [7, 2],\n   [27, 1],\n   [9, 1],\n   [11, 1],\n   [12, 3],\n   [34, 4],\n   [37, 5],\n   [20, 1],\n   [26, 1]],\n  [[0, 1]],\n  [[7, 2], [0, 2]],\n  [[59, 1], [60, 6]],\n  [[61, 1], [62, 7], [63, 7]],\n  [[64, 1], [63, 8]],\n  [[59, 1]],\n  [[61, 1]],\n  [[64, 1]]],\n [[[38, 1], [65, 2]], [[65, 2]], [[66, 2], [0, 2]]],\n [[[67, 1],\n   [68, 1],\n   [69, 1],\n   [70, 1],\n   [71, 1],\n   [72, 1],\n   [73, 1],\n   [74, 1],\n   [75, 1],\n   [76, 1],\n   [77, 1],\n   [78, 1],\n   [79, 1]],\n  [[0, 1]]],\n [[[14, 1]], [[0, 1]]],\n [[[13, 1]],\n  [[26, 2]],\n  [[48, 3], [34, 4]],\n  [[80, 5]],\n  [[61, 6], [81, 7]],\n  [[0, 5]],\n  [[48, 3]],\n  [[61, 6]]],\n [[[10, 1], [33, 2]],\n  [[33, 2]],\n  [[82, 3]],\n  [[83, 4]],\n  [[84, 5]],\n  [[85, 6], [0, 5]],\n  [[0, 6]]],\n [[[36, 1]], [[86, 2]], [[85, 3], [0, 2]], [[0, 3]]],\n [[[87, 1], [54, 1]], [[0, 1]]],\n [[[88, 1],\n   [89, 1],\n   [8, 2],\n   [90, 1],\n   [88, 1],\n   [83, 1],\n   [91, 1],\n   [92, 3],\n   [93, 1],\n   [94, 1]],\n  [[0, 1]],\n  [[83, 1]],\n  [[8, 1], [0, 3]]],\n [[[95, 1]], [[96, 0], [0, 1]]],\n [[[97, 1],\n   [98, 1],\n   [58, 1],\n   [99, 1],\n   [57, 1],\n   [100, 1],\n   [56, 1],\n   [101, 1],\n   [102, 1]],\n  [[0, 1]]],\n [[[40, 1]], [[0, 1]]],\n [[[18, 1]], [[0, 1]]],\n [[[103, 1]], [[56, 2], [104, 2], [99, 2]], [[0, 2]]],\n [[[41, 1]],\n  [[105, 2]],\n  [[34, 4], [2, 3]],\n  [[0, 3]],\n  [[61, 5], [81, 6]],\n  [[2, 3]],\n  [[61, 5]]],\n [[[106, 1]], [[106, 1], [0, 1]]],\n [[[39, 1]], [[82, 2]], [[0, 2]]],\n [[[49, 1], [107, 2], [53, 3]],\n  [[48, 4], [54, 5], [52, 6], [0, 1]],\n  [[54, 5], [52, 6], [0, 2]],\n  [[95, 7]],\n  [[49, 7]],\n  [[0, 5]],\n  [[49, 8], [107, 8], [0, 6]],\n  [[54, 5], [52, 9], [0, 7]],\n  [[52, 6], [0, 8]],\n  [[49, 10], [53, 11], [0, 9]],\n  [[48, 12]],\n  [[95, 13]],\n  [[49, 13]],\n  [[52, 9], [0, 13]]],\n [[[105, 1]], [[108, 2], [0, 1]], [[26, 3]], [[0, 3]]],\n [[[109, 1]], [[52, 0], [0, 1]]],\n [[[26, 1]], [[110, 0], [0, 1]]],\n [[[26, 1]], [[0, 1]]],\n [[[111, 1]], [[2, 1], [112, 2]], [[0, 2]]],\n [[[113, 1]],\n  [[49, 2], [0, 1]],\n  [[108, 3], [52, 3], [0, 2]],\n  [[49, 4]],\n  [[0, 4]]],\n [[[114, 1]], [[115, 0], [0, 1]]],\n [[[116, 1]],\n  [[117, 2], [50, 3], [118, 4], [0, 1]],\n  [[111, 4], [62, 4]],\n  [[116, 5], [62, 5]],\n  [[0, 4]],\n  [[50, 3], [0, 5]]],\n [[[95, 1], [107, 1]], [[52, 2], [0, 1]], [[95, 1], [107, 1], [0, 2]]],\n [[[119, 2], [30, 1], [23, 1], [43, 1]], [[120, 2]], [[0, 2]]],\n [[[2, 0], [112, 1], [121, 0]], [[0, 1]]],\n [[[122, 1], [123, 1], [124, 1], [125, 1], [126, 1]], [[0, 1]]],\n [[[33, 1]],\n  [[82, 2]],\n  [[83, 3]],\n  [[111, 4]],\n  [[48, 5]],\n  [[80, 6]],\n  [[127, 7], [0, 6]],\n  [[48, 8]],\n  [[80, 9]],\n  [[0, 9]]],\n [[[4, 1]],\n  [[26, 2]],\n  [[128, 3]],\n  [[129, 4], [48, 5]],\n  [[49, 6]],\n  [[80, 7]],\n  [[48, 5]],\n  [[0, 7]]],\n [[[32, 1]], [[26, 2]], [[52, 1], [0, 2]]],\n [[[36, 1]],\n  [[49, 2]],\n  [[48, 3]],\n  [[80, 4]],\n  [[127, 5], [130, 1], [0, 4]],\n  [[48, 6]],\n  [[80, 7]],\n  [[0, 7]]],\n [[[26, 1]], [[108, 2], [0, 1]], [[26, 3]], [[0, 3]]],\n [[[131, 1]], [[52, 2], [0, 1]], [[131, 1], [0, 2]]],\n [[[35, 1]],\n  [[105, 2], [20, 3], [110, 3]],\n  [[29, 4]],\n  [[105, 2], [20, 3], [29, 4], [110, 3]],\n  [[132, 5], [16, 5], [34, 6]],\n  [[0, 5]],\n  [[132, 7]],\n  [[61, 5]]],\n [[[29, 1]], [[133, 2]], [[0, 2]]],\n [[[134, 1], [135, 1]], [[0, 1]]],\n [[[15, 1]], [[48, 2], [136, 3]], [[49, 4]], [[48, 2]], [[0, 4]]],\n [[[15, 1]], [[48, 2], [136, 3]], [[86, 4]], [[48, 2]], [[0, 4]]],\n [[[19, 1]], [[26, 2]], [[52, 1], [0, 2]]],\n [[[8, 1], [137, 2]], [[46, 2]], [[0, 2]]],\n [[[138, 1]], [[139, 0], [0, 1]]],\n [[[34, 1]], [[61, 2], [140, 3]], [[0, 2]], [[61, 2]]],\n [[[28, 1]], [[0, 1]]],\n [[[141, 1]], [[53, 2], [0, 1]], [[120, 3]], [[0, 3]]],\n [[[17, 1]],\n  [[49, 2], [142, 3], [0, 1]],\n  [[52, 4], [0, 2]],\n  [[49, 5]],\n  [[49, 2], [0, 4]],\n  [[52, 6], [0, 5]],\n  [[49, 7]],\n  [[52, 8], [0, 7]],\n  [[49, 7], [0, 8]]],\n [[[5, 1]],\n  [[49, 2], [0, 1]],\n  [[35, 3], [52, 3], [0, 2]],\n  [[49, 4]],\n  [[52, 5], [0, 4]],\n  [[49, 6]],\n  [[0, 6]]],\n [[[24, 1]], [[111, 2], [0, 1]], [[0, 2]]],\n [[[143, 1]], [[142, 0], [144, 0], [0, 1]]],\n [[[145, 1]], [[2, 2], [146, 3]], [[0, 2]], [[145, 1], [2, 2]]],\n [[[48, 1]], [[49, 2], [0, 1]], [[0, 2]]],\n [[[147, 1],\n   [148, 1],\n   [149, 1],\n   [150, 1],\n   [151, 1],\n   [152, 1],\n   [153, 1],\n   [154, 1],\n   [155, 1],\n   [156, 1]],\n  [[0, 1]]],\n [[[16, 1]], [[95, 2]], [[0, 2]]],\n [[[1, 1], [3, 1]], [[0, 1]]],\n [[[49, 1], [48, 2]],\n  [[48, 2], [0, 1]],\n  [[49, 3], [157, 4], [0, 2]],\n  [[157, 4], [0, 3]],\n  [[0, 4]]],\n [[[158, 1]], [[52, 2], [0, 1]], [[158, 1], [0, 2]]],\n [[[1, 1], [2, 2]], [[0, 1]], [[159, 3]], [[121, 4]], [[160, 1], [121, 4]]],\n [[[120, 1]], [[161, 0], [16, 0], [162, 0], [41, 0], [163, 0], [0, 1]]],\n [[[84, 1], [164, 2]],\n  [[36, 3], [0, 1]],\n  [[0, 2]],\n  [[84, 4]],\n  [[127, 5]],\n  [[49, 2]]],\n [[[165, 1], [84, 1]], [[0, 1]]],\n [[[49, 1]], [[52, 2], [0, 1]], [[49, 1], [0, 2]]],\n [[[49, 1], [107, 1]],\n  [[54, 2], [52, 3], [0, 1]],\n  [[0, 2]],\n  [[49, 4], [107, 4], [0, 3]],\n  [[52, 3], [0, 4]]],\n [[[49, 1], [107, 1]], [[52, 2], [0, 1]], [[49, 1], [107, 1], [0, 2]]],\n [[[26, 1]], [[48, 2], [0, 1]], [[49, 3]], [[0, 3]]],\n [[[34, 1], [110, 2], [37, 3]],\n  [[61, 4], [81, 5]],\n  [[26, 4]],\n  [[166, 6]],\n  [[0, 4]],\n  [[61, 4]],\n  [[64, 4]]],\n [[[21, 1]],\n  [[48, 2]],\n  [[80, 3]],\n  [[167, 4], [168, 5]],\n  [[48, 6]],\n  [[48, 7]],\n  [[80, 8]],\n  [[80, 9]],\n  [[167, 4], [127, 10], [168, 5], [0, 8]],\n  [[0, 9]],\n  [[48, 11]],\n  [[80, 12]],\n  [[168, 5], [0, 12]]],\n [[[16, 1], [169, 2], [53, 3]],\n  [[169, 4], [52, 5], [0, 1]],\n  [[50, 6], [52, 7], [0, 2]],\n  [[169, 8]],\n  [[52, 5], [0, 4]],\n  [[169, 9], [53, 3], [0, 5]],\n  [[49, 10]],\n  [[16, 11], [169, 2], [53, 3], [0, 7]],\n  [[52, 12], [0, 8]],\n  [[50, 13], [52, 5], [0, 9]],\n  [[52, 7], [0, 10]],\n  [[169, 14], [52, 15], [0, 11]],\n  [[0, 12]],\n  [[49, 4]],\n  [[52, 15], [0, 14]],\n  [[169, 16], [53, 3], [0, 15]],\n  [[50, 17], [52, 15], [0, 16]],\n  [[49, 14]]],\n [[[16, 1], [53, 2], [170, 3]],\n  [[170, 5], [52, 4], [0, 1]],\n  [[170, 6]],\n  [[50, 7], [52, 8], [0, 3]],\n  [[53, 2], [170, 9], [0, 4]],\n  [[52, 4], [0, 5]],\n  [[52, 10], [0, 6]],\n  [[49, 11]],\n  [[16, 12], [53, 2], [170, 3], [0, 8]],\n  [[50, 13], [52, 4], [0, 9]],\n  [[0, 10]],\n  [[52, 8], [0, 11]],\n  [[52, 15], [170, 14], [0, 12]],\n  [[49, 5]],\n  [[52, 15], [0, 14]],\n  [[53, 2], [170, 16], [0, 15]],\n  [[50, 17], [52, 15], [0, 16]],\n  [[49, 14]]],\n [[[26, 1]], [[0, 1]]],\n [[[22, 1]],\n  [[49, 2]],\n  [[48, 3]],\n  [[80, 4]],\n  [[127, 5], [0, 4]],\n  [[48, 6]],\n  [[80, 7]],\n  [[0, 7]]],\n [[[49, 1]], [[108, 2], [0, 1]], [[95, 3]], [[0, 3]]],\n [[[42, 1]], [[171, 2]], [[48, 3], [52, 1]], [[80, 4]], [[0, 4]]],\n [[[172, 1]], [[173, 0], [0, 1]]],\n [[[111, 2], [35, 1]], [[49, 2]], [[0, 2]]],\n [[[31, 1]], [[174, 2], [0, 1]], [[0, 2]]],\n [[[62, 1]], [[0, 1]]]],\nlabels:\n[[0, 'EMPTY'],\n [317, null],\n [4, null],\n [276, null],\n [1, 'def'],\n [1, 'raise'],\n [1, 'True'],\n [3, null],\n [1, 'not'],\n [1, 'null'],\n [55, null],\n [2, null],\n [25, null],\n [1, 'class'],\n [1, 'break'],\n [1, 'lambda'],\n [16, null],\n [1, 'print'],\n [1, 'debugger'],\n [1, 'nonlocal'],\n [52, null],\n [1, 'try'],\n [1, 'while'],\n [31, null],\n [1, 'return'],\n [1, 'assert'],\n [1, null],\n [1, 'False'],\n [1, 'pass'],\n [1, 'import'],\n [15, null],\n [1, 'yield'],\n [1, 'global'],\n [1, 'for'],\n [7, null],\n [1, 'from'],\n [1, 'if'],\n [9, null],\n [54, null],\n [1, 'del'],\n [1, 'continue'],\n [49, null],\n [1, 'with'],\n [14, null],\n [316, null],\n [19, null],\n [308, null],\n [1, 'and'],\n [11, null],\n [326, null],\n [22, null],\n [261, null],\n [12, null],\n [35, null],\n [271, null],\n [325, null],\n [297, null],\n [339, null],\n [296, null],\n [26, null],\n [283, null],\n [8, null],\n [342, null],\n [329, null],\n [10, null],\n [266, null],\n [332, null],\n [45, null],\n [38, null],\n [40, null],\n [50, null],\n [46, null],\n [41, null],\n [42, null],\n [36, null],\n [43, null],\n [48, null],\n [44, null],\n [37, null],\n [39, null],\n [324, null],\n [260, null],\n [292, null],\n [1, 'in'],\n [309, null],\n [273, null],\n [327, null],\n [272, null],\n [28, null],\n [21, null],\n [27, null],\n [29, null],\n [1, 'is'],\n [30, null],\n [20, null],\n [290, null],\n [274, null],\n [333, null],\n [299, null],\n [270, null],\n [337, null],\n [279, null],\n [265, null],\n [281, null],\n [264, null],\n [286, null],\n [280, null],\n [320, null],\n [1, 'as'],\n [284, null],\n [23, null],\n [328, null],\n [0, null],\n [1, 'except'],\n [340, null],\n [18, null],\n [330, null],\n [268, null],\n [259, null],\n [312, null],\n [293, null],\n [321, null],\n [269, null],\n [277, null],\n [314, null],\n [315, null],\n [343, null],\n [1, 'else'],\n [310, null],\n [51, null],\n [1, 'elif'],\n [300, null],\n [301, null],\n [285, null],\n [303, null],\n [302, null],\n [335, null],\n [275, null],\n [258, null],\n [1, 'or'],\n [334, null],\n [267, null],\n [34, null],\n [262, null],\n [33, null],\n [319, null],\n [13, null],\n [295, null],\n [263, null],\n [304, null],\n [311, null],\n [307, null],\n [313, null],\n [282, null],\n [298, null],\n [291, null],\n [278, null],\n [318, null],\n [322, null],\n [5, null],\n [6, null],\n [47, null],\n [17, null],\n [24, null],\n [305, null],\n [306, null],\n [323, null],\n [289, null],\n [1, 'finally'],\n [331, null],\n [336, null],\n [338, null],\n [257, null],\n [32, null],\n [341, null]],\nkeywords:\n{'False': 27,\n 'null': 9,\n 'True': 6,\n 'and': 47,\n 'as': 108,\n 'assert': 25,\n 'break': 14,\n 'class': 13,\n 'continue': 40,\n 'debugger': 18,\n 'def': 4,\n 'del': 39,\n 'elif': 130,\n 'else': 127,\n 'except': 113,\n 'finally': 168,\n 'for': 33,\n 'from': 35,\n 'global': 32,\n 'if': 36,\n 'import': 29,\n 'in': 83,\n 'is': 92,\n 'lambda': 15,\n 'nonlocal': 19,\n 'not': 8,\n 'or': 139,\n 'pass': 28,\n 'print': 17,\n 'raise': 5,\n 'return': 24,\n 'try': 21,\n 'while': 22,\n 'with': 42,\n 'yield': 31},\ntokens:\n{0: 112,\n 1: 26,\n 2: 11,\n 3: 7,\n 4: 2,\n 5: 159,\n 6: 160,\n 7: 34,\n 8: 61,\n 9: 37,\n 10: 64,\n 11: 48,\n 12: 52,\n 13: 146,\n 14: 43,\n 15: 30,\n 16: 16,\n 17: 162,\n 18: 115,\n 19: 45,\n 20: 94,\n 21: 89,\n 22: 50,\n 23: 110,\n 24: 163,\n 25: 12,\n 26: 59,\n 27: 90,\n 28: 88,\n 29: 91,\n 30: 93,\n 31: 23,\n 32: 173,\n 33: 144,\n 34: 142,\n 35: 53,\n 36: 74,\n 37: 78,\n 38: 68,\n 39: 79,\n 40: 69,\n 41: 72,\n 42: 73,\n 43: 75,\n 44: 77,\n 45: 67,\n 46: 71,\n 47: 161,\n 48: 76,\n 49: 41,\n 50: 70,\n 51: 129,\n 52: 20,\n 54: 38,\n 55: 10},\nstart: 256\n};\n\n\n/***/ }),\n/* 45 */\n/***/ (function(module, exports) {\n\n// low level parser to a concrete syntax tree, derived from cpython's lib2to3\n\n/**\n *\n * @constructor\n * @param {Object} grammar\n *\n * p = new Parser(grammar);\n * p.setup([start]);\n * foreach input token:\n *     if p.addtoken(...):\n *         break\n * root = p.rootnode\n *\n * can throw SyntaxError\n */\nfunction Parser (filename, grammar) {\n    this.filename = filename;\n    this.grammar = grammar;\n    this.p_flags = 0;\n    return this;\n}\n\n// all possible parser flags\nParser.FUTURE_PRINT_FUNCTION = \"print_function\";\nParser.FUTURE_UNICODE_LITERALS = \"unicode_literals\";\nParser.FUTURE_DIVISION = \"division\";\nParser.FUTURE_ABSOLUTE_IMPORT = \"absolute_import\";\nParser.FUTURE_WITH_STATEMENT = \"with_statement\";\nParser.FUTURE_NESTED_SCOPES = \"nested_scopes\";\nParser.FUTURE_GENERATORS = \"generators\";\nParser.CO_FUTURE_PRINT_FUNCTION = 0x10000;\nParser.CO_FUTURE_UNICODE_LITERALS = 0x20000;\nParser.CO_FUTURE_DIVISON = 0x2000;\nParser.CO_FUTURE_ABSOLUTE_IMPORT = 0x4000;\nParser.CO_FUTURE_WITH_STATEMENT = 0x8000;\n\nParser.prototype.setup = function (start) {\n    var stackentry;\n    var newnode;\n    start = start || this.grammar.start;\n    //print(\"START:\"+start);\n\n    newnode =\n    {\n        type    : start,\n        value   : null,\n        context : null,\n        children: []\n    };\n    stackentry =\n    {\n        dfa  : this.grammar.dfas[start],\n        state: 0,\n        node : newnode\n    };\n    this.stack = [stackentry];\n    this.used_names = {};\n};\n\nfunction findInDfa (a, obj) {\n    var i = a.length;\n    while (i--) {\n        if (a[i][0] === obj[0] && a[i][1] === obj[1]) {\n            return true;\n        }\n    }\n    return false;\n}\n\n\n// Add a token; return true if we're done\nParser.prototype.addtoken = function (type, value, context) {\n    var errline;\n    var itsfirst;\n    var itsdfa;\n    var state;\n    var v;\n    var t;\n    var newstate;\n    var i;\n    var a;\n    var arcs;\n    var first;\n    var states;\n    var tp;\n    var ilabel = this.classify(type, value, context);\n    //print(\"ilabel:\"+ilabel);\n\n    OUTERWHILE:\n    while (true) {\n        tp = this.stack[this.stack.length - 1];\n        states = tp.dfa[0];\n        first = tp.dfa[1];\n        arcs = states[tp.state];\n\n        // look for a state with this label\n        for (a = 0; a < arcs.length; ++a) {\n            i = arcs[a][0];\n            newstate = arcs[a][1];\n            t = this.grammar.labels[i][0];\n            v = this.grammar.labels[i][1];\n            if (ilabel === i) {\n                // look it up in the list of labels\n                Sk.asserts.assert(t < 256);\n                // shift a token; we're done with it\n                this.shift(type, value, newstate, context);\n                // pop while we are in an accept-only state\n                state = newstate;\n                //print(\"before:\"+JSON.stringify(states[state]) + \":state:\"+state+\":\"+JSON.stringify(states[state]));\n                /* jshint ignore:start */\n                while (states[state].length === 1\n                    && states[state][0][0] === 0\n                    && states[state][0][1] === state) {\n                    // states[state] == [(0, state)])\n                    this.pop();\n                    //print(\"in after pop:\"+JSON.stringify(states[state]) + \":state:\"+state+\":\"+JSON.stringify(states[state]));\n                    if (this.stack.length === 0) {\n                        // done!\n                        return true;\n                    }\n                    tp = this.stack[this.stack.length - 1];\n                    state = tp.state;\n                    states = tp.dfa[0];\n                    first = tp.dfa[1];\n                    //print(JSON.stringify(states), JSON.stringify(first));\n                    //print(\"bottom:\"+JSON.stringify(states[state]) + \":state:\"+state+\":\"+JSON.stringify(states[state]));\n                }\n                /* jshint ignore:end */\n                // done with this token\n                //print(\"DONE, return false\");\n                return false;\n            } else if (t >= 256) {\n                itsdfa = this.grammar.dfas[t];\n                itsfirst = itsdfa[1];\n                if (itsfirst.hasOwnProperty(ilabel)) {\n                    // push a symbol\n                    this.push(t, this.grammar.dfas[t], newstate, context);\n                    continue OUTERWHILE;\n                }\n            }\n        }\n\n        //print(\"findInDfa: \" + JSON.stringify(arcs)+\" vs. \" + tp.state);\n        if (findInDfa(arcs, [0, tp.state])) {\n            // an accepting state, pop it and try somethign else\n            //print(\"WAA\");\n            this.pop();\n            if (this.stack.length === 0) {\n                throw new Sk.builtin.SyntaxError(\"too much input\", this.filename);\n            }\n        } else {\n            // no transition\n            errline = context[0][0];\n            throw new Sk.builtin.SyntaxError(\"bad input\", this.filename, errline, context);\n        }\n    }\n};\n\n// turn a token into a label\nParser.prototype.classify = function (type, value, context) {\n    var ilabel;\n    if (type === Sk.token.tokens.T_NAME) {\n        this.used_names[value] = true;\n        ilabel = this.grammar.keywords.hasOwnProperty(value) && this.grammar.keywords[value];\n\n        /* Check for handling print as an builtin function */\n        if(value === \"print\" && (this.p_flags & Parser.CO_FUTURE_PRINT_FUNCTION || Sk.__future__.print_function === true)) {\n            ilabel = false; // ilabel determines if the value is a keyword\n        }\n\n        if (ilabel) {\n            //print(\"is keyword\");\n            return ilabel;\n        }\n    }\n    ilabel = this.grammar.tokens.hasOwnProperty(type) && this.grammar.tokens[type];\n    if (!ilabel) {\n        // throw new Sk.builtin.SyntaxError(\"bad token\", type, value, context);\n        // Questionable modification to put line number in position 2\n        // like everywhere else and filename in position 1.\n        throw new Sk.builtin.SyntaxError(\"bad token\", this.filename, context[0][0], context);\n    }\n    return ilabel;\n};\n\n// shift a token\nParser.prototype.shift = function (type, value, newstate, context) {\n    var dfa = this.stack[this.stack.length - 1].dfa;\n    var state = this.stack[this.stack.length - 1].state;\n    var node = this.stack[this.stack.length - 1].node;\n    //print(\"context\", context);\n    var newnode = {\n        type      : type,\n        value     : value,\n        lineno    : context[0][0],         // throwing away end here to match cpython\n        col_offset: context[0][1],\n        children  : null\n    };\n    if (newnode) {\n        node.children.push(newnode);\n    }\n    this.stack[this.stack.length - 1] = {\n        dfa  : dfa,\n        state: newstate,\n        node : node\n    };\n};\n\n// push a nonterminal\nParser.prototype.push = function (type, newdfa, newstate, context) {\n    var dfa = this.stack[this.stack.length - 1].dfa;\n    var node = this.stack[this.stack.length - 1].node;\n    var newnode = {\n        type      : type,\n        value     : null,\n        lineno    : context[0][0],      // throwing away end here to match cpython\n        col_offset: context[0][1],\n        children  : []\n    };\n    this.stack[this.stack.length - 1] = {\n        dfa  : dfa,\n        state: newstate,\n        node : node\n    };\n    this.stack.push({\n        dfa  : newdfa,\n        state: 0,\n        node : newnode\n    });\n};\n\n//var ac = 0;\n//var bc = 0;\n\n// pop a nonterminal\nParser.prototype.pop = function () {\n    var node;\n    var pop = this.stack.pop();\n    var newnode = pop.node;\n    //print(\"POP\");\n    if (newnode) {\n        //print(\"A\", ac++, newnode.type);\n        //print(\"stacklen:\"+this.stack.length);\n        if (this.stack.length !== 0) {\n            //print(\"B\", bc++);\n            node = this.stack[this.stack.length - 1].node;\n            node.children.push(newnode);\n        } else {\n            //print(\"C\");\n            this.rootnode = newnode;\n            this.rootnode.used_names = this.used_names;\n        }\n    }\n};\n\n/**\n * parser for interactive input. returns a function that should be called with\n * lines of input as they are entered. the function will return false\n * until the input is complete, when it will return the rootnode of the parse.\n *\n * @param {string} filename\n * @param {string=} style root of parse tree (optional)\n */\nfunction makeParser (filename, style) {\n    if (style === undefined) {\n        style = \"file_input\";\n    }\n    var p = new Parser(filename, Sk.ParseTables);\n    // for closure's benefit\n    if (style === \"file_input\") {\n        p.setup(Sk.ParseTables.sym.file_input);\n    } else {\n        Sk.asserts.fail(\"todo;\");\n    }\n    return p;\n}\n\nSk.parse = function parse (filename, input) {\n    var T_COMMENT = Sk.token.tokens.T_COMMENT;\n    var T_NL = Sk.token.tokens.T_NL;\n    var T_OP = Sk.token.tokens.T_OP;\n    var T_ENDMARKER = Sk.token.tokens.T_ENDMARKER;\n    var T_ENCODING = Sk.token.tokens.T_ENCODING;\n\n    var endmarker_seen = false;\n    var parser = makeParser(filename);\n\n    /**\n     * takes a string splits it on '\\n' and returns a function that returns\n     * @param {Array<string>} input\n     * @returns {function(): string}\n     */\n    function readline(input) {\n        var lines = input.split(\"\\n\").reverse().map(function (l) { return l + \"\\n\"; });\n\n        return function() {\n            if (lines.length === 0) {\n                throw new Sk.builtin.Exception(\"EOF\");\n            }\n\n            return lines.pop();\n        };\n    }\n\n    Sk._tokenize(readline(input), \"utf-8\", function (tokenInfo) {\n        var s_lineno = tokenInfo.start[0];\n        var s_column = tokenInfo.start[1];\n        var type = null;\n        var prefix, lineno, column;\n\n        /* I don't know\n         if (s_lineno !== lineno && s_column !== column)\n         {\n         // todo; update prefix and line/col\n         }\n         */\n\n        if (tokenInfo.type === T_COMMENT || tokenInfo.type === T_NL || tokenInfo.type === T_ENCODING) {\n            prefix += tokenInfo.value;\n            lineno = tokenInfo.end[0];\n            column = tokenInfo.end[1];\n            if (tokenInfo.string[tokenInfo.string.length - 1] === \"\\n\") {\n                lineno += 1;\n                column = 0;\n            }\n        } else {\n            if (tokenInfo.type === T_OP) {\n                type = Sk.OpMap[tokenInfo.string];\n            }\n\n            parser.addtoken(type || tokenInfo.type, tokenInfo.string, [tokenInfo.start, tokenInfo.end, tokenInfo.line]);\n\n            if (tokenInfo.type === T_ENDMARKER) {\n                endmarker_seen = true;\n            }\n        }\n    });\n\n    if (!endmarker_seen) {\n        throw new Sk.builtin.SyntaxError(\"incomplete input\", this.filename);\n    }\n\n    /**\n     * Small adjustments here in order to return th flags and the cst\n     */\n    return {\"cst\": parser.rootnode, \"flags\": parser.p_flags};\n};\n\nSk.parseTreeDump = function parseTreeDump (n, indent) {\n    //return JSON.stringify(n, null, 2);\n    var i;\n    var ret;\n    indent = indent || \"\";\n    ret = \"\";\n    ret += indent;\n    if (n.type >= 256) { // non-term\n        ret += Sk.ParseTables.number2symbol[n.type] + \"\\n\";\n        for (i = 0; i < n.children.length; ++i) {\n            ret += Sk.parseTreeDump(n.children[i], indent + \"  \");\n        }\n    } else {\n        ret += Sk.token.tok_name[n.type] + \": \" + new Sk.builtin.str(n.value)[\"$r\"]().v + \"\\n\";\n    }\n    return ret;\n};\n\n\nSk.exportSymbol(\"Sk.Parser\", Parser);\nSk.exportSymbol(\"Sk.parse\", Sk.parse);\nSk.exportSymbol(\"Sk.parseTreeDump\", Sk.parseTreeDump);\n\n\n/***/ }),\n/* 46 */\n/***/ (function(module, exports) {\n\n/* File automatically generated by asdl_js.py. */\n\n/* Object that holds all nodes */\nSk.astnodes = {};\n\n/* ----- expr_context ----- */\n/** @constructor */\nSk.astnodes.Load = function Load() {}\n/** @constructor */\nSk.astnodes.Store = function Store() {}\n/** @constructor */\nSk.astnodes.Del = function Del() {}\n/** @constructor */\nSk.astnodes.AugLoad = function AugLoad() {}\n/** @constructor */\nSk.astnodes.AugStore = function AugStore() {}\n/** @constructor */\nSk.astnodes.Param = function Param() {}\n\n/* ----- boolop ----- */\n/** @constructor */\nSk.astnodes.And = function And() {}\n/** @constructor */\nSk.astnodes.Or = function Or() {}\n\n/* ----- operator ----- */\n/** @constructor */\nSk.astnodes.Add = function Add() {}\n/** @constructor */\nSk.astnodes.Sub = function Sub() {}\n/** @constructor */\nSk.astnodes.Mult = function Mult() {}\n/** @constructor */\nSk.astnodes.MatMult = function MatMult() {}\n/** @constructor */\nSk.astnodes.Div = function Div() {}\n/** @constructor */\nSk.astnodes.Mod = function Mod() {}\n/** @constructor */\nSk.astnodes.Pow = function Pow() {}\n/** @constructor */\nSk.astnodes.LShift = function LShift() {}\n/** @constructor */\nSk.astnodes.RShift = function RShift() {}\n/** @constructor */\nSk.astnodes.BitOr = function BitOr() {}\n/** @constructor */\nSk.astnodes.BitXor = function BitXor() {}\n/** @constructor */\nSk.astnodes.BitAnd = function BitAnd() {}\n/** @constructor */\nSk.astnodes.FloorDiv = function FloorDiv() {}\n\n/* ----- unaryop ----- */\n/** @constructor */\nSk.astnodes.Invert = function Invert() {}\n/** @constructor */\nSk.astnodes.Not = function Not() {}\n/** @constructor */\nSk.astnodes.UAdd = function UAdd() {}\n/** @constructor */\nSk.astnodes.USub = function USub() {}\n\n/* ----- cmpop ----- */\n/** @constructor */\nSk.astnodes.Eq = function Eq() {}\n/** @constructor */\nSk.astnodes.NotEq = function NotEq() {}\n/** @constructor */\nSk.astnodes.Lt = function Lt() {}\n/** @constructor */\nSk.astnodes.LtE = function LtE() {}\n/** @constructor */\nSk.astnodes.Gt = function Gt() {}\n/** @constructor */\nSk.astnodes.GtE = function GtE() {}\n/** @constructor */\nSk.astnodes.Is = function Is() {}\n/** @constructor */\nSk.astnodes.IsNot = function IsNot() {}\n/** @constructor */\nSk.astnodes.In = function In() {}\n/** @constructor */\nSk.astnodes.NotIn = function NotIn() {}\n\n\n\n\n\n\n\n/* ---------------------- */\n/* constructors for nodes */\n/* ---------------------- */\n\n\n\n\n\n/** @constructor */\nSk.astnodes.Module = function Module(/* {asdl_seq *} */ body, /* {string} */\n                                          docstring)\n{\n    this.body = body;\n    this.docstring = docstring;\n    return this;\n}\n\n/** @constructor */\nSk.astnodes.Interactive = function Interactive(/* {asdl_seq *} */ body)\n{\n    this.body = body;\n    return this;\n}\n\n/** @constructor */\nSk.astnodes.Expression = function Expression(/* {expr_ty} */ body)\n{\n    this.body = body;\n    return this;\n}\n\n/** @constructor */\nSk.astnodes.Suite = function Suite(/* {asdl_seq *} */ body)\n{\n    this.body = body;\n    return this;\n}\n\n/** @constructor */\nSk.astnodes.FunctionDef = function FunctionDef(/* {identifier} */ name, /*\n                                                    {arguments__ty} */ args, /*\n                                                    {asdl_seq *} */ body, /*\n                                                    {asdl_seq *} */\n                                                    decorator_list, /*\n                                                    {expr_ty} */ returns, /*\n                                                    {string} */ docstring, /*\n                                                    {int} */ lineno, /* {int}\n                                                    */ col_offset)\n{\n    Sk.asserts.assert(lineno !== null && lineno !== undefined);\n    Sk.asserts.assert(col_offset !== null && col_offset !== undefined);\n    this.name = name;\n    this.args = args;\n    this.body = body;\n    this.decorator_list = decorator_list;\n    this.returns = returns;\n    this.docstring = docstring;\n    this.lineno = lineno;\n    this.col_offset = col_offset;\n    return this;\n}\n\n/** @constructor */\nSk.astnodes.AsyncFunctionDef = function AsyncFunctionDef(/* {identifier} */\n                                                              name, /*\n                                                              {arguments__ty}\n                                                              */ args, /*\n                                                              {asdl_seq *} */\n                                                              body, /*\n                                                              {asdl_seq *} */\n                                                              decorator_list,\n                                                              /* {expr_ty} */\n                                                              returns, /*\n                                                              {string} */\n                                                              docstring, /*\n                                                              {int} */ lineno,\n                                                              /* {int} */\n                                                              col_offset)\n{\n    Sk.asserts.assert(lineno !== null && lineno !== undefined);\n    Sk.asserts.assert(col_offset !== null && col_offset !== undefined);\n    this.name = name;\n    this.args = args;\n    this.body = body;\n    this.decorator_list = decorator_list;\n    this.returns = returns;\n    this.docstring = docstring;\n    this.lineno = lineno;\n    this.col_offset = col_offset;\n    return this;\n}\n\n/** @constructor */\nSk.astnodes.ClassDef = function ClassDef(/* {identifier} */ name, /* {asdl_seq\n                                              *} */ bases, /* {asdl_seq *} */\n                                              keywords, /* {asdl_seq *} */\n                                              body, /* {asdl_seq *} */\n                                              decorator_list, /* {string} */\n                                              docstring, /* {int} */ lineno, /*\n                                              {int} */ col_offset)\n{\n    Sk.asserts.assert(lineno !== null && lineno !== undefined);\n    Sk.asserts.assert(col_offset !== null && col_offset !== undefined);\n    this.name = name;\n    this.bases = bases;\n    this.keywords = keywords;\n    this.body = body;\n    this.decorator_list = decorator_list;\n    this.docstring = docstring;\n    this.lineno = lineno;\n    this.col_offset = col_offset;\n    return this;\n}\n\n/** @constructor */\nSk.astnodes.Return = function Return(/* {expr_ty} */ value, /* {int} */ lineno,\n                                          /* {int} */ col_offset)\n{\n    Sk.asserts.assert(lineno !== null && lineno !== undefined);\n    Sk.asserts.assert(col_offset !== null && col_offset !== undefined);\n    this.value = value;\n    this.lineno = lineno;\n    this.col_offset = col_offset;\n    return this;\n}\n\n/** @constructor */\nSk.astnodes.Delete = function Delete(/* {asdl_seq *} */ targets, /* {int} */\n                                          lineno, /* {int} */ col_offset)\n{\n    Sk.asserts.assert(lineno !== null && lineno !== undefined);\n    Sk.asserts.assert(col_offset !== null && col_offset !== undefined);\n    this.targets = targets;\n    this.lineno = lineno;\n    this.col_offset = col_offset;\n    return this;\n}\n\n/** @constructor */\nSk.astnodes.Assign = function Assign(/* {asdl_seq *} */ targets, /* {expr_ty}\n                                          */ value, /* {int} */ lineno, /*\n                                          {int} */ col_offset)\n{\n    Sk.asserts.assert(lineno !== null && lineno !== undefined);\n    Sk.asserts.assert(col_offset !== null && col_offset !== undefined);\n    this.targets = targets;\n    this.value = value;\n    this.lineno = lineno;\n    this.col_offset = col_offset;\n    return this;\n}\n\n/** @constructor */\nSk.astnodes.AugAssign = function AugAssign(/* {expr_ty} */ target, /*\n                                                {operator_ty} */ op, /*\n                                                {expr_ty} */ value, /* {int} */\n                                                lineno, /* {int} */ col_offset)\n{\n    Sk.asserts.assert(lineno !== null && lineno !== undefined);\n    Sk.asserts.assert(col_offset !== null && col_offset !== undefined);\n    this.target = target;\n    this.op = op;\n    this.value = value;\n    this.lineno = lineno;\n    this.col_offset = col_offset;\n    return this;\n}\n\n/** @constructor */\nSk.astnodes.AnnAssign = function AnnAssign(/* {expr_ty} */ target, /* {expr_ty}\n                                                */ annotation, /* {expr_ty} */\n                                                value, /* {int} */ simple, /*\n                                                {int} */ lineno, /* {int} */\n                                                col_offset)\n{\n    Sk.asserts.assert(lineno !== null && lineno !== undefined);\n    Sk.asserts.assert(col_offset !== null && col_offset !== undefined);\n    this.target = target;\n    this.annotation = annotation;\n    this.value = value;\n    this.simple = simple;\n    this.lineno = lineno;\n    this.col_offset = col_offset;\n    return this;\n}\n\n/** @constructor */\nSk.astnodes.For = function For(/* {expr_ty} */ target, /* {expr_ty} */ iter, /*\n                                    {asdl_seq *} */ body, /* {asdl_seq *} */\n                                    orelse, /* {int} */ lineno, /* {int} */\n                                    col_offset)\n{\n    Sk.asserts.assert(lineno !== null && lineno !== undefined);\n    Sk.asserts.assert(col_offset !== null && col_offset !== undefined);\n    this.target = target;\n    this.iter = iter;\n    this.body = body;\n    this.orelse = orelse;\n    this.lineno = lineno;\n    this.col_offset = col_offset;\n    return this;\n}\n\n/** @constructor */\nSk.astnodes.AsyncFor = function AsyncFor(/* {expr_ty} */ target, /* {expr_ty}\n                                              */ iter, /* {asdl_seq *} */ body,\n                                              /* {asdl_seq *} */ orelse, /*\n                                              {int} */ lineno, /* {int} */\n                                              col_offset)\n{\n    Sk.asserts.assert(lineno !== null && lineno !== undefined);\n    Sk.asserts.assert(col_offset !== null && col_offset !== undefined);\n    this.target = target;\n    this.iter = iter;\n    this.body = body;\n    this.orelse = orelse;\n    this.lineno = lineno;\n    this.col_offset = col_offset;\n    return this;\n}\n\n/** @constructor */\nSk.astnodes.While = function While(/* {expr_ty} */ test, /* {asdl_seq *} */\n                                        body, /* {asdl_seq *} */ orelse, /*\n                                        {int} */ lineno, /* {int} */ col_offset)\n{\n    Sk.asserts.assert(lineno !== null && lineno !== undefined);\n    Sk.asserts.assert(col_offset !== null && col_offset !== undefined);\n    this.test = test;\n    this.body = body;\n    this.orelse = orelse;\n    this.lineno = lineno;\n    this.col_offset = col_offset;\n    return this;\n}\n\n/** @constructor */\nSk.astnodes.If = function If(/* {expr_ty} */ test, /* {asdl_seq *} */ body, /*\n                                  {asdl_seq *} */ orelse, /* {int} */ lineno,\n                                  /* {int} */ col_offset)\n{\n    Sk.asserts.assert(lineno !== null && lineno !== undefined);\n    Sk.asserts.assert(col_offset !== null && col_offset !== undefined);\n    this.test = test;\n    this.body = body;\n    this.orelse = orelse;\n    this.lineno = lineno;\n    this.col_offset = col_offset;\n    return this;\n}\n\n/** @constructor */\nSk.astnodes.With = function With(/* {asdl_seq *} */ items, /* {asdl_seq *} */\n                                      body, /* {int} */ lineno, /* {int} */\n                                      col_offset)\n{\n    Sk.asserts.assert(lineno !== null && lineno !== undefined);\n    Sk.asserts.assert(col_offset !== null && col_offset !== undefined);\n    this.items = items;\n    this.body = body;\n    this.lineno = lineno;\n    this.col_offset = col_offset;\n    return this;\n}\n\n/** @constructor */\nSk.astnodes.AsyncWith = function AsyncWith(/* {asdl_seq *} */ items, /*\n                                                {asdl_seq *} */ body, /* {int}\n                                                */ lineno, /* {int} */\n                                                col_offset)\n{\n    Sk.asserts.assert(lineno !== null && lineno !== undefined);\n    Sk.asserts.assert(col_offset !== null && col_offset !== undefined);\n    this.items = items;\n    this.body = body;\n    this.lineno = lineno;\n    this.col_offset = col_offset;\n    return this;\n}\n\n/** @constructor */\nSk.astnodes.Raise = function Raise(/* {expr_ty} */ exc, /* {expr_ty} */ cause,\n                                        /* {expr_ty} */ inst, /* {expr_ty} */\n                                        tback, /* {int} */ lineno, /* {int} */\n                                        col_offset)\n{\n    Sk.asserts.assert(lineno !== null && lineno !== undefined);\n    Sk.asserts.assert(col_offset !== null && col_offset !== undefined);\n    this.exc = exc;\n    this.cause = cause;\n    this.inst = inst;\n    this.tback = tback;\n    this.lineno = lineno;\n    this.col_offset = col_offset;\n    return this;\n}\n\n/** @constructor */\nSk.astnodes.Try = function Try(/* {asdl_seq *} */ body, /* {asdl_seq *} */\n                                    handlers, /* {asdl_seq *} */ orelse, /*\n                                    {asdl_seq *} */ finalbody, /* {int} */\n                                    lineno, /* {int} */ col_offset)\n{\n    Sk.asserts.assert(lineno !== null && lineno !== undefined);\n    Sk.asserts.assert(col_offset !== null && col_offset !== undefined);\n    this.body = body;\n    this.handlers = handlers;\n    this.orelse = orelse;\n    this.finalbody = finalbody;\n    this.lineno = lineno;\n    this.col_offset = col_offset;\n    return this;\n}\n\n/** @constructor */\nSk.astnodes.Assert = function Assert(/* {expr_ty} */ test, /* {expr_ty} */ msg,\n                                          /* {int} */ lineno, /* {int} */\n                                          col_offset)\n{\n    Sk.asserts.assert(lineno !== null && lineno !== undefined);\n    Sk.asserts.assert(col_offset !== null && col_offset !== undefined);\n    this.test = test;\n    this.msg = msg;\n    this.lineno = lineno;\n    this.col_offset = col_offset;\n    return this;\n}\n\n/** @constructor */\nSk.astnodes.Import = function Import(/* {asdl_seq *} */ names, /* {int} */\n                                          lineno, /* {int} */ col_offset)\n{\n    Sk.asserts.assert(lineno !== null && lineno !== undefined);\n    Sk.asserts.assert(col_offset !== null && col_offset !== undefined);\n    this.names = names;\n    this.lineno = lineno;\n    this.col_offset = col_offset;\n    return this;\n}\n\n/** @constructor */\nSk.astnodes.ImportFrom = function ImportFrom(/* {identifier} */ module, /*\n                                                  {asdl_seq *} */ names, /*\n                                                  {int} */ level, /* {int} */\n                                                  lineno, /* {int} */\n                                                  col_offset)\n{\n    Sk.asserts.assert(lineno !== null && lineno !== undefined);\n    Sk.asserts.assert(col_offset !== null && col_offset !== undefined);\n    this.module = module;\n    this.names = names;\n    this.level = level;\n    this.lineno = lineno;\n    this.col_offset = col_offset;\n    return this;\n}\n\n/** @constructor */\nSk.astnodes.Global = function Global(/* {asdl_seq *} */ names, /* {int} */\n                                          lineno, /* {int} */ col_offset)\n{\n    Sk.asserts.assert(lineno !== null && lineno !== undefined);\n    Sk.asserts.assert(col_offset !== null && col_offset !== undefined);\n    this.names = names;\n    this.lineno = lineno;\n    this.col_offset = col_offset;\n    return this;\n}\n\n/** @constructor */\nSk.astnodes.Nonlocal = function Nonlocal(/* {asdl_seq *} */ names, /* {int} */\n                                              lineno, /* {int} */ col_offset)\n{\n    Sk.asserts.assert(lineno !== null && lineno !== undefined);\n    Sk.asserts.assert(col_offset !== null && col_offset !== undefined);\n    this.names = names;\n    this.lineno = lineno;\n    this.col_offset = col_offset;\n    return this;\n}\n\n/** @constructor */\nSk.astnodes.Expr = function Expr(/* {expr_ty} */ value, /* {int} */ lineno, /*\n                                      {int} */ col_offset)\n{\n    Sk.asserts.assert(lineno !== null && lineno !== undefined);\n    Sk.asserts.assert(col_offset !== null && col_offset !== undefined);\n    this.value = value;\n    this.lineno = lineno;\n    this.col_offset = col_offset;\n    return this;\n}\n\n/** @constructor */\nSk.astnodes.Pass = function Pass(/* {int} */ lineno, /* {int} */ col_offset)\n{\n    Sk.asserts.assert(lineno !== null && lineno !== undefined);\n    Sk.asserts.assert(col_offset !== null && col_offset !== undefined);\n    this.lineno = lineno;\n    this.col_offset = col_offset;\n    return this;\n}\n\n/** @constructor */\nSk.astnodes.Break = function Break(/* {int} */ lineno, /* {int} */ col_offset)\n{\n    Sk.asserts.assert(lineno !== null && lineno !== undefined);\n    Sk.asserts.assert(col_offset !== null && col_offset !== undefined);\n    this.lineno = lineno;\n    this.col_offset = col_offset;\n    return this;\n}\n\n/** @constructor */\nSk.astnodes.Continue = function Continue(/* {int} */ lineno, /* {int} */\n                                              col_offset)\n{\n    Sk.asserts.assert(lineno !== null && lineno !== undefined);\n    Sk.asserts.assert(col_offset !== null && col_offset !== undefined);\n    this.lineno = lineno;\n    this.col_offset = col_offset;\n    return this;\n}\n\n/** @constructor */\nSk.astnodes.Print = function Print(/* {expr_ty} */ dest, /* {asdl_seq *} */\n                                        values, /* {int} */ nl, /* {int} */\n                                        lineno, /* {int} */ col_offset)\n{\n    Sk.asserts.assert(lineno !== null && lineno !== undefined);\n    Sk.asserts.assert(col_offset !== null && col_offset !== undefined);\n    this.dest = dest;\n    this.values = values;\n    this.nl = nl;\n    this.lineno = lineno;\n    this.col_offset = col_offset;\n    return this;\n}\n\n/** @constructor */\nSk.astnodes.Debugger = function Debugger(/* {int} */ lineno, /* {int} */\n                                              col_offset)\n{\n    Sk.asserts.assert(lineno !== null && lineno !== undefined);\n    Sk.asserts.assert(col_offset !== null && col_offset !== undefined);\n    this.lineno = lineno;\n    this.col_offset = col_offset;\n    return this;\n}\n\n/** @constructor */\nSk.astnodes.BoolOp = function BoolOp(/* {boolop_ty} */ op, /* {asdl_seq *} */\n                                          values, /* {int} */ lineno, /* {int}\n                                          */ col_offset)\n{\n    Sk.asserts.assert(lineno !== null && lineno !== undefined);\n    Sk.asserts.assert(col_offset !== null && col_offset !== undefined);\n    this.op = op;\n    this.values = values;\n    this.lineno = lineno;\n    this.col_offset = col_offset;\n    return this;\n}\n\n/** @constructor */\nSk.astnodes.BinOp = function BinOp(/* {expr_ty} */ left, /* {operator_ty} */\n                                        op, /* {expr_ty} */ right, /* {int} */\n                                        lineno, /* {int} */ col_offset)\n{\n    Sk.asserts.assert(lineno !== null && lineno !== undefined);\n    Sk.asserts.assert(col_offset !== null && col_offset !== undefined);\n    this.left = left;\n    this.op = op;\n    this.right = right;\n    this.lineno = lineno;\n    this.col_offset = col_offset;\n    return this;\n}\n\n/** @constructor */\nSk.astnodes.UnaryOp = function UnaryOp(/* {unaryop_ty} */ op, /* {expr_ty} */\n                                            operand, /* {int} */ lineno, /*\n                                            {int} */ col_offset)\n{\n    Sk.asserts.assert(lineno !== null && lineno !== undefined);\n    Sk.asserts.assert(col_offset !== null && col_offset !== undefined);\n    this.op = op;\n    this.operand = operand;\n    this.lineno = lineno;\n    this.col_offset = col_offset;\n    return this;\n}\n\n/** @constructor */\nSk.astnodes.Lambda = function Lambda(/* {arguments__ty} */ args, /* {expr_ty}\n                                          */ body, /* {int} */ lineno, /* {int}\n                                          */ col_offset)\n{\n    Sk.asserts.assert(lineno !== null && lineno !== undefined);\n    Sk.asserts.assert(col_offset !== null && col_offset !== undefined);\n    this.args = args;\n    this.body = body;\n    this.lineno = lineno;\n    this.col_offset = col_offset;\n    return this;\n}\n\n/** @constructor */\nSk.astnodes.IfExp = function IfExp(/* {expr_ty} */ test, /* {expr_ty} */ body,\n                                        /* {expr_ty} */ orelse, /* {int} */\n                                        lineno, /* {int} */ col_offset)\n{\n    Sk.asserts.assert(lineno !== null && lineno !== undefined);\n    Sk.asserts.assert(col_offset !== null && col_offset !== undefined);\n    this.test = test;\n    this.body = body;\n    this.orelse = orelse;\n    this.lineno = lineno;\n    this.col_offset = col_offset;\n    return this;\n}\n\n/** @constructor */\nSk.astnodes.Dict = function Dict(/* {asdl_seq *} */ keys, /* {asdl_seq *} */\n                                      values, /* {int} */ lineno, /* {int} */\n                                      col_offset)\n{\n    Sk.asserts.assert(lineno !== null && lineno !== undefined);\n    Sk.asserts.assert(col_offset !== null && col_offset !== undefined);\n    this.keys = keys;\n    this.values = values;\n    this.lineno = lineno;\n    this.col_offset = col_offset;\n    return this;\n}\n\n/** @constructor */\nSk.astnodes.Set = function Set(/* {asdl_seq *} */ elts, /* {int} */ lineno, /*\n                                    {int} */ col_offset)\n{\n    Sk.asserts.assert(lineno !== null && lineno !== undefined);\n    Sk.asserts.assert(col_offset !== null && col_offset !== undefined);\n    this.elts = elts;\n    this.lineno = lineno;\n    this.col_offset = col_offset;\n    return this;\n}\n\n/** @constructor */\nSk.astnodes.ListComp = function ListComp(/* {expr_ty} */ elt, /* {asdl_seq *}\n                                              */ generators, /* {int} */\n                                              lineno, /* {int} */ col_offset)\n{\n    Sk.asserts.assert(lineno !== null && lineno !== undefined);\n    Sk.asserts.assert(col_offset !== null && col_offset !== undefined);\n    this.elt = elt;\n    this.generators = generators;\n    this.lineno = lineno;\n    this.col_offset = col_offset;\n    return this;\n}\n\n/** @constructor */\nSk.astnodes.SetComp = function SetComp(/* {expr_ty} */ elt, /* {asdl_seq *} */\n                                            generators, /* {int} */ lineno, /*\n                                            {int} */ col_offset)\n{\n    Sk.asserts.assert(lineno !== null && lineno !== undefined);\n    Sk.asserts.assert(col_offset !== null && col_offset !== undefined);\n    this.elt = elt;\n    this.generators = generators;\n    this.lineno = lineno;\n    this.col_offset = col_offset;\n    return this;\n}\n\n/** @constructor */\nSk.astnodes.DictComp = function DictComp(/* {expr_ty} */ key, /* {expr_ty} */\n                                              value, /* {asdl_seq *} */\n                                              generators, /* {int} */ lineno,\n                                              /* {int} */ col_offset)\n{\n    Sk.asserts.assert(lineno !== null && lineno !== undefined);\n    Sk.asserts.assert(col_offset !== null && col_offset !== undefined);\n    this.key = key;\n    this.value = value;\n    this.generators = generators;\n    this.lineno = lineno;\n    this.col_offset = col_offset;\n    return this;\n}\n\n/** @constructor */\nSk.astnodes.GeneratorExp = function GeneratorExp(/* {expr_ty} */ elt, /*\n                                                      {asdl_seq *} */\n                                                      generators, /* {int} */\n                                                      lineno, /* {int} */\n                                                      col_offset)\n{\n    Sk.asserts.assert(lineno !== null && lineno !== undefined);\n    Sk.asserts.assert(col_offset !== null && col_offset !== undefined);\n    this.elt = elt;\n    this.generators = generators;\n    this.lineno = lineno;\n    this.col_offset = col_offset;\n    return this;\n}\n\n/** @constructor */\nSk.astnodes.Await = function Await(/* {expr_ty} */ value, /* {int} */ lineno,\n                                        /* {int} */ col_offset)\n{\n    Sk.asserts.assert(lineno !== null && lineno !== undefined);\n    Sk.asserts.assert(col_offset !== null && col_offset !== undefined);\n    this.value = value;\n    this.lineno = lineno;\n    this.col_offset = col_offset;\n    return this;\n}\n\n/** @constructor */\nSk.astnodes.Yield = function Yield(/* {expr_ty} */ value, /* {int} */ lineno,\n                                        /* {int} */ col_offset)\n{\n    Sk.asserts.assert(lineno !== null && lineno !== undefined);\n    Sk.asserts.assert(col_offset !== null && col_offset !== undefined);\n    this.value = value;\n    this.lineno = lineno;\n    this.col_offset = col_offset;\n    return this;\n}\n\n/** @constructor */\nSk.astnodes.YieldFrom = function YieldFrom(/* {expr_ty} */ value, /* {int} */\n                                                lineno, /* {int} */ col_offset)\n{\n    Sk.asserts.assert(lineno !== null && lineno !== undefined);\n    Sk.asserts.assert(col_offset !== null && col_offset !== undefined);\n    this.value = value;\n    this.lineno = lineno;\n    this.col_offset = col_offset;\n    return this;\n}\n\n/** @constructor */\nSk.astnodes.Compare = function Compare(/* {expr_ty} */ left, /* {asdl_int_seq\n                                            *} */ ops, /* {asdl_seq *} */\n                                            comparators, /* {int} */ lineno, /*\n                                            {int} */ col_offset)\n{\n    Sk.asserts.assert(lineno !== null && lineno !== undefined);\n    Sk.asserts.assert(col_offset !== null && col_offset !== undefined);\n    this.left = left;\n    this.ops = ops;\n    this.comparators = comparators;\n    this.lineno = lineno;\n    this.col_offset = col_offset;\n    return this;\n}\n\n/** @constructor */\nSk.astnodes.Call = function Call(/* {expr_ty} */ func, /* {asdl_seq *} */ args,\n                                      /* {asdl_seq *} */ keywords, /* {int} */\n                                      lineno, /* {int} */ col_offset)\n{\n    Sk.asserts.assert(lineno !== null && lineno !== undefined);\n    Sk.asserts.assert(col_offset !== null && col_offset !== undefined);\n    this.func = func;\n    this.args = args;\n    this.keywords = keywords;\n    this.lineno = lineno;\n    this.col_offset = col_offset;\n    return this;\n}\n\n/** @constructor */\nSk.astnodes.Num = function Num(/* {object} */ n, /* {int} */ lineno, /* {int}\n                                    */ col_offset)\n{\n    Sk.asserts.assert(lineno !== null && lineno !== undefined);\n    Sk.asserts.assert(col_offset !== null && col_offset !== undefined);\n    this.n = n;\n    this.lineno = lineno;\n    this.col_offset = col_offset;\n    return this;\n}\n\n/** @constructor */\nSk.astnodes.Str = function Str(/* {string} */ s, /* {int} */ lineno, /* {int}\n                                    */ col_offset)\n{\n    Sk.asserts.assert(lineno !== null && lineno !== undefined);\n    Sk.asserts.assert(col_offset !== null && col_offset !== undefined);\n    this.s = s;\n    this.lineno = lineno;\n    this.col_offset = col_offset;\n    return this;\n}\n\n/** @constructor */\nSk.astnodes.FormattedValue = function FormattedValue(/* {expr_ty} */ value, /*\n                                                          {int} */ conversion,\n                                                          /* {expr_ty} */\n                                                          format_spec, /* {int}\n                                                          */ lineno, /* {int}\n                                                          */ col_offset)\n{\n    Sk.asserts.assert(lineno !== null && lineno !== undefined);\n    Sk.asserts.assert(col_offset !== null && col_offset !== undefined);\n    this.value = value;\n    this.conversion = conversion;\n    this.format_spec = format_spec;\n    this.lineno = lineno;\n    this.col_offset = col_offset;\n    return this;\n}\n\n/** @constructor */\nSk.astnodes.JoinedStr = function JoinedStr(/* {asdl_seq *} */ values, /* {int}\n                                                */ lineno, /* {int} */\n                                                col_offset)\n{\n    Sk.asserts.assert(lineno !== null && lineno !== undefined);\n    Sk.asserts.assert(col_offset !== null && col_offset !== undefined);\n    this.values = values;\n    this.lineno = lineno;\n    this.col_offset = col_offset;\n    return this;\n}\n\n/** @constructor */\nSk.astnodes.Bytes = function Bytes(/* {bytes} */ s, /* {int} */ lineno, /*\n                                        {int} */ col_offset)\n{\n    Sk.asserts.assert(lineno !== null && lineno !== undefined);\n    Sk.asserts.assert(col_offset !== null && col_offset !== undefined);\n    this.s = s;\n    this.lineno = lineno;\n    this.col_offset = col_offset;\n    return this;\n}\n\n/** @constructor */\nSk.astnodes.NameConstant = function NameConstant(/* {singleton} */ value, /*\n                                                      {int} */ lineno, /* {int}\n                                                      */ col_offset)\n{\n    Sk.asserts.assert(lineno !== null && lineno !== undefined);\n    Sk.asserts.assert(col_offset !== null && col_offset !== undefined);\n    this.value = value;\n    this.lineno = lineno;\n    this.col_offset = col_offset;\n    return this;\n}\n\n/** @constructor */\nSk.astnodes.Ellipsis = function Ellipsis(/* {int} */ lineno, /* {int} */\n                                              col_offset)\n{\n    Sk.asserts.assert(lineno !== null && lineno !== undefined);\n    Sk.asserts.assert(col_offset !== null && col_offset !== undefined);\n    this.lineno = lineno;\n    this.col_offset = col_offset;\n    return this;\n}\n\n/** @constructor */\nSk.astnodes.Constant = function Constant(/* {constant} */ value, /* {int} */\n                                              lineno, /* {int} */ col_offset)\n{\n    Sk.asserts.assert(lineno !== null && lineno !== undefined);\n    Sk.asserts.assert(col_offset !== null && col_offset !== undefined);\n    this.value = value;\n    this.lineno = lineno;\n    this.col_offset = col_offset;\n    return this;\n}\n\n/** @constructor */\nSk.astnodes.Attribute = function Attribute(/* {expr_ty} */ value, /*\n                                                {identifier} */ attr, /*\n                                                {expr_context_ty} */ ctx, /*\n                                                {int} */ lineno, /* {int} */\n                                                col_offset)\n{\n    Sk.asserts.assert(lineno !== null && lineno !== undefined);\n    Sk.asserts.assert(col_offset !== null && col_offset !== undefined);\n    this.value = value;\n    this.attr = attr;\n    this.ctx = ctx;\n    this.lineno = lineno;\n    this.col_offset = col_offset;\n    return this;\n}\n\n/** @constructor */\nSk.astnodes.Subscript = function Subscript(/* {expr_ty} */ value, /* {slice_ty}\n                                                */ slice, /* {expr_context_ty}\n                                                */ ctx, /* {int} */ lineno, /*\n                                                {int} */ col_offset)\n{\n    Sk.asserts.assert(lineno !== null && lineno !== undefined);\n    Sk.asserts.assert(col_offset !== null && col_offset !== undefined);\n    this.value = value;\n    this.slice = slice;\n    this.ctx = ctx;\n    this.lineno = lineno;\n    this.col_offset = col_offset;\n    return this;\n}\n\n/** @constructor */\nSk.astnodes.Starred = function Starred(/* {expr_ty} */ value, /*\n                                            {expr_context_ty} */ ctx, /* {int}\n                                            */ lineno, /* {int} */ col_offset)\n{\n    Sk.asserts.assert(lineno !== null && lineno !== undefined);\n    Sk.asserts.assert(col_offset !== null && col_offset !== undefined);\n    this.value = value;\n    this.ctx = ctx;\n    this.lineno = lineno;\n    this.col_offset = col_offset;\n    return this;\n}\n\n/** @constructor */\nSk.astnodes.Name = function Name(/* {identifier} */ id, /* {expr_context_ty} */\n                                      ctx, /* {int} */ lineno, /* {int} */\n                                      col_offset)\n{\n    Sk.asserts.assert(lineno !== null && lineno !== undefined);\n    Sk.asserts.assert(col_offset !== null && col_offset !== undefined);\n    this.id = id;\n    this.ctx = ctx;\n    this.lineno = lineno;\n    this.col_offset = col_offset;\n    return this;\n}\n\n/** @constructor */\nSk.astnodes.List = function List(/* {asdl_seq *} */ elts, /* {expr_context_ty}\n                                      */ ctx, /* {int} */ lineno, /* {int} */\n                                      col_offset)\n{\n    Sk.asserts.assert(lineno !== null && lineno !== undefined);\n    Sk.asserts.assert(col_offset !== null && col_offset !== undefined);\n    this.elts = elts;\n    this.ctx = ctx;\n    this.lineno = lineno;\n    this.col_offset = col_offset;\n    return this;\n}\n\n/** @constructor */\nSk.astnodes.Tuple = function Tuple(/* {asdl_seq *} */ elts, /*\n                                        {expr_context_ty} */ ctx, /* {int} */\n                                        lineno, /* {int} */ col_offset)\n{\n    Sk.asserts.assert(lineno !== null && lineno !== undefined);\n    Sk.asserts.assert(col_offset !== null && col_offset !== undefined);\n    this.elts = elts;\n    this.ctx = ctx;\n    this.lineno = lineno;\n    this.col_offset = col_offset;\n    return this;\n}\n\n/** @constructor */\nSk.astnodes.Slice = function Slice(/* {expr_ty} */ lower, /* {expr_ty} */\n                                        upper, /* {expr_ty} */ step)\n{\n    this.lower = lower;\n    this.upper = upper;\n    this.step = step;\n    return this;\n}\n\n/** @constructor */\nSk.astnodes.ExtSlice = function ExtSlice(/* {asdl_seq *} */ dims)\n{\n    this.dims = dims;\n    return this;\n}\n\n/** @constructor */\nSk.astnodes.Index = function Index(/* {expr_ty} */ value)\n{\n    this.value = value;\n    return this;\n}\n\n/** @constructor */\nSk.astnodes.comprehension = function comprehension(/* {expr_ty} */ target, /*\n                                                        {expr_ty} */ iter, /*\n                                                        {asdl_seq *} */ ifs, /*\n                                                        {int} */ is_async)\n{\n    this.target = target;\n    this.iter = iter;\n    this.ifs = ifs;\n    this.is_async = is_async;\n    return this;\n}\n\n/** @constructor */\nSk.astnodes.ExceptHandler = function ExceptHandler(/* {expr_ty} */ type, /*\n                                                        {identifier} */ name,\n                                                        /* {asdl_seq *} */\n                                                        body, /* {int} */\n                                                        lineno, /* {int} */\n                                                        col_offset)\n{\n    Sk.asserts.assert(lineno !== null && lineno !== undefined);\n    Sk.asserts.assert(col_offset !== null && col_offset !== undefined);\n    this.type = type;\n    this.name = name;\n    this.body = body;\n    this.lineno = lineno;\n    this.col_offset = col_offset;\n    return this;\n}\n\n/** @constructor */\nSk.astnodes.arguments_ = function arguments_(/* {asdl_seq *} */ args, /*\n                                                  {arg_ty} */ vararg, /*\n                                                  {asdl_seq *} */ kwonlyargs,\n                                                  /* {asdl_seq *} */\n                                                  kw_defaults, /* {arg_ty} */\n                                                  kwarg, /* {asdl_seq *} */\n                                                  defaults)\n{\n    this.args = args;\n    this.vararg = vararg;\n    this.kwonlyargs = kwonlyargs;\n    this.kw_defaults = kw_defaults;\n    this.kwarg = kwarg;\n    this.defaults = defaults;\n    return this;\n}\n\n/** @constructor */\nSk.astnodes.arg = function arg(/* {identifier} */ arg, /* {expr_ty} */\n                                    annotation)\n{\n    this.arg = arg;\n    this.annotation = annotation;\n    return this;\n}\n\n/** @constructor */\nSk.astnodes.keyword = function keyword(/* {identifier} */ arg, /* {expr_ty} */\n                                            value)\n{\n    this.arg = arg;\n    this.value = value;\n    return this;\n}\n\n/** @constructor */\nSk.astnodes.alias = function alias(/* {identifier} */ name, /* {identifier} */\n                                        asname)\n{\n    this.name = name;\n    this.asname = asname;\n    return this;\n}\n\n/** @constructor */\nSk.astnodes.withitem = function withitem(/* {expr_ty} */ context_expr, /*\n                                              {expr_ty} */ optional_vars)\n{\n    this.context_expr = context_expr;\n    this.optional_vars = optional_vars;\n    return this;\n}\n\n\nSk.astnodes.Module.prototype._astname = \"Module\";\nSk.astnodes.Module.prototype._fields = [\n    \"body\", function(n) { return n.body; },\n    \"docstring\", function(n) { return n.docstring; }\n];\nSk.astnodes.Interactive.prototype._astname = \"Interactive\";\nSk.astnodes.Interactive.prototype._fields = [\n    \"body\", function(n) { return n.body; }\n];\nSk.astnodes.Expression.prototype._astname = \"Expression\";\nSk.astnodes.Expression.prototype._fields = [\n    \"body\", function(n) { return n.body; }\n];\nSk.astnodes.Suite.prototype._astname = \"Suite\";\nSk.astnodes.Suite.prototype._fields = [\n    \"body\", function(n) { return n.body; }\n];\nSk.astnodes.FunctionDef.prototype._astname = \"FunctionDef\";\nSk.astnodes.FunctionDef.prototype._fields = [\n    \"name\", function(n) { return n.name; },\n    \"args\", function(n) { return n.args; },\n    \"body\", function(n) { return n.body; },\n    \"decorator_list\", function(n) { return n.decorator_list; },\n    \"returns\", function(n) { return n.returns; },\n    \"docstring\", function(n) { return n.docstring; }\n];\nSk.astnodes.AsyncFunctionDef.prototype._astname = \"AsyncFunctionDef\";\nSk.astnodes.AsyncFunctionDef.prototype._fields = [\n    \"name\", function(n) { return n.name; },\n    \"args\", function(n) { return n.args; },\n    \"body\", function(n) { return n.body; },\n    \"decorator_list\", function(n) { return n.decorator_list; },\n    \"returns\", function(n) { return n.returns; },\n    \"docstring\", function(n) { return n.docstring; }\n];\nSk.astnodes.ClassDef.prototype._astname = \"ClassDef\";\nSk.astnodes.ClassDef.prototype._fields = [\n    \"name\", function(n) { return n.name; },\n    \"bases\", function(n) { return n.bases; },\n    \"keywords\", function(n) { return n.keywords; },\n    \"body\", function(n) { return n.body; },\n    \"decorator_list\", function(n) { return n.decorator_list; },\n    \"docstring\", function(n) { return n.docstring; }\n];\nSk.astnodes.Return.prototype._astname = \"Return\";\nSk.astnodes.Return.prototype._fields = [\n    \"value\", function(n) { return n.value; }\n];\nSk.astnodes.Delete.prototype._astname = \"Delete\";\nSk.astnodes.Delete.prototype._fields = [\n    \"targets\", function(n) { return n.targets; }\n];\nSk.astnodes.Assign.prototype._astname = \"Assign\";\nSk.astnodes.Assign.prototype._fields = [\n    \"targets\", function(n) { return n.targets; },\n    \"value\", function(n) { return n.value; }\n];\nSk.astnodes.AugAssign.prototype._astname = \"AugAssign\";\nSk.astnodes.AugAssign.prototype._fields = [\n    \"target\", function(n) { return n.target; },\n    \"op\", function(n) { return n.op; },\n    \"value\", function(n) { return n.value; }\n];\nSk.astnodes.AnnAssign.prototype._astname = \"AnnAssign\";\nSk.astnodes.AnnAssign.prototype._fields = [\n    \"target\", function(n) { return n.target; },\n    \"annotation\", function(n) { return n.annotation; },\n    \"value\", function(n) { return n.value; },\n    \"simple\", function(n) { return n.simple; }\n];\nSk.astnodes.For.prototype._astname = \"For\";\nSk.astnodes.For.prototype._fields = [\n    \"target\", function(n) { return n.target; },\n    \"iter\", function(n) { return n.iter; },\n    \"body\", function(n) { return n.body; },\n    \"orelse\", function(n) { return n.orelse; }\n];\nSk.astnodes.AsyncFor.prototype._astname = \"AsyncFor\";\nSk.astnodes.AsyncFor.prototype._fields = [\n    \"target\", function(n) { return n.target; },\n    \"iter\", function(n) { return n.iter; },\n    \"body\", function(n) { return n.body; },\n    \"orelse\", function(n) { return n.orelse; }\n];\nSk.astnodes.While.prototype._astname = \"While\";\nSk.astnodes.While.prototype._fields = [\n    \"test\", function(n) { return n.test; },\n    \"body\", function(n) { return n.body; },\n    \"orelse\", function(n) { return n.orelse; }\n];\nSk.astnodes.If.prototype._astname = \"If\";\nSk.astnodes.If.prototype._fields = [\n    \"test\", function(n) { return n.test; },\n    \"body\", function(n) { return n.body; },\n    \"orelse\", function(n) { return n.orelse; }\n];\nSk.astnodes.With.prototype._astname = \"With\";\nSk.astnodes.With.prototype._fields = [\n    \"items\", function(n) { return n.items; },\n    \"body\", function(n) { return n.body; }\n];\nSk.astnodes.AsyncWith.prototype._astname = \"AsyncWith\";\nSk.astnodes.AsyncWith.prototype._fields = [\n    \"items\", function(n) { return n.items; },\n    \"body\", function(n) { return n.body; }\n];\nSk.astnodes.Raise.prototype._astname = \"Raise\";\nSk.astnodes.Raise.prototype._fields = [\n    \"exc\", function(n) { return n.exc; },\n    \"cause\", function(n) { return n.cause; },\n    \"inst\", function(n) { return n.inst; },\n    \"tback\", function(n) { return n.tback; }\n];\nSk.astnodes.Try.prototype._astname = \"Try\";\nSk.astnodes.Try.prototype._fields = [\n    \"body\", function(n) { return n.body; },\n    \"handlers\", function(n) { return n.handlers; },\n    \"orelse\", function(n) { return n.orelse; },\n    \"finalbody\", function(n) { return n.finalbody; }\n];\nSk.astnodes.Assert.prototype._astname = \"Assert\";\nSk.astnodes.Assert.prototype._fields = [\n    \"test\", function(n) { return n.test; },\n    \"msg\", function(n) { return n.msg; }\n];\nSk.astnodes.Import.prototype._astname = \"Import\";\nSk.astnodes.Import.prototype._fields = [\n    \"names\", function(n) { return n.names; }\n];\nSk.astnodes.ImportFrom.prototype._astname = \"ImportFrom\";\nSk.astnodes.ImportFrom.prototype._fields = [\n    \"module\", function(n) { return n.module; },\n    \"names\", function(n) { return n.names; },\n    \"level\", function(n) { return n.level; }\n];\nSk.astnodes.Global.prototype._astname = \"Global\";\nSk.astnodes.Global.prototype._fields = [\n    \"names\", function(n) { return n.names; }\n];\nSk.astnodes.Nonlocal.prototype._astname = \"Nonlocal\";\nSk.astnodes.Nonlocal.prototype._fields = [\n    \"names\", function(n) { return n.names; }\n];\nSk.astnodes.Expr.prototype._astname = \"Expr\";\nSk.astnodes.Expr.prototype._fields = [\n    \"value\", function(n) { return n.value; }\n];\nSk.astnodes.Pass.prototype._astname = \"Pass\";\nSk.astnodes.Pass.prototype._fields = [\n];\nSk.astnodes.Break.prototype._astname = \"Break\";\nSk.astnodes.Break.prototype._fields = [\n];\nSk.astnodes.Continue.prototype._astname = \"Continue\";\nSk.astnodes.Continue.prototype._fields = [\n];\nSk.astnodes.Print.prototype._astname = \"Print\";\nSk.astnodes.Print.prototype._fields = [\n    \"dest\", function(n) { return n.dest; },\n    \"values\", function(n) { return n.values; },\n    \"nl\", function(n) { return n.nl; }\n];\nSk.astnodes.Debugger.prototype._astname = \"Debugger\";\nSk.astnodes.Debugger.prototype._fields = [\n];\nSk.astnodes.BoolOp.prototype._astname = \"BoolOp\";\nSk.astnodes.BoolOp.prototype._fields = [\n    \"op\", function(n) { return n.op; },\n    \"values\", function(n) { return n.values; }\n];\nSk.astnodes.BinOp.prototype._astname = \"BinOp\";\nSk.astnodes.BinOp.prototype._fields = [\n    \"left\", function(n) { return n.left; },\n    \"op\", function(n) { return n.op; },\n    \"right\", function(n) { return n.right; }\n];\nSk.astnodes.UnaryOp.prototype._astname = \"UnaryOp\";\nSk.astnodes.UnaryOp.prototype._fields = [\n    \"op\", function(n) { return n.op; },\n    \"operand\", function(n) { return n.operand; }\n];\nSk.astnodes.Lambda.prototype._astname = \"Lambda\";\nSk.astnodes.Lambda.prototype._fields = [\n    \"args\", function(n) { return n.args; },\n    \"body\", function(n) { return n.body; }\n];\nSk.astnodes.IfExp.prototype._astname = \"IfExp\";\nSk.astnodes.IfExp.prototype._fields = [\n    \"test\", function(n) { return n.test; },\n    \"body\", function(n) { return n.body; },\n    \"orelse\", function(n) { return n.orelse; }\n];\nSk.astnodes.Dict.prototype._astname = \"Dict\";\nSk.astnodes.Dict.prototype._fields = [\n    \"keys\", function(n) { return n.keys; },\n    \"values\", function(n) { return n.values; }\n];\nSk.astnodes.Set.prototype._astname = \"Set\";\nSk.astnodes.Set.prototype._fields = [\n    \"elts\", function(n) { return n.elts; }\n];\nSk.astnodes.ListComp.prototype._astname = \"ListComp\";\nSk.astnodes.ListComp.prototype._fields = [\n    \"elt\", function(n) { return n.elt; },\n    \"generators\", function(n) { return n.generators; }\n];\nSk.astnodes.SetComp.prototype._astname = \"SetComp\";\nSk.astnodes.SetComp.prototype._fields = [\n    \"elt\", function(n) { return n.elt; },\n    \"generators\", function(n) { return n.generators; }\n];\nSk.astnodes.DictComp.prototype._astname = \"DictComp\";\nSk.astnodes.DictComp.prototype._fields = [\n    \"key\", function(n) { return n.key; },\n    \"value\", function(n) { return n.value; },\n    \"generators\", function(n) { return n.generators; }\n];\nSk.astnodes.GeneratorExp.prototype._astname = \"GeneratorExp\";\nSk.astnodes.GeneratorExp.prototype._fields = [\n    \"elt\", function(n) { return n.elt; },\n    \"generators\", function(n) { return n.generators; }\n];\nSk.astnodes.Await.prototype._astname = \"Await\";\nSk.astnodes.Await.prototype._fields = [\n    \"value\", function(n) { return n.value; }\n];\nSk.astnodes.Yield.prototype._astname = \"Yield\";\nSk.astnodes.Yield.prototype._fields = [\n    \"value\", function(n) { return n.value; }\n];\nSk.astnodes.YieldFrom.prototype._astname = \"YieldFrom\";\nSk.astnodes.YieldFrom.prototype._fields = [\n    \"value\", function(n) { return n.value; }\n];\nSk.astnodes.Compare.prototype._astname = \"Compare\";\nSk.astnodes.Compare.prototype._fields = [\n    \"left\", function(n) { return n.left; },\n    \"ops\", function(n) { return n.ops; },\n    \"comparators\", function(n) { return n.comparators; }\n];\nSk.astnodes.Call.prototype._astname = \"Call\";\nSk.astnodes.Call.prototype._fields = [\n    \"func\", function(n) { return n.func; },\n    \"args\", function(n) { return n.args; },\n    \"keywords\", function(n) { return n.keywords; }\n];\nSk.astnodes.Num.prototype._astname = \"Num\";\nSk.astnodes.Num.prototype._fields = [\n    \"n\", function(n) { return n.n; }\n];\nSk.astnodes.Str.prototype._astname = \"Str\";\nSk.astnodes.Str.prototype._fields = [\n    \"s\", function(n) { return n.s; }\n];\nSk.astnodes.FormattedValue.prototype._astname = \"FormattedValue\";\nSk.astnodes.FormattedValue.prototype._fields = [\n    \"value\", function(n) { return n.value; },\n    \"conversion\", function(n) { return n.conversion; },\n    \"format_spec\", function(n) { return n.format_spec; }\n];\nSk.astnodes.JoinedStr.prototype._astname = \"JoinedStr\";\nSk.astnodes.JoinedStr.prototype._fields = [\n    \"values\", function(n) { return n.values; }\n];\nSk.astnodes.Bytes.prototype._astname = \"Bytes\";\nSk.astnodes.Bytes.prototype._fields = [\n    \"s\", function(n) { return n.s; }\n];\nSk.astnodes.NameConstant.prototype._astname = \"NameConstant\";\nSk.astnodes.NameConstant.prototype._fields = [\n    \"value\", function(n) { return n.value; }\n];\nSk.astnodes.Ellipsis.prototype._astname = \"Ellipsis\";\nSk.astnodes.Ellipsis.prototype._fields = [\n];\nSk.astnodes.Constant.prototype._astname = \"Constant\";\nSk.astnodes.Constant.prototype._fields = [\n    \"value\", function(n) { return n.value; }\n];\nSk.astnodes.Attribute.prototype._astname = \"Attribute\";\nSk.astnodes.Attribute.prototype._fields = [\n    \"value\", function(n) { return n.value; },\n    \"attr\", function(n) { return n.attr; },\n    \"ctx\", function(n) { return n.ctx; }\n];\nSk.astnodes.Subscript.prototype._astname = \"Subscript\";\nSk.astnodes.Subscript.prototype._fields = [\n    \"value\", function(n) { return n.value; },\n    \"slice\", function(n) { return n.slice; },\n    \"ctx\", function(n) { return n.ctx; }\n];\nSk.astnodes.Starred.prototype._astname = \"Starred\";\nSk.astnodes.Starred.prototype._fields = [\n    \"value\", function(n) { return n.value; },\n    \"ctx\", function(n) { return n.ctx; }\n];\nSk.astnodes.Name.prototype._astname = \"Name\";\nSk.astnodes.Name.prototype._fields = [\n    \"id\", function(n) { return n.id; },\n    \"ctx\", function(n) { return n.ctx; }\n];\nSk.astnodes.List.prototype._astname = \"List\";\nSk.astnodes.List.prototype._fields = [\n    \"elts\", function(n) { return n.elts; },\n    \"ctx\", function(n) { return n.ctx; }\n];\nSk.astnodes.Tuple.prototype._astname = \"Tuple\";\nSk.astnodes.Tuple.prototype._fields = [\n    \"elts\", function(n) { return n.elts; },\n    \"ctx\", function(n) { return n.ctx; }\n];\nSk.astnodes.Load.prototype._astname = \"Load\";\nSk.astnodes.Load.prototype._isenum = true;\nSk.astnodes.Store.prototype._astname = \"Store\";\nSk.astnodes.Store.prototype._isenum = true;\nSk.astnodes.Del.prototype._astname = \"Del\";\nSk.astnodes.Del.prototype._isenum = true;\nSk.astnodes.AugLoad.prototype._astname = \"AugLoad\";\nSk.astnodes.AugLoad.prototype._isenum = true;\nSk.astnodes.AugStore.prototype._astname = \"AugStore\";\nSk.astnodes.AugStore.prototype._isenum = true;\nSk.astnodes.Param.prototype._astname = \"Param\";\nSk.astnodes.Param.prototype._isenum = true;\nSk.astnodes.Slice.prototype._astname = \"Slice\";\nSk.astnodes.Slice.prototype._fields = [\n    \"lower\", function(n) { return n.lower; },\n    \"upper\", function(n) { return n.upper; },\n    \"step\", function(n) { return n.step; }\n];\nSk.astnodes.ExtSlice.prototype._astname = \"ExtSlice\";\nSk.astnodes.ExtSlice.prototype._fields = [\n    \"dims\", function(n) { return n.dims; }\n];\nSk.astnodes.Index.prototype._astname = \"Index\";\nSk.astnodes.Index.prototype._fields = [\n    \"value\", function(n) { return n.value; }\n];\nSk.astnodes.And.prototype._astname = \"And\";\nSk.astnodes.And.prototype._isenum = true;\nSk.astnodes.Or.prototype._astname = \"Or\";\nSk.astnodes.Or.prototype._isenum = true;\nSk.astnodes.Add.prototype._astname = \"Add\";\nSk.astnodes.Add.prototype._isenum = true;\nSk.astnodes.Sub.prototype._astname = \"Sub\";\nSk.astnodes.Sub.prototype._isenum = true;\nSk.astnodes.Mult.prototype._astname = \"Mult\";\nSk.astnodes.Mult.prototype._isenum = true;\nSk.astnodes.MatMult.prototype._astname = \"MatMult\";\nSk.astnodes.MatMult.prototype._isenum = true;\nSk.astnodes.Div.prototype._astname = \"Div\";\nSk.astnodes.Div.prototype._isenum = true;\nSk.astnodes.Mod.prototype._astname = \"Mod\";\nSk.astnodes.Mod.prototype._isenum = true;\nSk.astnodes.Pow.prototype._astname = \"Pow\";\nSk.astnodes.Pow.prototype._isenum = true;\nSk.astnodes.LShift.prototype._astname = \"LShift\";\nSk.astnodes.LShift.prototype._isenum = true;\nSk.astnodes.RShift.prototype._astname = \"RShift\";\nSk.astnodes.RShift.prototype._isenum = true;\nSk.astnodes.BitOr.prototype._astname = \"BitOr\";\nSk.astnodes.BitOr.prototype._isenum = true;\nSk.astnodes.BitXor.prototype._astname = \"BitXor\";\nSk.astnodes.BitXor.prototype._isenum = true;\nSk.astnodes.BitAnd.prototype._astname = \"BitAnd\";\nSk.astnodes.BitAnd.prototype._isenum = true;\nSk.astnodes.FloorDiv.prototype._astname = \"FloorDiv\";\nSk.astnodes.FloorDiv.prototype._isenum = true;\nSk.astnodes.Invert.prototype._astname = \"Invert\";\nSk.astnodes.Invert.prototype._isenum = true;\nSk.astnodes.Not.prototype._astname = \"Not\";\nSk.astnodes.Not.prototype._isenum = true;\nSk.astnodes.UAdd.prototype._astname = \"UAdd\";\nSk.astnodes.UAdd.prototype._isenum = true;\nSk.astnodes.USub.prototype._astname = \"USub\";\nSk.astnodes.USub.prototype._isenum = true;\nSk.astnodes.Eq.prototype._astname = \"Eq\";\nSk.astnodes.Eq.prototype._isenum = true;\nSk.astnodes.NotEq.prototype._astname = \"NotEq\";\nSk.astnodes.NotEq.prototype._isenum = true;\nSk.astnodes.Lt.prototype._astname = \"Lt\";\nSk.astnodes.Lt.prototype._isenum = true;\nSk.astnodes.LtE.prototype._astname = \"LtE\";\nSk.astnodes.LtE.prototype._isenum = true;\nSk.astnodes.Gt.prototype._astname = \"Gt\";\nSk.astnodes.Gt.prototype._isenum = true;\nSk.astnodes.GtE.prototype._astname = \"GtE\";\nSk.astnodes.GtE.prototype._isenum = true;\nSk.astnodes.Is.prototype._astname = \"Is\";\nSk.astnodes.Is.prototype._isenum = true;\nSk.astnodes.IsNot.prototype._astname = \"IsNot\";\nSk.astnodes.IsNot.prototype._isenum = true;\nSk.astnodes.In.prototype._astname = \"In\";\nSk.astnodes.In.prototype._isenum = true;\nSk.astnodes.NotIn.prototype._astname = \"NotIn\";\nSk.astnodes.NotIn.prototype._isenum = true;\nSk.astnodes.comprehension.prototype._astname = \"comprehension\";\nSk.astnodes.comprehension.prototype._fields = [\n    \"target\", function(n) { return n.target; },\n    \"iter\", function(n) { return n.iter; },\n    \"ifs\", function(n) { return n.ifs; },\n    \"is_async\", function(n) { return n.is_async; }\n];\nSk.astnodes.ExceptHandler.prototype._astname = \"ExceptHandler\";\nSk.astnodes.ExceptHandler.prototype._fields = [\n    \"type\", function(n) { return n.type; },\n    \"name\", function(n) { return n.name; },\n    \"body\", function(n) { return n.body; }\n];\nSk.astnodes.arguments_.prototype._astname = \"arguments\";\nSk.astnodes.arguments_.prototype._fields = [\n    \"args\", function(n) { return n.args; },\n    \"vararg\", function(n) { return n.vararg; },\n    \"kwonlyargs\", function(n) { return n.kwonlyargs; },\n    \"kw_defaults\", function(n) { return n.kw_defaults; },\n    \"kwarg\", function(n) { return n.kwarg; },\n    \"defaults\", function(n) { return n.defaults; }\n];\nSk.astnodes.arg.prototype._astname = \"arg\";\nSk.astnodes.arg.prototype._fields = [\n    \"arg\", function(n) { return n.arg; },\n    \"annotation\", function(n) { return n.annotation; }\n];\nSk.astnodes.keyword.prototype._astname = \"keyword\";\nSk.astnodes.keyword.prototype._fields = [\n    \"arg\", function(n) { return n.arg; },\n    \"value\", function(n) { return n.value; }\n];\nSk.astnodes.alias.prototype._astname = \"alias\";\nSk.astnodes.alias.prototype._fields = [\n    \"name\", function(n) { return n.name; },\n    \"asname\", function(n) { return n.asname; }\n];\nSk.astnodes.withitem.prototype._astname = \"withitem\";\nSk.astnodes.withitem.prototype._fields = [\n    \"context_expr\", function(n) { return n.context_expr; },\n    \"optional_vars\", function(n) { return n.optional_vars; }\n];\n\nSk.exportSymbol(\"Sk.astnodes\", Sk.astnodes);\n\n\n/***/ }),\n/* 47 */\n/***/ (function(module, exports) {\n\n//\n// This is pretty much a straight port of ast.c from CPython 3.7.3\n// (with a few leftovers from 2.6.5).\n//\n// The previous version was easier to work with and more JS-ish, but having a\n// somewhat different ast structure than cpython makes testing more difficult.\n//\n// This way, we can use a dump from the ast module on any arbitrary python\n// code and know that we're the same up to ast level, at least.\n//\n\nvar SYM = Sk.ParseTables.sym;\nvar TOK = Sk.token.tokens;\nvar COMP_GENEXP = 0;\nvar COMP_LISTCOMP = 1;\nvar COMP_SETCOMP = 2;\nvar NULL = null;\nvar _slice_kind = { \n    Slice_kind: 1,\n    ExtSlice_kind: 2, \n    Index_kind: 3\n};\n\nvar _expr_kind = {\n    BoolOp_kind: 1, NamedExpr_kind: 2, BinOp_kind: 3, UnaryOp_kind: 4,\n    Lambda_kind: 5, IfExp_kind: 6, Dict_kind: 7, Set_kind: 8,\n    ListComp_kind: 9, SetComp_kind: 10, DictComp_kind: 11,\n    GeneratorExp_kind: 12, Await_kind: 13, Yield_kind: 14,\n    YieldFrom_kind: 15, Compare_kind: 16, Call_kind: 17,\n    FormattedValue_kind: 18, JoinedStr_kind: 19, Constant_kind: 20,\n    Attribute_kind: 21, Subscript_kind: 22, Starred_kind: 23,\n    Name_kind: 24, List_kind: 25, Tuple_kind: 26 };\n\n/** @constructor */\nfunction Compiling (encoding, filename, c_flags) {\n    this.c_encoding = encoding;\n    this.c_filename = filename;\n    this.c_flags = c_flags || 0;\n}\n\n/**\n * @return {number}\n */\nfunction NCH (n) {\n    Sk.asserts.assert(n !== undefined, \"node must be defined\");\n    if (n.children === null) {\n        return 0;\n    }\n    return n.children.length;\n}\n\nfunction CHILD (n, i) {\n    Sk.asserts.assert(n !== undefined, \"node must be defined\");\n    Sk.asserts.assert(i !== undefined, \"index of child must be specified\");\n    return n.children[i];\n}\n\nfunction REQ (n, type) {\n    Sk.asserts.assert(n.type === type, \"node wasn't expected type\");\n}\n\nfunction TYPE(n) {\n    return n.type;\n}\n\nfunction LINENO(n) {\n    return n.lineno;\n}\n\nfunction STR(ch) {\n    return ch.value;\n}\n\nfunction ast_error(c, n, msg) {\n    throw new Sk.builtin.SyntaxError(msg, c.c_filename, n.lineno);\n}\n\nfunction strobj (s) {\n    Sk.asserts.assert(typeof s === \"string\", \"expecting string, got \" + (typeof s));\n    return new Sk.builtin.str(s);\n}\n\n/** @return {number} */\nfunction numStmts (n) {\n    var ch;\n    var i;\n    var cnt;\n    switch (n.type) {\n        case SYM.single_input:\n            if (CHILD(n, 0).type === TOK.T_NEWLINE) {\n                return 0;\n            }\n            else {\n                return numStmts(CHILD(n, 0));\n            }\n        case SYM.file_input:\n            cnt = 0;\n            for (i = 0; i < NCH(n); ++i) {\n                ch = CHILD(n, i);\n                if (ch.type === SYM.stmt) {\n                    cnt += numStmts(ch);\n                }\n            }\n            return cnt;\n        case SYM.stmt:\n            return numStmts(CHILD(n, 0));\n        case SYM.compound_stmt:\n            return 1;\n        case SYM.simple_stmt:\n            return Math.floor(NCH(n) / 2); // div 2 is to remove count of ;s\n        case SYM.suite:\n            if (NCH(n) === 1) {\n                return numStmts(CHILD(n, 0));\n            }\n            else {\n                cnt = 0;\n                for (i = 2; i < NCH(n) - 1; ++i) {\n                    cnt += numStmts(CHILD(n, i));\n                }\n                return cnt;\n            }\n            break;\n        default:\n            Sk.asserts.fail(\"Non-statement found\");\n    }\n    return 0;\n}\n\nfunction forbiddenCheck (c, n, x, lineno) {\n    if (x instanceof Sk.builtin.str) {\n        x = x.v;\n    }\n    if (x === \"None\") {\n        throw new Sk.builtin.SyntaxError(\"assignment to None\", c.c_filename, lineno);\n    }\n    if (x === \"True\" || x === \"False\") {\n        throw new Sk.builtin.SyntaxError(\"assignment to True or False is forbidden\", c.c_filename, lineno);\n    }\n}\n\n/**\n * Set the context ctx for e, recursively traversing e.\n *\n * Only sets context for expr kinds that can appear in assignment context as\n * per the asdl file.\n */\nfunction setContext (c, e, ctx, n) {\n    var i;\n    var exprName;\n    var s;\n    Sk.asserts.assert(ctx !== Sk.astnodes.AugStore && ctx !== Sk.astnodes.AugLoad, \"context not AugStore or AugLoad\");\n    s = null;\n    exprName = null;\n\n    switch (e.constructor) {\n        case Sk.astnodes.Attribute:\n        case Sk.astnodes.Name:\n            if (ctx === Sk.astnodes.Store) {\n                forbiddenCheck(c, n, e.attr, n.lineno);\n            }\n            e.ctx = ctx;\n            break;\n        case Sk.astnodes.Subscript:\n            e.ctx = ctx;\n            break;\n        case Sk.astnodes.List:\n            e.ctx = ctx;\n            s = e.elts;\n            break;\n        case Sk.astnodes.Tuple:\n            if (e.elts.length === 0) {\n                throw new Sk.builtin.SyntaxError(\"can't assign to ()\", c.c_filename, n.lineno);\n            }\n            e.ctx = ctx;\n            s = e.elts;\n            break;\n        case Sk.astnodes.Lambda:\n            exprName = \"lambda\";\n            break;\n        case Sk.astnodes.Call:\n            exprName = \"function call\";\n            break;\n        case Sk.astnodes.BoolOp:\n        case Sk.astnodes.BinOp:\n        case Sk.astnodes.UnaryOp:\n            exprName = \"operator\";\n            break;\n        case Sk.astnodes.GeneratorExp:\n            exprName = \"generator expression\";\n            break;\n        case Sk.astnodes.Yield:\n            exprName = \"yield expression\";\n            break;\n        case Sk.astnodes.ListComp:\n            exprName = \"list comprehension\";\n            break;\n        case Sk.astnodes.SetComp:\n            exprName = \"set comprehension\";\n            break;\n        case Sk.astnodes.DictComp:\n            exprName = \"dict comprehension\";\n            break;\n        case Sk.astnodes.Dict:\n        case Sk.astnodes.Set:\n        case Sk.astnodes.Num:\n        case Sk.astnodes.Str:\n            exprName = \"literal\";\n            break;\n        case Sk.astnodes.NameConstant:\n            exprName = \"True, False or None\";\n            break;\n        case Sk.astnodes.Compare:\n            exprName = \"comparison\";\n            break;\n        case Sk.astnodes.Repr:\n            exprName = \"repr\";\n            break;\n        case Sk.astnodes.IfExp:\n            exprName = \"conditional expression\";\n            break;\n        default:\n            Sk.asserts.fail(\"unhandled expression in assignment\");\n    }\n    if (exprName) {\n        throw new Sk.builtin.SyntaxError(\"can't \" + (ctx === Sk.astnodes.Store ? \"assign to\" : \"delete\") + \" \" + exprName, c.c_filename, n.lineno);\n    }\n\n    if (s) {\n        for (i = 0; i < s.length; ++i) {\n            setContext(c, s[i], ctx, n);\n        }\n    }\n}\n\nvar operatorMap = {};\n(function () {\n    operatorMap[TOK.T_VBAR] = Sk.astnodes.BitOr;\n    operatorMap[TOK.T_CIRCUMFLEX] = Sk.astnodes.BitXor;\n    operatorMap[TOK.T_AMPER] = Sk.astnodes.BitAnd;\n    operatorMap[TOK.T_LEFTSHIFT] = Sk.astnodes.LShift;\n    operatorMap[TOK.T_RIGHTSHIFT] = Sk.astnodes.RShift;\n    operatorMap[TOK.T_PLUS] = Sk.astnodes.Add;\n    operatorMap[TOK.T_MINUS] = Sk.astnodes.Sub;\n    operatorMap[TOK.T_STAR] = Sk.astnodes.Mult;\n    operatorMap[TOK.T_SLASH] = Sk.astnodes.Div;\n    operatorMap[TOK.T_DOUBLESLASH] = Sk.astnodes.FloorDiv;\n    operatorMap[TOK.T_PERCENT] = Sk.astnodes.Mod;\n}());\n\nfunction getOperator (n) {\n    Sk.asserts.assert(operatorMap[n.type] !== undefined, \"Operator missing from operatorMap\");\n    return operatorMap[n.type];\n}\n\nfunction new_identifier(n, c) {\n    if (n.value) {\n        return Sk.builtin.str(n.value);\n    }\n\n    return Sk.builtin.str(n);\n}\n\nfunction astForCompOp (c, n) {\n    /* comp_op: '<'|'>'|'=='|'>='|'<='|'!='|'in'|'not' 'in'|'is'\n     |'is' 'not'\n     */\n    REQ(n, SYM.comp_op);\n    if (NCH(n) === 1) {\n        n = CHILD(n, 0);\n        switch (n.type) {\n            case TOK.T_LESS:\n                return Sk.astnodes.Lt;\n            case TOK.T_GREATER:\n                return Sk.astnodes.Gt;\n            case TOK.T_EQEQUAL:\n                return Sk.astnodes.Eq;\n            case TOK.T_LESSEQUAL:\n                return Sk.astnodes.LtE;\n            case TOK.T_GREATEREQUAL:\n                return Sk.astnodes.GtE;\n            case TOK.T_NOTEQUAL:\n                return Sk.astnodes.NotEq;\n            case TOK.T_NAME:\n                if (n.value === \"in\") {\n                    return Sk.astnodes.In;\n                }\n                if (n.value === \"is\") {\n                    return Sk.astnodes.Is;\n                }\n        }\n    }\n    else if (NCH(n) === 2) {\n        if (CHILD(n, 0).type === TOK.T_NAME) {\n            if (CHILD(n, 1).value === \"in\") {\n                return Sk.astnodes.NotIn;\n            }\n            if (CHILD(n, 0).value === \"is\") {\n                return Sk.astnodes.IsNot;\n            }\n        }\n    }\n    Sk.asserts.fail(\"invalid comp_op\");\n}\n\nfunction copy_location(e, n)\n{\n    if (e) {\n        e.lineno = LINENO(n);\n        e.col_offset = n.col_offset;\n        e.end_lineno = n.end_lineno;\n        e.end_col_offset = n.end_col_offset;\n    }\n    return e;\n}\n\nfunction seq_for_testlist (c, n) {\n    /* testlist: test (',' test)* [',']\n       testlist_star_expr: test|star_expr (',' test|star_expr)* [',']\n    */\n    var i;\n    var seq = [];\n    Sk.asserts.assert(n.type === SYM.testlist ||\n        n.type === SYM.testlist_star_expr ||\n        n.type === SYM.listmaker ||\n        n.type === SYM.testlist_comp ||\n        n.type === SYM.testlist_safe ||\n        n.type === SYM.testlist1, \"node type must be listlike\");\n    for (i = 0; i < NCH(n); i += 2) {\n        Sk.asserts.assert(CHILD(n, i).type === SYM.test || CHILD(n, i).type === SYM.old_test || CHILD(n, i).type === SYM.star_expr);\n        seq[i / 2] = ast_for_expr(c, CHILD(n, i));\n    }\n    return seq;\n}\n\nfunction astForSuite (c, n) {\n    /* suite: simple_stmt | NEWLINE INDENT stmt+ DEDENT */\n    var j;\n    var num;\n    var i;\n    var end;\n    var ch;\n    var pos;\n    var seq;\n    REQ(n, SYM.suite);\n    seq = [];\n    pos = 0;\n    if (CHILD(n, 0).type === SYM.simple_stmt) {\n        n = CHILD(n, 0);\n        /* simple_stmt always ends with an NEWLINE and may have a trailing\n         * SEMI. */\n        end = NCH(n) - 1;\n        if (CHILD(n, end - 1).type === TOK.T_SEMI) {\n            end -= 1;\n        }\n        for (i = 0; i < end; i += 2) // by 2 to skip ;\n        {\n            seq[pos++] = astForStmt(c, CHILD(n, i));\n        }\n    }\n    else {\n        for (i = 2; i < NCH(n) - 1; ++i) {\n            ch = CHILD(n, i);\n            REQ(ch, SYM.stmt);\n            num = numStmts(ch);\n            if (num === 1) {\n                // small_stmt or compound_stmt w/ only 1 child\n                seq[pos++] = astForStmt(c, ch);\n            }\n            else {\n                ch = CHILD(ch, 0);\n                REQ(ch, SYM.simple_stmt);\n                for (j = 0; j < NCH(ch); j += 2) {\n                    if (NCH(CHILD(ch, j)) === 0) {\n                        Sk.asserts.assert(j + 1 === NCH(ch));\n                        break;\n                    }\n                    seq[pos++] = astForStmt(c, CHILD(ch, j));\n                }\n            }\n        }\n    }\n    Sk.asserts.assert(pos === numStmts(n));\n    return seq;\n}\n\nfunction astForExceptClause (c, exc, body) {\n    /* except_clause: 'except' [test [(',' | 'as') test]] */\n    var e;\n    REQ(exc, SYM.except_clause);\n    REQ(body, SYM.suite);\n    if (NCH(exc) === 1) {\n        return new Sk.astnodes.ExceptHandler(null, null, astForSuite(c, body), exc.lineno, exc.col_offset);\n    }\n    else if (NCH(exc) === 2) {\n        return new Sk.astnodes.ExceptHandler(ast_for_expr(c, CHILD(exc, 1)), null, astForSuite(c, body), exc.lineno, exc.col_offset);\n    }\n    else if (NCH(exc) === 4) {\n        var expression = ast_for_expr(c, CHILD(exc, 1));\n        e = ast_for_expr(c, CHILD(exc, 3));\n        setContext(c, e, Sk.astnodes.Store, CHILD(exc, 3));\n        return new Sk.astnodes.ExceptHandler(ast_for_expr(c, CHILD(exc, 1)), e, astForSuite(c, body), exc.lineno, exc.col_offset);\n    }\n    Sk.asserts.fail(\"wrong number of children for except clause\");\n}\n\nfunction astForTryStmt (c, n) {\n    var exceptSt;\n    var i;\n    var handlers = [];\n    var nc = NCH(n);\n    var nexcept = (nc - 3) / 3;\n    var body, orelse = [],\n        finally_ = null;\n\n    REQ(n, SYM.try_stmt);\n    body = astForSuite(c, CHILD(n, 2));\n    if (CHILD(n, nc - 3).type === TOK.T_NAME) {\n        if (CHILD(n, nc - 3).value === \"finally\") {\n            if (nc >= 9 && CHILD(n, nc - 6).type === TOK.T_NAME) {\n                /* we can assume it's an \"else\",\n                 because nc >= 9 for try-else-finally and\n                 it would otherwise have a type of except_clause */\n                orelse = astForSuite(c, CHILD(n, nc - 4));\n                nexcept--;\n            }\n\n            finally_ = astForSuite(c, CHILD(n, nc - 1));\n            nexcept--;\n        }\n        else {\n            /* we can assume it's an \"else\",\n             otherwise it would have a type of except_clause */\n            orelse = astForSuite(c, CHILD(n, nc - 1));\n            nexcept--;\n        }\n    }\n    else if (CHILD(n, nc - 3).type !== SYM.except_clause) {\n        throw new Sk.builtin.SyntaxError(\"malformed 'try' statement\", c.c_filename, n.lineno);\n    }\n\n    if (nexcept > 0) {\n        /* process except statements to create a try ... except */\n        for (i = 0; i < nexcept; i++) {\n            handlers[i] = astForExceptClause(c, CHILD(n, 3 + i * 3), CHILD(n, 5 + i * 3));\n        }\n    }\n\n    Sk.asserts.assert(!!finally_ || handlers.length != 0);\n    return new Sk.astnodes.Try(body, handlers, orelse, finally_, n.lineno, n.col_offset);\n}\n\nfunction astForDottedName (c, n) {\n    var i;\n    var e;\n    var id;\n    var col_offset;\n    var lineno;\n    REQ(n, SYM.dotted_name);\n    lineno = n.lineno;\n    col_offset = n.col_offset;\n    id = strobj(CHILD(n, 0).value);\n    e = new Sk.astnodes.Name(id, Sk.astnodes.Load, lineno, col_offset);\n    for (i = 2; i < NCH(n); i += 2) {\n        id = strobj(CHILD(n, i).value);\n        e = new Sk.astnodes.Attribute(e, id, Sk.astnodes.Load, lineno, col_offset);\n    }\n    return e;\n}\n\nfunction astForDecorator (c, n) {\n    /* decorator: '@' dotted_name [ '(' [arglist] ')' ] NEWLINE */\n    var nameExpr;\n    REQ(n, SYM.decorator);\n    REQ(CHILD(n, 0), TOK.T_AT);\n    REQ(CHILD(n, NCH(n) - 1), TOK.T_NEWLINE);\n    nameExpr = astForDottedName(c, CHILD(n, 1));\n    if (NCH(n) === 3) // no args\n    {\n        return nameExpr;\n    }\n    else if (NCH(n) === 5) // call with no args\n    {\n        return new Sk.astnodes.Call(nameExpr, [], [], null, null, n.lineno, n.col_offset);\n    }\n    else {\n        return ast_for_call(c, CHILD(n, 3), nameExpr);\n    }\n}\n\nfunction astForDecorators (c, n) {\n    var i;\n    var decoratorSeq;\n    REQ(n, SYM.decorators);\n    decoratorSeq = [];\n    for (i = 0; i < NCH(n); ++i) {\n        decoratorSeq[i] = astForDecorator(c, CHILD(n, i));\n    }\n    return decoratorSeq;\n}\n\nfunction ast_for_decorated (c, n) {\n    /* decorated: decorators (classdef | funcdef | async_funcdef) */\n    var thing = null;\n    var decorator_seq = null;\n\n    REQ(n, SYM.decorated);\n\n    decorator_seq = astForDecorators(c, CHILD(n, 0));\n    Sk.asserts.assert(TYPE(CHILD(n, 1)) == SYM.funcdef ||\n            TYPE(CHILD(n, 1)) == SYM.async_funcdef ||\n            TYPE(CHILD(n, 1)) == SYM.classdef);\n\n    if (TYPE(CHILD(n, 1)) == SYM.funcdef) {\n        thing = ast_for_funcdef(c, CHILD(n, 1), decorator_seq);\n    } else if (TYPE(CHILD(n, 1)) == SYM.classdef) {\n        thing = astForClassdef(c, CHILD(n, 1), decorator_seq);\n    } else if (TYPE(CHILD(n, 1)) == SYM.async_funcdef) {\n        thing = ast_for_async_funcdef(c, CHILD(n, 1), decorator_seq);\n    }\n    /* we count the decorators in when talking about the class' or\n        * function's line number */\n    if (thing) {\n        thing.lineno = LINENO(n);\n        thing.col_offset = n.col_offset;\n    }\n    return thing;\n}\n\n/* with_item: test ['as' expr] */\nfunction ast_for_with_item (c, n) {\n    var context_expr, optional_vars;\n    REQ(n, SYM.with_item);\n    context_expr = ast_for_expr(c, CHILD(n, 0));\n    if (NCH(n) == 3) {\n        optional_vars = ast_for_expr(c, CHILD(n, 2));\n        setContext(c, optional_vars, Sk.astnodes.Store, n);\n    }\n\n    return new Sk.astnodes.withitem(context_expr, optional_vars);\n}\n\n/* with_stmt: 'with' with_item (',' with_item)* ':' suite */\nfunction ast_for_with_stmt(c, n0, is_async) {\n    const n = is_async ? CHILD(n0, 1) : n0;\n    var i\n    var items = [], body;\n\n    REQ(n, SYM.with_stmt);\n\n    for (i = 1; i < NCH(n) - 2; i += 2) {\n        var item = ast_for_with_item(c, CHILD(n, i));\n        items[(i - 1) / 2] = item;\n    }\n\n    body = astForSuite(c, CHILD(n, NCH(n) - 1));\n\n    if (is_async) {\n        return new Sk.astnodes.AsyncWith(items, body, LINENO(n0), n0.col_offset);\n    } else {\n        return new Sk.astnodes.With(items, body, LINENO(n), n.col_offset);\n    }\n}\n\nfunction astForExecStmt (c, n) {\n    var expr1, globals = null, locals = null;\n    var nchildren = NCH(n);\n    Sk.asserts.assert(nchildren === 2 || nchildren === 4 || nchildren === 6);\n\n    /* exec_stmt: 'exec' expr ['in' test [',' test]] */\n    REQ(n, SYM.exec_stmt);\n    expr1 = ast_for_expr(c, CHILD(n, 1));\n    if (nchildren >= 4) {\n        globals = ast_for_expr(c, CHILD(n, 3));\n    }\n    if (nchildren === 6) {\n        locals = ast_for_expr(c, CHILD(n, 5));\n    }\n    return new Sk.astnodes.Exec(expr1, globals, locals, n.lineno, n.col_offset);\n}\n\nfunction astForIfStmt (c, n) {\n    /* if_stmt: 'if' test ':' suite ('elif' test ':' suite)*\n     ['else' ':' suite]\n     */\n    var off;\n    var i;\n    var orelse;\n    var hasElse;\n    var nElif;\n    var decider;\n    var s;\n    REQ(n, SYM.if_stmt);\n    if (NCH(n) === 4) {\n        return new Sk.astnodes.If(\n            ast_for_expr(c, CHILD(n, 1)),\n            astForSuite(c, CHILD(n, 3)),\n            [], n.lineno, n.col_offset);\n    }\n\n    s = CHILD(n, 4).value;\n    decider = s.charAt(2); // elSe or elIf\n    if (decider === \"s\") {\n        return new Sk.astnodes.If(\n            ast_for_expr(c, CHILD(n, 1)),\n            astForSuite(c, CHILD(n, 3)),\n            astForSuite(c, CHILD(n, 6)),\n            n.lineno, n.col_offset);\n    }\n    else if (decider === \"i\") {\n        nElif = NCH(n) - 4;\n        hasElse = false;\n        orelse = [];\n\n        /* must reference the child nElif+1 since 'else' token is third, not\n         * fourth child from the end. */\n        if (CHILD(n, nElif + 1).type === TOK.T_NAME &&\n            CHILD(n, nElif + 1).value.charAt(2) === \"s\") {\n            hasElse = true;\n            nElif -= 3;\n        }\n        nElif /= 4;\n\n        if (hasElse) {\n            orelse = [\n                new Sk.astnodes.If(\n                    ast_for_expr(c, CHILD(n, NCH(n) - 6)),\n                    astForSuite(c, CHILD(n, NCH(n) - 4)),\n                    astForSuite(c, CHILD(n, NCH(n) - 1)),\n                    CHILD(n, NCH(n) - 6).lineno,\n                    CHILD(n, NCH(n) - 6).col_offset)];\n            nElif--;\n        }\n\n        for (i = 0; i < nElif; ++i) {\n            off = 5 + (nElif - i - 1) * 4;\n            orelse = [\n                new Sk.astnodes.If(\n                    ast_for_expr(c, CHILD(n, off)),\n                    astForSuite(c, CHILD(n, off + 2)),\n                    orelse,\n                    CHILD(n, off).lineno,\n                    CHILD(n, off).col_offset)];\n        }\n        return new Sk.astnodes.If(\n            ast_for_expr(c, CHILD(n, 1)),\n            astForSuite(c, CHILD(n, 3)),\n            orelse, n.lineno, n.col_offset);\n    }\n\n    Sk.asserts.fail(\"unexpected token in 'if' statement\");\n}\n\nfunction ast_for_exprlist (c, n, context) {\n    var e;\n    var i;\n    var seq;\n    REQ(n, SYM.exprlist);\n    seq = [];\n    for (i = 0; i < NCH(n); i += 2) {\n        e = ast_for_expr(c, CHILD(n, i));\n        seq[i / 2] = e;\n        if (context) {\n            setContext(c, e, context, CHILD(n, i));\n        }\n    }\n    return seq;\n}\n\nfunction astForDelStmt (c, n) {\n    /* del_stmt: 'del' exprlist */\n    REQ(n, SYM.del_stmt);\n    return new Sk.astnodes.Delete(ast_for_exprlist(c, CHILD(n, 1), Sk.astnodes.Del), n.lineno, n.col_offset);\n}\n\nfunction astForGlobalStmt (c, n) {\n    /* global_stmt: 'global' NAME (',' NAME)* */\n    var i;\n    var s = [];\n    REQ(n, SYM.global_stmt);\n    for (i = 1; i < NCH(n); i += 2) {\n        s[(i - 1) / 2] = strobj(CHILD(n, i).value);\n    }\n    return new Sk.astnodes.Global(s, n.lineno, n.col_offset);\n}\n\nfunction astForAssertStmt (c, n) {\n    /* assert_stmt: 'assert' test [',' test] */\n    REQ(n, SYM.assert_stmt);\n    if (NCH(n) === 2) {\n        return new Sk.astnodes.Assert(ast_for_expr(c, CHILD(n, 1)), null, n.lineno, n.col_offset);\n    }\n    else if (NCH(n) === 4) {\n        return new Sk.astnodes.Assert(ast_for_expr(c, CHILD(n, 1)), ast_for_expr(c, CHILD(n, 3)), n.lineno, n.col_offset);\n    }\n    Sk.asserts.fail(\"improper number of parts to assert stmt\");\n}\n\nfunction aliasForImportName (c, n) {\n    /*\n     import_as_name: NAME ['as' NAME]\n     dotted_as_name: dotted_name ['as' NAME]\n     dotted_name: NAME ('.' NAME)*\n     */\n\n    var i;\n    var a;\n    var name;\n    var str;\n    loop: while (true) {\n        switch (n.type) {\n            case SYM.import_as_name:\n                str = null;\n                name = strobj(CHILD(n, 0).value);\n                if (NCH(n) === 3) {\n                    str = CHILD(n, 2).value;\n                }\n                return new Sk.astnodes.alias(name, str == null ? null : strobj(str));\n            case SYM.dotted_as_name:\n                if (NCH(n) === 1) {\n                    n = CHILD(n, 0);\n                    continue loop;\n                }\n                else {\n                    a = aliasForImportName(c, CHILD(n, 0));\n                    Sk.asserts.assert(!a.asname);\n                    a.asname = strobj(CHILD(n, 2).value);\n                    return a;\n                }\n                break;\n            case SYM.dotted_name:\n                if (NCH(n) === 1) {\n                    return new Sk.astnodes.alias(strobj(CHILD(n, 0).value), null);\n                }\n                else {\n                    // create a string of the form a.b.c\n                    str = \"\";\n                    for (i = 0; i < NCH(n); i += 2) {\n                        str += CHILD(n, i).value + \".\";\n                    }\n                    return new Sk.astnodes.alias(strobj(str.substr(0, str.length - 1)), null);\n                }\n                break;\n            case TOK.T_STAR:\n                return new Sk.astnodes.alias(strobj(\"*\"), null);\n            default:\n                throw new Sk.builtin.SyntaxError(\"unexpected import name\", c.c_filename, n.lineno);\n        }\n        break;\n    }\n}\n\nfunction astForImportStmt (c, n) {\n    /*\n     import_stmt: import_name | import_from\n     import_name: 'import' dotted_as_names\n     import_from: 'from' ('.'* dotted_name | '.') 'import'\n     ('*' | '(' import_as_names ')' | import_as_names)\n     */\n    var modname;\n    var idx;\n    var nchildren;\n    var ndots;\n    var mod;\n    var i;\n    var aliases;\n    var col_offset;\n    var lineno;\n    REQ(n, SYM.import_stmt);\n    lineno = n.lineno;\n    col_offset = n.col_offset;\n    n = CHILD(n, 0);\n    if (n.type === SYM.import_name) {\n        n = CHILD(n, 1);\n        REQ(n, SYM.dotted_as_names);\n        aliases = [];\n        for (i = 0; i < NCH(n); i += 2) {\n            aliases[i / 2] = aliasForImportName(c, CHILD(n, i));\n        }\n        return new Sk.astnodes.Import(aliases, lineno, col_offset);\n    }\n    else if (n.type === SYM.import_from) {\n        mod = null;\n        ndots = 0;\n\n        for (idx = 1; idx < NCH(n); ++idx) {\n            if (CHILD(n, idx).type === SYM.dotted_name) {\n                mod = aliasForImportName(c, CHILD(n, idx));\n                idx++;\n                break;\n            }\n            else if (CHILD(n, idx).type !== TOK.T_DOT) {\n                break;\n            }\n            ndots++;\n        }\n        ++idx; // skip the import keyword\n        switch (CHILD(n, idx).type) {\n            case TOK.T_STAR:\n                // from ... import\n                n = CHILD(n, idx);\n                nchildren = 1;\n                break;\n            case TOK.T_LPAR:\n                // from ... import (x, y, z)\n                n = CHILD(n, idx + 1);\n                nchildren = NCH(n);\n                break;\n            case SYM.import_as_names:\n                // from ... import x, y, z\n                n = CHILD(n, idx);\n                nchildren = NCH(n);\n                if (nchildren % 2 === 0) {\n                    throw new Sk.builtin.SyntaxError(\"trailing comma not allowed without surrounding parentheses\", c.c_filename, n.lineno);\n                }\n                break;\n            default:\n                throw new Sk.builtin.SyntaxError(\"Unexpected node-type in from-import\", c.c_filename, n.lineno);\n        }\n        aliases = [];\n        if (n.type === TOK.T_STAR) {\n            aliases[0] = aliasForImportName(c, n);\n        }\n        else {\n            for (i = 0; i < NCH(n); i += 2) {\n                aliases[i / 2] = aliasForImportName(c, CHILD(n, i));\n            }\n        }\n        modname = mod ? mod.name.v : \"\";\n        return new Sk.astnodes.ImportFrom(strobj(modname), aliases, ndots, lineno, col_offset);\n    }\n    throw new Sk.builtin.SyntaxError(\"unknown import statement\", c.c_filename, n.lineno);\n}\n\nfunction ast_for_testlistComp(c, n) {\n    /* testlist_comp: test ( comp_for | (',' test)* [','] ) */\n    /* argument: test [comp_for] */\n    Sk.asserts.assert(n.type === SYM.testlist_comp || n.type === SYM.argument);\n    if (NCH(n) > 1 && CHILD(n, 1).type === SYM.comp_for) {\n        return ast_for_gen_expr(c, n);\n    }\n    return ast_for_testlist(c, n);\n}\nfunction ast_for_genexp(c, n)\n{\n    Sk.asserts.assert(TYPE(n) == SYM.testlist_comp || TYPE(n) == SYM.argument);\n    return ast_for_itercomp(c, n, COMP_GENEXP);\n}\n\nfunction  ast_for_listcomp(c, n) {\n    Sk.asserts.assert(TYPE(n) == (SYM.testlist_comp));\n    return ast_for_itercomp(c, n, COMP_LISTCOMP);\n}\n\nfunction astForFactor (c, n) {\n    /* some random peephole thing that cpy does */\n    var expression;\n    var pnum;\n    var patom;\n    var ppower;\n    var pfactor;\n    if (CHILD(n, 0).type === TOK.T_MINUS && NCH(n) === 2) {\n        pfactor = CHILD(n, 1);\n        if (pfactor.type === SYM.factor && NCH(pfactor) === 1) {\n            ppower = CHILD(pfactor, 0);\n            if (ppower.type === SYM.power && NCH(ppower) === 1) {\n                patom = CHILD(ppower, 0);\n                if (patom.type === SYM.atom) {\n                    pnum = CHILD(patom, 0);\n                    if (pnum.type === TOK.T_NUMBER) {\n                        pnum.value = \"-\" + pnum.value;\n                        return ast_for_atom(c, patom);\n                    }\n                }\n            }\n        }\n    }\n\n    expression = ast_for_expr(c, CHILD(n, 1));\n    switch (CHILD(n, 0).type) {\n        case TOK.T_PLUS:\n            return new Sk.astnodes.UnaryOp(Sk.astnodes.UAdd, expression, n.lineno, n.col_offset);\n        case TOK.T_MINUS:\n            return new Sk.astnodes.UnaryOp(Sk.astnodes.USub, expression, n.lineno, n.col_offset);\n        case TOK.T_TILDE:\n            return new Sk.astnodes.UnaryOp(Sk.astnodes.Invert, expression, n.lineno, n.col_offset);\n    }\n\n    Sk.asserts.fail(\"unhandled factor\");\n}\n\nfunction astForForStmt (c, n) {\n    /* for_stmt: 'for' exprlist 'in' testlist ':' suite ['else' ':' suite] */\n    var target;\n    var _target;\n    var nodeTarget;\n    var seq = [];\n    REQ(n, SYM.for_stmt);\n    if (NCH(n) === 9) {\n        seq = astForSuite(c, CHILD(n, 8));\n    }\n    nodeTarget = CHILD(n, 1);\n    _target = ast_for_exprlist(c, nodeTarget, Sk.astnodes.Store);\n    if (NCH(nodeTarget) === 1) {\n        target = _target[0];\n    }\n    else {\n        target = new Sk.astnodes.Tuple(_target, Sk.astnodes.Store, n.lineno, n.col_offset);\n    }\n\n    return new Sk.astnodes.For(target,\n        ast_for_testlist(c, CHILD(n, 3)),\n        astForSuite(c, CHILD(n, 5)),\n        seq, n.lineno, n.col_offset);\n}\n\nfunction ast_for_call(c, n, func, allowgen)\n{\n    /*\n      arglist: argument (',' argument)*  [',']\n      argument: ( test [comp_for] | '*' test | test '=' test | '**' test )\n    */\n\n    var i, nargs, nkeywords;\n    var ndoublestars;\n    var args;\n    var keywords;\n\n    REQ(n, SYM.arglist);\n\n    nargs = 0;\n    nkeywords = 0;\n    for (i = 0; i < NCH(n); i++) {\n        var ch = CHILD(n, i);\n        if (TYPE(ch) == SYM.argument) {\n            if (NCH(ch) == 1) {\n                nargs++;\n            } else if (TYPE(CHILD(ch, 1)) == SYM.comp_for) {\n                nargs++;\n                if (!allowgen) {\n                    ast_error(c, ch, \"invalid syntax\");\n                }\n                if (NCH(n) > 1) {\n                    ast_error(c, ch, \"Generator expression must be parenthesized\");\n                }\n            } else if (TYPE(CHILD(ch, 0)) == TOK.T_STAR) {\n                nargs++;\n            } else {\n                /* TYPE(CHILD(ch, 0)) == DOUBLESTAR or keyword argument */\n                nkeywords++;\n            }\n        }\n    }\n\n    args = []\n    keywords = []\n\n    nargs = 0;  /* positional arguments + iterable argument unpackings */\n    nkeywords = 0;  /* keyword arguments + keyword argument unpackings */\n    ndoublestars = 0;  /* just keyword argument unpackings */\n    for (i = 0; i < NCH(n); i++) {\n        ch = CHILD(n, i);\n        if (TYPE(ch) == SYM.argument) {\n            var e;\n            var chch = CHILD(ch, 0);\n            if (NCH(ch) == 1) {\n                /* a positional argument */\n                if (nkeywords) {\n                    if (ndoublestars) {\n                        ast_error(c, chch,\n                                \"positional argument follows \" +\n                                \"keyword argument unpacking\");\n                    } else {\n                        ast_error(c, chch,\n                                \"positional argument follows \" +\n                                \"keyword argument\");\n                    }\n                }\n                e = ast_for_expr(c, chch);\n                if (!e) {\n                    return NULL;\n                }\n                args[nargs++] = e;\n            } else if (TYPE(chch) == TOK.T_STAR) {\n                /* an iterable argument unpacking */\n                var starred;\n                if (ndoublestars) {\n                    ast_error(c, chch,\n                            \"iterable argument unpacking follows \" +\n                            \"keyword argument unpacking\");\n                    return NULL;\n                }\n                e = ast_for_expr(c, CHILD(ch, 1));\n                if (!e) {\n                    return NULL;\n                }\n                starred = new Sk.astnodes.Starred(e, Sk.astnodes.Load, LINENO(chch),\n                        chch.col_offset);\n                args[nargs++] = starred;\n            } else if (TYPE(chch) == TOK.T_DOUBLESTAR) {\n                /* a keyword argument unpacking */\n                var kw;\n                i++;\n                e = ast_for_expr(c, CHILD(ch, 1));\n                if (!e) {\n                    return NULL;\n                }\n                kw = new Sk.astnodes.keyword(NULL, e);\n                keywords[nkeywords++] = kw;\n                ndoublestars++;\n            } else if (TYPE(CHILD(ch, 1)) == SYM.comp_for) {\n                /* the lone generator expression */\n                e = ast_for_genexp(c, ch);\n                if (!e) {\n                    return NULL;\n                }\n                args[nargs++] = e;\n            } else {\n                /* a keyword argument */\n                var kw;\n                var key, tmp;\n                var k;\n\n                /* chch is test, but must be an identifier? */\n                e = ast_for_expr(c, chch);\n                if (!e) {\n                    return NULL;\n                }\n                /* f(lambda x: x[0] = 3) ends up getting parsed with\n                 * LHS test = lambda x: x[0], and RHS test = 3.\n                 * SF bug 132313 points out that complaining about a keyword\n                 * then is very confusing.\n                 */\n                if (e.constructor === Sk.astnodes.Lambda) {\n                    ast_error(c, chch,\n                            \"lambda cannot contain assignment\");\n                    return NULL;\n                }\n                else if (e.constructor !== Sk.astnodes.Name) {\n                    ast_error(c, chch,\n                            \"keyword can't be an expression\");\n                    return NULL;\n                }\n                else if (forbiddenCheck(c, e.id, ch, 1)) {\n                    return NULL;\n                }\n                key = e.id;\n                for (k = 0; k < nkeywords; k++) {\n                    tmp = keywords[k].arg;\n                    if (tmp && tmp === key) {\n                        ast_error(c, chch,\n                                \"keyword argument repeated\");\n                        return NULL;\n                    }\n                }\n                e = ast_for_expr(c, CHILD(ch, 2));\n                if (!e)\n                    return NULL;\n                kw = new Sk.astnodes.keyword(key, e);\n                keywords[nkeywords++] = kw;\n            }\n        }\n    }\n\n    return new Sk.astnodes.Call(func, args, keywords, func.lineno, func.col_offset);\n}\n\nfunction ast_for_trailer(c, n, left_expr) {\n    /* trailer: '(' [arglist] ')' | '[' subscriptlist ']' | '.' NAME\n       subscriptlist: subscript (',' subscript)* [',']\n       subscript: '.' '.' '.' | test | [test] ':' [test] [sliceop]\n     */\n    REQ(n, SYM.trailer);\n    if (TYPE(CHILD(n, 0)) == TOK.T_LPAR) {\n        if (NCH(n) == 2)\n            return new Sk.astnodes.Call(left_expr, NULL, NULL, LINENO(n),\n                        n.col_offset);\n        else\n            return ast_for_call(c, CHILD(n, 1), left_expr, true);\n    }\n    else if (TYPE(CHILD(n, 0)) == TOK.T_DOT) {\n        var attr_id = new_identifier(CHILD(n, 1));\n        if (!attr_id)\n            return NULL;\n        return new Sk.astnodes.Attribute(left_expr, attr_id, Sk.astnodes.Load,\n                         LINENO(n), n.col_offset);\n    }\n    else {\n        REQ(CHILD(n, 0), TOK.T_LSQB);\n        REQ(CHILD(n, 2), TOK.T_RSQB);\n        n = CHILD(n, 1);\n        if (NCH(n) == 1) {\n            var slc = astForSlice(c, CHILD(n, 0));\n            if (!slc) {\n                return NULL;\n            }\n            return new Sk.astnodes.Subscript(left_expr, slc, Sk.astnodes.Load, LINENO(n), n.col_offset);\n        }\n        else {\n            /* The grammar is ambiguous here. The ambiguity is resolved\n               by treating the sequence as a tuple literal if there are\n               no slice features.\n            */\n            var j;\n            var slc;\n            var e;\n            var simple = 1;\n            var slices = [], elts;\n\n            for (j = 0; j < NCH(n); j += 2) {\n                slc = astForSlice(c, CHILD(n, j));\n                if (!slc) {\n                    return NULL;\n                }\n                if (slc.kind != _slice_kind.Index_kind) {\n                    simple = 0;\n                }\n                slices[j / 2] = slc;\n            }\n            if (!simple) {\n                return new Sk.astnodes.Subscript(left_expr, new Sk.astnodes.ExtSlice(slices),\n                                Sk.astnodes.Load, LINENO(n), n.col_offset);\n            }\n            /* extract Index values and put them in a Tuple */\n            elts = [];\n            for (j = 0; j < slices.length; ++j) {\n                // @meredydd any idea how we reach this?\n                slc = slices[j];\n                Sk.asserts.assert(slc.kind == _slice_kind.Index_kind  && slc.v.Index.value);\n                elts[j] = slc.v.Index.value;\n            }\n            e = new Sk.astnodes.Tuple(elts, Sk.astnodes.Load, LINENO(n), n.col_offset);\n\n            return new Sk.astnodes.Subscript(left_expr, new Sk.astnodes.Index(e),\n                             Sk.astnodes.Load, LINENO(n), n.col_offset);\n        }\n    }\n}\n\nfunction ast_for_flow_stmt(c, n)\n{\n    /*\n      flow_stmt: break_stmt | continue_stmt | return_stmt | raise_stmt\n                 | yield_stmt\n      break_stmt: 'break'\n      continue_stmt: 'continue'\n      return_stmt: 'return' [testlist]\n      yield_stmt: yield_expr\n      yield_expr: 'yield' testlist | 'yield' 'from' test\n      raise_stmt: 'raise' [test [',' test [',' test]]]\n    */\n    var ch;\n\n    REQ(n, SYM.flow_stmt);\n    ch = CHILD(n, 0);\n    switch (TYPE(ch)) {\n        case SYM.break_stmt:\n            return new Sk.astnodes.Break(LINENO(n), n.col_offset,\n                         n.end_lineno, n.end_col_offset);\n        case SYM.continue_stmt:\n            return new Sk.astnodes.Continue(LINENO(n), n.col_offset,\n                            n.end_lineno, n.end_col_offset);\n        case SYM.yield_stmt: { /* will reduce to yield_expr */\n            var exp = ast_for_expr(c, CHILD(ch, 0));\n            if (!exp) {\n                return null;\n            }\n            return new Sk.astnodes.Expr(exp, LINENO(n), n.col_offset,\n                        n.end_lineno, n.end_col_offset);\n        }\n        case SYM.return_stmt:\n            if (NCH(ch) == 1)\n                return new Sk.astnodes.Return(null, LINENO(n), n.col_offset,\n                              n.end_lineno, n.end_col_offset);\n            else {\n                var expression = ast_for_testlist(c, CHILD(ch, 1));\n                if (!expression) {\n                    return null;\n                }\n                return new Sk.astnodes.Return(expression, LINENO(n), n.col_offset,\n                              n.end_lineno, n.end_col_offset);\n            }\n        case SYM.raise_stmt:\n            // This is tricky and Skulpt-specific, because we need to handle\n            // both Python 3-style and Python 2-style 'raise' statements\n            if (NCH(ch) == 1)\n                return new Sk.astnodes.Raise(null, null, null, null, LINENO(n), n.col_offset,\n                             n.end_lineno, n.end_col_offset);\n            else if (NCH(ch) >= 2) {\n                var cause = null;\n                var expression = ast_for_expr(c, CHILD(ch, 1));\n                var inst = null, tback = null;\n\n                // raise [expression] from [cause]\n                if (NCH(ch) == 4 && CHILD(ch, 2).value == 'from') {\n                    if (!Sk.__future__.python3) {\n                        ast_error(c, CHILD(ch, 2), \"raise ... from ... is not available in Python 2\");\n                    }\n                    cause = ast_for_expr(c, CHILD(ch, 3));\n                } else if (NCH(ch) >= 4 && CHILD(ch, 2).value == ',') {\n                    if (Sk.__future__.python3) {\n                        ast_error(c, n, \"Old raise syntax is not available in Python 3\")\n                    }\n                    // raise [exception_type], [instantiation value] [, [traceback]]\n                    // NB traceback isn't implemented in Skulpt yet\n                    inst = ast_for_expr(c, CHILD(ch, 3));\n\n                    if (NCH(ch) == 6) {\n                        tback = ast_for_expr(c, CHILD(ch, 5));\n                    }\n                }\n                return new Sk.astnodes.Raise(expression, cause, inst, tback, LINENO(n), n.col_offset,\n                             n.end_lineno, n.end_col_offset);\n            }\n            /* fall through */\n        default:\n            Sk.asserts.fail(\"unexpected flow_stmt: \", TYPE(ch));\n            return null;\n    }\n}\n\nfunction astForArg(c, n)\n{\n    var name;\n    var annotation = null;\n    var ch;\n\n    Sk.asserts.assert(n.type === SYM.tfpdef || n.type === SYM.vfpdef);\n    ch = CHILD(n, 0);\n    forbiddenCheck(c, ch, ch.value, ch.lineno);\n    name = strobj(ch.value);\n\n    if (NCH(n) == 3 && CHILD(n, 1).type === TOK.T_COLON) {\n        annotation = ast_for_expr(c, CHILD(n, 2));\n    }\n\n    return new Sk.astnodes.arg(name, annotation, n.lineno, n.col_offset);\n}\n\n/* returns -1 if failed to handle keyword only arguments\n   returns new position to keep processing if successful\n               (',' tfpdef ['=' test])*\n                     ^^^\n   start pointing here\n */\nfunction handleKeywordonlyArgs(c, n, start, kwonlyargs, kwdefaults)\n{\n    var argname;\n    var ch;\n    var expression;\n    var annotation;\n    var arg;\n    var i = start;\n    var j = 0; /* index for kwdefaults and kwonlyargs */\n\n    if (!kwonlyargs) {\n        ast_error(c, CHILD(n, start), \"named arguments must follow bare *\");\n    }\n    Sk.asserts.assert(kwdefaults);\n    while (i < NCH(n)) {\n        ch = CHILD(n, i);\n        switch (ch.type) {\n            case SYM.vfpdef:\n            case SYM.tfpdef:\n                if (i + 1 < NCH(n) && CHILD(n, i + 1).type == TOK.T_EQUAL) {\n                    kwdefaults[j] = ast_for_expr(c, CHILD(n, i + 2));\n                    i += 2; /* '=' and test */\n                }\n                else { /* setting NULL if no default value exists */\n                    kwdefaults[j] = null;\n                }\n                if (NCH(ch) == 3) {\n                    /* ch is NAME ':' test */\n                    annotation = ast_for_expr(c, CHILD(ch, 2));\n                }\n                else {\n                    annotation = null;\n                }\n                ch = CHILD(ch, 0);\n                forbiddenCheck(c, ch, ch.value, ch.lineno);\n                argname = strobj(ch.value);\n                kwonlyargs[j++] = new Sk.astnodes.arg(argname, annotation, ch.lineno, ch.col_offset);\n                i += 2; /* the name and the comma */\n                break;\n            case TOK.T_DOUBLESTAR:\n                return i;\n            default:\n                ast_error(c, ch, \"unexpected node\");\n        }\n    }\n    return i;\n}\n\nfunction astForArguments (c, n) {\n    var k;\n    var j;\n    var i;\n    var foundDefault;\n    var posargs = [];\n    var posdefaults = [];\n    var kwonlyargs = [];\n    var kwdefaults = [];\n    var vararg = null;\n    var kwarg = null;\n    var ch = null;\n\n    /* This function handles both typedargslist (function definition)\n       and varargslist (lambda definition).\n\n       parameters: '(' [typedargslist] ')'\n       typedargslist: (tfpdef ['=' test] (',' tfpdef ['=' test])* [',' [\n               '*' [tfpdef] (',' tfpdef ['=' test])* [',' ['**' tfpdef [',']]]\n             | '**' tfpdef [',']]]\n         | '*' [tfpdef] (',' tfpdef ['=' test])* [',' ['**' tfpdef [',']]]\n         | '**' tfpdef [','])\n       tfpdef: NAME [':' test]\n       varargslist: (vfpdef ['=' test] (',' vfpdef ['=' test])* [',' [\n               '*' [vfpdef] (',' vfpdef ['=' test])* [',' ['**' vfpdef [',']]]\n             | '**' vfpdef [',']]]\n         | '*' [vfpdef] (',' vfpdef ['=' test])* [',' ['**' vfpdef [',']]]\n         | '**' vfpdef [',']\n       )\n       vfpdef: NAME\n\n    */\n    if (n.type === SYM.parameters) {\n        if (NCH(n) === 2) // () as arglist\n        {\n            return new Sk.astnodes.arguments_([], null, [], [], null, []);\n        }\n        n = CHILD(n, 1);\n    }\n    Sk.asserts.assert(n.type === SYM.varargslist ||\n                        n.type === SYM.typedargslist);\n\n\n    // Skulpt note: the \"counting numbers of args\" section\n    // from ast.c is omitted because JS arrays autoexpand\n\n    /* tfpdef: NAME [':' test]\n       vfpdef: NAME\n    */\n    i = 0;\n    j = 0;  /* index for defaults */\n    k = 0;  /* index for args */\n    while (i < NCH(n)) {\n        ch = CHILD(n, i);\n        switch (ch.type) {\n            case SYM.tfpdef:\n            case SYM.vfpdef:\n                /* XXX Need to worry about checking if TYPE(CHILD(n, i+1)) is\n                   anything other than EQUAL or a comma? */\n                /* XXX Should NCH(n) check be made a separate check? */\n                if (i + 1 < NCH(n) && CHILD(n, i + 1).type == TOK.T_EQUAL) {\n                    posdefaults[j++] = ast_for_expr(c, CHILD(n, i + 2));\n                    i += 2;\n                    foundDefault = 1;\n                }\n                else if (foundDefault) {\n                    throw new Sk.builtin.SyntaxError(\"non-default argument follows default argument\", c.c_filename, n.lineno);\n                }\n                posargs[k++] = astForArg(c, ch);\n                i += 2; /* the name and the comma */\n                break;\n            case TOK.T_STAR:\n                if (i+1 >= NCH(n) ||\n                    (i+2 == NCH(n) && CHILD(n, i+1).type == TOK.T_COMMA)) {\n                    throw new Sk.builtin.SyntaxError(\"named arguments must follow bare *\", c.c_filename, n.lineno);\n                }\n                ch = CHILD(n, i+1);  /* tfpdef or COMMA */\n                if (ch.type == TOK.T_COMMA) {\n                    i += 2; /* now follows keyword only arguments */\n                    i = handleKeywordonlyArgs(c, n, i,\n                                                  kwonlyargs, kwdefaults);\n                }\n                else {\n                    vararg = astForArg(c, ch);\n\n                    i += 3;\n                    if (i < NCH(n) && (CHILD(n, i).type == SYM.tfpdef\n                                    || CHILD(n, i).type == SYM.vfpdef)) {\n                        i = handleKeywordonlyArgs(c, n, i,\n                                                      kwonlyargs, kwdefaults);\n                    }\n                }\n                break;\n            case TOK.T_DOUBLESTAR:\n                ch = CHILD(n, i+1);  /* tfpdef */\n                Sk.asserts.assert(ch.type == SYM.tfpdef || ch.type == SYM.vfpdef);\n                kwarg = astForArg(c, ch);\n                i += 3;\n                break;\n            default:\n                Sk.asserts.fail(\"unexpected node in varargslist\");\n                return;\n        }\n    }\n    return new Sk.astnodes.arguments_(posargs, vararg, kwonlyargs, kwdefaults, kwarg, posdefaults);\n}\n\nfunction ast_for_async_funcdef(c, n, decorator_seq)\n{\n    /* async_funcdef: 'async' funcdef */\n    REQ(n, SYM.async_funcdef);\n    REQ(CHILD(n, 0), TOK.T_NAME);\n    Sk.asserts.assert(STR(CHILD(n, 0) === \"async\"));\n    REQ(CHILD(n, 1), SYM.funcdef);\n\n    return ast_for_funcdef_impl(c, n, decorator_seq,\n                                true /* is_async */);\n}\n\nfunction ast_for_funcdef(c, n, decorator_seq) {\n    /* funcdef: 'def' NAME parameters ['->' test] ':' suite */\n    return ast_for_funcdef_impl(c, n, decorator_seq,\n        false /* is_async */);\n}\n\nfunction ast_for_funcdef_impl(c, n0, decorator_seq, is_async) {\n    /* funcdef: 'def' NAME parameters ['->' test] ':' [TYPE_COMMENT] suite */\n    var n = is_async ? CHILD(n0, 1) : n0;\n    var name;\n    var args;\n    var body;\n    var returns = NULL;\n    var name_i = 1;\n    var end_lineno, end_col_offset;\n    var tc;\n    var type_comment = NULL;\n\n    if (is_async && c.c_feature_version < 5) {\n        ast_error(c, n,\n                  \"Async functions are only supported in Python 3.5 and greater\");\n        return NULL;\n    }\n\n    REQ(n, SYM.funcdef);\n\n    name = new_identifier(CHILD(n, name_i));\n\n    if (forbiddenCheck(c, name, CHILD(n, name_i), 0)) {\n        return NULL;\n    }\n    args = astForArguments(c, CHILD(n, name_i + 1));\n    if (!args) {\n        return NULL;\n    }\n    if (TYPE(CHILD(n, name_i+2)) == TOK.T_RARROW) {\n        returns = ast_for_expr(c, CHILD(n, name_i + 3));\n        if (!returns) {\n            return NULL\n        }\n        name_i += 2;\n    }\n\n    if (TYPE(CHILD(n, name_i + 3)) == TOK.T_TYPE_COMMENT) {\n        type_comment = TOK.T_NEW_TYPE_COMMENT(CHILD(n, name_i + 3));\n        if (!type_comment)\n            return NULL;\n        name_i += 1;\n    }\n\n    body = astForSuite(c, CHILD(n, name_i + 3));\n    if (!body) {\n        return NULL;\n    }\n    // get_last_end_pos(body, &end_lineno, &end_col_offset);\n\n    if (NCH(CHILD(n, name_i + 3)) > 1) {\n        /* Check if the suite has a type comment in it. */\n        tc = CHILD(CHILD(n, name_i + 3), 1);\n\n        if (TYPE(tc) == TOK.T_TYPE_COMMENT) {\n            if (type_comment != NULL) {\n                ast_error(c, n, \"Cannot have two type comments on def\");\n                return NULL;\n            }\n            type_comment = TOK.T_NEW_TYPE_COMMENT(tc);\n            if (!type_comment)\n                return NULL;\n        }\n    }\n\n    if (is_async)\n        return new Sk.astnodes.AsyncFunctionDef(name, args, body, decorator_seq, returns, type_comment,\n                                LINENO(n0), n0.col_offset, end_lineno, end_col_offset);\n    else\n        return new Sk.astnodes.FunctionDef(name, args, body, decorator_seq, returns, type_comment,\n                           LINENO(n), n.col_offset, end_lineno, end_col_offset);\n}\n\nfunction astForClassBases (c, n) {\n    /* testlist: test (',' test)* [','] */\n    Sk.asserts.assert(NCH(n) > 0);\n    REQ(n, SYM.testlist);\n    if (NCH(n) === 1) {\n        return [ ast_for_expr(c, CHILD(n, 0)) ];\n    }\n    return seq_for_testlist(c, n);\n}\n\nfunction astForClassdef (c, n, decoratorSeq) {\n    /* classdef: 'class' NAME ['(' arglist ')'] ':' suite */\n    var classname;\n    var call;\n    var s;\n\n    REQ(n, SYM.classdef);\n\n    if (NCH(n) == 4) { /* class NAME ':' suite */\n        s = astForSuite(c, CHILD(n, 3));\n        classname = new_identifier(CHILD(n, 1).value);\n        forbiddenCheck(c, CHILD(n,3), classname, n.lineno);\n\n        return new Sk.astnodes.ClassDef(classname, [], [], s, decoratorSeq,\n                                    /*TODO docstring*/null, LINENO(n), n.col_offset);\n    }\n\n    if (TYPE(CHILD(n, 3)) === TOK.T_RPAR) { /* class NAME '(' ')' ':' suite */\n        s = astForSuite(c, CHILD(n, 5));\n        classname = new_identifier(CHILD(n, 1).value);\n        forbiddenCheck(c, CHILD(n, 3), classname, CHILD(n, 3).lineno);\n        return new Sk.astnodes.ClassDef(classname, [], [], s, decoratorSeq,\n                                    /*TODO docstring*/null, LINENO(n), n.col_offset);\n    }\n\n    /* class NAME '(' arglist ')' ':' suite */\n    /* build up a fake Call node so we can extract its pieces */\n    {\n        var dummy_name;\n        var dummy;\n        dummy_name = new_identifier(CHILD(n, 1));\n        dummy = new Sk.astnodes.Name(dummy_name, Sk.astnodes.Load, LINENO(n), n.col_offset);\n        call = ast_for_call(c, CHILD(n, 3), dummy, false);\n    }\n    s = astForSuite(c, CHILD(n, 6));\n    classname = new_identifier(CHILD(n, 1).value);\n    forbiddenCheck(c, CHILD(n,1), classname, CHILD(n,1).lineno);\n\n    return new Sk.astnodes.ClassDef(classname, call.args, call.keywords, s,\n                               decoratorSeq, /*TODO docstring*/null, LINENO(n), n.col_offset);\n}\n\nfunction astForLambdef (c, n) {\n    /* lambdef: 'lambda' [varargslist] ':' test */\n    var args;\n    var expression;\n    if (NCH(n) === 3) {\n        args = new Sk.astnodes.arguments_([], null, null, []);\n        expression = ast_for_expr(c, CHILD(n, 2));\n    }\n    else {\n        args = astForArguments(c, CHILD(n, 1));\n        expression = ast_for_expr(c, CHILD(n, 3));\n    }\n    return new Sk.astnodes.Lambda(args, expression, n.lineno, n.col_offset);\n}\n\nfunction astForComprehension(c, n) {\n    /* testlist_comp: test ( comp_for | (',' test)* [','] )\n       argument: test [comp_for] | test '=' test       # Really [keyword '='] test */\n\n    var j;\n    var ifs;\n    var nifs;\n    var ge;\n    var expression;\n    var t;\n    var forch;\n    var i;\n    var ch;\n    var genexps;\n    var nfors;\n    var elt;\n    var comps;\n    var comp;\n\n    function countCompFors(c, n) {\n        var nfors = 0;\n        count_comp_for: while (true) {\n            nfors++;\n            REQ(n, SYM.comp_for);\n            if (NCH(n) === 5) {\n                n = CHILD(n, 4);\n            } else {\n                return nfors;\n            }\n            count_comp_iter: while (true) {\n                REQ(n, SYM.comp_iter);\n                n = CHILD(n, 0);\n                if (n.type === SYM.comp_for) {\n                    continue count_comp_for;\n                } else if (n.type === SYM.comp_if) {\n                    if (NCH(n) === 3) {\n                        n = CHILD(n, 2);\n                        continue count_comp_iter;\n                    } else {\n                        return nfors;\n                    }\n                }\n                break;\n            }\n            break;\n        }\n        Sk.asserts.fail(\"logic error in countCompFors\");\n    }\n\n    function countCompIfs(c, n) {\n        var nifs = 0;\n        while (true) {\n            REQ(n, SYM.comp_iter);\n            if (CHILD(n, 0).type === SYM.comp_for) {\n                return nifs;\n            }\n            n = CHILD(n, 0);\n            REQ(n, SYM.comp_if);\n            nifs++;\n            if (NCH(n) === 2) {\n                return nifs;\n            }\n            n = CHILD(n, 2);\n        }\n    }\n\n    nfors = countCompFors(c, n);\n    comps = [];\n    for (i = 0; i < nfors; ++i) {\n        REQ(n, SYM.comp_for);\n        forch = CHILD(n, 1);\n        t = ast_for_exprlist(c, forch, Sk.astnodes.Store);\n        expression = ast_for_expr(c, CHILD(n, 3));\n        if (NCH(forch) === 1) {\n            comp = new Sk.astnodes.comprehension(t[0], expression, []);\n        } else {\n            comp = new Sk.astnodes.comprehension(new Sk.astnodes.Tuple(t, Sk.astnodes.Store, n.lineno, n.col_offset), expression, []);\n        }\n        if (NCH(n) === 5) {\n            n = CHILD(n, 4);\n            nifs = countCompIfs(c, n);\n            ifs = [];\n            for (j = 0; j < nifs; ++j) {\n                REQ(n, SYM.comp_iter);\n                n = CHILD(n, 0);\n                REQ(n, SYM.comp_if);\n                expression = ast_for_expr(c, CHILD(n, 1));\n                ifs[j] = expression;\n                if (NCH(n) === 3) {\n                    n = CHILD(n, 2);\n                }\n            }\n            if (n.type === SYM.comp_iter) {\n                n = CHILD(n, 0);\n            }\n            comp.ifs = ifs;\n        }\n        comps[i] = comp;\n    }\n    return comps;\n}\n\nfunction astForIterComp(c, n, type) {\n    var elt, comps;\n    Sk.asserts.assert(NCH(n) > 1);\n    elt = ast_for_expr(c, CHILD(n, 0));\n    comps = astForComprehension(c, CHILD(n, 1));\n    if (type === COMP_GENEXP) {\n        return new Sk.astnodes.GeneratorExp(elt, comps, n.lineno, n.col_offset);\n    } else if (type === COMP_SETCOMP) {\n        return new Sk.astnodes.SetComp(elt, comps, n.lineno, n.col_offset);\n    }\n}\n\n/*\n   Count the number of 'for' loops in a comprehension.\n   Helper for ast_for_comprehension().\n*/\nfunction count_comp_fors(c, n) {\n    var n_fors = 0;\n    var is_async;\n    count_comp_for: while (true) {\n        // @meredydd needs new grammar\n        // REQ(n, SYM.comp_for);\n        // if (NCH(n) === 2) {\n        //     REQ(CHILD(n, 0), TOK.T_ASYNC);\n        //     n = CHILD(n, 1);\n        // } else if (NCH(n) === 1) {\n        //     n = CHILD(n, 0);\n        // } else {\n        //     Sk.asserts.fail(\"logic error in count_comp_fors\");\n        // }\n        // if (NCH(n) == (5)) {\n        //     n = CHILD(n, 4);\n        // } else {\n        //     return n_fors;\n        // }\n        is_async = 0;\n        n_fors++;\n        REQ(n, SYM.comp_for);\n        if (TYPE(CHILD(n, 0)) == TOK.T_ASYNC) {\n            is_async = 1;\n        }\n        if (NCH(n) == (5 + is_async)) {\n            n = CHILD(n, 4 + is_async);\n        }\n        else {\n            return n_fors;\n        }\n        count_comp_iter: while (true) {\n            REQ(n, SYM.comp_iter);\n            n = CHILD(n, 0);\n            if (TYPE(n) === SYM.comp_for) {\n                continue count_comp_for;\n            } else if (TYPE(n) === SYM.comp_if) {\n                if (NCH(n) === 3) {\n                    n = CHILD(n, 2);\n                    continue count_comp_iter;\n                } else {\n                    return n_fors;\n                }\n            }\n            break;\n        }\n        break;\n    }\n}\n\nfunction count_comp_ifs(c, n)\n{\n    var n_ifs = 0;\n\n    while (true) {\n        REQ(n, SYM.comp_iter);\n        if (TYPE(CHILD(n, 0)) == SYM.comp_for)\n            return n_ifs;\n        n = CHILD(n, 0);\n        REQ(n, SYM.comp_if);\n        n_ifs++;\n        if (NCH(n) == 2) {\n            return n_ifs;\n        }\n        n = CHILD(n, 2);\n    }\n}\n\nfunction ast_for_comprehension(c, n) {\n    var i, n_fors;\n    var comps = [];\n    n_fors = count_comp_fors(c, n);\n\n    for (i = 0; i < n_fors; i++) {\n        var comp;\n        var t;\n        var expression, first;\n        var for_ch;\n        var is_async = 0;\n\n        if (TYPE(CHILD(n, 0)) == TOK.T_ASYNC) {\n            is_async = 1;\n        }\n\n        for_ch = CHILD(n, 1 + is_async);\n        t = ast_for_exprlist(c, for_ch, Sk.astnodes. Store);\n        if (!t) {\n            return null;\n        }\n\n        expression = ast_for_expr(c, CHILD(n, 3 + is_async));\n\n        if (!expression) {\n            return null;\n        }\n\n        // again new grammar needed\n        // REQ(n, SYM.comp_for);\n\n        // if (NCH(n) == 2) {\n        //     is_async = 1;\n        //     REQ(CHILD(n, 0), TOK.T_ASYNC);\n        //     sync_n = CHILD(n, 1);\n        // }\n        // else {\n        //     sync_n = CHILD(n, 0);\n        // }\n        // REQ(sync_n, SYM.sync_comp_for);\n\n        // /* Async comprehensions only allowed in Python 3.6 and greater */\n        // /* @meredydd see below for the joys of the future! */\n        // if (is_async && c.c_feature_version < 6) {\n        //     ast_error(c, n,\n        //               \"Async comprehensions are only supported in Python 3.6 and greater\");\n        //     return null;\n        // }\n\n        // for_ch = CHILD(sync_n, 1);\n        // t = ast_for_exprlist(c, for_ch, Sk.astnodes.Store);\n\n        // expression = ast_for_expr(c, CHILD(sync_n, 3));\n\n        /* Check the # of children rather than the length of t, since\n           (x for x, in ...) has 1 element in t, but still requires a Tuple. */\n        first = t[0];\n        if (NCH(for_ch) == 1)\n            comp = new Sk.astnodes.comprehension(first, expression, null, is_async);\n        else\n            comp = new Sk.astnodes.comprehension(new Sk.astnodes.Tuple(t, Sk.astnodes.Store, first.lineno, first.col_offset,\n                                       for_ch.end_lineno, for_ch.end_col_offset),\n                                 expression, null, is_async);\n\n        if (NCH(n) == (5 + is_async)) {\n            var j, n_ifs;\n            var ifs = [];\n\n            n = CHILD(n, 4 + is_async);\n            n_ifs = count_comp_ifs(c, n);\n            if (n_ifs == -1) {\n                return null;\n            }\n\n            for (j = 0; j < n_ifs; j++) {\n                REQ(n, SYM.comp_iter);\n                n = CHILD(n, 0);\n                REQ(n, SYM.comp_if);\n\n                expression = ast_for_expr(c, CHILD(n, 1));\n                if (!expression) {\n                    return null;\n                }\n\n                ifs[j] = expression;\n                if (NCH(n) == 3) {\n                    n = CHILD(n, 2);\n                }\n            }\n            /* on exit, must guarantee that n is a comp_for */\n            if (TYPE(n) == SYM.comp_iter) {\n                n = CHILD(n, 0);\n            }\n            comp.ifs = ifs;\n        }\n        // if (NCH(sync_n) == 5) {\n        //     var j, n_ifs;\n        //     var ifs = [];\n\n        //     n = CHILD(sync_n, 4);\n        //     n_ifs = count_comp_ifs(c, n);\n\n        //     for (j = 0; j < n_ifs; j++) {\n        //         REQ(n, comp_iter);\n        //         n = CHILD(n, 0);\n        //         REQ(n, comp_if);\n\n        //         expression = ast_for_expr(c, CHILD(n, 1));\n        //         if (!expression) {\n        //             return null;\n        //         }\n\n        //         ifs[j] = expression;\n        //         if (NCH(n) == 3) {\n        //             n = CHILD(n, 2);\n        //         }\n        //     }\n        //     /* on exit, must guarantee that n is a comp_for */\n        //     if (TYPE(n) == SYM.comp_iter) {\n        //         n = CHILD(n, 0);\n        //     }\n        //     comp.ifs = ifs;\n        // }\n        comps[i] = comp;\n    }\n    return comps;\n}\n\nfunction ast_for_itercomp(c, n, type) {\n    /* testlist_comp: (test|star_expr)\n     *                ( comp_for | (',' (test|star_expr))* [','] ) */\n    var elt;\n    var comps;\n    var ch;\n\n    Sk.asserts.assert(NCH(n) > 1);\n\n    ch = CHILD(n, 0);\n    elt = ast_for_expr(c, ch);\n\n    if (elt.constructor === Sk.astnodes.Starred) {\n        ast_error(c, ch, \"iterable unpacking cannot be used in comprehension\");\n        return NULL;\n    }\n\n    comps = ast_for_comprehension(c, CHILD(n, 1));\n\n    if (type == COMP_GENEXP) {\n        return new Sk.astnodes.GeneratorExp(elt, comps, LINENO(n), n.col_offset,\n                            n.end_lineno, n.end_col_offset);\n    } else if (type == COMP_LISTCOMP) {\n        return new Sk.astnodes.ListComp(elt, comps, LINENO(n), n.col_offset,\n                        n.end_lineno, n.end_col_offset);\n    } else if (type == COMP_SETCOMP) {\n        return new Sk.astnodes.SetComp(elt, comps, LINENO(n), n.col_offset,\n                       n.end_lineno, n.end_col_offset);\n    } else {\n        /* Should never happen */\n        return null;\n    }\n}\n\n/* Fills in the key, value pair corresponding to the dict element.  In case\n * of an unpacking, key is NULL.  *i is advanced by the number of ast\n * elements.  Iff successful, nonzero is returned.\n */\nfunction ast_for_dictelement(c, n, i)\n{\n    var expression;\n    if (TYPE(CHILD(n, i)) == TOK.T_DOUBLESTAR) {\n        Sk.asserts.assert(NCH(n) - i >= 2);\n\n        expression = ast_for_expr(c, CHILD(n, i + 1));\n\n        return { key: null, value: expression, i: i + 2 }\n    } else {\n        Sk.asserts.assert(NCH(n) - i >= 3);\n\n        expression = ast_for_expr(c, CHILD(n, i));\n        if (!expression)\n            return 0;\n        var key = expression;\n\n        REQ(CHILD(n, i + 1), TOK.T_COLON);\n\n        expression = ast_for_expr(c, CHILD(n, i + 2));\n        if (!expression) {\n            return false;\n        }\n\n        var value = expression;\n\n        return { key: key, value: value, i: i + 3 };\n    }\n}\n\nfunction ast_for_dictcomp(c, n) {\n    var key, value;\n    var comps = [];\n    Sk.asserts.assert(NCH(n) > 3);\n    REQ(CHILD(n, 1), TOK.T_COLON);\n    key = ast_for_expr(c, CHILD(n, 0));\n    value = ast_for_expr(c, CHILD(n, 2));\n    comps = astForComprehension(c, CHILD(n, 3));\n    return new Sk.astnodes.DictComp(key, value, comps, n.lineno, n.col_offset);\n}\n\nfunction ast_for_dictdisplay(c, n)\n{\n    var i;\n    var j;\n    var keys = [], values = [];\n\n    j = 0;\n    for (i = 0; i < NCH(n); i++) {\n        var res = ast_for_dictelement(c, n, i);\n        i = res.i\n        keys[j] = res.key;\n        values[j] = res.value;\n        j++;\n    }\n\n    return new Sk.astnodes.Dict(keys, values, LINENO(n), n.col_offset,\n                n.end_lineno, n.end_col_offset);\n}\n\nfunction ast_for_gen_expr(c, n) {\n    Sk.asserts.assert(n.type === SYM.testlist_comp || n.type === SYM.argument);\n    return astForIterComp(c, n, COMP_GENEXP);\n}\n\nfunction ast_for_setcomp(c, n) {\n    Sk.asserts.assert(n.type === SYM.dictorsetmaker);\n    return astForIterComp(c, n, COMP_SETCOMP);\n}\n\nfunction astForWhileStmt (c, n) {\n    /* while_stmt: 'while' test ':' suite ['else' ':' suite] */\n    REQ(n, SYM.while_stmt);\n    if (NCH(n) === 4) {\n        return new Sk.astnodes.While(ast_for_expr(c, CHILD(n, 1)), astForSuite(c, CHILD(n, 3)), [], n.lineno, n.col_offset);\n    }\n    else if (NCH(n) === 7) {\n        return new Sk.astnodes.While(ast_for_expr(c, CHILD(n, 1)), astForSuite(c, CHILD(n, 3)), astForSuite(c, CHILD(n, 6)), n.lineno, n.col_offset);\n    }\n    Sk.asserts.fail(\"wrong number of tokens for 'while' stmt\");\n}\n\nfunction astForAugassign (c, n) {\n    REQ(n, SYM.augassign);\n    n = CHILD(n, 0);\n    switch (n.value.charAt(0)) {\n        case \"+\":\n            return Sk.astnodes.Add;\n        case \"-\":\n            return Sk.astnodes.Sub;\n        case \"/\":\n            if (n.value.charAt(1) === \"/\") {\n                return Sk.astnodes.FloorDiv;\n            }\n            return Sk.astnodes.Div;\n        case \"%\":\n            return Sk.astnodes.Mod;\n        case \"<\":\n            return Sk.astnodes.LShift;\n        case \">\":\n            return Sk.astnodes.RShift;\n        case \"&\":\n            return Sk.astnodes.BitAnd;\n        case \"^\":\n            return Sk.astnodes.BitXor;\n        case \"|\":\n            return Sk.astnodes.BitOr;\n        case \"*\":\n            if (n.value.charAt(1) === \"*\") {\n                return Sk.astnodes.Pow;\n            }\n            return Sk.astnodes.Mult;\n        default:\n            Sk.asserts.fail(\"invalid augassign\");\n    }\n}\n\nfunction astForBinop (c, n) {\n    /* Must account for a sequence of expressions.\n     How should A op B op C by represented?\n     BinOp(BinOp(A, op, B), op, C).\n     */\n    var tmp;\n    var newoperator;\n    var nextOper;\n    var i;\n    var result = new Sk.astnodes.BinOp(\n        ast_for_expr(c, CHILD(n, 0)),\n        getOperator(CHILD(n, 1)),\n        ast_for_expr(c, CHILD(n, 2)),\n        n.lineno, n.col_offset);\n    var nops = (NCH(n) - 1) / 2;\n    for (i = 1; i < nops; ++i) {\n        nextOper = CHILD(n, i * 2 + 1);\n        newoperator = getOperator(nextOper);\n        tmp = ast_for_expr(c, CHILD(n, i * 2 + 2));\n        result = new Sk.astnodes.BinOp(result, newoperator, tmp, nextOper.lineno, nextOper.col_offset);\n    }\n    return result;\n}\n\nfunction ast_for_testlist (c, n) {\n    /* testlist_comp: test (',' comp_for | (',' test)* [',']) */\n    /* testlist: test (',' test)* [','] */\n    Sk.asserts.assert(NCH(n) > 0);\n    if (n.type === SYM.testlist_comp) {\n        if (NCH(n) > 1) {\n            Sk.asserts.assert(CHILD(n, 1).type !== SYM.comp_for);\n        }\n    }\n    else {\n        Sk.asserts.assert(n.type === SYM.testlist || n.type === SYM.testlist_star_expr);\n    }\n\n    if (NCH(n) === 1) {\n        return ast_for_expr(c, CHILD(n, 0));\n    }\n    else {\n        return new Sk.astnodes.Tuple(seq_for_testlist(c, n), Sk.astnodes.Load, n.lineno, n.col_offset/*, c.c_arena */);\n    }\n}\n\nfunction ast_for_exprStmt (c, n) {\n    var expression;\n    var value;\n    var e;\n    var i;\n    var targets;\n    var expr2;\n    var varName;\n    var expr1;\n    var ch;\n    REQ(n, SYM.expr_stmt);\n    /* expr_stmt: testlist_star_expr (annassign | augassign (yield_expr|testlist) |\n                            ('=' (yield_expr|testlist_star_expr))*)\n       annassign: ':' test ['=' test]\n       testlist_star_expr: (test|star_expr) (',' test|star_expr)* [',']\n       augassign: '+=' | '-=' | '*=' | '@=' | '/=' | '%=' | '&=' | '|=' | '^='\n                | '<<=' | '>>=' | '**=' | '//='\n       test: ... here starts the operator precedence dance\n     */\n    if (NCH(n) === 1) {\n        return new Sk.astnodes.Expr(ast_for_testlist(c, CHILD(n, 0)), n.lineno, n.col_offset);\n    }\n    else if (CHILD(n, 1).type === SYM.augassign) {\n        ch = CHILD(n, 0);\n        expr1 = ast_for_testlist(c, ch);\n        setContext(c, expr1, Sk.astnodes.Store, ch);\n        switch (expr1.constructor) {\n            case Sk.astnodes.Name:\n                varName = expr1.id;\n                forbiddenCheck(c, ch, varName, n.lineno);\n                break;\n            case Sk.astnodes.Attribute:\n            case Sk.astnodes.Subscript:\n                break;\n            case Sk.astnodes.GeneratorExp:\n                throw new Sk.builtin.SyntaxError(\"augmented assignment to generator expression not possible\", c.c_filename, n.lineno);\n            case Sk.astnodes.Yield:\n                throw new Sk.builtin.SyntaxError(\"augmented assignment to yield expression not possible\", c.c_filename, n.lineno);\n            default:\n                throw new Sk.builtin.SyntaxError(\"illegal expression for augmented assignment\", c.c_filename, n.lineno);\n        }\n\n        ch = CHILD(n, 2);\n        if (ch.type === SYM.testlist) {\n            expr2 = ast_for_testlist(c, ch);\n        }\n        else {\n            expr2 = ast_for_expr(c, ch);\n        }\n\n        return new Sk.astnodes.AugAssign(expr1, astForAugassign(c, CHILD(n, 1)), expr2, n.lineno, n.col_offset);\n    }\n    else if (CHILD(n, 1).type === SYM.annassign) {\n        // TODO translate the relevant section from ast.c\n        throw new Sk.builtin.SyntaxError(\"Skulpt does not yet support type assignments\", c.c_filename, n.lineno);\n    }\n    else {\n        // normal assignment\n        REQ(CHILD(n, 1), TOK.T_EQUAL);\n        targets = [];\n        for (i = 0; i < NCH(n) - 2; i += 2) {\n            ch = CHILD(n, i);\n            if (ch.type === SYM.yield_expr) {\n                throw new Sk.builtin.SyntaxError(\"assignment to yield expression not possible\", c.c_filename, n.lineno);\n            }\n            e = ast_for_testlist(c, ch);\n            setContext(c, e, Sk.astnodes.Store, CHILD(n, i));\n            targets[i / 2] = e;\n        }\n        value = CHILD(n, NCH(n) - 1);\n        if (value.type === SYM.testlist_star_expr) {\n            expression = ast_for_testlist(c, value);\n        }\n        else {\n            expression = ast_for_expr(c, value);\n        }\n        return new Sk.astnodes.Assign(targets, expression, n.lineno, n.col_offset);\n    }\n}\n\nfunction astForIfexpr (c, n) {\n    /* test: or_test 'if' or_test 'else' test */\n    Sk.asserts.assert(NCH(n) === 5);\n    return new Sk.astnodes.IfExp(\n        ast_for_expr(c, CHILD(n, 2)),\n        ast_for_expr(c, CHILD(n, 0)),\n        ast_for_expr(c, CHILD(n, 4)),\n        n.lineno, n.col_offset);\n}\n\n/**\n * s is a python-style string literal, including quote characters and u/r/b\n * prefixes. Returns decoded string object.\n */\nfunction parsestr (c, s) {\n    var encodeUtf8 = function (s) {\n        return unescape(encodeURIComponent(s));\n    };\n    var decodeUtf8 = function (s) {\n        return decodeURIComponent(escape(s));\n    };\n    var decodeEscape = function (s, quote) {\n        var d3;\n        var d2;\n        var d1;\n        var d0;\n        var c;\n        var i;\n        var len = s.length;\n        var ret = \"\";\n        for (i = 0; i < len; ++i) {\n            c = s.charAt(i);\n            if (c === \"\\\\\") {\n                ++i;\n                c = s.charAt(i);\n                if (c === \"n\") {\n                    ret += \"\\n\";\n                }\n                else if (c === \"\\\\\") {\n                    ret += \"\\\\\";\n                }\n                else if (c === \"t\") {\n                    ret += \"\\t\";\n                }\n                else if (c === \"r\") {\n                    ret += \"\\r\";\n                }\n                else if (c === \"b\") {\n                    ret += \"\\b\";\n                }\n                else if (c === \"f\") {\n                    ret += \"\\f\";\n                }\n                else if (c === \"v\") {\n                    ret += \"\\v\";\n                }\n                else if (c === \"0\") {\n                    ret += \"\\0\";\n                }\n                else if (c === '\"') {\n                    ret += '\"';\n                }\n                else if (c === '\\'') {\n                    ret += '\\'';\n                }\n                else if (c === \"\\n\") /* escaped newline, join lines */ {\n                }\n                else if (c === \"x\") {\n                    d0 = s.charAt(++i);\n                    d1 = s.charAt(++i);\n                    ret += String.fromCharCode(parseInt(d0 + d1, 16));\n                }\n                else if (c === \"u\" || c === \"U\") {\n                    d0 = s.charAt(++i);\n                    d1 = s.charAt(++i);\n                    d2 = s.charAt(++i);\n                    d3 = s.charAt(++i);\n                    ret += String.fromCharCode(parseInt(d0 + d1, 16), parseInt(d2 + d3, 16));\n                }\n                else {\n                    // Leave it alone\n                    ret += \"\\\\\" + c;\n                    // Sk.asserts.fail(\"unhandled escape: '\" + c.charCodeAt(0) + \"'\");\n                }\n            }\n            else {\n                ret += c;\n            }\n        }\n        return ret;\n    };\n\n    //print(\"parsestr\", s);\n\n    var quote = s.charAt(0);\n    var rawmode = false;\n    var unicode = false;\n\n    // treats every sequence as unicodes even if they are not treated with uU prefix\n    // kinda hacking though working for most purposes\n    if((c.c_flags & Sk.Parser.CO_FUTURE_UNICODE_LITERALS || Sk.__future__.unicode_literals === true)) {\n        unicode = true;\n    }\n\n    if (quote === \"u\" || quote === \"U\") {\n        s = s.substr(1);\n        quote = s.charAt(0);\n        unicode = true;\n    }\n    else if (quote === \"r\" || quote === \"R\") {\n        s = s.substr(1);\n        quote = s.charAt(0);\n        rawmode = true;\n    }\n    Sk.asserts.assert(quote !== \"b\" && quote !== \"B\", \"todo; haven't done b'' strings yet\");\n\n    Sk.asserts.assert(quote === \"'\" || quote === '\"' && s.charAt(s.length - 1) === quote);\n    s = s.substr(1, s.length - 2);\n    if (unicode) {\n        s = encodeUtf8(s);\n    }\n\n    if (s.length >= 4 && s.charAt(0) === quote && s.charAt(1) === quote) {\n        Sk.asserts.assert(s.charAt(s.length - 1) === quote && s.charAt(s.length - 2) === quote);\n        s = s.substr(2, s.length - 4);\n    }\n\n    if (rawmode || s.indexOf(\"\\\\\") === -1) {\n        return strobj(decodeUtf8(s));\n    }\n    return strobj(decodeEscape(s, quote));\n}\n\nfunction parsestrplus (c, n) {\n    var i;\n    var ret;\n    REQ(CHILD(n, 0), TOK.T_STRING);\n    ret = new Sk.builtin.str(\"\");\n    for (i = 0; i < NCH(n); ++i) {\n        try {\n            ret = ret.sq$concat(parsestr(c, CHILD(n, i).value));\n        } catch (x) {\n            throw new Sk.builtin.SyntaxError(\"invalid string (possibly contains a unicode character)\", c.c_filename, CHILD(n, i).lineno);\n        }\n    }\n    return ret;\n}\n\nfunction parsenumber (c, s, lineno) {\n    var neg;\n    var val;\n    var tmp;\n    var end = s.charAt(s.length - 1);\n\n    // call internal complex type constructor for complex strings\n    if (end === \"j\" || end === \"J\") {\n        return Sk.builtin.complex.complex_subtype_from_string(s);\n    }\n\n    // Handle longs\n    if (end === \"l\" || end === \"L\") {\n        return Sk.longFromStr(s.substr(0, s.length - 1), 0);\n    }\n\n    // todo; we don't currently distinguish between int and float so\n    // str is wrong for these.\n    if (s.indexOf(\".\") !== -1) {\n        return new Sk.builtin.float_(parseFloat(s));\n    }\n\n    // Handle integers of various bases\n    tmp = s;\n    neg = false;\n    if (s.charAt(0) === \"-\") {\n        tmp = s.substr(1);\n        neg = true;\n    }\n\n    if (tmp.charAt(0) === \"0\" && (tmp.charAt(1) === \"x\" || tmp.charAt(1) === \"X\")) {\n        // Hex\n        tmp = tmp.substring(2);\n        val = parseInt(tmp, 16);\n    } else if ((s.indexOf(\"e\") !== -1) || (s.indexOf(\"E\") !== -1)) {\n        // Float with exponent (needed to make sure e/E wasn't hex first)\n        return new Sk.builtin.float_(parseFloat(s));\n    } else if (tmp.charAt(0) === \"0\" && (tmp.charAt(1) === \"b\" || tmp.charAt(1) === \"B\")) {\n        // Binary\n        tmp = tmp.substring(2);\n        val = parseInt(tmp, 2);\n    } else if (tmp.charAt(0) === \"0\") {\n        if (tmp === \"0\") {\n            // Zero\n            val = 0;\n        } else {\n            // Octal\n            tmp = tmp.substring(1);\n            if ((tmp.charAt(0) === \"o\") || (tmp.charAt(0) === \"O\")) {\n                tmp = tmp.substring(1);\n            }\n            val = parseInt(tmp, 8);\n        }\n    }\n    else {\n        // Decimal\n        val = parseInt(tmp, 10);\n    }\n\n    // Convert to long\n    if (val > Sk.builtin.int_.threshold$ &&\n        Math.floor(val) === val &&\n        (s.indexOf(\"e\") === -1 && s.indexOf(\"E\") === -1)) {\n        return Sk.longFromStr(s, 0);\n    }\n\n    // Small enough, return parsed number\n    if (neg) {\n        return new Sk.builtin.int_(-val);\n    } else {\n        return new Sk.builtin.int_(val);\n    }\n}\n\nfunction astForSlice (c, n) {\n    var n2;\n    var step;\n    var upper;\n    var lower;\n    var ch;\n    REQ(n, SYM.subscript);\n\n    /*\n     subscript: '.' '.' '.' | test | [test] ':' [test] [sliceop]\n     sliceop: ':' [test]\n     */\n    ch = CHILD(n, 0);\n    lower = null;\n    upper = null;\n    step = null;\n    if (ch.type === TOK.T_DOT) {\n        return new Sk.astnodes.Ellipsis();\n    }\n    if (NCH(n) === 1 && ch.type === SYM.test) {\n        return new Sk.astnodes.Index(ast_for_expr(c, ch));\n    }\n    if (ch.type === SYM.test) {\n        lower = ast_for_expr(c, ch);\n    }\n    if (ch.type === TOK.T_COLON) {\n        if (NCH(n) > 1) {\n            n2 = CHILD(n, 1);\n            if (n2.type === SYM.test) {\n                upper = ast_for_expr(c, n2);\n            }\n        }\n    }\n    else if (NCH(n) > 2) {\n        n2 = CHILD(n, 2);\n        if (n2.type === SYM.test) {\n            upper = ast_for_expr(c, n2);\n        }\n    }\n\n    ch = CHILD(n, NCH(n) - 1);\n    if (ch.type === SYM.sliceop) {\n        if (NCH(ch) === 1) {\n            ch = CHILD(ch, 0);\n            step = new Sk.astnodes.NameConstant(Sk.builtin.none.none$, Sk.astnodes.Load, ch.lineno, ch.col_offset);\n        }\n        else {\n            ch = CHILD(ch, 1);\n            if (ch.type === SYM.test) {\n                step = ast_for_expr(c, ch);\n            }\n        }\n    }\n    return new Sk.astnodes.Slice(lower, upper, step);\n}\n\nfunction ast_for_atom(c, n)\n{\n    /* atom: '(' [yield_expr|testlist_comp] ')' | '[' [testlist_comp] ']'\n       | '{' [dictmaker|testlist_comp] '}' | NAME | NUMBER | STRING+\n       | '...' | 'None' | 'True' | 'False'\n    */\n    var ch = CHILD(n, 0);\n\n    switch (TYPE(ch)) {\n        case TOK.T_NAME: {\n            var name;\n            var s = STR(ch);\n            if (s.length >= 4 && s.length <= 5) {\n                if (s === \"None\") {\n                    return new Sk.astnodes.NameConstant(Sk.builtin.none.none$, n.lineno, n.col_offset);\n                }\n\n                if (s === \"True\") {\n                    return new Sk.astnodes.NameConstant(Sk.builtin.bool.true$, n.lineno, n.col_offset);\n                }\n\n                if (s === \"False\") {\n                    return new Sk.astnodes.NameConstant(Sk.builtin.bool.false$, n.lineno, n.col_offset);\n                }\n            }\n            name = new_identifier(s, c);\n            /* All names start in Load context, but may later be changed. */\n            return new Sk.astnodes.Name(name, Sk.astnodes.Load, LINENO(n), n.col_offset,\n                        n.end_lineno, n.end_col_offset);\n        }\n        case TOK.T_STRING: {\n            var str = parsestrplus(c, n);\n            // if (!str) {\n            //     const char *errtype = NULL;\n            //     if (PyErr_ExceptionMatches(PyExc_UnicodeError))\n            //         errtype = \"unicode error\";\n            //     else if (PyErr_ExceptionMatches(PyExc_ValueError))\n            //         errtype = \"value error\";\n            //     if (errtype) {\n            //         PyObject *type, *value, *tback, *errstr;\n            //         PyErr_Fetch(&type, &value, &tback);\n            //         errstr = PyObject_Str(value);\n            //         if (errstr) {\n            //             ast_error(c, n, \"(%s) %U\", errtype, errstr);\n            //             Py_DECREF(errstr);\n            //         }\n            //         else {\n            //             PyErr_Clear();\n            //             ast_error(c, n, \"(%s) unknown error\", errtype);\n            //         }\n            //         Py_DECREF(type);\n            //         Py_XDECREF(value);\n            //         Py_XDECREF(tback);\n            //     }\n            //     return NULL;\n            // }\n            return new Sk.astnodes.Str(str, LINENO(n), n.col_offset, c.end_lineno, n.end_col_offset);\n        }\n        case TOK.T_NUMBER:\n            return new Sk.astnodes.Num(parsenumber(c, ch.value, n.lineno), n.lineno, n.col_offset);\n        case TOK.T_ELLIPSIS: /* Ellipsis */\n            return new Sk.astnodes.Ellipsis(LINENO(n), n.col_offset,\n                            n.end_lineno, n.end_col_offset);\n        case TOK.T_LPAR: /* some parenthesized expressions */\n            ch = CHILD(n, 1);\n\n            if (TYPE(ch) == TOK.T_RPAR)\n                return new Sk.astnodes.Tuple([], Sk.astnodes.Load, LINENO(n), n.col_offset,\n                            n.end_lineno, n.end_col_offset);\n\n            if (TYPE(ch) == SYM.yield_expr) {\n                return ast_for_expr(c, ch);\n            }\n\n            /* testlist_comp: test ( comp_for | (',' test)* [','] ) */\n            if (NCH(ch) == 1) {\n                return ast_for_testlist(c, ch);\n            }\n\n            if (TYPE(CHILD(ch, 1)) == SYM.comp_for) {\n                return copy_location(ast_for_genexp(c, ch), n);\n            }\n            else {\n                return copy_location(ast_for_testlist(c, ch), n);\n            }\n        case TOK.T_LSQB: /* list (or list comprehension) */\n            ch = CHILD(n, 1);\n\n            if (TYPE(ch) == TOK.T_RSQB)\n                return new Sk.astnodes.List([], Sk.astnodes.Load, LINENO(n), n.col_offset,\n                            n.end_lineno, n.end_col_offset);\n\n            REQ(ch, SYM.testlist_comp);\n            if (NCH(ch) == 1 || TYPE(CHILD(ch, 1)) == TOK.T_COMMA) {\n                var elts = seq_for_testlist(c, ch);\n                if (!elts) {\n                    return null;\n                }\n                return new Sk.astnodes.List(elts, Sk.astnodes.Load, LINENO(n), n.col_offset,\n                            n.end_lineno, n.end_col_offset);\n            }\n            else {\n                return copy_location(ast_for_listcomp(c, ch), n);\n            }\n        case TOK.T_LBRACE: {\n            /* dictorsetmaker: ( ((test ':' test | '**' test)\n            *                    (comp_for | (',' (test ':' test | '**' test))* [','])) |\n            *                   ((test | '*' test)\n            *                    (comp_for | (',' (test | '*' test))* [','])) ) */\n            var res;\n            ch = CHILD(n, 1);\n            if (TYPE(ch) == TOK.T_RBRACE) {\n                /* It's an empty dict. */\n                return new Sk.astnodes.Dict(null, null, LINENO(n), n.col_offset,\n                    n.end_lineno, n.end_col_offset);\n            }\n            else {\n                var is_dict = (TYPE(CHILD(ch, 0)) == TOK.T_DOUBLESTAR);\n                if (NCH(ch) == 1 ||\n                        (NCH(ch) > 1 &&\n                        TYPE(CHILD(ch, 1)) == TOK.T_COMMA)) {\n                    /* It's a set display. */\n                    res = ast_for_setdisplay(c, ch);\n                }\n                else if (NCH(ch) > 1 &&\n                        TYPE(CHILD(ch, 1)) == SYM.comp_for) {\n                    /* It's a set comprehension. */\n                    res = ast_for_setcomp(c, ch);\n                }\n                else if (NCH(ch) > 3 - is_dict &&\n                        TYPE(CHILD(ch, 3 - is_dict)) == SYM.comp_for) {\n                    /* It's a dictionary comprehension. */\n                    if (is_dict) {\n                        ast_error(c, n,\n                                \"dict unpacking cannot be used in dict comprehension\");\n                        return null;\n                    }\n                    res = ast_for_dictcomp(c, ch);\n                }\n                else {\n                    /* It's a dictionary display. */\n                    res = ast_for_dictdisplay(c, ch);\n                }\n                return copy_location(res, n);\n            }\n        }\n        default:\n            Sk.assert.fail(\"unhandled atom \" + TYPE(ch));\n            return null;\n    }\n}\n\nfunction ast_for_setdisplay(c, n) {\n    var i;\n    var elts = [];\n\n    Sk.asserts.assert(TYPE(n) === SYM.dictorsetmaker);\n\n    for (i = 0; i < NCH(n); i += 2) {\n        var expression;\n        expression = ast_for_expr(c, CHILD(n, i));\n        elts[i / 2] = expression;\n    }\n\n    return new Sk.astnodes.Set(elts, LINENO(n), n.col_offset);\n}\n\n\nfunction astForAtom(c, n) {\n    /* atom: '(' [yield_expr|testlist_comp] ')' | '[' [testlist_comp] ']'\n       | '{' [dictmaker|testlist_comp] '}' | NAME | NUMBER | STRING+\n       | '...' | 'None' | 'True' | 'False'\n    */\n    var i;\n    var values;\n    var keys;\n    var size;\n    var ch = CHILD(n, 0);\n    var elts;\n    switch (ch.type) {\n        case TOK.T_NAME:\n            var s = ch.value;\n            // All names start in Load context, but may be changed later\n            if (s.length >= 4 && s.length <= 5) {\n                if (s === \"None\") {\n                    return new Sk.astnodes.NameConstant(Sk.builtin.none.none$, n.lineno, n.col_offset /* c.c_arena*/);\n                }\n\n                if (s === \"True\") {\n                    return new Sk.astnodes.NameConstant(Sk.builtin.bool.true$, n.lineno, n.col_offset /* c.c_arena*/);\n                }\n\n                if (s === \"False\") {\n                    return new Sk.astnodes.NameConstant(Sk.builtin.bool.false$, n.lineno, n.col_offset /* c.c_arena*/);\n                }\n\n            }\n            var name = new_identifier(s, c)\n\n            /* All names start in Load context, but may later be changed. */\n            return new Sk.astnodes.Name(name, Sk.astnodes.Load, n.lineno, n.col_offset);\n        case TOK.T_STRING:\n            return new Sk.astnodes.Str(parsestrplus(c, n), n.lineno, n.col_offset);\n        case TOK.T_NUMBER:\n            return new Sk.astnodes.Num(parsenumber(c, ch.value, n.lineno), n.lineno, n.col_offset);\n        case TOK.T_LPAR: // various uses for parens\n            ch = CHILD(n, 1);\n            if (ch.type === TOK.T_RPAR) {\n                return new Sk.astnodes.Tuple([], Sk.astnodes.Load, n.lineno, n.col_offset);\n            }\n            if (ch.type === SYM.yield_expr) {\n                return ast_for_expr(c, ch);\n            }\n            //            if (NCH(ch) > 1 && CHILD(ch, 1).type === SYM.comp_for) {\n            //                return astForComprehension(c, ch);\n            //            }\n            return ast_for_testlistComp(c, ch);\n        case TOK.T_LSQB: // list or listcomp\n            ch = CHILD(n, 1);\n            if (ch.type === TOK.T_RSQB) {\n                return new Sk.astnodes.List([], Sk.astnodes.Load, n.lineno, n.col_offset);\n            }\n            REQ(ch, SYM.listmaker);\n            if (NCH(ch) === 1 || CHILD(ch, 1).type === TOK.T_COMMA) {\n                return new Sk.astnodes.List(seq_for_testlist(c, ch), Sk.astnodes.Load, n.lineno, n.col_offset);\n            }\n            return ast_for_listcomp(c, ch);\n\n        case TOK.T_LBRACE:\n            /* dictorsetmaker:\n             *     (test ':' test (comp_for : (',' test ':' test)* [','])) |\n             *     (test (comp_for | (',' test)* [',']))\n             */\n            keys = [];\n            values = [];\n            ch = CHILD(n, 1);\n            if (n.type === TOK.T_RBRACE) {\n                //it's an empty dict\n                return new Sk.astnodes.Dict([], null, n.lineno, n.col_offset);\n            }\n            else if (NCH(ch) === 1 || (NCH(ch) !== 0 && CHILD(ch, 1).type === TOK.T_COMMA)) {\n                //it's a simple set\n                elts = [];\n                size = Math.floor((NCH(ch) + 1) / 2);\n                for (i = 0; i < NCH(ch); i += 2) {\n                    var expression = ast_for_expr(c, CHILD(ch, i));\n                    elts[i / 2] = expression;\n                }\n                return new Sk.astnodes.Set(elts, n.lineno, n.col_offset);\n            }\n            else if (NCH(ch) !== 0 && CHILD(ch, 1).type == SYM.comp_for) {\n                //it's a set comprehension\n                return ast_for_setcomp(c, ch);\n            }\n            else if (NCH(ch) > 3 && CHILD(ch, 3).type === SYM.comp_for) {\n                //it's a dict compr. I think.\n                return ast_for_dictcomp(c, ch);\n            }\n            else {\n                size = Math.floor((NCH(ch) + 1) / 4); // + 1 for no trailing comma case\n                for (i = 0; i < NCH(ch); i += 4) {\n                    keys[i / 4] = ast_for_expr(c, CHILD(ch, i));\n                    values[i / 4] = ast_for_expr(c, CHILD(ch, i + 2));\n                }\n                return new Sk.astnodes.Dict(keys, values, n.lineno, n.col_offset);\n            }\n        case TOK.T_BACKQUOTE:\n            //throw new Sk.builtin.SyntaxError(\"backquote not supported, use repr()\", c.c_filename, n.lineno);\n            return new Sk.astnodes.Repr(ast_for_testlist(c, CHILD(n, 1)), n.lineno, n.col_offset);\n        default:\n            Sk.asserts.fail(\"unhandled atom\", ch.type);\n\n    }\n}\n\nfunction astForAtomExpr(c, n) {\n    var i, nch, start = 0;\n    var e, tmp;\n\n    REQ(n, SYM.atom_expr);\n    nch = NCH(n);\n\n    if (CHILD(n, 0).type === TOK.T_AWAIT) {\n        start = 1;\n        Sk.asserts.assert(nch > 1);\n    }\n\n    e = ast_for_atom(c, CHILD(n, start));\n    if (!e) {\n        return null;\n    }\n\n    if (nch === 1) {\n        return e;\n    }\n\n    if (start && nch === 2) {\n        return new Sk.astnodes.Await(e, n.lineno, n.col_offset /*, c->c_arena*/);\n    }\n\n    for (i = start + 1; i < nch; i++) {\n        var ch = CHILD(n, i);\n        if (ch.type !== SYM.trailer) {\n            break;\n        }\n        tmp = ast_for_trailer(c, ch, e);\n        if (!tmp) {\n            return null;\n        }\n\n        tmp.lineno = e.lineno;\n        tmp.col_offset = e.col_offset;\n        e = tmp;\n    }\n\n    if (start) {\n        /* there was an AWAIT */\n        return new Sk.astnodes.Await(e, n.line, n.col_offset /*, c->c_arena*/);\n    }\n    else {\n        return e;\n    }\n}\n\nfunction astForPower (c, n) {\n    /* power: atom trailer* ('**' factor)*\n     */\n    var f;\n    var tmp;\n    var ch;\n    var i;\n    var e;\n    REQ(n, SYM.power);\n    e = astForAtomExpr(c, CHILD(n, 0));\n    if (NCH(n) === 1) {\n        return e;\n    }\n    if (CHILD(n, NCH(n) - 1).type === SYM.factor) {\n        f = ast_for_expr(c, CHILD(n, NCH(n) - 1));\n        e = new Sk.astnodes.BinOp(e, Sk.astnodes.Pow, f, n.lineno, n.col_offset);\n    }\n    return e;\n}\n\nfunction astForStarred(c, n) {\n    REQ(n, SYM.star_expr);\n\n    /* The Load context is changed later */\n    return new Sk.astnodes.Starred(ast_for_expr(c, CHILD(n ,1)), Sk.astnodes.Load, n.lineno, n.col_offset /*, c.c_arena */)\n}\n\nfunction ast_for_expr (c, n) {\n    /*\n     handle the full range of simple expressions\n     test: or_test ['if' or_test 'else' test] | lambdef\n     test_nocond: or_test | lambdef_nocond\n     or_test: and_test ('or' and_test)*\n     and_test: not_test ('and' not_test)*\n     not_test: 'not' not_test | comparison\n     comparison: expr (comp_op expr)*\n     expr: xor_expr ('|' xor_expr)*\n     xor_expr: and_expr ('^' and_expr)*\n     and_expr: shift_expr ('&' shift_expr)*\n     shift_expr: arith_expr (('<<'|'>>') arith_expr)*\n     arith_expr: term (('+'|'-') term)*\n     term: factor (('*'|'/'|'%'|'//') factor)*\n     factor: ('+'|'-'|'~') factor | power\n     power: atom_expr ['**' factor]\n     atom_expr: [AWAIT] atom trailer*\n     yield_expr: 'yield' [yield_arg]\n    */\n\n    var exp;\n    var cmps;\n    var ops;\n    var i;\n    var seq;\n    LOOP: while (true) {\n        switch (n.type) {\n            case SYM.test:\n            case SYM.test_nocond:\n                if (CHILD(n, 0).type === SYM.lambdef || CHILD(n, 0).type === SYM.lambdef_nocond) {\n                    return astForLambdef(c, CHILD(n, 0));\n                }\n                else if (NCH(n) > 1) {\n                    return astForIfexpr(c, n);\n                }\n                // fallthrough\n            case SYM.or_test:\n            case SYM.and_test:\n                if (NCH(n) === 1) {\n                    n = CHILD(n, 0);\n                    continue LOOP;\n                }\n                seq = [];\n                for (i = 0; i < NCH(n); i += 2) {\n                    seq[i / 2] = ast_for_expr(c, CHILD(n, i));\n                }\n                if (CHILD(n, 1).value === \"and\") {\n                    return new Sk.astnodes.BoolOp(Sk.astnodes.And, seq, n.lineno, n.col_offset /*, c.c_arena*/);\n                }\n                Sk.asserts.assert(CHILD(n, 1).value === \"or\");\n                return new Sk.astnodes.BoolOp(Sk.astnodes.Or, seq, n.lineno, n.col_offset);\n            case SYM.not_test:\n                if (NCH(n) === 1) {\n                    n = CHILD(n, 0);\n                    continue LOOP;\n                }\n                else {\n                    return new Sk.astnodes.UnaryOp(Sk.astnodes.Not, ast_for_expr(c, CHILD(n, 1)), n.lineno, n.col_offset);\n                }\n                break;\n            case SYM.comparison:\n                if (NCH(n) === 1) {\n                    n = CHILD(n, 0);\n                    continue LOOP;\n                }\n                else {\n                    ops = [];\n                    cmps = [];\n                    for (i = 1; i < NCH(n); i += 2) {\n                        ops[(i - 1) / 2] = astForCompOp(c, CHILD(n, i));\n                        cmps[(i - 1) / 2] = ast_for_expr(c, CHILD(n, i + 1));\n                    }\n                    return new Sk.astnodes.Compare(ast_for_expr(c, CHILD(n, 0)), ops, cmps, n.lineno, n.col_offset);\n                }\n                break;\n            case SYM.star_expr:\n                return astForStarred(c, n);\n            /* The next fize cases all handle BinOps  The main body of code\n               is the same in each case, but the switch turned inside out to\n               reuse the code for each type of operator\n             */\n            case SYM.expr:\n            case SYM.xor_expr:\n            case SYM.and_expr:\n            case SYM.shift_expr:\n            case SYM.arith_expr:\n            case SYM.term:\n                if (NCH(n) === 1) {\n                    n = CHILD(n, 0);\n                    continue LOOP;\n                }\n                return astForBinop(c, n);\n            case SYM.yield_expr:\n                var an;\n                var en\n                var is_from = false;\n                exp = null;\n                if (NCH(n) > 1) {\n                    an = CHILD(n, 1); /* yield_arg */\n                }\n\n                if (an) {\n                    en = CHILD(an, NCH(an) - 1);\n                    if (NCH(an) == 2) {\n                        is_from = true;\n                        exp = ast_for_expr(c, en);\n                    } else {\n                        exp = ast_for_testlist(c, en);\n                    }\n                }\n\n                if (is_from) {\n                    return new Sk.astnodes.YieldFrom(exp, n.lineno, n.col_offset);\n                }\n\n                return new Sk.astnodes.Yield(exp, n.lineno, n.col_offset);\n            case SYM.factor:\n                if (NCH(n) === 1) {\n                    n = CHILD(n, 0);\n                    continue LOOP;\n                }\n                return astForFactor(c, n);\n            case SYM.power:\n                return astForPower(c, n);\n            default:\n                Sk.asserts.fail(\"unhandled expr\", \"n.type: %d\", n.type);\n        }\n        break;\n    }\n}\n\nfunction astForNonLocalStmt(c, n) {\n    ast_error(c, n, \"Not implemented: nonlocal\");\n}\n\nfunction astForAsyncStmt(c, n) {\n    ast_error(c, n, \"Not implemented: async\");\n}\n\n// This is only used for Python 2 support.\nfunction astForPrintStmt (c, n) {\n\n    if (Sk.__future__.print_function) {\n        ast_error(c, n, \"Missing parentheses in call to 'print'\");\n    }\n\n    /* print_stmt: 'print' ( [ test (',' test)* [','] ]\n     | '>>' test [ (',' test)+ [','] ] )\n     */\n    var nl;\n    var i, j;\n    var seq;\n    var start = 1;\n    var dest = null;\n    REQ(n, SYM.print_stmt);\n    if (NCH(n) >= 2 && CHILD(n, 1).type === TOK.T_RIGHTSHIFT) {\n        dest = ast_for_expr(c, CHILD(n, 2));\n        start = 4;\n    }\n    seq = [];\n    for (i = start, j = 0; i < NCH(n); i += 2, ++j) {\n        seq[j] = ast_for_expr(c, CHILD(n, i));\n    }\n    nl = (CHILD(n, NCH(n) - 1)).type === TOK.T_COMMA ? false : true;\n    return new Sk.astnodes.Print(dest, seq, nl, n.lineno, n.col_offset);\n}\n\nfunction astForStmt (c, n) {\n    var ch;\n    if (n.type === SYM.stmt) {\n        Sk.asserts.assert(NCH(n) === 1);\n        n = CHILD(n, 0);\n    }\n    if (n.type === SYM.simple_stmt) {\n        Sk.asserts.assert(numStmts(n) === 1);\n        n = CHILD(n, 0);\n    }\n    if (n.type === SYM.small_stmt) {\n        n = CHILD(n, 0);\n        /* small_stmt: expr_stmt | del_stmt | pass_stmt | flow_stmt\n                   | import_stmt | global_stmt | nonlocal_stmt | assert_stmt\n                   | debugger_stmt (skulpt special)\n        */\n        switch (n.type) {\n            case SYM.expr_stmt:\n                return ast_for_exprStmt(c, n);\n            case SYM.del_stmt:\n                return astForDelStmt(c, n);\n            case SYM.pass_stmt:\n                return new Sk.astnodes.Pass(n.lineno, n.col_offset);\n            case SYM.flow_stmt:\n                return ast_for_flow_stmt(c, n);\n            case SYM.import_stmt:\n                return astForImportStmt(c, n);\n            case SYM.global_stmt:\n                return astForGlobalStmt(c, n);\n            case SYM.nonlocal_stmt:\n                return astForNonLocalStmt(c, n);\n            case SYM.assert_stmt:\n                return astForAssertStmt(c, n);\n            case SYM.print_stmt:\n                return astForPrintStmt(c, n);\n            case SYM.debugger_stmt:\n                return new Sk.astnodes.Debugger(n.lineno, n.col_offset);\n            default:\n                Sk.asserts.fail(\"unhandled small_stmt\");\n        }\n    }\n    else {\n        /* compound_stmt: if_stmt | while_stmt | for_stmt | try_stmt\n                        | funcdef | classdef | decorated | async_stmt\n        */\n        ch = CHILD(n, 0);\n        REQ(n, SYM.compound_stmt);\n        switch (ch.type) {\n            case SYM.if_stmt:\n                return astForIfStmt(c, ch);\n            case SYM.while_stmt:\n                return astForWhileStmt(c, ch);\n            case SYM.for_stmt:\n                return astForForStmt(c, ch);\n            case SYM.try_stmt:\n                return astForTryStmt(c, ch);\n            case SYM.with_stmt:\n                return ast_for_with_stmt(c, ch);\n            case SYM.funcdef:\n                return ast_for_funcdef(c, ch, []);\n            case SYM.classdef:\n                return astForClassdef(c, ch, []);\n            case SYM.decorated:\n                return ast_for_decorated(c, ch);\n            case SYM.async_stmt:\n                return astForAsyncStmt(c, ch);\n            default:\n                Sk.asserts.assert(\"unhandled compound_stmt\");\n        }\n    }\n};\n\nSk.astFromParse = function (n, filename, c_flags) {\n    var j;\n    var num;\n    var ch;\n    var i;\n    var c = new Compiling(\"utf-8\", filename, c_flags);\n    var stmts = [];\n    var k = 0;\n    switch (n.type) {\n        case SYM.file_input:\n            for (i = 0; i < NCH(n) - 1; ++i) {\n                ch = CHILD(n, i);\n                if (n.type === TOK.T_NEWLINE) {\n                    continue;\n                }\n                REQ(ch, SYM.stmt);\n                num = numStmts(ch);\n                if (num === 1) {\n                    stmts[k++] = astForStmt(c, ch);\n                }\n                else {\n                    ch = CHILD(ch, 0);\n                    REQ(ch, SYM.simple_stmt);\n                    for (j = 0; j < num; ++j) {\n                        stmts[k++] = astForStmt(c, CHILD(ch, j * 2));\n                    }\n                }\n            }\n            return new Sk.astnodes.Module(stmts);\n        case SYM.eval_input:\n            Sk.asserts.fail(\"todo;\");\n        case SYM.single_input:\n            Sk.asserts.fail(\"todo;\");\n        default:\n            Sk.asserts.fail(\"todo;\");\n    }\n};\n\nSk.astDump = function (node) {\n    var spaces = function (n) // todo; blurgh\n    {\n        var i;\n        var ret = \"\";\n        for (i = 0; i < n; ++i) {\n            ret += \" \";\n        }\n        return ret;\n    };\n\n    var _format = function (node, indent) {\n        var ret;\n        var elemsstr;\n        var x;\n        var elems;\n        var fieldstr;\n        var field;\n        var attrs;\n        var fieldlen;\n        var b;\n        var a;\n        var i;\n        var fields;\n        var namelen;\n        if (node === null) {\n            return indent + \"None\";\n        }\n        else if (node.prototype && node.prototype._astname !== undefined && node.prototype._isenum) {\n            return indent + node.prototype._astname + \"()\";\n        }\n        else if (node._astname !== undefined) {\n            namelen = spaces(node._astname.length + 1);\n            fields = [];\n            for (i = 0; i < node._fields.length; i += 2) // iter_fields\n            {\n                a = node._fields[i]; // field name\n                b = node._fields[i + 1](node); // field getter func\n                fieldlen = spaces(a.length + 1);\n                fields.push([a, _format(b, indent + namelen + fieldlen)]);\n            }\n            attrs = [];\n            for (i = 0; i < fields.length; ++i) {\n                field = fields[i];\n                attrs.push(field[0] + \"=\" + field[1].replace(/^\\s+/, \"\"));\n            }\n            fieldstr = attrs.join(\",\\n\" + indent + namelen);\n            return indent + node._astname + \"(\" + fieldstr + \")\";\n        }\n        else if (Sk.isArrayLike(node)) {\n            //Sk.debugout(\"arr\", node.length);\n            elems = [];\n            for (i = 0; i < node.length; ++i) {\n                x = node[i];\n                elems.push(_format(x, indent + \" \"));\n            }\n            elemsstr = elems.join(\",\\n\");\n            return indent + \"[\" + elemsstr.replace(/^\\s+/, \"\") + \"]\";\n        }\n        else {\n            if (node === true) {\n                ret = \"True\";\n            }\n            else if (node === false) {\n                ret = \"False\";\n            }\n            else if (node instanceof Sk.builtin.lng) {\n                ret = node.tp$str().v;\n            }\n            else if (node instanceof Sk.builtin.str) {\n                ret = node[\"$r\"]().v;\n            }\n            else {\n                ret = \"\" + node;\n            }\n            return indent + ret;\n        }\n    };\n\n    return _format(node, \"\");\n};\n\nSk.exportSymbol(\"Sk.astFromParse\", Sk.astFromParse);\nSk.exportSymbol(\"Sk.astDump\", Sk.astDump);\n\n\n/***/ }),\n/* 48 */\n/***/ (function(module, exports) {\n\n/* Flags for def-use information */\n\nvar DEF_GLOBAL = 1;\n/* global stmt */\nvar DEF_LOCAL = 2;\n/* assignment in code block */\nvar DEF_PARAM = 2 << 1;\n/* formal parameter */\nvar USE = 2 << 2;\n/* name is used */\nvar DEF_STAR = 2 << 3;\n/* parameter is star arg */\nvar DEF_DOUBLESTAR = 2 << 4;\n/* parameter is star-star arg */\nvar DEF_INTUPLE = 2 << 5;\n/* name defined in tuple in parameters */\nvar DEF_FREE = 2 << 6;\n/* name used but not defined in nested block */\nvar DEF_FREE_GLOBAL = 2 << 7;\n/* free variable is actually implicit global */\nvar DEF_FREE_CLASS = 2 << 8;\n/* free variable from class's method */\nvar DEF_IMPORT = 2 << 9;\n/* assignment occurred via import */\n\nvar DEF_BOUND = (DEF_LOCAL | DEF_PARAM | DEF_IMPORT);\n\n/* GLOBAL_EXPLICIT and GLOBAL_IMPLICIT are used internally by the symbol\n table.  GLOBAL is returned from PyST_GetScope() for either of them.\n It is stored in ste_symbols at bits 12-14.\n */\nvar SCOPE_OFF = 11;\nvar SCOPE_MASK = 7;\n\nvar LOCAL = 1;\nvar GLOBAL_EXPLICIT = 2;\nvar GLOBAL_IMPLICIT = 3;\nvar FREE = 4;\nvar CELL = 5;\n\n/* The following three names are used for the ste_unoptimized bit field */\nvar OPT_IMPORT_STAR = 1;\nvar OPT_EXEC = 2;\nvar OPT_BARE_EXEC = 4;\nvar OPT_TOPLEVEL = 8;\n/* top-level names, including eval and exec */\n\nvar GENERATOR = 2;\nvar GENERATOR_EXPRESSION = 2;\n\nvar ModuleBlock = \"module\";\nvar FunctionBlock = \"function\";\nvar ClassBlock = \"class\";\n\nvar SYMTAB_CONSTS = {\n    DEF_GLOBAL: DEF_GLOBAL,\n    DEF_LOCAL: DEF_LOCAL,\n    DEF_PARAM: DEF_PARAM,\n    USE: USE,\n    DEF_STAR: DEF_STAR,\n    DEF_DOUBLESTAR: DEF_DOUBLESTAR,\n    DEF_INTUPLE: DEF_INTUPLE,\n    DEF_FREE: DEF_FREE,\n    DEF_FREE_GLOBAL: DEF_FREE_GLOBAL,\n    DEF_FREE_CLASS: DEF_FREE_CLASS,\n    DEF_IMPORT: DEF_IMPORT,\n    DEF_BOUND: DEF_BOUND,\n    SCOPE_OFF: SCOPE_OFF,\n    SCOPE_MASK: SCOPE_MASK,\n    LOCAL: LOCAL,\n    GLOBAL_EXPLICIT: GLOBAL_EXPLICIT,\n    GLOBAL_IMPLICIT: GLOBAL_IMPLICIT,\n    FREE: FREE,\n    CELL: CELL,\n    OPT_IMPORT_STAR: OPT_IMPORT_STAR,\n    OPT_EXEC: OPT_EXEC,\n    OPT_BARE_EXEC: OPT_BARE_EXEC,\n    OPT_TOPLEVEL: OPT_TOPLEVEL,\n    GENERATOR: GENERATOR,\n    GENERATOR_EXPRESSION: GENERATOR_EXPRESSION,\n    ModuleBlock: ModuleBlock,\n    FunctionBlock: FunctionBlock,\n    ClassBlock: ClassBlock\n};\n\nSk.exportSymbol(\"Sk.SYMTAB_CONSTS\", SYMTAB_CONSTS);\n\n/**\n * @constructor\n * @param {string} name\n * @param {number} flags\n * @param {Array.<SymbolTableScope>} namespaces\n */\nfunction Symbol_ (name, flags, namespaces) {\n    this.__name = name;\n    this.__flags = flags;\n    this.__scope = (flags >> SCOPE_OFF) & SCOPE_MASK;\n    this.__namespaces = namespaces || [];\n}\nSymbol_.prototype.get_name = function () {\n    return this.__name;\n};\nSymbol_.prototype.is_referenced = function () {\n    return !!(this.__flags & USE);\n};\nSymbol_.prototype.is_parameter = function () {\n    return !!(this.__flags & DEF_PARAM);\n};\nSymbol_.prototype.is_global = function () {\n    return this.__scope === GLOBAL_IMPLICIT || this.__scope == GLOBAL_EXPLICIT;\n};\nSymbol_.prototype.is_declared_global = function () {\n    return this.__scope == GLOBAL_EXPLICIT;\n};\nSymbol_.prototype.is_local = function () {\n    return !!(this.__flags & DEF_BOUND);\n};\nSymbol_.prototype.is_free = function () {\n    return this.__scope == FREE;\n};\nSymbol_.prototype.is_imported = function () {\n    return !!(this.__flags & DEF_IMPORT);\n};\nSymbol_.prototype.is_assigned = function () {\n    return !!(this.__flags & DEF_LOCAL);\n};\nSymbol_.prototype.is_namespace = function () {\n    return this.__namespaces && this.__namespaces.length > 0;\n};\nSymbol_.prototype.get_namespaces = function () {\n    return this.__namespaces;\n};\n\nvar astScopeCounter = 0;\n\n/**\n * @constructor\n * @param {SymbolTable} table\n * @param {string} name\n * @param {string} type\n * @param {number} lineno\n */\nfunction SymbolTableScope (table, name, type, ast, lineno) {\n    this.symFlags = {};\n    this.name = name;\n    this.varnames = [];\n    this.children = [];\n    this.blockType = type;\n\n    this.isNested = false;\n    this.hasFree = false;\n    this.childHasFree = false;  // true if child block has free vars including free refs to globals\n    this.generator = false;\n    this.varargs = false;\n    this.varkeywords = false;\n    this.returnsValue = false;\n\n    this.lineno = lineno;\n\n    this.table = table;\n\n    if (table.cur && (table.cur.nested || table.cur.blockType === FunctionBlock)) {\n        this.isNested = true;\n    }\n\n    ast.scopeId = astScopeCounter++;\n    table.stss[ast.scopeId] = this;\n\n    // cache of Symbols for returning to other parts of code\n    this.symbols = {};\n}\nSymbolTableScope.prototype.get_type = function () {\n    return this.blockType;\n};\nSymbolTableScope.prototype.get_name = function () {\n    return this.name;\n};\nSymbolTableScope.prototype.get_lineno = function () {\n    return this.lineno;\n};\nSymbolTableScope.prototype.is_nested = function () {\n    return this.isNested;\n};\nSymbolTableScope.prototype.has_children = function () {\n    return this.children.length > 0;\n};\nSymbolTableScope.prototype.get_identifiers = function () {\n    return this._identsMatching(function () {\n        return true;\n    });\n};\nSymbolTableScope.prototype.lookup = function (name) {\n    var namespaces;\n    var flags;\n    var sym;\n    if (!this.symbols.hasOwnProperty(name)) {\n        flags = this.symFlags[name];\n        namespaces = this.__check_children(name);\n        sym = this.symbols[name] = new Symbol_(name, flags, namespaces);\n    }\n    else {\n        sym = this.symbols[name];\n    }\n    return sym;\n};\nSymbolTableScope.prototype.__check_children = function (name) {\n    //print(\"  check_children:\", name);\n    var child;\n    var i;\n    var ret = [];\n    for (i = 0; i < this.children.length; ++i) {\n        child = this.children[i];\n        if (child.name === name) {\n            ret.push(child);\n        }\n    }\n    return ret;\n};\n\nSymbolTableScope.prototype._identsMatching = function (f) {\n    var k;\n    var ret = [];\n    for (k in this.symFlags) {\n        if (this.symFlags.hasOwnProperty(k)) {\n            if (f(this.symFlags[k])) {\n                ret.push(k);\n            }\n        }\n    }\n    ret.sort();\n    return ret;\n};\nSymbolTableScope.prototype.get_parameters = function () {\n    Sk.asserts.assert(this.get_type() == \"function\", \"get_parameters only valid for function scopes\");\n    if (!this._funcParams) {\n        this._funcParams = this._identsMatching(function (x) {\n            return x & DEF_PARAM;\n        });\n    }\n    return this._funcParams;\n};\nSymbolTableScope.prototype.get_locals = function () {\n    Sk.asserts.assert(this.get_type() == \"function\", \"get_locals only valid for function scopes\");\n    if (!this._funcLocals) {\n        this._funcLocals = this._identsMatching(function (x) {\n            return x & DEF_BOUND;\n        });\n    }\n    return this._funcLocals;\n};\nSymbolTableScope.prototype.get_globals = function () {\n    Sk.asserts.assert(this.get_type() == \"function\", \"get_globals only valid for function scopes\");\n    if (!this._funcGlobals) {\n        this._funcGlobals = this._identsMatching(function (x) {\n            var masked = (x >> SCOPE_OFF) & SCOPE_MASK;\n            return masked == GLOBAL_IMPLICIT || masked == GLOBAL_EXPLICIT;\n        });\n    }\n    return this._funcGlobals;\n};\nSymbolTableScope.prototype.get_frees = function () {\n    Sk.asserts.assert(this.get_type() == \"function\", \"get_frees only valid for function scopes\");\n    if (!this._funcFrees) {\n        this._funcFrees = this._identsMatching(function (x) {\n            var masked = (x >> SCOPE_OFF) & SCOPE_MASK;\n            return masked == FREE;\n        });\n    }\n    return this._funcFrees;\n};\nSymbolTableScope.prototype.get_methods = function () {\n    var i;\n    var all;\n    Sk.asserts.assert(this.get_type() == \"class\", \"get_methods only valid for class scopes\");\n    if (!this._classMethods) {\n        // todo; uniq?\n        all = [];\n        for (i = 0; i < this.children.length; ++i) {\n            all.push(this.children[i].name);\n        }\n        all.sort();\n        this._classMethods = all;\n    }\n    return this._classMethods;\n};\nSymbolTableScope.prototype.getScope = function (name) {\n    //print(\"getScope\");\n    //for (var k in this.symFlags) print(k);\n    var v = this.symFlags[name];\n    if (v === undefined) {\n        return 0;\n    }\n    return (v >> SCOPE_OFF) & SCOPE_MASK;\n};\n\n/**\n * @constructor\n * @param {string} filename\n */\nfunction SymbolTable (filename) {\n    this.filename = filename;\n    this.cur = null;\n    this.top = null;\n    this.stack = [];\n    this.global = null; // points at top level module symFlags\n    this.curClass = null; // current class or null\n    this.tmpname = 0;\n\n    // mapping from ast nodes to their scope if they have one. we add an\n    // id to the ast node when a scope is created for it, and store it in\n    // here for the compiler to lookup later.\n    this.stss = {};\n}\nSymbolTable.prototype.getStsForAst = function (ast) {\n    var v;\n    Sk.asserts.assert(ast.scopeId !== undefined, \"ast wasn't added to st?\");\n    v = this.stss[ast.scopeId];\n    Sk.asserts.assert(v !== undefined, \"unknown sym tab entry\");\n    return v;\n};\n\nSymbolTable.prototype.SEQStmt = function (nodes) {\n    var val;\n    var i;\n    var len;\n    if (nodes !== null) {\n        Sk.asserts.assert(Sk.isArrayLike(nodes), \"SEQ: nodes isn't array? got \" + nodes.toString());\n        len = nodes.length;\n        for (i = 0; i < len; ++i) {\n            val = nodes[i];\n            if (val) {\n                this.visitStmt(val);\n            }\n        }\n    }\n};\n\nSymbolTable.prototype.SEQExpr = function (nodes) {\n    var val;\n    var i;\n    var len;\n    if (nodes !== null) {\n        Sk.asserts.assert(Sk.isArrayLike(nodes), \"SEQ: nodes isn't array? got \" + nodes.toString());\n        len = nodes.length;\n        for (i = 0; i < len; ++i) {\n            val = nodes[i];\n            if (val) {\n                this.visitExpr(val);\n            }\n        }\n    }\n};\n\nSymbolTable.prototype.enterBlock = function (name, blockType, ast, lineno) {\n    var prev;\n    name = Sk.fixReservedNames(name);\n    //print(\"enterBlock:\", name);\n    prev = null;\n    if (this.cur) {\n        prev = this.cur;\n        this.stack.push(this.cur);\n    }\n    this.cur = new SymbolTableScope(this, name, blockType, ast, lineno);\n    if (name === \"top\") {\n        this.global = this.cur.symFlags;\n    }\n    if (prev) {\n        //print(\"    adding\", this.cur.name, \"to\", prev.name);\n        prev.children.push(this.cur);\n    }\n};\n\nSymbolTable.prototype.exitBlock = function () {\n    //print(\"exitBlock\");\n    this.cur = null;\n    if (this.stack.length > 0) {\n        this.cur = this.stack.pop();\n    }\n};\n\nSymbolTable.prototype.visitParams = function (args, toplevel) {\n    var arg;\n    var i;\n    for (i = 0; i < args.length; ++i) {\n        arg = args[i];\n        if (arg.constructor === Sk.astnodes.arg) {\n            // TODO arguments are more complicated in Python 3...\n            this.addDef(arg.arg, DEF_PARAM, arg.lineno);\n        }\n        else {\n            // Tuple isn't supported\n            throw new Sk.builtin.SyntaxError(\"invalid expression in parameter list\", this.filename);\n        }\n    }\n};\n\nSymbolTable.prototype.visitArguments = function (a, lineno) {\n    if (a.args) {\n        this.visitParams(a.args, true);\n    }\n    if (a.kwonlyargs) {\n        this.visitParams(a.kwonlyargs, true);\n    }\n    if (a.vararg) {\n        this.addDef(a.vararg.arg, DEF_PARAM, lineno);\n        this.cur.varargs = true;\n    }\n    if (a.kwarg) {\n        this.addDef(a.kwarg.arg, DEF_PARAM, lineno);\n        this.cur.varkeywords = true;\n    }\n};\n\nSymbolTable.prototype.newTmpname = function (lineno) {\n    this.addDef(new Sk.builtin.str(\"_[\" + (++this.tmpname) + \"]\"), DEF_LOCAL, lineno);\n};\n\nSymbolTable.prototype.addDef = function (name, flag, lineno) {\n    var fromGlobal;\n    var val;\n    var mangled = Sk.mangleName(this.curClass, new Sk.builtin.str(name)).v;\n    mangled = Sk.fixReservedNames(mangled);\n    val = this.cur.symFlags[mangled];\n    if (val !== undefined) {\n        if ((flag & DEF_PARAM) && (val & DEF_PARAM)) {\n            throw new Sk.builtin.SyntaxError(\"duplicate argument '\" + name.v + \"' in function definition\", this.filename, lineno);\n        }\n        val |= flag;\n    }\n    else {\n        val = flag;\n    }\n    this.cur.symFlags[mangled] = val;\n    if (flag & DEF_PARAM) {\n        this.cur.varnames.push(mangled);\n    }\n    else if (flag & DEF_GLOBAL) {\n        val = flag;\n        fromGlobal = this.global[mangled];\n        if (fromGlobal !== undefined) {\n            val |= fromGlobal;\n        }\n        this.global[mangled] = val;\n    }\n};\n\nSymbolTable.prototype.visitSlice = function (s) {\n    var i;\n    switch (s.constructor) {\n        case Sk.astnodes.Slice:\n            if (s.lower) {\n                this.visitExpr(s.lower);\n            }\n            if (s.upper) {\n                this.visitExpr(s.upper);\n            }\n            if (s.step) {\n                this.visitExpr(s.step);\n            }\n            break;\n        case Sk.astnodes.ExtSlice:\n            for (i = 0; i < s.dims.length; ++i) {\n                this.visitSlice(s.dims[i]);\n            }\n            break;\n        case Sk.astnodes.Index:\n            this.visitExpr(s.value);\n            break;\n        case Sk.astnodes.Ellipsis:\n            break;\n    }\n};\n\nSymbolTable.prototype.visitStmt = function (s) {\n    var cur;\n    var name;\n    var i;\n    var nameslen;\n    var tmp;\n    Sk.asserts.assert(s !== undefined, \"visitStmt called with undefined\");\n    switch (s.constructor) {\n        case Sk.astnodes.FunctionDef:\n            this.addDef(s.name, DEF_LOCAL, s.lineno);\n            if (s.args.defaults) {\n                this.SEQExpr(s.args.defaults);\n            }\n            if (s.decorator_list) {\n                this.SEQExpr(s.decorator_list);\n            }\n            this.enterBlock(s.name.v, FunctionBlock, s, s.lineno);\n            this.visitArguments(s.args, s.lineno);\n            this.SEQStmt(s.body);\n            this.exitBlock();\n            break;\n        case Sk.astnodes.ClassDef:\n            this.addDef(s.name, DEF_LOCAL, s.lineno);\n            this.SEQExpr(s.bases);\n            if (s.decorator_list) {\n                this.SEQExpr(s.decorator_list);\n            }\n            this.enterBlock(s.name.v, ClassBlock, s, s.lineno);\n            tmp = this.curClass;\n            this.curClass = s.name;\n            this.SEQStmt(s.body);\n            this.exitBlock();\n            break;\n        case Sk.astnodes.Return:\n            if (s.value) {\n                this.visitExpr(s.value);\n                this.cur.returnsValue = true;\n                if (this.cur.generator) {\n                    throw new Sk.builtin.SyntaxError(\"'return' with argument inside generator\", this.filename);\n                }\n            }\n            break;\n        case Sk.astnodes.Delete:\n            this.SEQExpr(s.targets);\n            break;\n        case Sk.astnodes.Assign:\n            this.SEQExpr(s.targets);\n            this.visitExpr(s.value);\n            break;\n        case Sk.astnodes.AugAssign:\n            this.visitExpr(s.target);\n            this.visitExpr(s.value);\n            break;\n        case Sk.astnodes.Print:\n            if (s.dest) {\n                this.visitExpr(s.dest);\n            }\n            this.SEQExpr(s.values);\n            break;\n        case Sk.astnodes.For:\n            this.visitExpr(s.target);\n            this.visitExpr(s.iter);\n            this.SEQStmt(s.body);\n            if (s.orelse) {\n                this.SEQStmt(s.orelse);\n            }\n            break;\n        case Sk.astnodes.While:\n            this.visitExpr(s.test);\n            this.SEQStmt(s.body);\n            if (s.orelse) {\n                this.SEQStmt(s.orelse);\n            }\n            break;\n        case Sk.astnodes.If:\n            this.visitExpr(s.test);\n            this.SEQStmt(s.body);\n            if (s.orelse) {\n                this.SEQStmt(s.orelse);\n            }\n            break;\n        case Sk.astnodes.Raise:\n            if (s.exc) {\n                this.visitExpr(s.exc);\n                // Our hacked AST supports both Python 2 (inst, tback)\n                // and Python 3 (cause) versions of the Raise statement\n                if (s.inst) {\n                    this.visitExpr(s.inst);\n                    if (s.tback) {\n                        this.visitExpr(s.tback);\n                    }\n                }\n                if (s.cause) {\n                    this.visitExpr(s.cause);\n                }\n            }\n            break;\n        case Sk.astnodes.Assert:\n            this.visitExpr(s.test);\n            if (s.msg) {\n                this.visitExpr(s.msg);\n            }\n            break;\n        case Sk.astnodes.Import:\n        case Sk.astnodes.ImportFrom:\n            this.visitAlias(s.names, s.lineno);\n            break;\n        case Sk.astnodes.Global:\n            nameslen = s.names.length;\n            for (i = 0; i < nameslen; ++i) {\n                name = Sk.mangleName(this.curClass, s.names[i]).v;\n                name = Sk.fixReservedNames(name);\n                cur = this.cur.symFlags[name];\n                if (cur & (DEF_LOCAL | USE)) {\n                    if (cur & DEF_LOCAL) {\n                        throw new Sk.builtin.SyntaxError(\"name '\" + name + \"' is assigned to before global declaration\", this.filename, s.lineno);\n                    }\n                    else {\n                        throw new Sk.builtin.SyntaxError(\"name '\" + name + \"' is used prior to global declaration\", this.filename, s.lineno);\n                    }\n                }\n                this.addDef(new Sk.builtin.str(name), DEF_GLOBAL, s.lineno);\n            }\n            break;\n        case Sk.astnodes.Expr:\n            this.visitExpr(s.value);\n            break;\n        case Sk.astnodes.Pass:\n        case Sk.astnodes.Break:\n        case Sk.astnodes.Continue:\n        case Sk.astnodes.Debugger:\n            // nothing\n            break;\n        case Sk.astnodes.With:\n            VISIT_SEQ(this.visit_withitem.bind(this), s.items);\n            VISIT_SEQ(this.visitStmt.bind(this), s.body);\n            break;\n\n        case Sk.astnodes.Try:\n            this.SEQStmt(s.body);\n            this.visitExcepthandlers(s.handlers)\n            this.SEQStmt(s.orelse);\n            this.SEQStmt(s.finalbody);\n            break;\n\n        default:\n            Sk.asserts.fail(\"Unhandled type \" + s.constructor.name + \" in visitStmt\");\n    }\n};\n\nSymbolTable.prototype.visit_withitem = function(item) {\n    this.visitExpr(item.context_expr);\n    if (item.optional_vars) {\n        this.visitExpr(item.optional_vars);\n    }\n}\n\n\nfunction VISIT_SEQ(visitFunc, seq) {\n    var i;\n    for (i = 0; i < seq.length; i++) {\n        var elt = seq[i];\n        visitFunc(elt)\n    }\n}\n\nSymbolTable.prototype.visitExpr = function (e) {\n    var i;\n    Sk.asserts.assert(e !== undefined, \"visitExpr called with undefined\");\n    // console.log(\"  e: \", e.constructor.name);\n    switch (e.constructor) {\n        case Sk.astnodes.BoolOp:\n            this.SEQExpr(e.values);\n            break;\n        case Sk.astnodes.BinOp:\n            this.visitExpr(e.left);\n            this.visitExpr(e.right);\n            break;\n        case Sk.astnodes.UnaryOp:\n            this.visitExpr(e.operand);\n            break;\n        case Sk.astnodes.Lambda:\n            this.addDef(new Sk.builtin.str(\"lambda\"), DEF_LOCAL, e.lineno);\n            if (e.args.defaults) {\n                this.SEQExpr(e.args.defaults);\n            }\n            this.enterBlock(\"lambda\", FunctionBlock, e, e.lineno);\n            this.visitArguments(e.args, e.lineno);\n            this.visitExpr(e.body);\n            this.exitBlock();\n            break;\n        case Sk.astnodes.IfExp:\n            this.visitExpr(e.test);\n            this.visitExpr(e.body);\n            this.visitExpr(e.orelse);\n            break;\n        case Sk.astnodes.Dict:\n            this.SEQExpr(e.keys);\n            this.SEQExpr(e.values);\n            break;\n        case Sk.astnodes.DictComp:\n        case Sk.astnodes.SetComp:\n            this.visitComprehension(e.generators, 0);\n            break;\n        case Sk.astnodes.ListComp:\n            this.newTmpname(e.lineno);\n            this.visitExpr(e.elt);\n            this.visitComprehension(e.generators, 0);\n            break;\n        case Sk.astnodes.GeneratorExp:\n            this.visitGenexp(e);\n            break;\n        case Sk.astnodes.Yield:\n            if (e.value) {\n                this.visitExpr(e.value);\n            }\n            this.cur.generator = true;\n            if (this.cur.returnsValue) {\n                throw new Sk.builtin.SyntaxError(\"'return' with argument inside generator\", this.filename);\n            }\n            break;\n        case Sk.astnodes.Compare:\n            this.visitExpr(e.left);\n            this.SEQExpr(e.comparators);\n            break;\n        case Sk.astnodes.Call:\n            this.visitExpr(e.func);\n            if (e.args) {\n                for (let a of e.args) {\n                    if (a.constructor === Sk.astnodes.Starred) {\n                        this.visitExpr(a.value);\n                    } else {\n                        this.visitExpr(a);\n                    }\n                }\n            }\n            if (e.keywords) {\n                for (let k of e.keywords) {\n                    this.visitExpr(k.value);\n                }\n            }\n            break;\n        case Sk.astnodes.Num:\n        case Sk.astnodes.Str:\n            break;\n        case Sk.astnodes.Attribute:\n            this.visitExpr(e.value);\n            break;\n        case Sk.astnodes.Subscript:\n            this.visitExpr(e.value);\n            this.visitSlice(e.slice);\n            break;\n        case Sk.astnodes.Name:\n            this.addDef(e.id, e.ctx === Sk.astnodes.Load ? USE : DEF_LOCAL, e.lineno);\n            break;\n        case Sk.astnodes.NameConstant:\n            break;\n        case Sk.astnodes.List:\n        case Sk.astnodes.Tuple:\n        case Sk.astnodes.Set:\n            this.SEQExpr(e.elts);\n            break;\n        case Sk.astnodes.Starred:\n            this.visitExpr(e.value);\n            break;\n        default:\n            Sk.asserts.fail(\"Unhandled type \" + e.constructor.name + \" in visitExpr\");\n    }\n};\n\nSymbolTable.prototype.visitComprehension = function (lcs, startAt) {\n    var lc;\n    var i;\n    var len = lcs.length;\n    for (i = startAt; i < len; ++i) {\n        lc = lcs[i];\n        this.visitExpr(lc.target);\n        this.visitExpr(lc.iter);\n        this.SEQExpr(lc.ifs);\n    }\n};\n\nSymbolTable.prototype.visitAlias = function (names, lineno) {\n    /* Compute store_name, the name actually bound by the import\n     operation.  It is diferent than a->name when a->name is a\n     dotted package name (e.g. spam.eggs)\n     */\n    var dot;\n    var storename;\n    var name;\n    var a;\n    var i;\n    for (i = 0; i < names.length; ++i) {\n        a = names[i];\n        name = a.asname === null ? a.name.v : a.asname.v;\n        storename = name;\n        dot = name.indexOf(\".\");\n        if (dot !== -1) {\n            storename = name.substr(0, dot);\n        }\n        if (name !== \"*\") {\n            this.addDef(new Sk.builtin.str(storename), DEF_IMPORT, lineno);\n        }\n        else {\n            if (this.cur.blockType !== ModuleBlock) {\n                throw new Sk.builtin.SyntaxError(\"import * only allowed at module level\", this.filename);\n            }\n        }\n    }\n};\n\nSymbolTable.prototype.visitGenexp = function (e) {\n    var outermost = e.generators[0];\n    // outermost is evaled in current scope\n    this.visitExpr(outermost.iter);\n    this.enterBlock(\"genexpr\", FunctionBlock, e, e.lineno);\n    this.cur.generator = true;\n    this.addDef(new Sk.builtin.str(\".0\"), DEF_PARAM, e.lineno);\n    this.visitExpr(outermost.target);\n    this.SEQExpr(outermost.ifs);\n    this.visitComprehension(e.generators, 1);\n    this.visitExpr(e.elt);\n    this.exitBlock();\n};\n\nSymbolTable.prototype.visitExcepthandlers = function (handlers) {\n    var i, eh;\n    for (i = 0; eh = handlers[i]; ++i) {\n        if (eh.type) {\n            this.visitExpr(eh.type);\n        }\n        if (eh.name) {\n            this.visitExpr(eh.name);\n        }\n        this.SEQStmt(eh.body);\n    }\n};\n\nfunction _dictUpdate (a, b) {\n    var kb;\n    for (kb in b) {\n        a[kb] = b[kb];\n    }\n}\n\nSymbolTable.prototype.analyzeBlock = function (ste, bound, free, global) {\n    var c;\n    var i;\n    var childlen;\n    var allfree;\n    var flags;\n    var name;\n    var local = {};\n    var scope = {};\n    var newglobal = {};\n    var newbound = {};\n    var newfree = {};\n\n    if (ste.blockType == ClassBlock) {\n        _dictUpdate(newglobal, global);\n        if (bound) {\n            _dictUpdate(newbound, bound);\n        }\n    }\n\n    for (name in ste.symFlags) {\n        flags = ste.symFlags[name];\n        this.analyzeName(ste, scope, name, flags, bound, local, free, global);\n    }\n\n    if (ste.blockType !== ClassBlock) {\n        if (ste.blockType === FunctionBlock) {\n            _dictUpdate(newbound, local);\n        }\n        if (bound) {\n            _dictUpdate(newbound, bound);\n        }\n        _dictUpdate(newglobal, global);\n    }\n\n    allfree = {};\n    childlen = ste.children.length;\n    for (i = 0; i < childlen; ++i) {\n        c = ste.children[i];\n        this.analyzeChildBlock(c, newbound, newfree, newglobal, allfree);\n        if (c.hasFree || c.childHasFree) {\n            ste.childHasFree = true;\n        }\n    }\n\n    _dictUpdate(newfree, allfree);\n    if (ste.blockType === FunctionBlock) {\n        this.analyzeCells(scope, newfree);\n    }\n    this.updateSymbols(ste.symFlags, scope, bound, newfree, ste.blockType === ClassBlock);\n\n    _dictUpdate(free, newfree);\n};\n\nSymbolTable.prototype.analyzeChildBlock = function (entry, bound, free, global, childFree) {\n    var tempGlobal;\n    var tempFree;\n    var tempBound = {};\n    _dictUpdate(tempBound, bound);\n    tempFree = {};\n    _dictUpdate(tempFree, free);\n    tempGlobal = {};\n    _dictUpdate(tempGlobal, global);\n\n    this.analyzeBlock(entry, tempBound, tempFree, tempGlobal);\n    _dictUpdate(childFree, tempFree);\n};\n\nSymbolTable.prototype.analyzeCells = function (scope, free) {\n    var flags;\n    var name;\n    for (name in scope) {\n        flags = scope[name];\n        if (flags !== LOCAL) {\n            continue;\n        }\n        if (free[name] === undefined) {\n            continue;\n        }\n        scope[name] = CELL;\n        delete free[name];\n    }\n};\n\n/**\n * store scope info back into the st symbols dict. symbols is modified,\n * others are not.\n */\nSymbolTable.prototype.updateSymbols = function (symbols, scope, bound, free, classflag) {\n    var i;\n    var o;\n    var pos;\n    var freeValue;\n    var w;\n    var flags;\n    var name;\n    for (name in symbols) {\n        flags = symbols[name];\n        w = scope[name];\n        flags |= w << SCOPE_OFF;\n        symbols[name] = flags;\n    }\n\n    freeValue = FREE << SCOPE_OFF;\n    pos = 0;\n    for (name in free) {\n        o = symbols[name];\n        if (o !== undefined) {\n            // it could be a free variable in a method of the class that has\n            // the same name as a local or global in the class scope\n            if (classflag && (o & (DEF_BOUND | DEF_GLOBAL))) {\n                i = o | DEF_FREE_CLASS;\n                symbols[name] = i;\n            }\n            // else it's not free, probably a cell\n            continue;\n        }\n        if (bound[name] === undefined) {\n            continue;\n        }\n        symbols[name] = freeValue;\n    }\n};\n\nSymbolTable.prototype.analyzeName = function (ste, dict, name, flags, bound, local, free, global) {\n    if (flags & DEF_GLOBAL) {\n        if (flags & DEF_PARAM) {\n            throw new Sk.builtin.SyntaxError(\"name '\" + name + \"' is local and global\", this.filename, ste.lineno);\n        }\n        dict[name] = GLOBAL_EXPLICIT;\n        global[name] = null;\n        if (bound && bound[name] !== undefined) {\n            delete bound[name];\n        }\n        return;\n    }\n    if (flags & DEF_BOUND) {\n        dict[name] = LOCAL;\n        local[name] = null;\n        delete global[name];\n        return;\n    }\n\n    if (bound && bound[name] !== undefined) {\n        dict[name] = FREE;\n        ste.hasFree = true;\n        free[name] = null;\n    }\n    else if (global && global[name] !== undefined) {\n        dict[name] = GLOBAL_IMPLICIT;\n    }\n    else {\n        if (ste.isNested) {\n            ste.hasFree = true;\n        }\n        dict[name] = GLOBAL_IMPLICIT;\n    }\n};\n\nSymbolTable.prototype.analyze = function () {\n    var free = {};\n    var global = {};\n    this.analyzeBlock(this.top, null, free, global);\n};\n\n/**\n * @param {Object} ast\n * @param {string} filename\n */\nSk.symboltable = function (ast, filename) {\n    var i;\n    var ret = new SymbolTable(filename);\n\n    ret.enterBlock(\"top\", ModuleBlock, ast, 0);\n    ret.top = ret.cur;\n\n    //print(Sk.astDump(ast));\n    for (i = 0; i < ast.body.length; ++i) {\n        ret.visitStmt(ast.body[i]);\n    }\n\n    ret.exitBlock();\n\n    ret.analyze();\n\n    return ret;\n};\n\nSk.dumpSymtab = function (st) {\n    var pyBoolStr = function (b) {\n        return b ? \"True\" : \"False\";\n    }\n    var pyList = function (l) {\n        var i;\n        var ret = [];\n        for (i = 0; i < l.length; ++i) {\n            ret.push(new Sk.builtin.str(l[i])[\"$r\"]().v);\n        }\n        return \"[\" + ret.join(\", \") + \"]\";\n    };\n    var getIdents = function (obj, indent) {\n        var ns;\n        var j;\n        var sub;\n        var nsslen;\n        var nss;\n        var info;\n        var i;\n        var objidentslen;\n        var objidents;\n        var ret;\n        if (indent === undefined) {\n            indent = \"\";\n        }\n        ret = \"\";\n        ret += indent + \"Sym_type: \" + obj.get_type() + \"\\n\";\n        ret += indent + \"Sym_name: \" + obj.get_name() + \"\\n\";\n        ret += indent + \"Sym_lineno: \" + obj.get_lineno() + \"\\n\";\n        ret += indent + \"Sym_nested: \" + pyBoolStr(obj.is_nested()) + \"\\n\";\n        ret += indent + \"Sym_haschildren: \" + pyBoolStr(obj.has_children()) + \"\\n\";\n        if (obj.get_type() === \"class\") {\n            ret += indent + \"Class_methods: \" + pyList(obj.get_methods()) + \"\\n\";\n        }\n        else if (obj.get_type() === \"function\") {\n            ret += indent + \"Func_params: \" + pyList(obj.get_parameters()) + \"\\n\";\n            ret += indent + \"Func_locals: \" + pyList(obj.get_locals()) + \"\\n\";\n            ret += indent + \"Func_globals: \" + pyList(obj.get_globals()) + \"\\n\";\n            ret += indent + \"Func_frees: \" + pyList(obj.get_frees()) + \"\\n\";\n        }\n        ret += indent + \"-- Identifiers --\\n\";\n        objidents = obj.get_identifiers();\n        objidentslen = objidents.length;\n        for (i = 0; i < objidentslen; ++i) {\n            info = obj.lookup(objidents[i]);\n            ret += indent + \"name: \" + info.get_name() + \"\\n\";\n            ret += indent + \"  is_referenced: \" + pyBoolStr(info.is_referenced()) + \"\\n\";\n            ret += indent + \"  is_imported: \" + pyBoolStr(info.is_imported()) + \"\\n\";\n            ret += indent + \"  is_parameter: \" + pyBoolStr(info.is_parameter()) + \"\\n\";\n            ret += indent + \"  is_global: \" + pyBoolStr(info.is_global()) + \"\\n\";\n            ret += indent + \"  is_declared_global: \" + pyBoolStr(info.is_declared_global()) + \"\\n\";\n            ret += indent + \"  is_local: \" + pyBoolStr(info.is_local()) + \"\\n\";\n            ret += indent + \"  is_free: \" + pyBoolStr(info.is_free()) + \"\\n\";\n            ret += indent + \"  is_assigned: \" + pyBoolStr(info.is_assigned()) + \"\\n\";\n            ret += indent + \"  is_namespace: \" + pyBoolStr(info.is_namespace()) + \"\\n\";\n            nss = info.get_namespaces();\n            nsslen = nss.length;\n            ret += indent + \"  namespaces: [\\n\";\n            sub = [];\n            for (j = 0; j < nsslen; ++j) {\n                ns = nss[j];\n                sub.push(getIdents(ns, indent + \"    \"));\n            }\n            ret += sub.join(\"\\n\");\n            ret += indent + \"  ]\\n\";\n        }\n        return ret;\n    };\n    return getIdents(st.top, \"\");\n};\n\nSk.exportSymbol(\"Sk.symboltable\", Sk.symboltable);\nSk.exportSymbol(\"Sk.dumpSymtab\", Sk.dumpSymtab);\n\n\n/***/ }),\n/* 49 */\n/***/ (function(module, exports) {\n\n/** @param {...*} x */\nvar out;\n\nSk.gensymcount = 0;\n\n/**\n * @constructor\n * @param {string} filename\n * @param {SymbolTable} st\n * @param {number} flags\n * @param {boolean=} canSuspend whether compiled code can suspend\n * @param {string=} sourceCodeForAnnotation used to add original source to listing if desired\n */\nfunction Compiler (filename, st, flags, canSuspend, sourceCodeForAnnotation) {\n    this.filename = filename;\n    this.st = st;\n    this.flags = flags;\n    this.canSuspend = canSuspend;\n    this.interactive = false;\n    this.nestlevel = 0;\n\n    this.u = null;\n    this.stack = [];\n\n    this.result = [];\n\n    // this.gensymcount = 0;\n\n    this.allUnits = [];\n\n    this.source = sourceCodeForAnnotation ? sourceCodeForAnnotation.split(\"\\n\") : false;\n}\n\n/**\n * @constructor\n *\n * Stuff that changes on entry/exit of code blocks. must be saved and restored\n * when returning to a block.\n *\n * Corresponds to the body of a module, class, or function.\n */\n\nfunction CompilerUnit () {\n    this.ste = null;\n    this.name = null;\n    this.canSuspend = false;\n    this.doesSuspend = false;\n\n    this.private_ = null;\n    this.firstlineno = 0;\n    this.lineno = 0;\n    this.linenoSet = false;\n    this.localnames = [];\n\n    this.localtemps = [];\n    this.tempsToSave = [];\n\n    this.blocknum = 0;\n    this.blocks = [];\n    this.curblock = 0;\n\n    this.consts = {};\n\n    this.scopename = null;\n\n    this.prefixCode = \"\";\n    this.varDeclsCode = \"\";\n    this.switchCode = \"\";\n    this.suffixCode = \"\";\n\n    // stack of where to go on a break\n    this.breakBlocks = [];\n    // stack of where to go on a continue\n    this.continueBlocks = [];\n    this.exceptBlocks = [];\n    // state of where to go on a return\n    this.finallyBlocks = [];\n}\n\nCompilerUnit.prototype.activateScope = function () {\n    var self = this;\n\n    out = function () {\n        var i;\n        var b = self.blocks[self.curblock];\n        if (b._next === null) {\n            for (i = 0; i < arguments.length; ++i) {\n                b.push(arguments[i]);\n            }\n        }\n        // TODO: Warn about unreachable code after an unconditional jump?\n    };\n};\n\nCompiler.prototype.getSourceLine = function (lineno) {\n    Sk.asserts.assert(this.source);\n    return this.source[lineno - 1];\n};\n\nCompiler.prototype.annotateSource = function (ast) {\n    var i;\n    var col_offset;\n    var lineno;\n    if (this.source) {\n        lineno = ast.lineno;\n        col_offset = ast.col_offset;\n        out(\"\\n//\\n// line \", lineno, \":\\n// \", this.getSourceLine(lineno), \"\\n// \");\n        for (i = 0; i < col_offset; ++i) {\n            out(\" \");\n        }\n        out(\"^\\n//\\n\");\n\n        Sk.asserts.assert(ast.lineno !== undefined && ast.col_offset !== undefined);\n        out(\"$currLineNo = \", lineno, \";\\n$currColNo = \", col_offset, \";\\n\\n\");\n    }\n};\n\nCompiler.prototype.gensym = function (hint) {\n    hint = hint || \"\";\n    hint = \"$\" + hint;\n    hint += Sk.gensymcount++;\n    return hint;\n};\n\nCompiler.prototype.niceName = function (roughName) {\n    return this.gensym(roughName.replace(\"<\", \"\").replace(\">\", \"\").replace(\" \", \"_\"));\n};\n\nvar reservedWords_ = {\n    \"abstract\": true,\n    \"as\": true,\n    \"boolean\": true,\n    \"break\": true,\n    \"byte\": true,\n    \"case\": true,\n    \"catch\": true,\n    \"char\": true,\n    \"class\": true,\n    \"continue\": true,\n    \"const\": true,\n    \"debugger\": true,\n    \"default\": true,\n    \"delete\": true,\n    \"do\": true,\n    \"double\": true,\n    \"else\": true,\n    \"enum\": true,\n    \"export\": true,\n    \"extends\": true,\n    \"false\": true,\n    \"final\": true,\n    \"finally\": true,\n    \"float\": true,\n    \"for\": true,\n    \"function\": true,\n    \"goto\": true,\n    \"if\": true,\n    \"implements\": true,\n    \"import\": true,\n    \"in\": true,\n    \"instanceof\": true,\n    \"int\": true,\n    \"interface\": true,\n    \"is\": true,\n    \"long\": true,\n    \"namespace\": true,\n    \"native\": true,\n    \"new\": true,\n    \"null\": true,\n    \"package\": true,\n    \"private\": true,\n    \"protected\": true,\n    \"public\": true,\n    \"return\": true,\n    \"short\": true,\n    \"static\": true,\n    \"super\": false,\n    \"switch\": true,\n    \"synchronized\": true,\n    \"this\": true,\n    \"throw\": true,\n    \"throws\": true,\n    \"transient\": true,\n    \"true\": true,\n    \"try\": true,\n    \"typeof\": true,\n    \"use\": true,\n    \"var\": true,\n    \"void\": true,\n    \"volatile\": true,\n    \"while\": true,\n    \"with\": true\n};\n\n/**\n * Fix reserved words\n *\n * @param {string} name\n */\nfunction fixReservedWords(name) {\n    if (reservedWords_[name] !== true) {\n        return name;\n    }\n    return name + \"_$rw$\";\n}\n\nvar reservedNames_ = {\n    \"__defineGetter__\": true,\n    \"__defineSetter__\": true,\n    \"apply\": true,\n    \"call\": true,\n    \"eval\": true,\n    \"hasOwnProperty\": true,\n    \"isPrototypeOf\": true,\n    \"__lookupGetter__\": true,\n    \"__lookupSetter__\": true,\n    \"__noSuchMethod__\": true,\n    \"propertyIsEnumerable\": true,\n    \"toSource\": true,\n    \"toLocaleString\": true,\n    \"toString\": true,\n    \"unwatch\": true,\n    \"valueOf\": true,\n    \"watch\": true,\n    \"length\": true,\n    \"name\": true,\n};\n\nfunction fixReservedNames (name) {\n    if (reservedNames_[name]) {\n        return name + \"_$rn$\";\n    }\n    return name;\n}\n\nfunction unfixReserved(name) {\n    return name.replace(/_\\$r[wn]\\$$/, \"\");\n}\n\nfunction mangleName (priv, ident) {\n    var name = ident.v;\n    var strpriv = null;\n\n\n    if (priv === null || name === null || name.charAt(0) !== \"_\" || name.charAt(1) !== \"_\") {\n        return ident;\n    }\n    // don't mangle __id__\n    if (name.charAt(name.length - 1) === \"_\" && name.charAt(name.length - 2) === \"_\") {\n        return ident;\n    }\n    // don't mangle classes that are all _ (obscure much?)\n    strpriv = priv.v;\n    strpriv.replace(/_/g, \"\");\n    if (strpriv === \"\") {\n        return ident;\n    }\n\n    strpriv = priv.v;\n    strpriv.replace(/^_*/, \"\");\n    strpriv = new Sk.builtin.str(\"_\" + strpriv + name);\n    return strpriv;\n}\n\n/**\n * @param {...*} rest\n */\nCompiler.prototype.makeConstant = function (rest) {\n    var i;\n    var v;\n    var val = \"\";\n    var cval;\n\n    // Construct constant value\n    for (i = 0; i < arguments.length; ++i) {\n        val += arguments[i];\n    }\n\n    // Check if we've already defined this exact constant\n    for (var constant in this.u.consts) {\n        if (this.u.consts.hasOwnProperty(constant)) {\n            cval = this.u.consts[constant];\n            if (cval == val) {\n                // We have, just use it\n                return constant;\n            }\n        }\n    }\n\n    // We have not, build new one\n    v = this.u.scopename + \".\" + this.gensym(\"const\");\n    this.u.consts[v] = val;\n    return v;\n}\n\n/**\n * @param {string} hint basename for gensym\n * @param {...*} rest\n */\nCompiler.prototype._gr = function (hint, rest) {\n    var i;\n    var v = this.gensym(hint);\n    this.u.localtemps.push(v);\n    out(\"var \", v, \"=\");\n    for (i = 1; i < arguments.length; ++i) {\n        out(arguments[i]);\n    }\n    out(\";\");\n    return v;\n};\n\n/**\n * Function to test if an interrupt should occur if the program has been running for too long.\n * This function is executed at every test/branch operation.\n */\nCompiler.prototype.outputInterruptTest = function () { // Added by RNL\n    var output = \"\";\n    if (Sk.execLimit !== null || Sk.yieldLimit !== null && this.u.canSuspend) {\n            output += \"var $dateNow = Date.now();\";\n        if (Sk.execLimit !== null) {\n            output += \"if ($dateNow - Sk.execStart > Sk.execLimit) {throw new Sk.builtin.TimeLimitError(Sk.timeoutMsg())}\";\n        }\n        if (Sk.yieldLimit !== null && this.u.canSuspend) {\n            output += \"if ($dateNow - Sk.lastYield > Sk.yieldLimit) {\";\n            output += \"var $susp = $saveSuspension({data: {type: 'Sk.yield'}, resume: function() {}}, '\"+this.filename+\"',$currLineNo,$currColNo);\";\n            output += \"$susp.$blk = $blk;\";\n            output += \"$susp.optional = true;\";\n            output += \"return $susp;\";\n            output += \"}\";\n            this.u.doesSuspend = true;\n        }\n    }\n    return output;\n};\n\nCompiler.prototype._jumpfalse = function (test, block) {\n    var cond = this._gr(\"jfalse\", \"(\", test, \"===false||!Sk.misceval.isTrue(\", test, \"))\");\n    out(\"if(\", cond, \"){/*test failed */$blk=\", block, \";continue;}\");\n};\n\nCompiler.prototype._jumpundef = function (test, block) {\n    out(\"if(\", test, \"===undefined){$blk=\", block, \";continue;}\");\n};\n\nCompiler.prototype._jumpnotundef = function (test, block) {\n    out(\"if(\", test, \"!==undefined){$blk=\", block, \";continue;}\");\n};\n\nCompiler.prototype._jumptrue = function (test, block) {\n    var cond = this._gr(\"jtrue\", \"(\", test, \"===true||Sk.misceval.isTrue(\", test, \"))\");\n    out(\"if(\", cond, \"){/*test passed */$blk=\", block, \";continue;}\");\n};\n\nCompiler.prototype._jump = function (block) {\n    if (this.u.blocks[this.u.curblock]._next === null) {\n        out(\"$blk=\", block, \";\");\n        this.u.blocks[this.u.curblock]._next = block;\n    }\n};\n\n/**\n * @param {Object=} e Object with keys 'lineno' and 'col_offset'\n */\nCompiler.prototype._checkSuspension = function(e) {\n    var retblk;\n    if (this.u.canSuspend) {\n\n        retblk = this.newBlock(\"function return or resume suspension\");\n        this._jump(retblk);\n        this.setBlock(retblk);\n\n        e = e || {lineno: \"$currLineNo\", col_offset: \"$currColNo\"};\n\n        out (\"if ($ret && $ret.$isSuspension) { return $saveSuspension($ret,'\"+this.filename+\"',\"+e.lineno+\",\"+e.col_offset+\"); }\");\n\n        this.u.doesSuspend = true;\n        this.u.tempsToSave = this.u.tempsToSave.concat(this.u.localtemps);\n\n    } else {\n        out (\"if ($ret && $ret.$isSuspension) { $ret = Sk.misceval.retryOptionalSuspensionOrThrow($ret); }\");\n    }\n};\nCompiler.prototype.cunpackstarstoarray = function(elts, permitEndOnly) {\n    if (!elts || elts.length == 0) {\n        return \"[]\";\n    }\n    let arr = this._gr(\"unpack\", \"[]\");\n    let hasStars = false;\n    for (let elt of elts) {\n        if (permitEndOnly && hasStars) {\n            throw new Sk.builtin.SyntaxError(\"Extended argument unpacking is not permitted in Python 2\");\n        }\n        if (elt.constructor !== Sk.astnodes.Starred) {\n            out(arr,\".push(\",this.vexpr(elt),\");\");\n        } else {\n            out(\"$ret = Sk.misceval.iterFor(Sk.abstr.iter(\",this.vexpr(elt.value),\"), function(e) { \",arr,\".push(e); });\");\n            this._checkSuspension();\n            hasStars = true;\n        }\n    }\n    return arr;\n}\n\nCompiler.prototype.ctuplelistorset = function(e, data, tuporlist) {\n    var i;\n    var items;\n    var item;\n    var allconsts;\n    Sk.asserts.assert(tuporlist === \"tuple\" || tuporlist === \"list\" || tuporlist === \"set\");\n\n    let hasStars = false;\n    for (let elt of e.elts) {\n        if (elt.constructor === Sk.astnodes.Starred) { hasStars = true; break; }\n    }\n\n    if (e.ctx === Sk.astnodes.Store) {\n        if (hasStars) {\n            // TODO support this in Python 3 mode\n            throw new Sk.builtin.SyntaxError(\"Tuple unpacking with stars is not supported\");\n        }\n        items = this._gr(\"items\", \"Sk.abstr.sequenceUnpack(\" + data + \",\" + e.elts.length + \")\");\n        for (i = 0; i < e.elts.length; ++i) {\n            this.vexpr(e.elts[i], items + \"[\" + i + \"]\");\n        }\n    }\n    else if (e.ctx === Sk.astnodes.Load || tuporlist === \"set\") { //because set's can't be assigned to.\n\n        if (hasStars) {\n            if (!Sk.__future__.python3) {\n                throw new Sk.builtin.SyntaxError(\"List packing with stars is not supported in Python 2\");\n            }\n            return this._gr(\"load\" + tuporlist, \"new Sk.builtins['\", tuporlist, \"'](\", this.cunpackstarstoarray(e.elts), \")\");\n        }\n        else if (tuporlist === \"tuple\") {\n            allconsts = true;\n            items = [];\n            for (i = 0; i < e.elts.length; ++i) {\n                item = this.vexpr(e.elts[i]);\n\n                // The following is an ugly check to see if item was\n                // turned into a constant.  As vexpr returns a string,\n                // this requires seeing if \"$const\" is contained\n                // within it.  A better solution would require a\n                // change to vexpr, which would be more invasive.\n                if (allconsts && (item.indexOf('$const') == -1)) {\n                    allconsts = false;\n                }\n                items.push(item);\n            }\n\n            if (allconsts) {\n                return this.makeConstant(\"new Sk.builtin.tuple([\" + items + \"])\");\n            } else {\n                for (i = 0; i < items.length; ++i) {\n                    items[i] = this._gr(\"elem\", items[i]);\n                }\n                return this._gr(\"load\" + tuporlist, \"new Sk.builtins['\", tuporlist, \"']([\", items, \"])\");\n            }\n        } else {\n            items = [];\n            for (i = 0; i < e.elts.length; ++i) {\n                items.push(this._gr(\"elem\", this.vexpr(e.elts[i])));\n            }\n            return this._gr(\"load\" + tuporlist, \"new Sk.builtins['\", tuporlist, \"']([\", items, \"])\");\n        }\n    }\n};\n\nCompiler.prototype.cdict = function (e) {\n    var v;\n    var i;\n    var items;\n    items = [];\n    if (e.keys !== null) {\n        Sk.asserts.assert(e.values.length === e.keys.length);\n        for (i = 0; i < e.values.length; ++i) {\n            v = this.vexpr(e.values[i]); // \"backwards\" to match order in cpy\n            items.push(this.vexpr(e.keys[i]));\n            items.push(v);\n        }\n    }\n    return this._gr(\"loaddict\", \"new Sk.builtins['dict']([\", items, \"])\");\n};\n\nCompiler.prototype.clistcomp = function(e) {\n    Sk.asserts.assert(e instanceof Sk.astnodes.ListComp);\n    var tmp = this._gr(\"_compr\", \"new Sk.builtins['list']([])\"); // note: _ is impt. for hack in name mangling (same as cpy)\n    return this.ccompgen(\"list\", tmp, e.generators, 0, e.elt, null, e);\n};\n\nCompiler.prototype.cdictcomp = function(e) {\n    Sk.asserts.assert(e instanceof Sk.astnodes.DictComp);\n    var tmp = this._gr(\"_dcompr\", \"new Sk.builtins.dict([])\");\n    return this.ccompgen(\"dict\", tmp, e.generators, 0, e.value, e.key, e);\n};\n\nCompiler.prototype.csetcomp = function(e) {\n    Sk.asserts.assert(e instanceof Sk.astnodes.SetComp);\n    var tmp = this._gr(\"_setcompr\", \"new Sk.builtins.set([])\");\n    return this.ccompgen(\"set\", tmp, e.generators, 0, e.elt, null, e);\n};\n\nCompiler.prototype.ccompgen = function (type, tmpname, generators, genIndex, value, key, e) {\n    var start = this.newBlock(type + \" comp start\");\n    var skip = this.newBlock(type + \" comp skip\");\n    var anchor = this.newBlock(type + \" comp anchor\");\n\n    var l = generators[genIndex];\n    var toiter = this.vexpr(l.iter);\n    var iter = this._gr(\"iter\", \"Sk.abstr.iter(\", toiter, \")\");\n    var lvalue;\n    var lkey;\n    var ifres;\n    var i;\n    var target;\n    var nexti;\n    var n;\n\n    this._jump(start);\n    this.setBlock(start);\n\n    // load targets\n    out(\"$ret = Sk.abstr.iternext(\", iter, \", true);\");\n\n    this._checkSuspension(e);\n\n    nexti = this._gr(\"next\", \"$ret\");\n    this._jumpundef(nexti, anchor); // todo; this should be handled by StopIteration\n    target = this.vexpr(l.target, nexti);\n\n    n = l.ifs ? l.ifs.length : 0;\n    for (i = 0; i < n; ++i) {\n        ifres = this.vexpr(l.ifs[i]);\n        this._jumpfalse(ifres, start);\n    }\n\n    if (++genIndex < generators.length) {\n        this.ccompgen(type, tmpname, generators, genIndex, value, key, e);\n    }\n\n    if (genIndex >= generators.length) {\n        lvalue = this.vexpr(value);\n        if (type === \"dict\") {\n            lkey = this.vexpr(key);\n            out(tmpname, \".mp$ass_subscript(\", lkey, \",\", lvalue, \");\");\n        }\n        else if (type === \"list\") {\n            out(tmpname, \".v.push(\", lvalue, \");\"); // todo;\n        }\n        else if (type === \"set\") {\n            out(tmpname, \".v.mp$ass_subscript(\", lvalue, \", true);\");\n        }\n        this._jump(skip);\n        this.setBlock(skip);\n    }\n\n    this._jump(start);\n\n    this.setBlock(anchor);\n\n    return tmpname;\n};\n\nCompiler.prototype.cyield = function(e)\n{\n    if (this.u.ste.blockType !== Sk.SYMTAB_CONSTS.FunctionBlock) {\n        throw new SyntaxError(\"'yield' outside function\");\n    }\n    var val = \"null\",\n        nextBlock;\n    if (e.value) {\n        val = this.vexpr(e.value);\n    }\n    nextBlock = this.newBlock(\"after yield\");\n    // return a pair: resume target block and yielded value\n    out(\"return [/*resume*/\", nextBlock, \",/*ret*/\", val, \"];\");\n    this.setBlock(nextBlock);\n    return \"$gen.gi$sentvalue\"; // will either be null if none sent, or the value from gen.send(value)\n};\n\nCompiler.prototype.ccompare = function (e) {\n    var res;\n    var rhs;\n    var i;\n    var fres;\n    var done;\n    var n;\n    var cur;\n    Sk.asserts.assert(e.ops.length === e.comparators.length);\n    cur = this.vexpr(e.left);\n    n = e.ops.length;\n    done = this.newBlock(\"done\");\n    fres = this._gr(\"compareres\", \"null\");\n\n    for (i = 0; i < n; ++i) {\n        rhs = this.vexpr(e.comparators[i]);\n        out(\"$ret = Sk.builtin.bool(Sk.misceval.richCompareBool(\", cur, \",\", rhs, \",'\", e.ops[i].prototype._astname, \"', true));\");\n        this._checkSuspension(e);\n        out(fres, \"=$ret;\");\n        this._jumpfalse(\"$ret\", done);\n        cur = rhs;\n    }\n    this._jump(done);\n    this.setBlock(done);\n    return fres;\n};\n\nCompiler.prototype.ccall = function (e) {\n    var func = this.vexpr(e.func);\n    var kwarray = null;\n    // Okay, here's the deal. We have some set of positional args\n    // and we need to unpack them. We have some set of keyword args\n    // and we need to unpack those too. Then we make a call.\n    // The existing Sk.misceval.call() and .apply() signatures do not\n    // help us here; we do it by hand.\n    // This is less than optimal (yep, that's the @rixner bat-sign),\n    // but should be correct.\n\n    let positionalArgs = this.cunpackstarstoarray(e.args, !Sk.__future__.python3);\n    let keywordArgs = \"undefined\";\n\n    if (e.keywords && e.keywords.length > 0) {\n        let hasStars = false;\n        kwarray = [];\n        for (let kw of e.keywords) {\n            if (hasStars && !Sk.__future__.python3) {\n                throw new SyntaxError(\"Advanced unpacking of function arguments is not supported in Python 2\");\n            }\n            if (kw.arg) {\n                kwarray.push(\"'\" + kw.arg.v + \"'\");\n                kwarray.push(this.vexpr(kw.value));\n            } else {\n                hasStars = true;\n            }\n        }\n        keywordArgs = \"[\" + kwarray.join(\",\") + \"]\";\n        if (hasStars) {\n            keywordArgs = this._gr(\"keywordArgs\", keywordArgs);\n            for (let kw of e.keywords) {\n                if (!kw.arg) {\n                    out(\"$ret = Sk.abstr.mappingUnpackIntoKeywordArray(\",keywordArgs,\",\",this.vexpr(kw.value),\",\",func,\");\");\n                    this._checkSuspension();\n                }\n            }\n        }\n    }\n\n    if (Sk.__future__.super_args && e.func.id && e.func.id.v === \"super\" && positionalArgs === \"[]\") {\n        // make sure there is a self variable\n        // note that it's part of the js API spec: https://developer.mozilla.org/en/docs/Web/API/Window/self\n        // so we should probably add self to the mangling\n        // TODO: feel free to ignore the above\n        out(\"if (typeof self === \\\"undefined\\\" || self.toString().indexOf(\\\"Window\\\") > 0) { throw new Sk.builtin.RuntimeError(\\\"super(): no arguments\\\") };\")\n        positionalArgs = \"[$gbl.__class__,self]\";\n    }\n    if (keywordArgs !== \"undefined\") {\n        out(\"$ret = Sk.misceval.applyOrSuspend(\",func,\",undefined,undefined,\",keywordArgs,\",\",positionalArgs,\");\");\n    } else if (positionalArgs != \"[]\") {\n        out (\"$ret = Sk.misceval.callsimOrSuspendArray(\", func, \", \", positionalArgs, \");\");\n    } else {\n        out (\"$ret = Sk.misceval.callsimOrSuspendArray(\", func, \");\");\n    }\n\n    this._checkSuspension(e);\n\n    return this._gr(\"call\", \"$ret\");\n};\n\nCompiler.prototype.cslice = function (s) {\n    var step;\n    var high;\n    var low;\n    Sk.asserts.assert(s instanceof Sk.astnodes.Slice);\n    if (Sk.__future__.python3) {\n        low = s.lower ? this.vexpr(s.lower) : \"Sk.builtin.none.none$\";\n        high = s.upper ? this.vexpr(s.upper) : \"Sk.builtin.none.none$\";\n        step = s.step ? this.vexpr(s.step) : \"Sk.builtin.none.none$\";\n    } else {\n        // This implements Python 2's idea of slice literals, which is...idiosyncratic.\n        // The rules for when you get None, and when you get an arbitrary integer (0 or maxint)\n        // seem pretty arbitrary. Python 3's are much saner.\n        low = s.lower ? this.vexpr(s.lower) : s.step ? \"Sk.builtin.none.none$\" : \"new Sk.builtin.int_(0)\"; // todo;ideally, these numbers would be constants\n        high = s.upper ? this.vexpr(s.upper) : s.step ? \"Sk.builtin.none.none$\" : \"new Sk.builtin.int_(2147483647)\";\n        step = s.step ? this.vexpr(s.step) : \"Sk.builtin.none.none$\";\n    }\n    return this._gr(\"slice\", \"new Sk.builtins['slice'](\", low, \",\", high, \",\", step, \")\");\n};\n\nCompiler.prototype.eslice = function (dims) {\n    var i;\n    var dimSubs, subs;\n    Sk.asserts.assert(dims instanceof Array);\n    dimSubs = [];\n    for (i = 0; i < dims.length; i++) {\n        dimSubs.push(this.vslicesub(dims[i]));\n    }\n    return this._gr(\"extslice\", \"new Sk.builtins['tuple']([\", dimSubs, \"])\");\n};\n\nCompiler.prototype.vslicesub = function (s) {\n    var subs;\n    switch (s.constructor) {\n        case Sk.astnodes.Index:\n            subs = this.vexpr(s.value);\n            break;\n        case Sk.astnodes.Slice:\n            subs = this.cslice(s);\n            break;\n        case Sk.astnodes.Ellipsis:\n            Sk.asserts.fail(\"todo compile.js Ellipsis;\");\n            break;\n        case Sk.astnodes.ExtSlice:\n            subs = this.eslice(s.dims);\n            break;\n        default:\n            Sk.asserts.fail(\"invalid subscript kind\");\n    }\n    return subs;\n};\n\nCompiler.prototype.vslice = function (s, ctx, obj, dataToStore) {\n    var subs = this.vslicesub(s);\n    return this.chandlesubscr(ctx, obj, subs, dataToStore);\n};\n\nCompiler.prototype.chandlesubscr = function (ctx, obj, subs, data) {\n    if (ctx === Sk.astnodes.Load || ctx === Sk.astnodes.AugLoad) {\n        out(\"$ret = Sk.abstr.objectGetItem(\", obj, \",\", subs, \", true);\");\n        this._checkSuspension();\n        return this._gr(\"lsubscr\", \"$ret\");\n    }\n    else if (ctx === Sk.astnodes.Store || ctx === Sk.astnodes.AugStore) {\n        out(\"$ret = Sk.abstr.objectSetItem(\", obj, \",\", subs, \",\", data, \", true);\");\n        this._checkSuspension();\n    }\n    else if (ctx === Sk.astnodes.Del) {\n        out(\"Sk.abstr.objectDelItem(\", obj, \",\", subs, \");\");\n    }\n    else {\n        Sk.asserts.fail(\"handlesubscr fail\");\n    }\n};\n\nCompiler.prototype.cboolop = function (e) {\n    var expres;\n    var i;\n    var retval;\n    var n;\n    var s;\n    var end;\n    var ifFailed;\n    var jtype;\n    Sk.asserts.assert(e instanceof Sk.astnodes.BoolOp);\n    if (e.op === Sk.astnodes.And) {\n        jtype = this._jumpfalse;\n    }\n    else {\n        jtype = this._jumptrue;\n    }\n    end = this.newBlock(\"end of boolop\");\n    s = e.values;\n    n = s.length;\n    for (i = 0; i < n; ++i) {\n        expres = this.vexpr(s[i]);\n        if (i === 0) {\n            retval = this._gr(\"boolopsucc\", expres);\n        }\n        out(retval, \"=\", expres, \";\");\n        jtype.call(this, expres, end);\n    }\n    this._jump(end);\n    this.setBlock(end);\n    return retval;\n};\n\n\n/**\n *\n * compiles an expression. to 'return' something, it'll gensym a var and store\n * into that var so that the calling code doesn't have avoid just pasting the\n * returned name.\n *\n * @param {Object} e\n * @param {string=} data data to store in a store operation\n * @param {Object=} augvar var to load/store to for augmented assignments like '+='.\n *                  (already vexpr'ed, so we can evaluate it once and reuse for both load and store ops)\n * @param {Object=} augsubs precomputed subscript for augmented assignments like '+='.\n *                  (already vexpr'ed, so we can evaluate it once and reuse for both load and store ops)\n */\nCompiler.prototype.vexpr = function (e, data, augvar, augsubs) {\n    var mangled, mname;\n    var val;\n    var result;\n    var nStr; // used for preserving signs for floats (zeros)\n    if (e.lineno > this.u.lineno) {\n        this.u.lineno = e.lineno;\n        this.u.linenoSet = false;\n    }\n    //this.annotateSource(e);\n    switch (e.constructor) {\n        case Sk.astnodes.BoolOp:\n            return this.cboolop(e);\n        case Sk.astnodes.BinOp:\n            return this._gr(\"binop\", \"Sk.abstr.numberBinOp(\", this.vexpr(e.left), \",\", this.vexpr(e.right), \",'\", e.op.prototype._astname, \"')\");\n        case Sk.astnodes.UnaryOp:\n            return this._gr(\"unaryop\", \"Sk.abstr.numberUnaryOp(\", this.vexpr(e.operand), \",'\", e.op.prototype._astname, \"')\");\n        case Sk.astnodes.Lambda:\n            return this.clambda(e);\n        case Sk.astnodes.IfExp:\n            return this.cifexp(e);\n        case Sk.astnodes.Dict:\n            return this.cdict(e);\n        case Sk.astnodes.ListComp:\n            return this.clistcomp(e);\n        case Sk.astnodes.DictComp:\n            return this.cdictcomp(e);\n        case Sk.astnodes.SetComp:\n            return this.csetcomp(e);\n        case Sk.astnodes.GeneratorExp:\n            return this.cgenexp(e);\n        case Sk.astnodes.Yield:\n            return this.cyield(e);\n        case Sk.astnodes.Compare:\n            return this.ccompare(e);\n        case Sk.astnodes.Call:\n            result = this.ccall(e);\n            // After the function call, we've returned to this line\n            this.annotateSource(e);\n            return result;\n        case Sk.astnodes.Num:\n            if (typeof e.n === \"number\") {\n                return e.n;\n            }\n            else if (e.n instanceof Sk.builtin.int_) {\n                return this.makeConstant(\"new Sk.builtin.int_(\" + e.n.v + \")\");\n            } else if (e.n instanceof Sk.builtin.float_) {\n                // Preserve sign of zero for floats\n                nStr = e.n.v === 0 && 1/e.n.v === -Infinity ? \"-0\" : e.n.v;\n                return this.makeConstant(\"new Sk.builtin.float_(\" + nStr + \")\");\n            }\n            else if (e.n instanceof Sk.builtin.lng) {\n                // long uses the tp$str() method which delegates to nmber.str$ which preserves the sign\n                return this.makeConstant(\"Sk.longFromStr('\" + e.n.tp$str().v + \"')\");\n            }\n            else if (e.n instanceof Sk.builtin.complex) {\n                // preserve sign of zero here too\n                var real_val = e.n.real.v === 0 && 1/e.n.real.v === -Infinity ? \"-0\" : e.n.real.v;\n                var imag_val = e.n.imag.v === 0 && 1/e.n.imag.v === -Infinity ? \"-0\" : e.n.imag.v;\n                return this.makeConstant(\"new Sk.builtin.complex(new Sk.builtin.float_(\" + real_val + \"), new Sk.builtin.float_(\" + imag_val + \"))\");\n            }\n            Sk.asserts.fail(\"unhandled Num type\");\n        case Sk.astnodes.Str:\n            return this.makeConstant(\"new Sk.builtin.str(\", e.s[\"$r\"]().v, \")\");\n        case Sk.astnodes.Attribute:\n            if (e.ctx !== Sk.astnodes.AugLoad && e.ctx !== Sk.astnodes.AugStore) {\n                val = this.vexpr(e.value);\n            }\n            mangled = e.attr[\"$r\"]().v;\n            mangled = mangled.substring(1, mangled.length - 1);\n            mangled = mangleName(this.u.private_, new Sk.builtin.str(mangled)).v;\n            mangled = fixReservedWords(mangled);\n            mangled = fixReservedNames(mangled);\n            mname = this.makeConstant(\"new Sk.builtin.str('\" + mangled + \"')\");\n            switch (e.ctx) {\n                case Sk.astnodes.AugLoad:\n                    out(\"$ret = Sk.abstr.gattr(\", augvar, \",\", mname, \", true);\");\n                    this._checkSuspension(e);\n                    return this._gr(\"lattr\", \"$ret\");\n                case Sk.astnodes.Load:\n                    out(\"$ret = Sk.abstr.gattr(\", val, \",\", mname, \", true);\");\n                    this._checkSuspension(e);\n                    return this._gr(\"lattr\", \"$ret\");\n                case Sk.astnodes.AugStore:\n                    // To be more correct, we shouldn't sattr() again if the in-place update worked.\n                    // At the time of writing (26/Feb/2015), Sk.abstr.numberInplaceBinOp never returns undefined,\n                    // so this will never *not* execute. But it could, if Sk.abstr.numberInplaceBinOp were fixed.\n                    out(\"$ret = undefined;\");\n                    out(\"if(\", data, \"!==undefined){\");\n                    out(\"$ret = Sk.abstr.sattr(\", augvar, \",\", mname, \",\", data, \", true);\");\n                    out(\"}\");\n                    this._checkSuspension(e);\n                    break;\n                case Sk.astnodes.Store:\n                    out(\"$ret = Sk.abstr.sattr(\", val, \",\", mname, \",\", data, \", true);\");\n                    this._checkSuspension(e);\n                    break;\n                case Sk.astnodes.Del:\n                    Sk.asserts.fail(\"todo Del;\");\n                    break;\n                case Sk.astnodes.Param:\n                default:\n                    Sk.asserts.fail(\"invalid attribute expression\");\n            }\n            break;\n        case Sk.astnodes.Subscript:\n            switch (e.ctx) {\n                case Sk.astnodes.AugLoad:\n                    out(\"$ret = Sk.abstr.objectGetItem(\",augvar,\",\",augsubs,\", true);\");\n                    this._checkSuspension(e)\n                    return this._gr(\"gitem\", \"$ret\");\n                case Sk.astnodes.Load:\n                case Sk.astnodes.Store:\n                case Sk.astnodes.Del:\n                    return this.vslice(e.slice, e.ctx, this.vexpr(e.value), data);\n                case Sk.astnodes.AugStore:\n                    // To be more correct, we shouldn't sattr() again if the in-place update worked.\n                    // At the time of writing (26/Feb/2015), Sk.abstr.numberInplaceBinOp never returns undefined,\n                    // so this will never *not* execute. But it could, if Sk.abstr.numberInplaceBinOp were fixed.\n\n                    out(\"$ret=undefined;\");\n                    out(\"if(\", data, \"!==undefined){\");\n                    out(\"$ret=Sk.abstr.objectSetItem(\",augvar,\",\",augsubs,\",\",data,\", true)\");\n                    out(\"}\");\n                    this._checkSuspension(e);\n                    break;\n                case Sk.astnodes.Param:\n                default:\n                    Sk.asserts.fail(\"invalid subscript expression\");\n            }\n            break;\n        case Sk.astnodes.Name:\n            return this.nameop(e.id, e.ctx, data);\n        case Sk.astnodes.NameConstant:\n            if (e.ctx === Sk.astnodes.Store || e.ctx === Sk.astnodes.AugStore || e.ctx === Sk.astnodes.Del) {\n                throw new Sk.builtin.SyntaxError(\"can not assign to a constant name\");\n            }\n\n            switch (e.value) {\n                case Sk.builtin.none.none$:\n                    return \"Sk.builtin.none.none$\";\n                case Sk.builtin.bool.true$:\n                    return \"Sk.builtin.bool.true$\";\n                case Sk.builtin.bool.false$:\n                    return \"Sk.builtin.bool.false$\";\n                default:\n                    Sk.asserts.fail(\"invalid named constant\")\n            }\n            break;\n        case Sk.astnodes.List:\n            return this.ctuplelistorset(e, data, 'list');\n        case Sk.astnodes.Tuple:\n            return this.ctuplelistorset(e, data, 'tuple');\n        case Sk.astnodes.Set:\n            return this.ctuplelistorset(e, data, 'set');\n        case Sk.astnodes.Starred:\n            break;\n        default:\n            Sk.asserts.fail(\"unhandled case \" + e.constructor.name + \" vexpr\");\n    }\n};\n\n/**\n * @param {Array.<Object>} exprs\n * @param {Array.<string>=} data\n */\nCompiler.prototype.vseqexpr = function (exprs, data) {\n    var i;\n    var ret;\n    Sk.asserts.assert(data === undefined || exprs.length === data.length);\n    ret = [];\n\n    // if (exprs.length === 1 && exprs[0].constructor === Sk.astnodes.Starred) {\n    //     exprs = exprs[0].value;\n    // }\n\n    for (i = 0; i < exprs.length; ++i) {\n        ret.push(this.vexpr(exprs[i], data === undefined ? undefined : data[i]));\n    }\n    return ret;\n};\n\nCompiler.prototype.caugassign = function (s) {\n    var to;\n    var augsub;\n    var res;\n    var val;\n    var aug;\n    var auge;\n    var e;\n    Sk.asserts.assert(s instanceof Sk.astnodes.AugAssign);\n    e = s.target;\n    switch (e.constructor) {\n        case Sk.astnodes.Attribute:\n            to = this.vexpr(e.value);\n            auge = new Sk.astnodes.Attribute(e.value, e.attr, Sk.astnodes.AugLoad, e.lineno, e.col_offset);\n            aug = this.vexpr(auge, undefined, to);\n            val = this.vexpr(s.value);\n            res = this._gr(\"inplbinopattr\", \"Sk.abstr.numberInplaceBinOp(\", aug, \",\", val, \",'\", s.op.prototype._astname, \"')\");\n            auge.ctx = Sk.astnodes.AugStore;\n            return this.vexpr(auge, res, to);\n        case Sk.astnodes.Subscript:\n            // Only compile the subscript value once\n            to = this.vexpr(e.value);\n            augsub = this.vslicesub(e.slice);\n            auge = new Sk.astnodes.Subscript(e.value, augsub, Sk.astnodes.AugLoad, e.lineno, e.col_offset);\n            aug = this.vexpr(auge, undefined, to, augsub);\n            val = this.vexpr(s.value);\n            res = this._gr(\"inplbinopsubscr\", \"Sk.abstr.numberInplaceBinOp(\", aug, \",\", val, \",'\", s.op.prototype._astname, \"')\");\n            auge.ctx = Sk.astnodes.AugStore;\n            return this.vexpr(auge, res, to, augsub);\n        case Sk.astnodes.Name:\n            to = this.nameop(e.id, Sk.astnodes.Load);\n            val = this.vexpr(s.value);\n            res = this._gr(\"inplbinop\", \"Sk.abstr.numberInplaceBinOp(\", to, \",\", val, \",'\", s.op.prototype._astname, \"')\");\n            return this.nameop(e.id, Sk.astnodes.Store, res);\n        default:\n            Sk.asserts.fail(\"unhandled case in augassign\");\n    }\n};\n\n/**\n * optimize some constant exprs. returns 0 if always false, 1 if always true or -1 otherwise.\n */\nCompiler.prototype.exprConstant = function (e) {\n    switch (e.constructor) {\n        case Sk.astnodes.Num:\n            return Sk.misceval.isTrue(e.n) ? 1 : 0;\n        case Sk.astnodes.Str:\n            return Sk.misceval.isTrue(e.s) ? 1 : 0;\n        case Sk.astnodes.Name:\n        // todo; do __debug__ test here if opt\n        default:\n            return -1;\n    }\n};\n\nCompiler.prototype.newBlock = function (name) {\n    var ret = this.u.blocknum++;\n    this.u.blocks[ret] = [];\n    this.u.blocks[ret]._name = name || \"<unnamed>\";\n    this.u.blocks[ret]._next = null;\n    return ret;\n};\nCompiler.prototype.setBlock = function (n) {\n    Sk.asserts.assert(n >= 0 && n < this.u.blocknum);\n    this.u.curblock = n;\n};\n\nCompiler.prototype.pushBreakBlock = function (n) {\n    Sk.asserts.assert(n >= 0 && n < this.u.blocknum);\n    this.u.breakBlocks.push(n);\n};\nCompiler.prototype.popBreakBlock = function () {\n    this.u.breakBlocks.pop();\n};\n\nCompiler.prototype.pushContinueBlock = function (n) {\n    Sk.asserts.assert(n >= 0 && n < this.u.blocknum);\n    this.u.continueBlocks.push(n);\n};\nCompiler.prototype.popContinueBlock = function () {\n    this.u.continueBlocks.pop();\n};\n\nCompiler.prototype.pushExceptBlock = function (n) {\n    Sk.asserts.assert(n >= 0 && n < this.u.blocknum);\n    this.u.exceptBlocks.push(n);\n};\nCompiler.prototype.popExceptBlock = function () {\n    this.u.exceptBlocks.pop();\n};\n\nCompiler.prototype.pushFinallyBlock = function (n) {\n    Sk.asserts.assert(n >= 0 && n < this.u.blocknum);\n    Sk.asserts.assert(this.u.breakBlocks.length === this.u.continueBlocks.length);\n    this.u.finallyBlocks.push({blk: n, breakDepth: this.u.breakBlocks.length});\n};\nCompiler.prototype.popFinallyBlock = function () {\n    this.u.finallyBlocks.pop();\n};\nCompiler.prototype.peekFinallyBlock = function() {\n    return (this.u.finallyBlocks.length > 0) ? this.u.finallyBlocks[this.u.finallyBlocks.length-1] : undefined;\n};\n\nCompiler.prototype.setupExcept = function (eb) {\n    out(\"$exc.push(\", eb, \");\");\n    //this.pushExceptBlock(eb);\n};\n\nCompiler.prototype.endExcept = function () {\n    out(\"$exc.pop();\");\n};\n\nCompiler.prototype.outputLocals = function (unit) {\n    var name;\n    var output;\n    var i;\n    var have = {};\n    //print(\"args\", unit.name.v, JSON.stringify(unit.argnames));\n    for (i = 0; unit.argnames && i < unit.argnames.length; ++i) {\n        have[unit.argnames[i]] = true;\n    }\n    unit.localnames.sort();\n    output = [];\n    for (i = 0; i < unit.localnames.length; ++i) {\n        name = unit.localnames[i];\n        if (have[name] === undefined) {\n            output.push(name);\n            have[name] = true;\n        }\n    }\n    if (output.length > 0) {\n        return \"var \" + output.join(\",\") + \"; /* locals */\";\n    }\n    return \"\";\n};\n\nCompiler.prototype.outputSuspensionHelpers = function (unit) {\n    var i, t;\n    var localSaveCode = [];\n    var localsToSave = unit.localnames.concat(unit.tempsToSave);\n    var seenTemps = {};\n    var hasCell = unit.ste.blockType === Sk.SYMTAB_CONSTS.FunctionBlock && unit.ste.childHasFree;\n    var output = (localsToSave.length > 0 ? (\"var \" + localsToSave.join(\",\") + \";\") : \"\") +\n                 \"var $wakeFromSuspension = function() {\" +\n                    \"var susp = \"+unit.scopename+\".$wakingSuspension; \"+unit.scopename+\".$wakingSuspension = undefined;\" +\n                    \"$blk=susp.$blk; $loc=susp.$loc; $gbl=susp.$gbl; $exc=susp.$exc; $err=susp.$err; $postfinally=susp.$postfinally;\" +\n                    \"$currLineNo=susp.$lineno; $currColNo=susp.$colno; Sk.lastYield=Date.now();\" +\n                    (hasCell?\"$cell=susp.$cell;\":\"\");\n\n    for (i = 0; i < localsToSave.length; i++) {\n        t = localsToSave[i];\n        if (seenTemps[t]===undefined) {\n            output += t + \"=susp.$tmps.\" + t + \";\";\n            seenTemps[t] = true;\n        }\n    }\n\n    output +=  \"try { $ret=susp.child.resume(); } catch(err) { if (!(err instanceof Sk.builtin.BaseException)) { err = new Sk.builtin.ExternalError(err); } err.traceback.push({lineno: $currLineNo, colno: $currColNo, filename: '\"+this.filename+\"'}); if($exc.length>0) { $err=err; $blk=$exc.pop(); } else { throw err; } }\" +\n                \"};\";\n\n    output += \"var $saveSuspension = function($child, $filename, $lineno, $colno) {\" +\n                \"var susp = new Sk.misceval.Suspension(); susp.child=$child;\" +\n                \"susp.resume=function(){\"+unit.scopename+\".$wakingSuspension=susp; return \"+unit.scopename+\"(\"+(unit.ste.generator?\"$gen\":\"\")+\"); };\" +\n                \"susp.data=susp.child.data;susp.$blk=$blk;susp.$loc=$loc;susp.$gbl=$gbl;susp.$exc=$exc;susp.$err=$err;susp.$postfinally=$postfinally;\" +\n                \"susp.$filename=$filename;susp.$lineno=$lineno;susp.$colno=$colno;\" +\n                \"susp.optional=susp.child.optional;\" +\n                (hasCell ? \"susp.$cell=$cell;\" : \"\");\n\n    seenTemps = {};\n    for (i = 0; i < localsToSave.length; i++) {\n        t = localsToSave[i];\n        if (seenTemps[t]===undefined) {\n            localSaveCode.push(\"\\\"\" + t + \"\\\":\" + t);\n            seenTemps[t]=true;\n        }\n    }\n    output +=   \"susp.$tmps={\" + localSaveCode.join(\",\") + \"};\" +\n                \"return susp;\" +\n              \"};\";\n\n    return output;\n}\n\nCompiler.prototype.outputAllUnits = function () {\n    var i;\n    var blocks;\n    var unit;\n    var j;\n    var ret = \"\";\n    var block;\n    var generatedBlocks;\n    for (j = 0; j < this.allUnits.length; ++j) {\n        unit = this.allUnits[j];\n        ret += unit.prefixCode;\n        ret += this.outputLocals(unit);\n        if (unit.doesSuspend) {\n            ret += this.outputSuspensionHelpers(unit);\n        }\n        ret += unit.varDeclsCode;\n        ret += unit.switchCode;\n        blocks = unit.blocks;\n        generatedBlocks = Object.create(null);\n        for (i = 0; i < blocks.length; ++i) {\n            block = i;\n            if (block in generatedBlocks)\n                continue;\n            while (true) {\n                generatedBlocks[block] = true;\n\n                ret += \"case \" + block + \": /* --- \" + blocks[block]._name + \" --- */\";\n                ret += blocks[block].join(\"\");\n\n                if (blocks[block]._next !== null) {\n                    if (!(blocks[block]._next in generatedBlocks)) {\n                        ret += \"/* allowing case fallthrough */\";\n                        block = blocks[block]._next;\n                    }\n                    else {\n                        ret += \"/* jump */ continue;\";\n                        break;\n                    }\n                }\n                else {\n                    ret += \"throw new Sk.builtin.SystemError('internal error: unterminated block');\";\n                    break;\n                }\n            }\n        }\n        ret += unit.suffixCode;\n    }\n    return ret;\n};\n\nCompiler.prototype.cif = function (s) {\n    var test;\n    var next;\n    var end;\n    var constant;\n    Sk.asserts.assert(s instanceof Sk.astnodes.If);\n    constant = this.exprConstant(s.test);\n    if (constant === 0) {\n        if (s.orelse && s.orelse.length > 0) {\n            this.vseqstmt(s.orelse);\n        }\n    }\n    else if (constant === 1) {\n        this.vseqstmt(s.body);\n    }\n    else {\n        end = this.newBlock(\"end of if\");\n        if (s.orelse && s.orelse.length > 0) {\n            next = this.newBlock(\"next branch of if\");\n        }\n\n        test = this.vexpr(s.test);\n\n        if (s.orelse && s.orelse.length > 0) {\n            this._jumpfalse(test, next);\n            this.vseqstmt(s.body);\n            this._jump(end);\n\n            this.setBlock(next);\n            this.vseqstmt(s.orelse);\n        }\n        else {\n            this._jumpfalse(test, end);\n            this.vseqstmt(s.body);\n        }\n        this._jump(end);\n        this.setBlock(end);\n    }\n\n};\n\nCompiler.prototype.cwhile = function (s) {\n    var body;\n    var orelse;\n    var next;\n    var top;\n    var constant = this.exprConstant(s.test);\n    if (constant === 0) {\n        if (s.orelse) {\n            this.vseqstmt(s.orelse);\n        }\n    }\n    else {\n        top = this.newBlock(\"while test\");\n        this._jump(top);\n        this.setBlock(top);\n\n        next = this.newBlock(\"after while\");\n        orelse = s.orelse.length > 0 ? this.newBlock(\"while orelse\") : null;\n        body = this.newBlock(\"while body\");\n\n        this.annotateSource(s);\n        this._jumpfalse(this.vexpr(s.test), orelse ? orelse : next);\n        this._jump(body);\n\n        this.pushBreakBlock(next);\n        this.pushContinueBlock(top);\n\n        this.setBlock(body);\n\n        if ((Sk.debugging || Sk.killableWhile) && this.u.canSuspend) {\n            var suspType = 'Sk.delay';\n            var debugBlock = this.newBlock(\"debug breakpoint for line \"+s.lineno);\n            out(\"if (Sk.breakpoints('\"+this.filename+\"',\"+s.lineno+\",\"+s.col_offset+\")) {\",\n                \"var $susp = $saveSuspension({data: {type: '\"+suspType+\"'}, resume: function() {}}, '\"+this.filename+\"',\"+s.lineno+\",\"+s.col_offset+\");\",\n                \"$susp.$blk = \"+debugBlock+\";\",\n                \"$susp.optional = true;\",\n                \"return $susp;\",\n                \"}\");\n            this._jump(debugBlock);\n            this.setBlock(debugBlock);\n            this.u.doesSuspend = true;\n        }\n\n        this.vseqstmt(s.body);\n\n        this._jump(top);\n\n        this.popContinueBlock();\n        this.popBreakBlock();\n\n        if (s.orelse.length > 0) {\n            this.setBlock(orelse);\n            this.vseqstmt(s.orelse);\n            this._jump(next);\n        }\n\n        this.setBlock(next);\n    }\n};\n\nCompiler.prototype.cfor = function (s) {\n    var target;\n    var nexti;\n    var iter;\n    var toiter;\n    var start = this.newBlock(\"for start\");\n    var cleanup = this.newBlock(\"for cleanup\");\n    var end = this.newBlock(\"for end\");\n\n    this.pushBreakBlock(end);\n    this.pushContinueBlock(start);\n\n    // get the iterator\n    toiter = this.vexpr(s.iter);\n    if (this.u.ste.generator) {\n        // if we're in a generator, we have to store the iterator to a local\n        // so it's preserved (as we cross blocks here and assume it survives)\n        iter = \"$loc.\" + this.gensym(\"iter\");\n        out(iter, \"=Sk.abstr.iter(\", toiter, \");\");\n    }\n    else {\n        iter = this._gr(\"iter\", \"Sk.abstr.iter(\", toiter, \")\");\n        this.u.tempsToSave.push(iter); // Save it across suspensions\n    }\n\n    this._jump(start);\n\n    this.setBlock(start);\n\n    // load targets\n    out (\"$ret = Sk.abstr.iternext(\", iter,(this.u.canSuspend?\", true\":\", false\"),\");\");\n\n    this._checkSuspension(s);\n\n    nexti = this._gr(\"next\", \"$ret\");\n    this._jumpundef(nexti, cleanup); // todo; this should be handled by StopIteration\n    target = this.vexpr(s.target, nexti);\n\n    if ((Sk.debugging || Sk.killableFor) && this.u.canSuspend) {\n        var suspType = 'Sk.delay';\n        var debugBlock = this.newBlock(\"debug breakpoint for line \"+s.lineno);\n        out(\"if (Sk.breakpoints('\"+this.filename+\"',\"+s.lineno+\",\"+s.col_offset+\")) {\",\n            \"var $susp = $saveSuspension({data: {type: '\"+suspType+\"'}, resume: function() {}}, '\"+this.filename+\"',\"+s.lineno+\",\"+s.col_offset+\");\",\n            \"$susp.$blk = \"+debugBlock+\";\",\n            \"$susp.optional = true;\",\n            \"return $susp;\",\n            \"}\");\n        this._jump(debugBlock);\n        this.setBlock(debugBlock);\n        this.u.doesSuspend = true;\n    }\n\n    // execute body\n    this.vseqstmt(s.body);\n\n    // jump to top of loop\n    this._jump(start);\n\n    this.setBlock(cleanup);\n    this.popContinueBlock();\n    this.popBreakBlock();\n\n    this.vseqstmt(s.orelse);\n    this._jump(end);\n\n    this.setBlock(end);\n};\n\nCompiler.prototype.craise = function (s) {\n    if (s.exc) {\n        var exc = this._gr(\"exc\", this.vexpr(s.exc));\n        // This is tricky - we're supporting both the weird-ass semantics\n        // of the Python 2 \"raise (exc), (inst), (tback)\" version,\n        // plus the sensible Python \"raise (exc) from (cause)\".\n        // ast.js takes care of ensuring that you can only use the right one\n        // for the Python version you're using.\n\n        var instantiatedException = this.newBlock(\"exception now instantiated\");\n        var isClass = this._gr(\"isclass\", exc + \" instanceof Sk.builtin.type || \" + exc + \".prototype instanceof Sk.builtin.BaseException\");\n        this._jumpfalse(isClass, instantiatedException);\n        //this._jumpfalse(instantiatedException, isClass);\n\n        // Instantiate exc with inst\n        if (s.inst) {\n            var inst = this._gr(\"inst\", this.vexpr(s.inst));\n            out(\"if(!(\",inst,\" instanceof Sk.builtin.tuple)) {\",\n                inst,\"= new Sk.builtin.tuple([\",inst,\"]);\",\n                \"}\");\n            out(\"$ret = Sk.misceval.callsimOrSuspendArray(\",exc,\",\",inst,\".v);\");\n        } else {\n            out(\"$ret = Sk.misceval.callsimOrSuspend(\",exc,\");\");\n        }\n        this._checkSuspension(s);\n        out(exc,\"=$ret;\");\n\n        this._jump(instantiatedException);\n\n        this.setBlock(instantiatedException);\n\n        // TODO TODO TODO set cause appropriately\n        // (and perhaps traceback for py2 if we care before it gets fully deprecated)\n\n        out(\"throw \",exc,\";\");\n    }\n    else {\n        // re-raise\n        out(\"throw $err;\");\n    }\n};\n\nCompiler.prototype.outputFinallyCascade = function (thisFinally) {\n    var nextFinally;\n\n    // What do we do when we're done executing a 'finally' block?\n    // Normally you just fall off the end. If we're 'return'ing,\n    // 'continue'ing or 'break'ing, $postfinally tells us what to do.\n    //\n    // But we might be in a nested pair of 'finally' blocks. If so, we need\n    // to work out whether to jump to the outer finally block.\n    //\n    // (NB we do NOT deal with re-raising exceptions here. That's handled\n    // elsewhere, because 'with' does special things with exceptions.)\n\n    if (this.u.finallyBlocks.length == 0) {\n        // No nested 'finally' block. Easy.\n        out(\"if($postfinally!==undefined) { if ($postfinally.returning) { return $postfinally.returning; } else { $blk=$postfinally.gotoBlock; $postfinally=undefined; continue; } }\");\n    } else {\n\n        // OK, we're nested. Do we jump straight to the outer 'finally' block?\n        // Depends on how we got here here.\n\n        // Normal execution ($postfinally===undefined)? No, we're done here.\n\n        // Returning ($postfinally.returning)? Yes, we want to execute all the\n        // 'finally' blocks on the way out.\n\n        // Breaking ($postfinally.isBreak)? It depends. Is the outer 'finally'\n        // block inside or outside the loop we're breaking out of? We compare\n        // its breakDepth to ours to find out. If we're at the same breakDepth,\n        // we're both inside the innermost loop, so we both need to execute.\n        // ('continue' is the same thing as 'break' for us)\n\n        nextFinally = this.peekFinallyBlock();\n\n        out(\"if($postfinally!==undefined) {\",\n                \"if ($postfinally.returning\",\n                    (nextFinally.breakDepth == thisFinally.breakDepth) ? \"|| $postfinally.isBreak\" : \"\", \") {\",\n\n                        \"$blk=\",nextFinally.blk,\";continue;\",\n                \"} else {\",\n                    \"$blk=$postfinally.gotoBlock;$postfinally=undefined;continue;\",\n                \"}\",\n            \"}\");\n    }\n};\n\nCompiler.prototype.ctry = function (s) {\n    var check;\n    var next;\n    var handlertype;\n    var handler;\n    var end;\n    var orelse;\n    var unhandled;\n    var i;\n    var n = s.handlers.length;\n\n    var finalBody, finalExceptionHandler, finalExceptionToReRaise;\n    var thisFinally;\n\n    if (s.finalbody) {\n        finalBody = this.newBlock(\"finalbody\");\n        finalExceptionHandler = this.newBlock(\"finalexh\")\n        finalExceptionToReRaise = this._gr(\"finally_reraise\", \"undefined\");\n\n        this.u.tempsToSave.push(finalExceptionToReRaise);\n        this.pushFinallyBlock(finalBody);\n        thisFinally = this.peekFinallyBlock();\n        this.setupExcept(finalExceptionHandler);\n    }\n\n    // Create a block for each except clause\n    var handlers = [];\n    for (i = 0; i < n; ++i) {\n        handlers.push(this.newBlock(\"except_\" + i + \"_\"));\n    }\n\n    unhandled = this.newBlock(\"unhandled\");\n    orelse = this.newBlock(\"orelse\");\n    end = this.newBlock(\"end\");\n\n    if (handlers.length != 0) {\n        this.setupExcept(handlers[0]);\n    }\n    this.vseqstmt(s.body);\n    if (handlers.length != 0) {\n        this.endExcept();\n    }\n    this._jump(orelse);\n\n    for (i = 0; i < n; ++i) {\n        this.setBlock(handlers[i]);\n        handler = s.handlers[i];\n        if (!handler.type && i < n - 1) {\n            throw new SyntaxError(\"default 'except:' must be last\");\n        }\n\n        if (handler.type) {\n            // should jump to next handler if err not isinstance of handler.type\n            handlertype = this.vexpr(handler.type);\n            next = (i == n - 1) ? unhandled : handlers[i + 1];\n\n            // var isinstance = this.nameop(new Sk.builtin.str(\"isinstance\"), Load));\n            // var check = this._gr('call', \"Sk.misceval.callsimArray(\", isinstance, \", [$err, \", handlertype, \"])\");\n\n            check = this._gr(\"instance\", \"Sk.misceval.isTrue(Sk.builtin.isinstance($err, \", handlertype, \"))\");\n            this._jumpfalse(check, next);\n        }\n\n        if (handler.name) {\n            this.vexpr(handler.name, \"$err\");\n        }\n\n        this.vseqstmt(handler.body);\n\n        this._jump(end);\n    }\n\n    // If no except clause catches exception, throw it again\n    this.setBlock(unhandled);\n    out(\"throw $err;\");\n\n    this.setBlock(orelse);\n    this.vseqstmt(s.orelse);\n    this._jump(end);\n\n    this.setBlock(end);\n    // End of the try/catch/else segment\n    if (s.finalbody) {\n        this.endExcept();\n\n        this._jump(finalBody);\n\n        this.setBlock(finalExceptionHandler);\n        // Exception handling also goes to the finally body,\n        // stashing the original exception to re-raise\n        out(finalExceptionToReRaise,\"=$err;\");\n        this._jump(finalBody);\n\n        this.setBlock(finalBody);\n        this.popFinallyBlock();\n        this.vseqstmt(s.finalbody);\n        // If finalbody executes normally, AND we have an exception\n        // to re-raise, we raise it.\n        out(\"if(\",finalExceptionToReRaise,\"!==undefined) { throw \",finalExceptionToReRaise,\";}\");\n\n        this.outputFinallyCascade(thisFinally);\n        // Else, we continue from here.\n    }\n};\n\nCompiler.prototype.cwith = function (s, itemIdx) {\n    var mgr, exit, value, exception;\n    var exceptionHandler = this.newBlock(\"withexh\"), tidyUp = this.newBlock(\"withtidyup\");\n    var carryOn = this.newBlock(\"withcarryon\");\n    var thisFinallyBlock;\n\n    // NB this does not *quite* match the semantics in PEP 343, which\n    // specifies \"exit = type(mgr).__exit__\" rather than getattr()ing,\n    // presumably for performance reasons.\n\n    mgr = this._gr(\"mgr\", this.vexpr(s.items[itemIdx].context_expr));\n\n    // exit = mgr.__exit__\n    out(\"$ret = Sk.abstr.gattr(\",mgr,\",Sk.builtin.str.$exit, true);\");\n    this._checkSuspension(s);\n    exit = this._gr(\"exit\", \"$ret\");\n    this.u.tempsToSave.push(exit);\n\n    // value = mgr.__enter__()\n    out(\"$ret = Sk.abstr.gattr(\",mgr,\",Sk.builtin.str.$enter, true);\");\n    this._checkSuspension(s);\n    out(\"$ret = Sk.misceval.callsimOrSuspendArray($ret);\");\n    this._checkSuspension(s);\n    value = this._gr(\"value\", \"$ret\");\n\n    // try:\n    this.pushFinallyBlock(tidyUp);\n    thisFinallyBlock = this.u.finallyBlocks[this.u.finallyBlocks.length-1];\n    this.setupExcept(exceptionHandler);\n\n    //    VAR = value\n    if (s.items[itemIdx].optional_vars) {\n        this.nameop(s.items[itemIdx].optional_vars.id, Sk.astnodes.Store, value);\n    }\n\n    //    (try body)\n\n    if (itemIdx +1 < s.items.length) {\n        // \"with\" statements with multiple items (context managers) are\n        // treated as nested \"with\" statements\n        this.cwith(s, itemIdx + 1);\n    } else {\n        this.vseqstmt(s.body);\n    }\n\n    this.endExcept();\n    this._jump(tidyUp);\n\n    // except:\n    this.setBlock(exceptionHandler);\n\n    //   if not exit(*sys.exc_info()):\n    //     raise\n    out(\"$ret = Sk.misceval.applyOrSuspend(\",exit,\",undefined,Sk.builtin.getExcInfo($err),undefined,[]);\");\n    this._checkSuspension(s);\n    this._jumptrue(\"$ret\", carryOn);\n    out(\"throw $err;\");\n\n    // finally: (kinda. NB that this is a \"finally\" that doesn't run in the\n    //           exception case!)\n    this.setBlock(tidyUp);\n    this.popFinallyBlock();\n\n    //   exit(None, None, None)\n    out(\"$ret = Sk.misceval.callsimOrSuspendArray(\",exit,\",[Sk.builtin.none.none$,Sk.builtin.none.none$,Sk.builtin.none.none$]);\");\n    this._checkSuspension(s);\n    // Ignore $ret.\n\n    this.outputFinallyCascade(thisFinallyBlock);\n\n    this._jump(carryOn);\n\n    this.setBlock(carryOn);\n};\n\nCompiler.prototype.cassert = function (s) {\n    /* todo; warnings method\n     if (s.test instanceof Tuple && s.test.elts.length > 0)\n     Sk.warn(\"assertion is always true, perhaps remove parentheses?\");\n     */\n\n    var test = this.vexpr(s.test);\n    var end = this.newBlock(\"end\");\n    this._jumptrue(test, end);\n    // todo; exception handling\n    // maybe replace with Sk.asserts.fail?? or just an alert?\n    out(\"throw new Sk.builtin.AssertionError(\", s.msg ? this.vexpr(s.msg) : \"\", \");\");\n    this.setBlock(end);\n};\n\nCompiler.prototype.cimportas = function (name, asname, mod) {\n    var attr;\n    var src = name.v;\n    var dotLoc = src.indexOf(\".\");\n    //print(\"src\", src);\n    //print(\"dotLoc\", dotLoc);\n    var cur = mod;\n    if (dotLoc !== -1) {\n        // if there's dots in the module name, __import__ will have returned\n        // the top-level module. so, we need to extract the actual module by\n        // getattr'ing up through the names, and then storing the leaf under\n        // the name it was to be imported as.\n        src = src.substr(dotLoc + 1);\n        //print(\"src now\", src);\n        while (dotLoc !== -1) {\n            dotLoc = src.indexOf(\".\");\n            attr = dotLoc !== -1 ? src.substr(0, dotLoc) : src;\n            cur = this._gr(\"lattr\", \"Sk.abstr.gattr(\", cur, \", new Sk.builtin.str('\", attr, \"'))\");\n            src = src.substr(dotLoc + 1);\n        }\n    }\n    return this.nameop(asname, Sk.astnodes.Store, cur);\n};\n\nCompiler.prototype.cimport = function (s) {\n    var lastDot;\n    var tmp;\n    var mod;\n    var alias;\n    var i;\n    var n = s.names.length;\n    for (i = 0; i < n; ++i) {\n        alias = s.names[i];\n        out(\"$ret = Sk.builtin.__import__(\", alias.name[\"$r\"]().v, \",$gbl,$loc,[],\",(Sk.__future__.absolute_import?0:-1),\");\");\n\n        this._checkSuspension(s);\n\n        mod = this._gr(\"module\", \"$ret\");\n\n        if (alias.asname) {\n            this.cimportas(alias.name, alias.asname, mod);\n        }\n        else {\n            tmp = alias.name;\n            lastDot = tmp.v.indexOf(\".\");\n            if (lastDot !== -1) {\n                tmp = new Sk.builtin.str(tmp.v.substr(0, lastDot));\n            }\n            this.nameop(tmp, Sk.astnodes.Store, mod);\n        }\n    }\n};\n\nCompiler.prototype.cfromimport = function (s) {\n    var storeName;\n    var got;\n    var alias;\n    var aliasOut;\n    var mod;\n    var i;\n    var n = s.names.length;\n    var names = [];\n    var level = s.level;\n    if (level == 0 && !Sk.__future__.absolute_import) {\n        level = -1;\n    }\n    for (i = 0; i < n; ++i) {\n        names[i] = \"'\" + fixReservedWords(s.names[i].name.v) + \"'\";\n    }\n    out(\"$ret = Sk.builtin.__import__(\", s.module[\"$r\"]().v, \",$gbl,$loc,[\", names, \"],\",level,\");\");\n\n    this._checkSuspension(s);\n\n    //out(\"print('__import__ returned ' + $ret);\");\n    //out(\"for (var x in $ret) { print(x); }\");\n    mod = this._gr(\"module\", \"$ret\");\n    for (i = 0; i < n; ++i) {\n        alias = s.names[i];\n        aliasOut = \"'\" + fixReservedWords(alias.name.v) + \"'\";\n        if (i === 0 && alias.name.v === \"*\") {\n            Sk.asserts.assert(n === 1);\n            out(\"Sk.importStar(\", mod, \",$loc, $gbl);\");\n            return;\n        }\n\n        //out(\"print(\\\"getting Sk.abstr.gattr(\", mod, \",\", alias.name[\"$r\"]().v, \")\\\");\");\n        got = this._gr(\"item\", \"Sk.abstr.gattr(\", mod, \", new Sk.builtin.str(\", aliasOut, \"))\");\n        //out(\"print('got');\");\n        storeName = alias.name;\n        if (alias.asname) {\n            storeName = alias.asname;\n        }\n        this.nameop(storeName, Sk.astnodes.Store, got);\n    }\n};\n\n/**\n * builds a code object (js function) for various constructs. used by def,\n * lambda, generator expressions. it isn't used for class because it seemed\n * different enough.\n *\n * handles:\n * - setting up a new scope\n * - decorators (if any)\n * - defaults setup\n * - setup for cell and free vars\n * - setup and modification for generators\n *\n * @param {Object} n ast node to build for\n * @param {Sk.builtin.str} coname name of code object to build\n * @param {Array} decorator_list ast of decorators if any\n * @param {Sk.astnodes.arguments_} args arguments to function, if any\n * @param {Function} callback called after setup to do actual work of function\n * @param {Sk.builtin.str=} class_for_super\n *\n * @returns the name of the newly created function or generator object.\n *\n */\nCompiler.prototype.buildcodeobj = function (n, coname, decorator_list, args, callback, class_for_super) {\n    var containingHasFree;\n    var frees;\n    var argnamesarr = [];\n    var start;\n    var kw;\n    var maxargs;\n    var minargs;\n    var id;\n    var argname;\n    var offset;\n    var cells;\n    var locals;\n    var i;\n    var funcArgs;\n    var entryBlock;\n    var hasCell;\n    var hasFree;\n    var isGenerator;\n    var scopename;\n    var decos = [];\n    var defaults = [];\n    var kw_defaults = [];\n    var vararg = null;\n    var kwarg = null;\n\n    // decorators and defaults have to be evaluated out here before we enter\n    // the new scope. we output the defaults and attach them to this code\n    // object, but only once we know the name of it (so we do it after we've\n    // exited the scope near the end of this function).\n    if (decorator_list) {\n        decos = this.vseqexpr(decorator_list);\n    }\n    if (args && args.defaults) {\n        defaults = this.vseqexpr(args.defaults);\n    }\n    if (args && args.kw_defaults) {\n        kw_defaults = args.kw_defaults.map(e => e ? this.vexpr(e) : 'undefined');\n    }\n    if (args && args.vararg) {\n        vararg = args.vararg;\n    }\n    if (args && args.kwarg) {\n        kwarg = args.kwarg;\n    }\n    if (!Sk.__future__.python3 && args && args.kwonlyargs && args.kwonlyargs.length != 0) {\n        throw new Sk.builtin.SyntaxError(\"Keyword-only arguments are not supported in Python 2\");\n    }\n\n    //\n    // enter the new scope, and create the first block\n    //\n    scopename = this.enterScope(coname, n, n.lineno, this.canSuspend);\n\n    isGenerator = this.u.ste.generator;\n    hasFree = this.u.ste.hasFree;\n    hasCell = this.u.ste.childHasFree;\n\n    entryBlock = this.newBlock(\"codeobj entry\");\n\n    //\n    // the header of the function, and arguments\n    //\n    this.u.prefixCode = \"var \" + scopename + \"=(function \" + this.niceName(coname.v) + \"$(\";\n\n    funcArgs = [];\n    if (isGenerator) {\n        // TODO make generators deal with arguments properly\n        if (kwarg) {\n            throw new SyntaxError(coname.v + \"(): keyword arguments in generators not supported\");\n        }\n        if (vararg) {\n            throw new SyntaxError(coname.v + \"(): variable number of arguments in generators not supported\");\n        }\n        funcArgs.push(\"$gen\");\n    }\n    else {\n        if (kwarg) {\n            funcArgs.push(\"$kwa\");\n            this.u.tempsToSave.push(\"$kwa\");\n        }\n        for (i = 0; args && i < args.args.length; ++i) {\n            funcArgs.push(this.nameop(args.args[i].arg, Sk.astnodes.Param));\n        }\n        for (i = 0; args && args.kwonlyargs && i < args.kwonlyargs.length; ++i) {\n            funcArgs.push(this.nameop(args.kwonlyargs[i].arg, Sk.astnodes.Param));\n        }\n        if (vararg) {\n            funcArgs.push(this.nameop(args.vararg.arg, Sk.astnodes.Param));\n        }\n    }\n    if (hasFree) {\n        funcArgs.push(\"$free\");\n        this.u.tempsToSave.push(\"$free\");\n    }\n\n    this.u.prefixCode += funcArgs.join(\",\");\n\n    this.u.prefixCode += \"){\";\n\n    if (isGenerator) {\n        this.u.prefixCode += \"\\n// generator\\n\";\n    }\n    if (hasFree) {\n        this.u.prefixCode += \"\\n// has free\\n\";\n    }\n    if (hasCell) {\n        this.u.prefixCode += \"\\n// has cell\\n\";\n    }\n\n    //\n    // set up standard dicts/variables\n    //\n    locals = \"{}\";\n    if (isGenerator) {\n        entryBlock = \"$gen.gi$resumeat\";\n        locals = \"$gen.gi$locals\";\n    }\n    cells = \",$cell={}\";\n    if (hasCell) {\n        if (isGenerator) {\n            cells = \",$cell=$gen.gi$cells\";\n        }\n    }\n\n    // note special usage of 'this' to avoid having to slice globals into\n    // all function invocations in call\n    this.u.varDeclsCode += \"var $blk=\" + entryBlock + \",$exc=[],$loc=\" + locals + cells + \",$gbl=this,$err=undefined,$ret=undefined,$postfinally=undefined,$currLineNo=undefined,$currColNo=undefined;\";\n    if (Sk.execLimit !== null) {\n        this.u.varDeclsCode += \"if (typeof Sk.execStart === 'undefined') {Sk.execStart = Date.now()}\";\n    }\n    if (Sk.yieldLimit !== null && this.u.canSuspend) {\n        this.u.varDeclsCode += \"if (typeof Sk.lastYield === 'undefined') {Sk.lastYield = Date.now()}\";\n    }\n\n    //\n    // If there is a suspension, resume from it. Otherwise, initialise\n    // parameters appropriately.\n    //\n    this.u.varDeclsCode += \"if (\"+scopename+\".$wakingSuspension!==undefined) { $wakeFromSuspension(); } else {\";\n\n    // TODO update generators to do their arg checks in outside generated code,\n    // like functions do\n    //\n    // this could potentially get removed if generators would learn to deal with args, kw, kwargs, varargs\n    // initialize default arguments. we store the values of the defaults to\n    // this code object as .$defaults just below after we exit this scope.\n    //\n    if (isGenerator && defaults.length > 0) {\n        // defaults have to be \"right justified\" so if there's less defaults\n        // than args we offset to make them match up (we don't need another\n        // correlation in the ast)\n        offset = args.args.length - defaults.length;\n        for (i = 0; i < defaults.length; ++i) {\n            argname = this.nameop(args.args[i + offset].arg, Sk.astnodes.Param);\n            this.u.varDeclsCode += \"if(\" + argname + \"===undefined)\" + argname + \"=\" + scopename + \".$defaults[\" + i + \"];\";\n        }\n    }\n\n    //\n    // copy all parameters that are also cells into the cells dict. this is so\n    // they can be accessed correctly by nested scopes.\n    //\n    for (i = 0; args && i < args.args.length; ++i) {\n        id = args.args[i].arg;\n        if (this.isCell(id)) {\n            this.u.varDeclsCode += \"$cell.\" + id.v + \"=\" + id.v + \";\";\n        }\n    }\n    for (i = 0; args && args.kwonlyargs && i < args.kwonlyargs.length; ++i) {\n        id = args.kwonlyargs[i].arg;\n        if (this.isCell(id)) {\n            this.u.varDeclsCode += \"$cell.\" + id.v + \"=\" + id.v + \";\";\n        }\n    }\n    if (vararg && this.isCell(vararg.arg)) {\n        this.u.varDeclsCode += \"$cell.\" + vararg.arg.v + \"=\" + vararg.arg.v + \";\";\n    }\n\n    //\n    // initialize kwarg, if any\n    //\n    if (kwarg) {\n        this.u.localnames.push(kwarg.arg.v);\n        this.u.varDeclsCode += kwarg.arg.v + \"=new Sk.builtins['dict']($kwa);\";\n        if (this.isCell(kwarg.arg)) {\n            this.u.varDeclsCode += \"$cell.\" + kwarg.arg.v + \"=\" + kwarg.arg.v + \";\";\n        }\n    }\n\n    //\n    // close the else{} block from the wakingSuspension check\n    //\n    this.u.varDeclsCode += \"}\";\n\n    // inject __class__ cell when running python3\n    if (Sk.python3 && class_for_super) {\n        this.u.varDeclsCode += \"$gbl.__class__=this.\" + class_for_super.v + \";\";\n    }\n\n    // finally, set up the block switch that the jump code expects\n    //\n    // Old switch code\n    // this.u.switchCode += \"while(true){switch($blk){\";\n    // this.u.suffixCode = \"}break;}});\";\n\n    // New switch code to catch exceptions\n    this.u.switchCode = \"while(true){try{\"\n    this.u.switchCode += this.outputInterruptTest();\n    this.u.switchCode += \"switch($blk){\";\n    this.u.suffixCode = \"} }catch(err){ if (!(err instanceof Sk.builtin.BaseException)) { err = new Sk.builtin.ExternalError(err); } err.traceback.push({lineno: $currLineNo, colno: $currColNo, filename: '\"+this.filename+\"'}); if ($exc.length>0) { $err = err; $blk=$exc.pop(); continue; } else { throw err; }} }});\";\n\n    //\n    // jump back to the handler so it can do the main actual work of the\n    // function\n    //\n    callback.call(this, scopename);\n\n    //\n    // get a list of all the argument names (used to attach to the code\n    // object, and also to allow us to declare only locals that aren't also\n    // parameters).\n    if (args) {\n        for (let arg of args.args) {\n            argnamesarr.push(arg.arg.v);\n        }\n        for (let arg of args.kwonlyargs || []) {\n            argnamesarr.push(arg.arg.v);\n        }\n\n        // store to unit so we know what local variables not to declare\n        this.u.argnames = argnamesarr;\n    }\n\n    //\n    // and exit the code object scope\n    //\n    this.exitScope();\n\n    //\n    // attach the default values we evaluated at the beginning to the code\n    // object so that it can get at them to set any arguments that are left\n    // unset.\n    //\n    if (defaults.length > 0) {\n        out(scopename, \".$defaults=[\", defaults.join(\",\"), \"];\");\n    }\n    if (args && args.kwonlyargs && args.kwonlyargs.length > 0) {\n        out(scopename, \".co_argcount=\", args.args.length, \";\");\n        out(scopename, \".co_kwonlyargcount=\", args.kwonlyargs.length, \";\");\n        out(scopename, \".$kwdefs=[\", kw_defaults.join(\",\"), \"];\");\n    }\n\n    if (decos.length > 0) {\n        out(scopename, \".$decorators=[\", decos.join(\",\"), \"];\");\n    }\n\n    //\n    // attach co_varnames (only the argument names) for keyword argument\n    // binding.\n    //\n    if (argnamesarr.length > 0) {\n        out(scopename, \".co_varnames=['\", argnamesarr.join(\"','\"), \"'];\");\n    } else {\n        out(scopename, \".co_varnames=[];\");\n    }\n\n    //\n    // attach flags\n    //\n    if (kwarg) {\n        out(scopename, \".co_kwargs=1;\");\n    }\n    if (vararg) {\n        out(scopename, \".co_varargs=1;\");\n    }\n\n    //\n    // build either a 'function' or 'generator'. the function is just a simple\n    // constructor call. the generator is more complicated. it needs to make a\n    // new generator every time it's called, so the thing that's returned is\n    // actually a function that makes the generator (and passes arguments to\n    // the function onwards to the generator). this should probably actually\n    // be a function object, rather than a js function like it is now. we also\n    // have to build the argument names to pass to the generator because it\n    // needs to store all locals into itself so that they're maintained across\n    // yields.\n    //\n    // todo; possibly this should be outside?\n    //\n    frees = \"\";\n    if (hasFree) {\n        frees = \",$cell\";\n        // if the scope we're in where we're defining this one has free\n        // vars, they may also be cell vars, so we pass those to the\n        // closure too.\n        containingHasFree = this.u.ste.hasFree;\n        if (containingHasFree) {\n            frees += \",$free\";\n        }\n    }\n    if (isGenerator)\n    // Keyword and variable arguments are not currently supported in generators.\n    // The call to pyCheckArgs assumes they can't be true.\n    {\n        if (args && args.args.length > 0) {\n            return this._gr(\"gener\", \"new Sk.builtins['function']((function(){var $origargs=Array.prototype.slice.call(arguments);Sk.builtin.pyCheckArgsLen(\\\"\",\n                coname.v, \"\\\",arguments.length,\", args.args.length - defaults.length, \",\", args.args.length,\n                \");return new Sk.builtins['generator'](\", scopename, \",$gbl,$origargs\", frees, \");}))\");\n        }\n        else {\n            return this._gr(\"gener\", \"new Sk.builtins['function']((function(){Sk.builtin.pyCheckArgsLen(\\\"\", coname.v,\n                \"\\\",arguments.length,0,0);return new Sk.builtins['generator'](\", scopename, \",$gbl,[]\", frees, \");}))\");\n        }\n    }\n    else {\n        var res;\n        if (decos.length > 0) {\n            out(\"$ret = Sk.misceval.callsimOrSuspendArray(\", scopename, \".$decorators[0], [new Sk.builtins['function'](\", scopename, \",$gbl\", frees, \")]);\");\n            this._checkSuspension();\n            return this._gr(\"funcobj\", \"$ret\");\n        }\n\n        return this._gr(\"funcobj\", \"new Sk.builtins['function'](\", scopename, \",$gbl\", frees, \")\");\n    }\n};\n\nCompiler.prototype.cfunction = function (s, class_for_super) {\n    var funcorgen;\n    Sk.asserts.assert(s instanceof Sk.astnodes.FunctionDef);\n    funcorgen = this.buildcodeobj(s, s.name, s.decorator_list, s.args, function (scopename) {\n        this.vseqstmt(s.body);\n        out(\"return Sk.builtin.none.none$;\"); // if we fall off the bottom, we want the ret to be None\n    }, class_for_super);\n    this.nameop(s.name, Sk.astnodes.Store, funcorgen);\n};\n\nCompiler.prototype.clambda = function (e) {\n    var func;\n    Sk.asserts.assert(e instanceof Sk.astnodes.Lambda);\n    func = this.buildcodeobj(e, new Sk.builtin.str(\"<lambda>\"), null, e.args, function (scopename) {\n        var val = this.vexpr(e.body);\n        out(\"return \", val, \";\");\n    });\n    return func;\n};\n\nCompiler.prototype.cifexp = function (e) {\n    var next = this.newBlock(\"next of ifexp\");\n    var end = this.newBlock(\"end of ifexp\");\n    var ret = this._gr(\"res\", \"null\");\n\n    var test = this.vexpr(e.test);\n    this._jumpfalse(test, next);\n\n    out(ret, \"=\", this.vexpr(e.body), \";\");\n    this._jump(end);\n\n    this.setBlock(next);\n    out(ret, \"=\", this.vexpr(e.orelse), \";\");\n    this._jump(end);\n\n    this.setBlock(end);\n    return ret;\n};\n\nCompiler.prototype.cgenexpgen = function (generators, genIndex, elt) {\n    var velt;\n    var ifres;\n    var i;\n    var n;\n    var target;\n    var nexti;\n    var toiter;\n    var start = this.newBlock(\"start for \" + genIndex);\n    var skip = this.newBlock(\"skip for \" + genIndex);\n    var ifCleanup = this.newBlock(\"if cleanup for \" + genIndex);\n    var end = this.newBlock(\"end for \" + genIndex);\n\n    var ge = generators[genIndex];\n\n    var iter;\n    if (genIndex === 0) {\n        // the outer most iterator is evaluated in the scope outside so we\n        // have to evaluate it outside and store it into the generator as a\n        // local, which we retrieve here.\n        iter = \"$loc.$iter0\";\n    }\n    else {\n        toiter = this.vexpr(ge.iter);\n        iter = \"$loc.\" + this.gensym(\"iter\");\n        out(iter, \"=\", \"Sk.abstr.iter(\", toiter, \");\");\n    }\n    this._jump(start);\n    this.setBlock(start);\n\n    this.annotateSource(elt);\n\n    // load targets\n    out (\"$ret = Sk.abstr.iternext(\", iter,(this.u.canSuspend?\", true\":\", false\"),\");\");\n\n    this._checkSuspension(elt);\n\n    nexti = this._gr(\"next\", \"$ret\");\n    this._jumpundef(nexti, end); // todo; this should be handled by StopIteration\n    target = this.vexpr(ge.target, nexti);\n\n    n = ge.ifs ? ge.ifs.length : 0;\n    for (i = 0; i < n; ++i) {\n        this.annotateSource(ge.ifs[i]);\n\n        ifres = this.vexpr(ge.ifs[i]);\n        this._jumpfalse(ifres, start);\n    }\n\n    if (++genIndex < generators.length) {\n        this.cgenexpgen(generators, genIndex, elt);\n    }\n\n    if (genIndex >= generators.length) {\n        this.annotateSource(elt);\n\n        velt = this.vexpr(elt);\n        out(\"return [\", skip, \"/*resume*/,\", velt, \"/*ret*/];\");\n        this.setBlock(skip);\n    }\n\n    this._jump(start);\n\n    this.setBlock(end);\n\n    if (genIndex === 1) {\n        out(\"return Sk.builtin.none.none$;\");\n    }\n};\n\nCompiler.prototype.cgenexp = function (e) {\n    var gen = this.buildcodeobj(e, new Sk.builtin.str(\"<genexpr>\"), null, null, function (scopename) {\n        this.cgenexpgen(e.generators, 0, e.elt);\n    });\n\n    // call the generator maker to get the generator. this is kind of dumb,\n    // but the code builder builds a wrapper that makes generators for normal\n    // function generators, so we just do it outside (even just new'ing it\n    // inline would be fine).\n    var gener = this._gr(\"gener\", \"Sk.misceval.callsimArray(\", gen, \");\");\n    // stuff the outermost iterator into the generator after evaluating it\n    // outside of the function. it's retrieved by the fixed name above.\n    out(gener, \".gi$locals.$iter0=Sk.abstr.iter(\", this.vexpr(e.generators[0].iter), \");\");\n    return gener;\n};\n\n\nCompiler.prototype.cclass = function (s) {\n    var wrapped;\n    var entryBlock;\n    var scopename;\n    var bases;\n    var decos;\n    Sk.asserts.assert(s instanceof Sk.astnodes.ClassDef);\n    decos = s.decorator_list;\n\n    // decorators and bases need to be eval'd out here\n    //this.vseqexpr(decos);\n\n    bases = this.vseqexpr(s.bases);\n\n    scopename = this.enterScope(s.name, s, s.lineno);\n    entryBlock = this.newBlock(\"class entry\");\n\n    this.u.prefixCode = \"var \" + scopename + \"=(function $\" + s.name.v + \"$class_outer($globals,$locals,$cell){var $gbl=$globals,$loc=$locals;$free=$globals;\";\n    this.u.switchCode += \"(function $\" + s.name.v + \"$_closure($cell){\";\n    this.u.switchCode += \"var $blk=\" + entryBlock + \",$exc=[],$ret=undefined,$postfinally=undefined,$currLineNo=undefined,$currColNo=undefined;\"\n\n    if (Sk.execLimit !== null) {\n        this.u.switchCode += \"if (typeof Sk.execStart === 'undefined') {Sk.execStart = Date.now()}\";\n    }\n    if (Sk.yieldLimit !== null && this.u.canSuspend) {\n        this.u.switchCode += \"if (typeof Sk.lastYield === 'undefined') {Sk.lastYield = Date.now()}\";\n    }\n\n    this.u.switchCode += \"while(true){try{\";\n    this.u.switchCode += this.outputInterruptTest();\n    this.u.switchCode += \"switch($blk){\";\n    this.u.suffixCode = \"}}catch(err){ if (!(err instanceof Sk.builtin.BaseException)) { err = new Sk.builtin.ExternalError(err); } err.traceback.push({lineno: $currLineNo, colno: $currColNo, filename: '\"+this.filename+\"'}); if ($exc.length>0) { $err = err; $blk=$exc.pop(); continue; } else { throw err; }}}\"\n    this.u.suffixCode += \"}).call(null, $cell);});\";\n\n    this.u.private_ = s.name;\n\n    this.cbody(s.body, s.name);\n    out(\"return;\");\n\n    // build class\n\n    // apply decorators\n\n    this.exitScope();\n\n    // todo; metaclass\n    wrapped = this._gr(\"built\", \"Sk.misceval.buildClass($gbl,\", scopename, \",\", s.name[\"$r\"]().v, \",[\", bases, \"], $cell)\");\n\n    // store our new class under the right name\n    this.nameop(s.name, Sk.astnodes.Store, wrapped);\n};\n\nCompiler.prototype.ccontinue = function (s) {\n    var nextFinally = this.peekFinallyBlock(), gotoBlock;\n    if (this.u.continueBlocks.length == 0) {\n        throw new SyntaxError(\"'continue' outside loop\");\n    }\n    // todo; continue out of exception blocks\n    gotoBlock = this.u.continueBlocks[this.u.continueBlocks.length - 1];\n    Sk.asserts.assert(this.u.breakBlocks.length === this.u.continueBlocks.length);\n    if (nextFinally && nextFinally.breakDepth == this.u.continueBlocks.length) {\n        out(\"$postfinally={isBreak:true,gotoBlock:\",gotoBlock,\"};\");\n    } else {\n        this._jump(gotoBlock);\n    }\n};\n\nCompiler.prototype.cbreak = function (s) {\n    var nextFinally = this.peekFinallyBlock(), gotoBlock;\n\n    if (this.u.breakBlocks.length === 0) {\n        throw new SyntaxError(\"'break' outside loop\");\n    }\n    gotoBlock = this.u.breakBlocks[this.u.breakBlocks.length - 1];\n    if (nextFinally && nextFinally.breakDepth == this.u.breakBlocks.length) {\n        out(\"$postfinally={isBreak:true,gotoBlock:\",gotoBlock,\"};\");\n    } else {\n        this._jump(gotoBlock);\n    }\n};\n\n/**\n * compiles a statement\n * @param {Object} s\n * @param {Sk.builtin.str=} class_for_super\n */\nCompiler.prototype.vstmt = function (s, class_for_super) {\n    var i;\n    var val;\n    var n;\n    var debugBlock;\n    this.u.lineno = s.lineno;\n    this.u.linenoSet = false;\n    this.u.localtemps = [];\n\n    if (Sk.debugging && this.u.canSuspend) {\n        debugBlock = this.newBlock(\"debug breakpoint for line \"+s.lineno);\n        out(\"if (Sk.breakpoints('\"+this.filename+\"',\"+s.lineno+\",\"+s.col_offset+\")) {\",\n            \"var $susp = $saveSuspension({data: {type: 'Sk.debug'}, resume: function() {}}, '\"+this.filename+\"',\"+s.lineno+\",\"+s.col_offset+\");\",\n            \"$susp.$blk = \" + debugBlock + \";\",\n            \"$susp.optional = true;\",\n            \"return $susp;\",\n            \"}\");\n        this._jump(debugBlock);\n        this.setBlock(debugBlock);\n        this.u.doesSuspend = true;\n    }\n\n    this.annotateSource(s);\n\n    switch (s.constructor) {\n        case Sk.astnodes.FunctionDef:\n            this.cfunction(s, class_for_super);\n            break;\n        case Sk.astnodes.ClassDef:\n            this.cclass(s);\n            break;\n        case Sk.astnodes.Return:\n            if (this.u.ste.blockType !== Sk.SYMTAB_CONSTS.FunctionBlock) {\n                throw new SyntaxError(\"'return' outside function\");\n            }\n            val = s.value ? this.vexpr(s.value) : \"Sk.builtin.none.none$\";\n            if (this.u.finallyBlocks.length == 0) {\n                out(\"return \", val, \";\");\n            } else {\n                out(\"$postfinally={returning:\",val,\"};\");\n                this._jump(this.peekFinallyBlock().blk);\n            }\n            break;\n        case Sk.astnodes.Delete:\n            this.vseqexpr(s.targets);\n            break;\n        case Sk.astnodes.Assign:\n            n = s.targets.length;\n            val = this.vexpr(s.value);\n            for (i = 0; i < n; ++i) {\n                this.vexpr(s.targets[i], val);\n            }\n            break;\n        case Sk.astnodes.AugAssign:\n            return this.caugassign(s);\n        case Sk.astnodes.Print:\n            this.cprint(s);\n            break;\n        case Sk.astnodes.For:\n            return this.cfor(s);\n        case Sk.astnodes.While:\n            return this.cwhile(s);\n        case Sk.astnodes.If:\n            return this.cif(s);\n        case Sk.astnodes.Raise:\n            return this.craise(s);\n        case Sk.astnodes.Try:\n            return this.ctry(s);\n        case Sk.astnodes.With:\n            return this.cwith(s, 0);\n        case Sk.astnodes.Assert:\n            return this.cassert(s);\n        case Sk.astnodes.Import:\n            return this.cimport(s);\n        case Sk.astnodes.ImportFrom:\n            return this.cfromimport(s);\n        case Sk.astnodes.Global:\n            break;\n        case Sk.astnodes.Expr:\n            this.vexpr(s.value);\n            break;\n        case Sk.astnodes.Pass:\n            break;\n        case Sk.astnodes.Break:\n            this.cbreak(s);\n            break;\n        case Sk.astnodes.Continue:\n            this.ccontinue(s);\n            break;\n        case Sk.astnodes.Debugger:\n            out(\"debugger;\");\n            break;\n        default:\n            Sk.asserts.fail(\"unhandled case in vstmt: \" + JSON.stringify(s));\n    }\n};\n\nCompiler.prototype.vseqstmt = function (stmts) {\n    var i;\n    for (i = 0; i < stmts.length; ++i) {\n        this.vstmt(stmts[i]);\n    }\n};\n\nvar OP_FAST = 0;\nvar OP_GLOBAL = 1;\nvar OP_DEREF = 2;\nvar OP_NAME = 3;\nvar D_NAMES = 0;\nvar D_FREEVARS = 1;\nvar D_CELLVARS = 2;\n\nCompiler.prototype.isCell = function (name) {\n    var mangled = mangleName(this.u.private_, name).v;\n    var scope = this.u.ste.getScope(mangled);\n    var dict = null;\n    return scope === Sk.SYMTAB_CONSTS.CELL;\n\n};\n\n/**\n * @param {Sk.builtin.str} name\n * @param {Object} ctx\n * @param {string=} dataToStore\n */\nCompiler.prototype.nameop = function (name, ctx, dataToStore) {\n    var v;\n    var mangledNoPre;\n    var dict;\n    var scope;\n    var optype;\n    var op;\n    var mangled;\n    if ((ctx === Sk.astnodes.Store || ctx === Sk.astnodes.AugStore || ctx === Sk.astnodes.Del) && name.v === \"__debug__\") {\n        throw new Sk.builtin.SyntaxError(\"can not assign to __debug__\");\n    }\n    Sk.asserts.assert(name.v !== \"None\");\n\n    if (name.v === \"NotImplemented\") {\n        return \"Sk.builtin.NotImplemented.NotImplemented$\";\n    }\n\n    mangled = mangleName(this.u.private_, name).v;\n    // Have to do this before looking it up in the scope\n    mangled = fixReservedNames(mangled);\n    op = 0;\n    optype = OP_NAME;\n    scope = this.u.ste.getScope(mangled);\n    dict = null;\n    switch (scope) {\n        case Sk.SYMTAB_CONSTS.FREE:\n            dict = \"$free\";\n            optype = OP_DEREF;\n            break;\n        case Sk.SYMTAB_CONSTS.CELL:\n            dict = \"$cell\";\n            optype = OP_DEREF;\n            break;\n        case Sk.SYMTAB_CONSTS.LOCAL:\n            // can't do FAST in generators or at module/class scope\n            if (this.u.ste.blockType === Sk.SYMTAB_CONSTS.FunctionBlock && !this.u.ste.generator) {\n                optype = OP_FAST;\n            }\n            break;\n        case Sk.SYMTAB_CONSTS.GLOBAL_IMPLICIT:\n            if (this.u.ste.blockType === Sk.SYMTAB_CONSTS.FunctionBlock) {\n                optype = OP_GLOBAL;\n            }\n            break;\n        case Sk.SYMTAB_CONSTS.GLOBAL_EXPLICIT:\n            optype = OP_GLOBAL;\n        default:\n            break;\n    }\n\n    // have to do this after looking it up in the scope\n    mangled = fixReservedWords(mangled);\n\n    //print(\"mangled\", mangled);\n    // TODO TODO TODO todo; import * at global scope failing here\n    Sk.asserts.assert(scope || name.v.charAt(1) === \"_\");\n\n    // in generator or at module scope, we need to store to $loc, rather that\n    // to actual JS stack variables.\n    mangledNoPre = mangled;\n    if (this.u.ste.generator || this.u.ste.blockType !== Sk.SYMTAB_CONSTS.FunctionBlock) {\n        mangled = \"$loc.\" + mangled;\n    }\n    else if (optype === OP_FAST || optype === OP_NAME) {\n        this.u.localnames.push(mangled);\n    }\n\n    switch (optype) {\n        case OP_FAST:\n            switch (ctx) {\n                case Sk.astnodes.Load:\n                case Sk.astnodes.Param:\n                    // Need to check that it is bound!\n                    out(\"if (\", mangled, \" === undefined) { throw new Sk.builtin.UnboundLocalError('local variable \\\\\\'\", mangled, \"\\\\\\' referenced before assignment'); }\\n\");\n                    return mangled;\n                case Sk.astnodes.Store:\n                    out(mangled, \"=\", dataToStore, \";\");\n                    break;\n                case Sk.astnodes.Del:\n                    out(\"delete \", mangled, \";\");\n                    break;\n                default:\n                    Sk.asserts.fail(\"unhandled\");\n            }\n            break;\n        case OP_NAME:\n            switch (ctx) {\n                case Sk.astnodes.Load:\n                    // can't be || for loc.x = 0 or null\n                    return this._gr(\"loadname\", mangled, \"!==undefined?\", mangled, \":Sk.misceval.loadname('\", mangledNoPre, \"',$gbl);\");\n                case Sk.astnodes.Store:\n                    out(mangled, \"=\", dataToStore, \";\");\n                    break;\n                case Sk.astnodes.Del:\n                    out(\"delete \", mangled, \";\");\n                    break;\n                case Sk.astnodes.Param:\n                    return mangled;\n                default:\n                    Sk.asserts.fail(\"unhandled\");\n            }\n            break;\n        case OP_GLOBAL:\n            switch (ctx) {\n                case Sk.astnodes.Load:\n                    return this._gr(\"loadgbl\", \"Sk.misceval.loadname('\", mangledNoPre, \"',$gbl)\");\n                case Sk.astnodes.Store:\n                    out(\"$gbl.\", mangledNoPre, \"=\", dataToStore, \";\");\n                    break;\n                case Sk.astnodes.Del:\n                    out(\"delete $gbl.\", mangledNoPre);\n                    break;\n                default:\n                    Sk.asserts.fail(\"unhandled case in name op_global\");\n            }\n            break;\n        case OP_DEREF:\n            switch (ctx) {\n                case Sk.astnodes.Load:\n                    return dict + \".\" + mangledNoPre;\n                case Sk.astnodes.Store:\n                    out(dict, \".\", mangledNoPre, \"=\", dataToStore, \";\");\n                    break;\n                case Sk.astnodes.Param:\n                    return mangledNoPre;\n                default:\n                    Sk.asserts.fail(\"unhandled case in name op_deref\");\n            }\n            break;\n        default:\n            Sk.asserts.fail(\"unhandled case\");\n    }\n};\n\n/**\n * @param {Sk.builtin.str} name\n * @param {Object} key\n * @param {number} lineno\n * @param {boolean=} canSuspend\n */\nCompiler.prototype.enterScope = function (name, key, lineno, canSuspend) {\n    var scopeName;\n    var u = new CompilerUnit();\n    u.ste = this.st.getStsForAst(key);\n    u.name = name;\n    u.firstlineno = lineno;\n    u.canSuspend = canSuspend || false;\n\n    if (this.u && this.u.private_) {\n        u.private_ = this.u.private_;\n    }\n\n    this.stack.push(this.u);\n    this.allUnits.push(u);\n    scopeName = this.gensym(\"scope\");\n    u.scopename = scopeName;\n\n    this.u = u;\n    this.u.activateScope();\n\n    this.nestlevel++;\n\n    return scopeName;\n};\n\nCompiler.prototype.exitScope = function () {\n    var mangled;\n    var prev = this.u;\n    this.nestlevel--;\n    if (this.stack.length - 1 >= 0) {\n        this.u = this.stack.pop();\n    }\n    else {\n        this.u = null;\n    }\n    if (this.u) {\n        this.u.activateScope();\n    }\n\n    if (prev.name.v !== \"<module>\") {// todo; hacky\n        mangled = prev.name[\"$r\"]().v;\n        mangled = mangled.substring(1, mangled.length - 1);\n        mangled = fixReservedWords(mangled);\n        mangled = fixReservedNames(mangled);\n        out(prev.scopename, \".co_name=new Sk.builtins['str']('\", mangled, \"');\");\n    }\n    for (var constant in prev.consts) {\n        if (prev.consts.hasOwnProperty(constant)) {\n            prev.suffixCode += constant + \" = \" + prev.consts[constant] + \";\";\n        }\n    }\n};\n\n/**\n * @param {Array} stmts\n * @param {Sk.builtin.str=} class_for_super\n */\nCompiler.prototype.cbody = function (stmts, class_for_super) {\n    var i;\n    for (i = 0; i < stmts.length; ++i) {\n        this.vstmt(stmts[i], class_for_super);\n    }\n};\n\nCompiler.prototype.cprint = function (s) {\n    var i;\n    var n;\n    var dest;\n    Sk.asserts.assert(s instanceof Sk.astnodes.Print);\n    dest = \"null\";\n    if (s.dest) {\n        dest = this.vexpr(s.dest);\n    }\n\n    n = s.values.length;\n    // todo; dest disabled\n    for (i = 0; i < n; ++i) {\n        out(\"$ret = Sk.misceval.print_(\", /*dest, ',',*/ \"new Sk.builtins['str'](\", this.vexpr(s.values[i]), \").v);\");\n        this._checkSuspension(s);\n    }\n    if (s.nl) {\n        out(\"$ret = Sk.misceval.print_(\", /*dest, ',*/ \"\\\"\\\\n\\\");\");\n        this._checkSuspension(s);\n    }\n\n};\n\nCompiler.prototype.cmod = function (mod) {\n    //print(\"-----\");\n    //print(Sk.astDump(mod));\n    var modf = this.enterScope(new Sk.builtin.str(\"<module>\"), mod, 0, this.canSuspend);\n\n    var entryBlock = this.newBlock(\"module entry\");\n    this.u.prefixCode = \"var \" + modf + \"=(function($forcegbl){\";\n    this.u.varDeclsCode =\n        \"var $gbl = $forcegbl || {}, $blk=\" + entryBlock +\n        \",$exc=[],$loc=$gbl,$cell={},$err=undefined;\" +\n        \"$loc.__file__=new Sk.builtins.str('\" + this.filename +\n        \"');var $ret=undefined,$postfinally=undefined,$currLineNo=undefined,$currColNo=undefined;\";\n\n    if (Sk.execLimit !== null) {\n        this.u.varDeclsCode += \"if (typeof Sk.execStart === 'undefined') {Sk.execStart = Date.now()}\";\n    }\n\n    if (Sk.yieldLimit !== null && this.u.canSuspend) {\n        this.u.varDeclsCode += \"if (typeof Sk.lastYield === 'undefined') {Sk.lastYield = Date.now()}\";\n    }\n\n    this.u.varDeclsCode += \"if (\"+modf+\".$wakingSuspension!==undefined) { $wakeFromSuspension(); }\" +\n        \"if (Sk.retainGlobals) {\" +\n        \"    if (Sk.globals) { $gbl = Sk.globals; Sk.globals = $gbl; $loc = $gbl; }\" +\n        \"    if (Sk.globals) { $gbl = Sk.globals; Sk.globals = $gbl; $loc = $gbl; $loc.__file__=new Sk.builtins.str('\" + this.filename + \"');}\" +\n        \"    else { Sk.globals = $gbl; }\" +\n        \"} else { Sk.globals = $gbl; }\";\n\n    // Add the try block that pops the try/except stack if one exists\n    // Github Issue #38\n    // Google Code Issue: 109 / 114\n\n    // Old code:\n    //this.u.switchCode = \"while(true){switch($blk){\";\n    //this.u.suffixCode = \"}}});\";\n\n    // New Code:\n    this.u.switchCode = \"while(true){try{\";\n    this.u.switchCode += this.outputInterruptTest();\n    this.u.switchCode += \"switch($blk){\";\n    this.u.suffixCode = \"}\"\n    this.u.suffixCode += \"}catch(err){ if (!(err instanceof Sk.builtin.BaseException)) { err = new Sk.builtin.ExternalError(err); } err.traceback.push({lineno: $currLineNo, colno: $currColNo, filename: '\"+this.filename+\"'}); if ($exc.length>0) { $err = err; $blk=$exc.pop(); continue; } else { throw err; }} } });\";\n\n    // Note - this change may need to be adjusted for all the other instances of\n    // switchCode and suffixCode in this file.  Not knowing how to test those\n    // other cases I left them alone.   At least the changes to\n    // setupExcept and endExcept will insure that the generated JavaScript\n    // will be syntactically correct.  The worst that will happen is that when\n    // code in a try block blows up, we will not know to run the except block.\n    // The other problem is that we might catch something that is really an internal\n    // error - it might be nice to add code in the above catch block that looked at\n    // the kind of exception and only popped the stack for exceptions that are\n    // from the original code rather than artifacts of some code generation or\n    // exeution environment error.  We at least err on the side of exceptions\n    // being revealed to the user.  drchuck - Wed Jan 23 19:20:18 EST 2013\n\n    switch (mod.constructor) {\n        case Sk.astnodes.Module:\n            this.cbody(mod.body);\n            out(\"return $loc;\");\n            break;\n        default:\n            Sk.asserts.fail(\"todo; unhandled case in compilerMod\");\n    }\n    this.exitScope();\n\n    this.result.push(this.outputAllUnits());\n    return modf;\n};\n\n/**\n * @param {string} source the code\n * @param {string} filename where it came from\n * @param {string} mode one of 'exec', 'eval', or 'single'\n * @param {boolean=} canSuspend if the generated code supports suspension\n */\nSk.compile = function (source, filename, mode, canSuspend) {\n    //print(\"FILE:\", filename);\n    // __future__ flags can be set from code\n    // (with \"from __future__ import ...\" statements),\n    // so make a temporary object that can be edited.\n    var savedFlags = Sk.__future__;\n    Sk.__future__ = Object.create(Sk.__future__);\n\n    var parse = Sk.parse(filename, source);\n    var ast = Sk.astFromParse(parse.cst, filename, parse.flags);\n    // console.log(JSON.stringify(ast, undefined, 2));\n\n    // compilers flags, later we can add other ones too\n    var flags = {};\n    flags.cf_flags = parse.flags;\n\n    var st = Sk.symboltable(ast, filename);\n    var c = new Compiler(filename, st, flags.cf_flags, canSuspend, source); // todo; CO_xxx\n    var funcname = c.cmod(ast);\n\n    // Restore the global __future__ flags\n    Sk.__future__ = savedFlags;\n\n    var ret = \"$compiledmod = function() {\" + c.result.join(\"\") + \"\\nreturn \" + funcname + \";}();\";\n    return {\n        funcname: \"$compiledmod\",\n        code    : ret\n    };\n};\n\nSk.exportSymbol(\"Sk.compile\", Sk.compile);\n\nSk.resetCompiler = function () {\n    Sk.gensymcount = 0;\n};\n\nSk.exportSymbol(\"Sk.resetCompiler\", Sk.resetCompiler);\n\nSk.fixReservedWords = fixReservedWords;\nSk.exportSymbol(\"Sk.fixReservedWords\", Sk.fixReservedWords);\n\nSk.fixReservedNames = fixReservedNames;\nSk.exportSymbol(\"Sk.fixReservedNames\", Sk.fixReservedNames);\n\nSk.unfixReserved = unfixReserved;\nSk.exportSymbol(\"Sk.unfixReserved\", Sk.unfixReserved);\n\nSk.mangleName = mangleName;\nSk.exportSymbol(\"Sk.mangleName\", Sk.mangleName);\n\n\n/***/ }),\n/* 50 */\n/***/ (function(module, exports) {\n\n/**\n * @namespace Sk\n *\n */\n\n// this is stored into sys specially, rather than created by sys\nSk.sysmodules = new Sk.builtin.dict([]);\nSk.realsyspath = undefined;\n\n/**\n * @param {string} name to look for\n * @param {string} ext extension to use (.py or .js)\n * @param {Object=} searchPath an iterable set of path strings\n */\nSk.importSearchPathForName = function (name, ext, searchPath) {\n    var fn;\n    var j;\n    var fns = [];\n    var nameAsPath = name.replace(/\\./g, \"/\");\n    var it, i;\n\n    var tryPathAndBreakOnSuccess = function(filename, packagePath) {\n        return Sk.misceval.chain(\n            Sk.misceval.tryCatch(function() {\n                return Sk.read(filename);\n            }, function(e) { /* Exceptions signal \"not found\" */ }),\n            function(code) {\n                if (code !== undefined) {\n                    // This will cause the iterFor() to return the specified value\n                    return new Sk.misceval.Break({filename: filename, code: code, packagePath: packagePath});\n                }\n            }\n        );\n    };\n\n    if (searchPath === undefined) {\n        searchPath = Sk.realsyspath;\n    }\n\n    return Sk.misceval.iterFor(searchPath.tp$iter(), function(pathStr) {\n        // For each element of path, try loading the module, and if that\n        // doesn't work, try the corresponding package.\n        return Sk.misceval.chain(\n            tryPathAndBreakOnSuccess(pathStr.v + \"/\" + nameAsPath + ext, false), // module\n            function(r) {\n                return r ? r : tryPathAndBreakOnSuccess(pathStr.v + \"/\" + nameAsPath + \"/__init__\" + ext,\n                                                        pathStr.v + \"/\" + nameAsPath); // package\n            }\n        );\n    });\n};\n\n/**\n * Complete any initialization of Python classes which relies on internal\n * dependencies.\n *\n * This includes making Python classes subclassable and ensuring that the\n * {@link Sk.builtin.object} magic methods are wrapped inside Python functions.\n *\n * @return {undefined}\n */\nSk.doOneTimeInitialization = function (canSuspend) {\n    var proto, name, i, x, func, typesWithFunctionsToWrap, builtin_type, j;\n\n    // can't fill these out when making the type because tuple/dict aren't\n    // defined yet.\n    Sk.builtin.type.basesStr_ = new Sk.builtin.str(\"__bases__\");\n    Sk.builtin.type.mroStr_ = new Sk.builtin.str(\"__mro__\");\n\n    // Register a Python class with an internal dictionary, which allows it to\n    // be subclassed\n    var setUpClass = function (child) {\n        var parent = child.tp$base;\n        var bases = [];\n        var base;\n\n        for (base = parent; base !== undefined; base = base.tp$base) {\n            bases.push(base);\n        }\n\n        child.tp$mro = new Sk.builtin.tuple([child]);\n        if (!child.tp$base){\n            child.tp$base = bases[0];\n        }\n        child[\"$d\"] = new Sk.builtin.dict([]);\n        child[\"$d\"].mp$ass_subscript(Sk.builtin.type.basesStr_, new Sk.builtin.tuple(bases));\n        child[\"$d\"].mp$ass_subscript(Sk.builtin.type.mroStr_, child.tp$mro);\n    };\n\n    for (x in Sk.builtin) {\n        func = Sk.builtin[x];\n        if ((func.prototype instanceof Sk.builtin.object ||\n             func === Sk.builtin.object) && !func.sk$abstract) {\n            setUpClass(func);\n        }\n    }\n\n    // Wrap the inner Javascript code of Sk.builtin.object's Python methods inside\n    // Sk.builtin.func, as that class was undefined when these functions were declared\n    typesWithFunctionsToWrap = [Sk.builtin.object, Sk.builtin.type, Sk.builtin.func, Sk.builtin.method];\n\n    for (i = 0; i < typesWithFunctionsToWrap.length; i++) {\n        builtin_type = typesWithFunctionsToWrap[i];\n        proto = builtin_type.prototype;\n        for (j = 0; j < builtin_type.pythonFunctions.length; j++) {\n            name = builtin_type.pythonFunctions[j];\n\n            if (proto[name] instanceof Sk.builtin.func) {\n                // If functions have already been initialized, do not wrap again.\n                break;\n            }\n\n            proto[name].co_kwargs = null;\n            proto[name] = new Sk.builtin.func(proto[name]);\n        }\n    }\n\n\n    for (var file in Sk.internalPy.files) {\n        var fileWithoutExtension = file.split(\".\")[0].split(\"/\")[1];\n        var mod = Sk.importBuiltinWithBody(fileWithoutExtension, false, Sk.internalPy.files[file], true);\n        mod = Sk.misceval.retryOptionalSuspensionOrThrow(mod);\n        Sk.asserts.assert(mod[\"$d\"][fileWithoutExtension] !== undefined, \"Should have imported name \" + fileWithoutExtension);\n        Sk.builtins[fileWithoutExtension] = mod[\"$d\"][fileWithoutExtension];\n    }\n};\n\n/**\n * currently only pull once from Sk.syspath. User might want to change\n * from js or from py.\n */\nSk.importSetUpPath = function (canSuspend) {\n    var i;\n    var paths;\n    if (!Sk.realsyspath) {\n        paths = [\n            new Sk.builtin.str(\"src/builtin\"),\n            new Sk.builtin.str(\"src/lib\"),\n            new Sk.builtin.str(\".\")\n        ];\n        for (i = 0; i < Sk.syspath.length; ++i) {\n            paths.push(new Sk.builtin.str(Sk.syspath[i]));\n        }\n        Sk.realsyspath = new Sk.builtin.list(paths);\n\n        Sk.doOneTimeInitialization(canSuspend);\n    }\n};\n\n/**\n * @param {string} name name of module to import\n * @param {boolean=} dumpJS whether to output the generated js code\n * @param {string=} modname what to call the module after it's imported if\n * it's to be renamed (i.e. __main__)\n * @param {string=} suppliedPyBody use as the body of the text for the module\n * rather than Sk.read'ing it.\n * @param {Object=} relativeToPackage perform import relative to this package\n * @param {boolean=} returnUndefinedOnTopLevelNotFound return 'undefined' rather than throwing ImportError if the *first* load failed\n * @param {boolean=} canSuspend whether we may return a Suspension object\n */\nSk.importModuleInternal_ = function (name, dumpJS, modname, suppliedPyBody, relativeToPackage, returnUndefinedOnTopLevelNotFound, canSuspend) {\n    //dumpJS = true;\n    var filename;\n    var prev;\n    var parentModName;\n    var parentModule;\n    var modNameSplit;\n    var ret;\n    var module;\n    var topLevelModuleToReturn = null;\n    var relativePackageName = relativeToPackage !== undefined ? relativeToPackage.tp$getattr(Sk.builtin.str.$name) : undefined;\n    var absolutePackagePrefix = relativePackageName !== undefined ? relativePackageName.v + \".\" : \"\";\n    var searchPath = relativeToPackage !== undefined ? relativeToPackage.tp$getattr(Sk.builtin.str.$path) : undefined;\n    Sk.importSetUpPath(canSuspend);\n\n    if (relativeToPackage && !relativePackageName) {\n        if (returnUndefinedOnTopLevelNotFound) {\n            return undefined;\n        } else {\n            throw new Sk.builtin.ValueError(\"Attempted to import relative to invalid package (no name)\");\n        }\n    }\n\n    // if no module name override, supplied, use default name\n    if (modname === undefined) {\n        modname = absolutePackagePrefix + name;\n    }\n\n    modNameSplit = name.split(\".\");\n\n    // if leaf is already in sys.modules, early out\n    try {\n        prev = Sk.sysmodules.mp$subscript(modname);\n        // if we're a dotted module, return the top level, otherwise ourselves\n        if (modNameSplit.length > 1) {\n            return Sk.sysmodules.mp$subscript(absolutePackagePrefix + modNameSplit[0]);\n        } else {\n            return prev;\n        }\n    } catch (x) {\n        // not in sys.modules, continue\n    }\n\n    if (modNameSplit.length > 1) {\n        // if we're a module inside a package (i.e. a.b.c), then we'll need to return the\n        // top-level package ('a'). recurse upwards on our parent, importing\n        // all parent packages. so, here we're importing 'a.b', which will in\n        // turn import 'a', and then return 'a' eventually.\n        parentModName = modNameSplit.slice(0, modNameSplit.length - 1).join(\".\");\n        topLevelModuleToReturn = Sk.importModuleInternal_(parentModName, dumpJS, undefined, undefined, relativeToPackage, returnUndefinedOnTopLevelNotFound, canSuspend);\n    }\n\n    ret = Sk.misceval.chain(topLevelModuleToReturn, function(topLevelModuleToReturn_) {\n        var codeAndPath, co, googClosure;\n        var searchFileName = name;\n        var result;\n\n        topLevelModuleToReturn = topLevelModuleToReturn_;\n\n        // If we're inside a package, look search using its __path__\n        if (modNameSplit.length > 1) {\n            if (!topLevelModuleToReturn) {\n                return undefined;\n            }\n            parentModule = Sk.sysmodules.mp$subscript(absolutePackagePrefix + parentModName);\n            searchFileName = modNameSplit[modNameSplit.length-1];\n            searchPath = parentModule.tp$getattr(Sk.builtin.str.$path);\n        }\n\n        // otherwise:\n        // - create module object\n        // - add module object to sys.modules\n        // - compile source to (function(){...});\n        // - run module and set the module locals returned to the module __dict__\n        module = new Sk.builtin.module();\n\n        if (suppliedPyBody) {\n            filename = name + \".py\";\n            co = Sk.compile(suppliedPyBody, filename, \"exec\", canSuspend);\n        } else {\n            co = Sk.misceval.chain(undefined, function() {\n                // If an onBeforeImport method is supplied, call it and if\n                // the result is false or a string, prevent the import.\n                // This allows for a user to conditionally prevent the usage\n                // of certain libraries.\n                if (Sk.onBeforeImport && typeof Sk.onBeforeImport === \"function\") {\n                    return Sk.onBeforeImport(name);\n                }\n\n                return;\n            }, function(result) {\n                if (result === false) {\n                    throw new Sk.builtin.ImportError(\"Importing \" + name + \" is not allowed\");\n                } else if (typeof result === \"string\") {\n                    throw new Sk.builtin.ImportError(result);\n                }\n\n                // Try loading as a builtin (i.e. already in JS) module, then try .py files\n                return Sk.importSearchPathForName(searchFileName, \".js\", searchPath);\n            }, function(codeAndPath) {\n                if (codeAndPath) {\n                    return {\n                        funcname: \"$builtinmodule\", code: codeAndPath.code,\n                        filename: codeAndPath.filename, packagePath: codeAndPath.packagePath\n                    };\n                } else {\n                    return Sk.misceval.chain(Sk.importSearchPathForName(searchFileName, \".py\", searchPath), function(codeAndPath_) {\n                        codeAndPath = codeAndPath_; // We'll want it in a moment\n                        if (codeAndPath) {\n                            return Sk.compile(codeAndPath.code, codeAndPath.filename, \"exec\", canSuspend);\n                        }\n                    }, function(co) {\n                        if (co) {\n                            co.packagePath = codeAndPath.packagePath;\n                            return co;\n                        }\n                    });\n                }\n            });\n\n        }\n        return co;\n\n    }, function(co) {\n\n        var finalcode;\n        var withLineNumbers;\n        var modscope;\n\n        if (!co) {\n            return undefined;\n        }\n\n        // Now we know this module exists, we can add it to the cache\n        Sk.sysmodules.mp$ass_subscript(modname, module);\n\n        module.$js = co.code; // todo; only in DEBUG?\n        finalcode = co.code;\n\n        if (filename == null) {\n            filename = co.filename;\n        }\n\n        if (Sk.dateSet == null || !Sk.dateSet) {\n            finalcode = \"Sk.execStart = Sk.lastYield = new Date();\\n\" + co.code;\n            Sk.dateSet = true;\n        }\n\n        // if (!COMPILED)\n        // {\n        if (dumpJS) {\n            withLineNumbers = function (code) {\n                var j;\n                var pad;\n                var width;\n                var i;\n                var beaut = Sk.js_beautify(code);\n                var lines = beaut.split(\"\\n\");\n                for (i = 1; i <= lines.length; ++i) {\n                    width = (\"\" + i).length;\n                    pad = \"\";\n                    for (j = width; j < 5; ++j) {\n                        pad += \" \";\n                    }\n                    lines[i - 1] = \"/* \" + pad + i + \" */ \" + lines[i - 1];\n                }\n                return lines.join(\"\\n\");\n            };\n            finalcode = withLineNumbers(finalcode);\n            Sk.debugout(finalcode);\n        }\n        // }\n\n        finalcode += \"\\n\" + co.funcname + \";\";\n\n        modscope = Sk.global[\"eval\"](finalcode);\n\n        module[\"$d\"] = {\n            \"__name__\": new Sk.builtin.str(modname),\n            \"__doc__\": Sk.builtin.none.none$,\n            \"__package__\": co.packagePath ? new Sk.builtin.str(modname) :\n            parentModName ? new Sk.builtin.str(absolutePackagePrefix + parentModName) :\n            relativePackageName ? relativePackageName : Sk.builtin.none.none$\n        };\n        if (co.packagePath) {\n            module[\"$d\"][\"__path__\"] = new Sk.builtin.tuple([new Sk.builtin.str(co.packagePath)]);\n        }\n\n        return modscope(module[\"$d\"]);\n\n    }, function (modlocs) {\n        var i;\n\n        if (modlocs === undefined) {\n            if (returnUndefinedOnTopLevelNotFound && !topLevelModuleToReturn) {\n                return undefined;\n            } else {\n                throw new Sk.builtin.ImportError(\"No module named \" + name);\n            }\n        }\n\n        // Some builtin modules replace their globals entirely.\n        // For their benefit, we copy over any of the standard\n        // dunder-values they didn't supply.\n        if (modlocs !== module[\"$d\"]) {\n            for (i in module[\"$d\"]) {\n                if (!modlocs[i]) {\n                    modlocs[i] = module[\"$d\"][i];\n                }\n            }\n            module[\"$d\"] = modlocs;\n        }\n\n        // If an onAfterImport method is defined on the global Sk\n        // then call it now after a library has been successfully imported\n        // and compiled.\n        if (Sk.onAfterImport && typeof Sk.onAfterImport === \"function\") {\n            try {\n                Sk.onAfterImport(name);\n            } catch (e) {\n            }\n        }\n\n        if (topLevelModuleToReturn) {\n            // if we were a dotted name, then we want to return the top-most\n            // package. we store ourselves into our parent as an attribute\n            parentModule.tp$setattr(new Sk.builtin.str(modNameSplit[modNameSplit.length - 1]), module);\n            //print(\"import returning parent module, modname\", modname, \"__name__\", toReturn.tp$getattr(\"__name__\").v);\n            return topLevelModuleToReturn;\n        }\n\n        if (relativeToPackage) {\n            relativeToPackage.tp$setattr(new Sk.builtin.str(name), module);\n        }\n\n        //print(\"name\", name, \"modname\", modname, \"returning leaf\");\n        // otherwise we return the actual module that we just imported\n        return module;\n    });\n\n    return canSuspend ? ret : Sk.misceval.retryOptionalSuspensionOrThrow(ret);\n};\n\n/**\n * @param {string} name the module name\n * @param {boolean=} dumpJS print out the js code after compilation for debugging\n * @param {boolean=} canSuspend can this function suspend and return a Suspension object?\n */\nSk.importModule = function (name, dumpJS, canSuspend) {\n    return Sk.importModuleInternal_(name, dumpJS, undefined, undefined, undefined, false, canSuspend);\n};\n\nSk.importMain = function (name, dumpJS, canSuspend) {\n    Sk.dateSet = false;\n    Sk.filesLoaded = false;\n    // Added to reset imports\n    Sk.sysmodules = new Sk.builtin.dict([]);\n    Sk.realsyspath = undefined;\n\n    Sk.resetCompiler();\n\n    return Sk.importModuleInternal_(name, dumpJS, \"__main__\", undefined, undefined, false, canSuspend);\n};\n\n/**\n * **Run Python Code in Skulpt**\n *\n * When you want to hand Skulpt a string corresponding to a Python program this is the function.\n *\n * @param name {string}  File name to use for messages related to this run\n * @param dumpJS {boolean} print out the compiled javascript\n * @param body {string} Python Code\n * @param canSuspend {boolean}  Use Suspensions for async execution\n *\n */\nSk.importMainWithBody = function (name, dumpJS, body, canSuspend) {\n    Sk.dateSet = false;\n    Sk.filesLoaded = false;\n    // Added to reset imports\n    Sk.sysmodules = new Sk.builtin.dict([]);\n    Sk.realsyspath = undefined;\n\n    Sk.resetCompiler();\n\n    return Sk.importModuleInternal_(name, dumpJS, \"__main__\", body, undefined, false, canSuspend);\n};\n\n/**\n * Imports internal python files into the `__builtin__` module. Used during startup\n * to compile and import all *.py files from the src/ directory.\n *\n * @param name {string}  File name to use for messages related to this run\n * @param dumpJS {boolean} print out the compiled javascript\n * @param body {string} Python Code\n * @param canSuspend {boolean}  Use Suspensions for async execution\n *\n */\nSk.importBuiltinWithBody = function (name, dumpJS, body, canSuspend) {\n    return Sk.importModuleInternal_(name, dumpJS, \"__builtin__.\"+name, body, undefined, false, canSuspend);\n};\n\nSk.builtin.__import__ = function (name, globals, locals, fromlist, level) {\n    //print(\"Importing: \", JSON.stringify(name), JSON.stringify(fromlist), level);\n    //if (name == \"\") { debugger; }\n\n    // Save the Sk.globals variable importModuleInternal_ may replace it when it compiles\n    // a Python language module.\n    var saveSk = Sk.globals;\n\n    // This might be a relative import, so first we get hold of the module object\n    // representing this module's package (so we can search its __path__).\n    // module.__package__ contains its name, so we use that to look it up in sys.modules.\n\n    var relativeToPackage;\n    var relativeToPackageName;\n    var relativeToPackageNames;\n\n    if (level === undefined) {\n        level = Sk.__future__.absolute_import ? 0 : -1;\n    }\n\n    if (level !== 0 && globals[\"__package__\"] && globals[\"__package__\"] !== Sk.builtin.none.none$) {\n        relativeToPackageName = globals[\"__package__\"].v;\n        if (relativeToPackageName && level > 0) {\n            // Trim <level> packages off the end\n            relativeToPackageNames = relativeToPackageName.split(\".\");\n            if (level-1 >= relativeToPackageNames.length) {\n                throw new Sk.builtin.ValueError(\"Attempted relative import beyond toplevel package\");\n            }\n            relativeToPackageNames.length -= level-1;\n            relativeToPackageName = relativeToPackageNames.join(\".\");\n        }\n        try {\n            relativeToPackage = Sk.sysmodules.mp$subscript(relativeToPackageName);\n        } catch(e) {\n            relativeToPackageName = undefined;\n        }\n    }\n\n    if (level > 0 && relativeToPackage === undefined) {\n        throw new Sk.builtin.ValueError(\"Attempted relative import in non-package\");\n    }\n\n    var dottedName = name.split(\".\");\n    var firstDottedName = dottedName[0];\n\n    return Sk.misceval.chain(undefined, function() {\n        // Attempt local load first (and just fall through to global\n        // case if level == -1 and we fail to load the top-level package)\n        if (level !== 0 && relativeToPackage !== undefined) {\n            if (name === \"\") {\n                // \"from .. import ...\"\n                return relativeToPackage;\n            } else {\n                return Sk.importModuleInternal_(name, undefined, relativeToPackageName + \".\" + name, undefined, relativeToPackage, level==-1, true);\n            }\n        }\n    }, function(ret) {\n        if (ret === undefined) {\n            // Either it was always a global import, or it was an\n            // either-way import that just fell through.\n            relativeToPackage = undefined;\n            relativeToPackageName = undefined;\n            return Sk.importModuleInternal_(name, undefined, undefined, undefined, undefined, false, true);\n        } else {\n            return ret;\n        }\n    }, function(ret) {\n        // We might also have to load modules named by the fromlist.\n        // If there is no fromlist, we have reached the end of the lookup, return\n        if (!fromlist || fromlist.length === 0) {\n            return ret;\n        } else {\n            // try to load from-names as modules from the file system\n            // if they are not present on the module itself\n            var i;\n            var fromName;\n            var leafModule;\n            var importChain;\n\n            leafModule = Sk.sysmodules.mp$subscript(\n                (relativeToPackageName || \"\") +\n                    ((relativeToPackageName && name) ? \".\" : \"\") +\n                    name);\n\n            for (i = 0; i < fromlist.length; i++) {\n                fromName = fromlist[i];\n\n                // \"ret\" is the module we're importing from\n                // Only import from file system if we have not found the fromName in the current module\n                if (fromName != \"*\" && leafModule.tp$getattr(new Sk.builtin.str(fromName)) === undefined) {\n                    importChain = Sk.misceval.chain(importChain,\n                                                    Sk.importModuleInternal_.bind(null, fromName, undefined, undefined, undefined, leafModule, true, true)\n                    );\n                }\n            }\n\n            return Sk.misceval.chain(importChain, function() {\n                // if there's a fromlist we want to return the leaf module\n                // (ret), not the toplevel namespace\n                Sk.asserts.assert(leafModule);\n                return leafModule;\n            });\n        }\n\n    }, function(ret) {\n        if (saveSk !== Sk.globals) {\n            Sk.globals = saveSk;\n        }\n        return ret;\n    });\n};\n\nSk.importStar = function (module, loc, global) {\n    var i;\n    var props = Object[\"getOwnPropertyNames\"](module[\"$d\"]);\n    for (i in props) {\n        if (props[i].charAt(0) != \"_\") {\n            loc[props[i]] = module[\"$d\"][props[i]];\n        }\n    }\n};\n\nSk.exportSymbol(\"Sk.importMain\", Sk.importMain);\nSk.exportSymbol(\"Sk.importMainWithBody\", Sk.importMainWithBody);\nSk.exportSymbol(\"Sk.importBuiltinWithBody\", Sk.importBuiltinWithBody);\nSk.exportSymbol(\"Sk.builtin.__import__\", Sk.builtin.__import__);\nSk.exportSymbol(\"Sk.importStar\", Sk.importStar);\n\n\n/***/ }),\n/* 51 */\n/***/ (function(module, exports) {\n\n/**\n * @constructor\n * @param {Sk.builtin.list=} list\n * @param {number=} length optional\n * @extends Sk.builtin.object\n */\nSk.builtin.timSort = function (list, length) {\n    this.list = new Sk.builtin.list(list.v);\n    // When we get into galloping mode, we stay there until both runs win less\n    // often than MIN_GALLOP consecutive times.  See listsort.txt for more info.\n    this.MIN_GALLOP = 7;\n    if (length) {\n        this.listlength = length;\n    } else {\n        this.listlength = list.sq$length();\n    }\n};\n\nSk.builtin.timSort.prototype.lt = function (a, b) {\n    return Sk.misceval.richCompareBool(a, b, \"Lt\");\n};\n\nSk.builtin.timSort.prototype.le = function (a, b) {\n    return !this.lt(b, a);\n};\n\nSk.builtin.timSort.prototype.setitem = function (item, value) {\n    this.list.v[item] = value;\n};\n\n/*\n # binarysort is the best method for sorting small arrays: it does\n # few compares, but can do data movement quadratic in the number of\n # elements.\n # \"a\" is a contiguous slice of a list, and is sorted via binary insertion.\n # This sort is stable.\n # On entry, the first \"sorted\" elements are already sorted.\n # Even in case of error, the output slice will be some permutation of\n # the input (nothing is lost or duplicated)\n */\nSk.builtin.timSort.prototype.binary_sort = function (a, sorted) {\n    var pivot;\n    var p;\n    var r;\n    var l;\n    var start;\n    for (start = a.base + sorted; start < a.base + a.len; start++) {\n        l = a.base;\n        r = start;\n        pivot = a.getitem(r);\n        // Invariants:\n        // pivot >= all in [base, l).\n        // pivot  < all in [r, start).\n        // The second is vacuously true at the start.\n        while (l < r) {\n            p = l + ((r - l) >> 1);\n            if (this.lt(pivot, a.getitem(p))) {\n                r = p;\n            } else {\n                l = p + 1;\n            }\n        }\n        Sk.asserts.assert(l === r);\n        // The invariants still hold, so pivot >= all in [base, l) and\n        // pivot < all in [l, start), so pivot belongs at l.  Note\n        // that if there are elements equal to pivot, l points to the\n        // first slot after them -- that's why this sort is stable.\n        // Slide over to make room.\n        for (p = start; p > l; p--) {\n            a.setitem(p, a.getitem(p - 1));\n        }\n        a.setitem(l, pivot);\n    }\n};\n\nSk.builtin.timSort.prototype.count_run = function (a) {\n    /*\n     # Compute the length of the run in the slice \"a\".\n     # \"A run\" is the longest ascending sequence, with\n     #\n     #     a[0] <= a[1] <= a[2] <= ...\n     #\n     # or the longest descending sequence, with\n     #\n     #     a[0] > a[1] > a[2] > ...\n     #\n     # Return (run, descending) where descending is False in the former case,\n     # or True in the latter.\n     # For its intended use in a stable mergesort, the strictness of the defn of\n     # \"descending\" is needed so that the caller can safely reverse a descending\n     # sequence without violating stability (strict > ensures there are no equal\n     # elements to get out of order).\n     */\n    var n;\n    var p;\n    var descending;\n    if (a.len <= 1) {\n        n = a.len;\n        descending = false;\n    } else {\n        n = 2;\n        if (this.lt(a.getitem(a.base + 1), a.getitem(a.base))) {\n            descending = true;\n            for (p = a.base + 2; p < a.base + a.len; p++) {\n                if (this.lt(a.getitem(p), a.getitem(p - 1))) {\n                    n++;\n                } else {\n                    break;\n                }\n            }\n        } else {\n            descending = false;\n            for (p = a.base + 2; p < a.base + a.len; p++) {\n                if (this.lt(a.getitem(p), a.getitem(p - 1))) {\n                    break;\n                } else {\n                    n++;\n                }\n            }\n        }\n    }\n    return {\"run\": new Sk.builtin.listSlice(a.list, a.base, n), \"descending\": descending};\n};\n\nSk.builtin.timSort.prototype.sort = function () {\n    /*\n     # ____________________________________________________________\n     # Entry point.\n     */\n\n    var minrun;\n    var cr;\n    var sorted;\n    var remaining = new Sk.builtin.listSlice(this.list, 0, this.listlength);\n    if (remaining.len < 2) {\n        return;\n    }\n\n    // March over the array once, left to right, finding natural runs,\n    // and extending short natural runs to minrun elements.\n    this.merge_init();\n    minrun = this.merge_compute_minrun(remaining.len);\n    while (remaining.len > 0) {\n        // Identify next run.\n        cr = this.count_run(remaining);\n        if (cr.descending) {\n            cr.run.reverse();\n        }\n        // If short, extend to min(minrun, nremaining).\n        if (cr.run.len < minrun) {\n            sorted = cr.run.len;\n            if (minrun < remaining.len) {\n                cr.run.len = minrun;\n            } else {\n                cr.run.len = remaining.len;\n            }\n            this.binary_sort(cr.run, sorted);\n        }\n        // Advance remaining past this run.\n        remaining.advance(cr.run.len);\n        // Push run onto pending-runs stack, and maybe merge.\n        this.pending.push(cr.run);\n        this.merge_collapse();\n    }\n    Sk.asserts.assert(remaining.base == this.listlength);\n\n    this.merge_force_collapse();\n    Sk.asserts.assert(this.pending.length == 1);\n    Sk.asserts.assert(this.pending[0].base === 0);\n    Sk.asserts.assert(this.pending[0].len == this.listlength);\n};\n\n/*\n # Locate the proper position of key in a sorted vector; if the vector\n # contains an element equal to key, return the position immediately to the\n # left of the leftmost equal element -- or to the right of the rightmost\n # equal element if the flag \"rightmost\" is set.\n #\n # \"hint\" is an index at which to begin the search, 0 <= hint < a.len.\n # The closer hint is to the final result, the faster this runs.\n #\n # The return value is the index 0 <= k <= a.len such that\n #\n #     a[k-1] < key <= a[k]      (if rightmost is False)\n #     a[k-1] <= key < a[k]      (if rightmost is True)\n #\n # as long as the indices are in bound.  IOW, key belongs at index k;\n # or, IOW, the first k elements of a should precede key, and the last\n # n-k should follow key.\n */\nSk.builtin.timSort.prototype.gallop = function (key, a, hint, rightmost) {\n    var lower;\n    var self;\n    var p;\n    var lastofs;\n    var ofs;\n    var maxofs;\n    var hintminofs;\n    var hintminlastofs;\n    var m;\n    Sk.asserts.assert(0 <= hint && hint < a.len);\n    self = this;\n    if (rightmost) {\n        lower = function (a, b) {\n            return self.le(a, b);\n        }; // search for the largest k for which a[k] <= key\n    } else {\n        lower = function (a, b) {\n            return self.lt(a, b);\n        }; // search for the largest k for which a[k] < key\n    }\n    p = a.base + hint;\n    lastofs = 0;\n    ofs = 1;\n    if (lower(a.getitem(p), key)) {\n        // a[hint] < key -- gallop right, until\n        // a[hint + lastofs] < key <= a[hint + ofs]\n\n        maxofs = a.len - hint; // a[a.len-1] is highest\n        while (ofs < maxofs) {\n            if (lower(a.getitem(p + ofs), key)) {\n                lastofs = ofs;\n                try {\n                    ofs = (ofs << 1) + 1;\n                } catch (err) {\n                    ofs = maxofs;\n                }\n            } else {\n                // key <= a[hint + ofs]\n                break;\n            }\n        }\n        if (ofs > maxofs) {\n            ofs = maxofs;\n        }\n        // Translate back to offsets relative to a.\n        lastofs += hint;\n        ofs += hint;\n    } else {\n        // key <= a[hint] -- gallop left, until\n        // a[hint - ofs] < key <= a[hint - lastofs]\n        maxofs = hint + 1;   // a[0] is lowest\n        while (ofs < maxofs) {\n            if (lower(a.getitem(p - ofs), key)) {\n                break;\n            } else {\n                // key <= a[hint - ofs]\n                lastofs = ofs;\n                try {\n                    ofs = (ofs << 1) + 1;\n                } catch (err) {\n                    ofs = maxofs;\n                }\n            }\n        }\n        if (ofs > maxofs) {\n            ofs = maxofs;\n        }\n        // Translate back to positive offsets relative to a.\n        hintminofs = hint - ofs;\n        hintminlastofs = hint - lastofs;\n        lastofs = hintminofs;\n        ofs = hintminlastofs;\n    }\n    Sk.asserts.assert(-1 <= lastofs < ofs <= a.len);\n\n    // Now a[lastofs] < key <= a[ofs], so key belongs somewhere to the\n    // right of lastofs but no farther right than ofs.  Do a binary\n    // search, with invariant a[lastofs-1] < key <= a[ofs].\n\n    lastofs += 1;\n    while (lastofs < ofs) {\n        m = lastofs + ((ofs - lastofs) >> 1);\n        if (lower(a.getitem(a.base + m), key)) {\n            lastofs = m + 1;   // a[m] < key\n        } else {\n            ofs = m;         // key <= a[m]\n        }\n    }\n    Sk.asserts.assert(lastofs == ofs);         // so a[ofs-1] < key <= a[ofs]\n    return ofs;\n};\n\n// ____________________________________________________________\n\nSk.builtin.timSort.prototype.merge_init = function () {\n    // This controls when we get *into* galloping mode.  It's initialized\n    // to MIN_GALLOP.  merge_lo and merge_hi tend to nudge it higher for\n    // random data, and lower for highly structured data.\n    this.min_gallop = this.MIN_GALLOP;\n\n    // A stack of n pending runs yet to be merged.  Run #i starts at\n    // address pending[i].base and extends for pending[i].len elements.\n    // It's always true (so long as the indices are in bounds) that\n    //\n    //     pending[i].base + pending[i].len == pending[i+1].base\n    //\n    // so we could cut the storage for this, but it's a minor amount,\n    // and keeping all the info explicit simplifies the code.\n    this.pending = [];\n};\n\n// Merge the slice \"a\" with the slice \"b\" in a stable way, in-place.\n// a.len <= b.len.  See listsort.txt for more info.\n// a.len and b.len must be > 0, and a.base + a.len == b.base.\n// Must also have that b.list[b.base] < a.list[a.base], that\n// a.list[a.base+a.len-1] belongs at the end of the merge, and should have\n\nSk.builtin.timSort.prototype.merge_lo = function (a, b) {\n    var min_gallop;\n    var dest;\n    var acount, bcount;\n    var p;\n    Sk.asserts.assert(a.len > 0 && b.len > 0 && a.base + a.len == b.base);\n    min_gallop = this.min_gallop;\n    dest = a.base;\n    a = a.copyitems();\n\n    // Invariant: elements in \"a\" are waiting to be reinserted into the list\n    // at \"dest\".  They should be merged with the elements of \"b\".\n    // b.base == dest + a.len.\n    // We use a finally block to ensure that the elements remaining in\n    // the copy \"a\" are reinserted back into this.list in all cases.\n    try {\n        this.setitem(dest, b.popleft());\n\n        dest++;\n        if (a.len == 1 || b.len === 0) {\n            return;\n        }\n\n        while (true) {\n            acount = 0;   // number of times A won in a row\n            bcount = 0;   // number of times B won in a row\n\n            // Do the straightforward thing until (if ever) one run\n            // appears to win consistently.\n            while (true) {\n                if (this.lt(b.getitem(b.base), a.getitem(a.base))) {\n                    this.setitem(dest, b.popleft());\n                    dest++;\n                    if (b.len === 0) {\n                        return;\n                    }\n                    bcount++;\n                    acount = 0;\n                    if (bcount >= min_gallop) {\n                        break;\n                    }\n                } else {\n                    this.setitem(dest, a.popleft());\n                    dest++;\n                    if (a.len == 1) {\n                        return;\n                    }\n                    acount++;\n                    bcount = 0;\n                    if (acount >= min_gallop) {\n                        break;\n                    }\n                }\n            }\n\n            // One run is winning so consistently that galloping may\n            // be a huge win.  So try that, and continue galloping until\n            // (if ever) neither run appears to be winning consistently\n            // anymore.\n            min_gallop += 1;\n\n            while (true) {\n                min_gallop -= min_gallop > 1;\n                this.min_gallop = min_gallop;\n                acount = this.gallop(b.getitem(b.base), a, 0, true);\n                for (p = a.base; p < a.base + acount; p++) {\n                    this.setitem(dest, a.getitem(p));\n                    dest++;\n                }\n\n                a.advance(acount);\n\n                if (a.len <= 1) {\n                    return;\n                }\n\n                this.setitem(dest, b.popleft());\n                dest++;\n\n                // a.len==0 is impossible now if the comparison\n                // function is consistent, but we can't assume\n                // that it is.\n                if (b.len === 0) {\n                    return;\n                }\n\n                bcount = this.gallop(a.getitem(a.base), b, 0, false);\n\n                for (p = b.base; p < b.base + bcount; p++) {\n                    this.setitem(dest, b.getitem(p));\n                    dest++;\n                }\n\n                b.advance(bcount);\n                if (b.len === 0) {\n                    return;\n                }\n                this.setitem(dest, a.popleft());\n                dest++;\n\n                if (a.len == 1) {\n                    return;\n                }\n\n                if (acount < this.MIN_GALLOP && bcount < this.MIN_GALLOP) {\n                    break;\n                }\n\n                min_gallop++;  // penalize it for leaving galloping mode\n                this.min_gallop = min_gallop;\n            }\n        }\n    } finally {\n        // The last element of a belongs at the end of the merge, so we copy\n        // the remaining elements of b before the remaining elements of a.\n        Sk.asserts.assert(a.len >= 0 && b.len >= 0);\n        for (p = b.base; p < b.base + b.len; p++) {\n            this.setitem(dest, b.getitem(p));\n            dest++;\n        }\n        for (p = a.base; p < a.base + a.len; p++) {\n            this.setitem(dest, a.getitem(p));\n            dest++;\n        }\n    }\n};\n\nSk.builtin.timSort.prototype.merge_hi = function (a, b) {\n    var min_gallop;\n    var dest;\n    var acount, bcount, nexta, nextb;\n    var k;\n    var p;\n    Sk.asserts.assert(a.len > 0 && b.len > 0 && a.base + a.len == b.base);\n    min_gallop = this.min_gallop;\n    dest = b.base + b.len;\n    b = b.copyitems();\n\n    // Invariant: elements in \"a\" are waiting to be reinserted into the list\n    // at \"dest\".  They should be merged with the elements of \"b\".\n    // b.base == dest + a.len.\n    // We use a finally block to ensure that the elements remaining in\n    // the copy \"a\" are reinserted back into this.list in all cases.\n    try {\n        dest--;\n        this.setitem(dest, a.popright());\n\n        if (a.len === 0 || b.len == 1) {\n            return;\n        }\n\n        while (true) {\n            acount = 0;   // number of times A won in a row\n            bcount = 0;   // number of times B won in a row\n\n            // Do the straightforward thing until (if ever) one run\n            // appears to win consistently.\n            while (true) {\n                nexta = a.getitem(a.base + a.len - 1);\n                nextb = b.getitem(b.base + b.len - 1);\n                if (this.lt(nextb, nexta)) {\n                    dest--;\n                    this.setitem(dest, nexta);\n                    a.len--;\n                    if (a.len === 0) {\n                        return;\n                    }\n                    acount++;\n                    bcount = 0;\n                    if (acount >= min_gallop) {\n                        break;\n                    }\n                } else {\n                    dest--;\n                    this.setitem(dest, nextb);\n                    b.len--;\n                    if (b.len == 1) {\n                        return;\n                    }\n                    bcount++;\n                    acount = 0;\n                    if (bcount >= min_gallop) {\n                        break;\n                    }\n                }\n            }\n\n            // One run is winning so consistently that galloping may\n            // be a huge win.  So try that, and continue galloping until\n            // (if ever) neither run appears to be winning consistently\n            // anymore.\n            min_gallop += 1;\n\n            while (true) {\n                min_gallop -= min_gallop > 1;\n                this.min_gallop = min_gallop;\n                nextb = b.getitem(b.base + b.len - 1);\n                k = this.gallop(nextb, a, a.len - 1, true);\n                acount = a.len - k;\n                for (p = a.base + a.len - 1; p > a.base + k - 1; p--) {\n                    dest--;\n                    this.setitem(dest, a.getitem(p));\n                }\n                a.len -= acount;\n                if (a.len === 0) {\n                    return;\n                }\n\n                dest--;\n                this.setitem(dest, b.popright());\n                if (b.len == 1) {\n                    return;\n                }\n\n                nexta = a.getitem(a.base + a.len - 1);\n                k = this.gallop(nexta, b, b.len - 1, false);\n                bcount = b.len - k;\n                for (p = b.base + b.len - 1; p > b.base + k - 1; p--) {\n                    dest--;\n                    this.setitem(dest, b.getitem(p));\n                }\n\n                b.len -= bcount;\n\n                // b.len==0 is impossible now if the comparison\n                // function is consistent, but we can't assume\n                // that it is.\n                if (b.len <= 1) {\n                    return;\n                }\n                dest--;\n                this.setitem(dest, a.popright());\n                if (a.len === 0) {\n                    return;\n                }\n\n                if (acount < this.MIN_GALLOP && bcount < this.MIN_GALLOP) {\n                    break;\n                }\n\n                min_gallop++;  // penalize it for leaving galloping mode\n                this.min_gallop = min_gallop;\n            }\n        }\n    } finally {\n        // The last element of a belongs at the end of the merge, so we copy\n        // the remaining elements of b before the remaining elements of a.\n        Sk.asserts.assert(a.len >= 0 && b.len >= 0);\n        for (p = a.base + a.len - 1; p > a.base - 1; p--) {\n            dest--;\n            this.setitem(dest, a.getitem(p));\n        }\n        for (p = b.base + b.len - 1; p > b.base - 1; p--) {\n            dest--;\n            this.setitem(dest, b.getitem(p));\n        }\n    }\n};\n\n// Merge the two runs at stack indices i and i+1.\n\nSk.builtin.timSort.prototype.merge_at = function (i) {\n    var a;\n    var b;\n    var k;\n    if (i < 0) {\n        i = this.pending.length + i;\n    }\n\n    a = this.pending[i];\n    b = this.pending[i + 1];\n    Sk.asserts.assert(a.len > 0 && b.len > 0);\n    Sk.asserts.assert(a.base + a.len == b.base);\n\n    // Record the length of the combined runs and remove the run b\n    this.pending[i] = new Sk.builtin.listSlice(this.list, a.base, a.len + b.len);\n    this.pending.splice(i + 1, 1);\n\n    // Where does b start in a?  Elements in a before that can be\n    // ignored (already in place).\n    k = this.gallop(b.getitem(b.base), a, 0, true);\n    a.advance(k);\n    if (a.len === 0) {\n        return;\n    }\n\n    // Where does a end in b?  Elements in b after that can be\n    // ignored (already in place).\n    b.len = this.gallop(a.getitem(a.base + a.len - 1), b, b.len - 1, false);\n    if (b.len === 0) {\n        return;\n    }\n\n    // Merge what remains of the runs.  The direction is chosen to\n    // minimize the temporary storage needed.\n    if (a.len <= b.len) {\n        this.merge_lo(a, b);\n    } else {\n        this.merge_hi(a, b);\n    }\n};\n\n// Examine the stack of runs waiting to be merged, merging adjacent runs\n// until the stack invariants are re-established:\n//\n// 1. len[-3] > len[-2] + len[-1]\n// 2. len[-2] > len[-1]\n//\n// See listsort.txt for more info.\nSk.builtin.timSort.prototype.merge_collapse = function () {\n    var p = this.pending;\n    while (p.length > 1) {\n        if (p.length >= 3 && p[p.length - 3].len <= p[p.length - 2].len + p[p.length - 1].len) {\n            if (p[p.length - 3].len < p[p.length - 1].len) {\n                this.merge_at(-3);\n            } else {\n                this.merge_at(-2);\n            }\n        } else if (p[p.length - 2].len <= p[p.length - 1].len) {\n            this.merge_at(-2);\n        } else {\n            break;\n        }\n    }\n};\n\n// Regardless of invariants, merge all runs on the stack until only one\n// remains.  This is used at the end of the mergesort.\n\nSk.builtin.timSort.prototype.merge_force_collapse = function () {\n    var p = this.pending;\n    while (p.length > 1) {\n        if (p.length >= 3 && p[p.length - 3].len < p[p.length - 1].len) {\n            this.merge_at(-3);\n        } else {\n            this.merge_at(-2);\n        }\n    }\n};\n// Compute a good value for the minimum run length; natural runs shorter\n// than this are boosted artificially via binary insertion.\n//\n// If n < 64, return n (it's too small to bother with fancy stuff).\n// Else if n is an exact power of 2, return 32.\n// Else return an int k, 32 <= k <= 64, such that n/k is close to, but\n// strictly less than, an exact power of 2.\n//\n// See listsort.txt for more info.\n\nSk.builtin.timSort.prototype.merge_compute_minrun = function (n) {\n    var r = 0;    // becomes 1 if any 1 bits are shifted off\n    while (n >= 64) {\n        r = r | n & 1;\n        n >>= 1;\n    }\n    return n + r;\n};\n\n//ListSlice\n/**\n * @constructor\n * @param {Sk.builtin.list=} list\n * @param {number=} base\n * @param {number=} len\n * @extends Sk.builtin.object\n */\nSk.builtin.listSlice = function (list, base, len) {\n    this.list = list;\n    this.base = base;\n    this.len = len;\n};\n\nSk.builtin.listSlice.prototype.copyitems = function () {\n    //Make a copy of the slice of the original list\n    var start = this.base;\n    var stop = this.base + this.len;\n    Sk.asserts.assert(0 <= start <= stop);\n    return new Sk.builtin.listSlice(new Sk.builtin.list(this.list.v.slice(start, stop)), 0, this.len);\n};\n\nSk.builtin.listSlice.prototype.advance = function (n) {\n    this.base += n;\n    this.len -= n;\n    Sk.asserts.assert(this.base <= this.list.sq$length());\n};\n\nSk.builtin.listSlice.prototype.getitem = function (item) {\n    return this.list.v[item];\n};\n\nSk.builtin.listSlice.prototype.setitem = function (item, value) {\n    this.list.v[item] = value;\n};\n\nSk.builtin.listSlice.prototype.popleft = function () {\n    var result = this.list.v[this.base];\n    this.base++;\n    this.len--;\n    return result;\n};\n\nSk.builtin.listSlice.prototype.popright = function () {\n    this.len--;\n    return this.list.v[this.base + this.len];\n};\n\nSk.builtin.listSlice.prototype.reverse = function () {\n    // Reverse the slice in-place.\n    var list_hi;\n    var list_lo;\n    var list = this.list;\n    var lo = this.base;\n    var hi = lo + this.len - 1;\n    while (lo < hi) {\n        list_hi = list.v[hi];\n        list_lo = list.v[lo];\n        list.v[lo] = list_hi;\n        list.v[hi] = list_lo;\n        lo++;\n        hi--;\n    }\n};\n\nSk.exportSymbol(\"Sk.builtin.listSlice\", Sk.builtin.listSlice);\nSk.exportSymbol(\"Sk.builtin.timSort\", Sk.builtin.timSort);\n\n\n/***/ }),\n/* 52 */\n/***/ (function(module, exports) {\n\nSk.builtin.sorted = function sorted (iterable, cmp, key, reverse) {\n    var arr;\n    var next;\n    var iter;\n    var compare_func;\n    var list;\n    var rev;\n\n    if (reverse === undefined) {\n        rev = false;\n    } else if (reverse instanceof Sk.builtin.float_) {\n        throw new Sk.builtin.TypeError(\"an integer is required, got float\");\n    } else if (reverse instanceof Sk.builtin.int_ || reverse.prototype instanceof Sk.builtin.int_) {\n        rev = Sk.misceval.isTrue(reverse);\n    } else {\n        throw new Sk.builtin.TypeError(\"an integer is required\");\n    }\n\n    if (key !== undefined && !(key instanceof Sk.builtin.none)) {\n        if (cmp instanceof Sk.builtin.none || cmp === undefined) {\n            compare_func = function (a, b) {\n                return Sk.misceval.richCompareBool(a[0], b[0], \"Lt\") ? new Sk.builtin.int_(-1) : new Sk.builtin.int_(0);\n            };\n        } else {\n            compare_func = function (a, b) {\n                return Sk.misceval.callsimArray(cmp, [a[0], b[0]]);\n            };\n        }\n        iter = iterable.tp$iter();\n        next = iter.tp$iternext();\n        arr = [];\n        while (next !== undefined) {\n            arr.push([Sk.misceval.callsimArray(key, [next]), next]);\n            next = iter.tp$iternext();\n        }\n        list = new Sk.builtin.list(arr);\n    } else {\n        if (!(cmp instanceof Sk.builtin.none) && cmp !== undefined) {\n            compare_func = cmp;\n        }\n        list = new Sk.builtin.list(iterable);\n    }\n\n    if (compare_func !== undefined) {\n        list.list_sort_(list, compare_func);\n    } else {\n        list.list_sort_(list);\n    }\n\n    if (rev) {\n        list.list_reverse_(list);\n    }\n\n    if (key !== undefined && !(key instanceof Sk.builtin.none)) {\n        iter = list.tp$iter();\n        next = iter.tp$iternext();\n        arr = [];\n        while (next !== undefined) {\n            arr.push(next[1]);\n            next = iter.tp$iternext();\n        }\n        list = new Sk.builtin.list(arr);\n    }\n\n    return list;\n};\n\n/* NOTE: See constants used for kwargs in constants.js */\n\n\n/***/ }),\n/* 53 */\n/***/ (function(module, exports) {\n\nSk.builtin.type_is_subtype_base_chain = function type_is_subtype_base_chain(a, b) {\n    do {\n        if (a == b) {\n            return true;\n        }\n        a = a.tp$base;\n    } while (a !== undefined);\n\n    return (b == Sk.builtin.object);\n};\n\nSk.builtin.PyType_IsSubtype = function PyType_IsSubtype(a, b) {\n    var mro = a.tp$mro;\n    if (mro) {\n        /* Deal with multiple inheritance without recursion\n           by walking the MRO tuple */\n        Sk.asserts.assert(mro instanceof Sk.builtin.tuple);\n        for (var i = 0; i < mro.v.length; i++) {\n            if (mro.v[i] == b) {\n                return true;\n            }\n        }\n        return false;\n    } else {\n        /* a is not completely initilized yet; follow tp_base */\n        return Sk.builtin.type_is_subtype_base_chain(a, b);\n    }\n};\n\n/**\n * @constructor\n * Sk.builtin.super_\n */\nSk.builtin.super_ = function super_ (a_type, self) {\n    Sk.builtin.pyCheckArgsLen(\"super\", arguments.length, 1);\n\n    if (!(this instanceof Sk.builtin.super_)) {\n        return new Sk.builtin.super_(a_type, self);\n    }\n\n    Sk.misceval.callsimArray(Sk.builtin.super_.__init__, [this, a_type, self]);\n\n    return this;\n};\n\nSk.builtin.super_.__init__ = new Sk.builtin.func(function(self, a_type, other_self) {\n    self.obj = other_self;\n    self.type = a_type;\n\n    if (!a_type.tp$mro) {\n        throw new Sk.builtin.TypeError(\"must be type, not \" + a_type.ob$type.tp$name);\n    }\n\n    self.obj_type = a_type.tp$mro.v[1];\n\n    if (!other_self) {\n        throw new Sk.builtin.NotImplementedError(\"unbound super not supported because \" +\n                \"skulpts implementation of type descriptors aren't brilliant yet, see this \" +\n                \"question for more information https://stackoverflow.com/a/30190341/117242\");\n    }\n\n    if (!Sk.builtin.PyType_IsSubtype(self.obj.ob$type, self.type)) {\n        throw new Sk.builtin.TypeError(\"super(type, obj): obj must be an instance of subtype of type\");\n    }\n\n    return Sk.builtin.none.none$;\n});\n\nSk.abstr.setUpInheritance(\"super\", Sk.builtin.super_, Sk.builtin.object);\n\n/**\n * Get an attribute\n * @param {Object} pyName Python name of the attribute\n * @param {boolean=} canSuspend Can we return a suspension?\n * @return {undefined}\n */\nSk.builtin.super_.prototype.tp$getattr = function (pyName, canSuspend) {\n    var res;\n    var f;\n    var descr;\n    var tp;\n    var dict;\n    var jsName = pyName.$jsstr();\n\n    tp = this.obj_type;\n    Sk.asserts.assert(tp !== undefined, \"object has no ob$type!\");\n\n    dict = this.obj[\"$d\"] || this.obj.constructor[\"$d\"];\n\n    // todo; assert? force?\n    if (dict) {\n        if (dict.mp$lookup) {\n            res = dict.mp$lookup(pyName);\n        } else if (dict.mp$subscript) {\n            res = Sk.builtin._tryGetSubscript(dict, pyName);\n        } else if (typeof dict === \"object\") {\n            // todo; definitely the wrong place for this. other custom tp$getattr won't work on object -- bnm -- implemented custom __getattr__ in abstract.js\n            res = dict[jsName];\n        }\n        if (res !== undefined) {\n            return res;\n        }\n    }\n\n    descr = Sk.builtin.type.typeLookup(tp, pyName);\n\n    // otherwise, look in the type for a descr\n    if (descr !== undefined && descr !== null) {\n        f = descr.tp$descr_get;\n        // todo - data descriptors (ie those with tp$descr_set too) get a different lookup priority\n\n        if (f) {\n            // non-data descriptor\n            return f.call(descr, this.obj, this.obj_type, canSuspend);\n        }\n    }\n\n    if (descr !== undefined) {\n        return descr;\n    }\n\n    return undefined;\n};\n\nSk.builtin.super_.prototype[\"$r\"] = function super_repr(self) {\n    if (this.obj) {\n        return new Sk.builtin.str(\"<super: <class '\" + (this.type ? this.type.tp$name : \"NULL\") + \"'>, <\" + this.obj.tp$name + \" object>>\");\n    }\n\n    return new Sk.builtin.str(\"<super: <class '\" + (this.type ? this.type.tp$name : \"NULL\") + \"'>, NULL>\");\n};\n\nSk.builtin.super_.__doc__ = new Sk.builtin.str(\n    \"super(type, obj) -> bound super object; requires isinstance(obj, type)\\n\" +\n    \"super(type) -> unbound super object\\n\" +\n    \"super(type, type2) -> bound super object; requires issubclass(type2, type)\\n\" +\n    \"Typical use to call a cooperative superclass method:\\n\" +\n    \"class C(B):\\n\" +\n    \"    def meth(self, arg):\\n\" +\n    \"        super(C, self).meth(arg)\");\n\n\n/***/ }),\n/* 54 */\n/***/ (function(module, exports) {\n\n// Note: the hacky names on int, long, float have to correspond with the\n// uniquization that the compiler does for words that are reserved in\n// Javascript. This is a bit hokey.\nSk.builtins = {\n    \"range\"     : new Sk.builtin.func(Sk.builtin.range),\n    \"round\"     : new Sk.builtin.func(Sk.builtin.round),\n    \"len\"       : new Sk.builtin.func(Sk.builtin.len),\n    \"min\"       : new Sk.builtin.func(Sk.builtin.min),\n    \"max\"       : new Sk.builtin.func(Sk.builtin.max),\n    \"sum\"       : new Sk.builtin.func(Sk.builtin.sum),\n    \"zip\"       : new Sk.builtin.func(Sk.builtin.zip),\n    \"abs\"       : new Sk.builtin.func(Sk.builtin.abs),\n    \"fabs\"      : new Sk.builtin.func(Sk.builtin.fabs),\n    \"ord\"       : new Sk.builtin.func(Sk.builtin.ord),\n    \"chr\"       : new Sk.builtin.func(Sk.builtin.chr),\n    \"hex\"       : new Sk.builtin.func(Sk.builtin.hex),\n    \"oct\"       : new Sk.builtin.func(Sk.builtin.oct),\n    \"bin\"       : new Sk.builtin.func(Sk.builtin.bin),\n    \"dir\"       : new Sk.builtin.func(Sk.builtin.dir),\n    \"repr\"      : new Sk.builtin.func(Sk.builtin.repr),\n    \"open\"      : new Sk.builtin.func(Sk.builtin.open),\n    \"isinstance\": new Sk.builtin.func(Sk.builtin.isinstance),\n    \"hash\"      : new Sk.builtin.func(Sk.builtin.hash),\n    \"getattr\"   : new Sk.builtin.func(Sk.builtin.getattr),\n    \"hasattr\"   : new Sk.builtin.func(Sk.builtin.hasattr),\n    \"id\"        : new Sk.builtin.func(Sk.builtin.id),\n\n    \"map\"       : new Sk.builtin.func(Sk.builtin.map),\n    \"filter\"    : new Sk.builtin.func(Sk.builtin.filter),\n    \"reduce\"    : new Sk.builtin.func(Sk.builtin.reduce),\n    \"sorted\"    : new Sk.builtin.func(Sk.builtin.sorted),\n    \"any\"       : new Sk.builtin.func(Sk.builtin.any),\n    \"all\"       : new Sk.builtin.func(Sk.builtin.all),\n\n    \"AttributeError\"     : Sk.builtin.AttributeError,\n    \"ValueError\"         : Sk.builtin.ValueError,\n    \"Exception\"          : Sk.builtin.Exception,\n    \"ZeroDivisionError\"  : Sk.builtin.ZeroDivisionError,\n    \"AssertionError\"     : Sk.builtin.AssertionError,\n    \"ImportError\"        : Sk.builtin.ImportError,\n    \"IndentationError\"   : Sk.builtin.IndentationError,\n    \"IndexError\"         : Sk.builtin.IndexError,\n    \"KeyError\"           : Sk.builtin.KeyError,\n    \"TypeError\"          : Sk.builtin.TypeError,\n    \"NameError\"          : Sk.builtin.NameError,\n    \"IOError\"            : Sk.builtin.IOError,\n    \"NotImplementedError\": Sk.builtin.NotImplementedError,\n    \"StandardError\"      : Sk.builtin.StandardError,\n    \"SystemExit\"         : Sk.builtin.SystemExit,\n    \"OverflowError\"      : Sk.builtin.OverflowError,\n    \"OperationError\"     : Sk.builtin.OperationError,\n    \"NegativePowerError\" : Sk.builtin.NegativePowerError,\n    \"RuntimeError\"       : Sk.builtin.RuntimeError,\n    \"StopIteration\"      : Sk.builtin.StopIteration,\n\n    \"float_$rw$\": Sk.builtin.float_,\n    \"int_$rw$\"  : Sk.builtin.int_,\n    \"bool\"      : Sk.builtin.bool,\n    \"complex\"   : Sk.builtin.complex,\n    \"enumerate\" : Sk.builtin.enumerate,\n    \"dict\"      : Sk.builtin.dict,\n    \"file\"      : Sk.builtin.file,\n    \"function\"  : Sk.builtin.func,\n    \"generator\" : Sk.builtin.generator,\n    \"list\"      : Sk.builtin.list,\n    \"long_$rw$\" : Sk.builtin.lng,\n    \"method\"    : Sk.builtin.method,\n    \"object\"    : Sk.builtin.object,\n    \"slice\"     : Sk.builtin.slice,\n    \"str\"       : Sk.builtin.str,\n    \"set\"       : Sk.builtin.set,\n    \"tuple\"     : Sk.builtin.tuple,\n    \"type\"      : Sk.builtin.type,\n\n    \"input\"     : new Sk.builtin.func(Sk.builtin.input),\n    \"raw_input\" : new Sk.builtin.func(Sk.builtin.raw_input),\n    \"setattr\"   : new Sk.builtin.func(Sk.builtin.setattr),\n    /*'read': Sk.builtin.read,*/\n    \"jseval\"    : Sk.builtin.jseval,\n    \"jsmillis\"  : Sk.builtin.jsmillis,\n    \"quit\"      : new Sk.builtin.func(Sk.builtin.quit),\n    \"exit\"      : new Sk.builtin.func(Sk.builtin.quit),\n    \"print\"     : Sk.builtin.print,\n    \"divmod\"    : new Sk.builtin.func(Sk.builtin.divmod),\n    \"format\"    : new Sk.builtin.func(Sk.builtin.format),\n    \"globals\"   : new Sk.builtin.func(Sk.builtin.globals),\n    \"issubclass\": new Sk.builtin.func(Sk.builtin.issubclass),\n    \"iter\"      : Sk.builtin.iter,\n\n    // Functions below are not implemented\n    \"bytearray\" : Sk.builtin.bytearray,\n    \"callable\"  : Sk.builtin.callable,\n    \"delattr\"   : Sk.builtin.delattr,\n    \"eval_$rn$\" : Sk.builtin.eval_,\n    \"execfile\"  : Sk.builtin.execfile,\n    \"frozenset\" : Sk.builtin.frozenset,\n    \"help\"      : Sk.builtin.help,\n    \"locals\"    : Sk.builtin.locals,\n    \"memoryview\": Sk.builtin.memoryview,\n    \"next\"      : Sk.builtin.next_,\n    \"pow\"       : Sk.builtin.pow,\n    \"reload\"    : Sk.builtin.reload,\n    \"reversed\"  : Sk.builtin.reversed,\n    \"super\"     : Sk.builtin.super_,\n    \"unichr\"    : Sk.builtin.unichr,\n    \"vars\"      : Sk.builtin.vars,\n    \"xrange\"    : Sk.builtin.xrange,\n    \"apply_$rn$\": Sk.builtin.apply_,\n    \"buffer\"    : Sk.builtin.buffer,\n    \"coerce\"    : Sk.builtin.coerce,\n    \"intern\"    : Sk.builtin.intern\n};\nSk.exportSymbol(\"Sk.builtins\", Sk.builtins);\n\n\n/***/ }),\n/* 55 */\n/***/ (function(module, exports) {\n\nSk.builtin.str.$emptystr = new Sk.builtin.str(\"\");\n\n/**\n * Python bool True constant.\n * @type {Sk.builtin.bool}\n * @memberOf Sk.builtin.bool\n */\nSk.builtin.bool.true$ = /** @type {Sk.builtin.bool} */ (Object.create(Sk.builtin.bool.prototype, {v: {value: 1, enumerable: true}}));\n\n/**\n * Python bool False constant.\n * @type {Sk.builtin.bool}\n * @memberOf Sk.builtin.bool\n */\nSk.builtin.bool.false$ = /** @type {Sk.builtin.bool} */ (Object.create(Sk.builtin.bool.prototype, {v: {value: 0, enumerable: true}}));\n\n/* Constants used for kwargs */\n\n// Sk.builtin.int_\nSk.builtin.int_.co_varnames = [ \"number\", \"base\" ];\nSk.builtin.int_.$defaults = [ 0, Sk.builtin.none.none$ ];\n\n// Sk.builtin.lng\nSk.builtin.lng.co_varnames = [ \"number\", \"base\" ];\nSk.builtin.lng.$defaults = [ 0, Sk.builtin.none.none$ ];\n\n// Sk.builtin.sorted\nSk.builtin.sorted.co_varnames = [\"list\", \"cmp\", \"key\", \"reverse\"];\nSk.builtin.sorted.$defaults = [Sk.builtin.none.none$, Sk.builtin.none.none$, Sk.builtin.bool.false$];\n\n// Sk.builtin.dict.fromkeys\nSk.builtin.dict.$fromkeys.co_name = new Sk.builtin.str(\"fromkeys\");\nSk.builtin.dict.prototype[\"fromkeys\"] = new Sk.builtin.func(Sk.builtin.dict.$fromkeys);\n\n// String constants\nSk.builtin.str.$empty = new Sk.builtin.str(\"\");\n\nSk.builtin.str.$default_factory = new Sk.builtin.str(\"default_factory\");\nSk.builtin.str.$imag = new Sk.builtin.str(\"imag\");\nSk.builtin.str.$real = new Sk.builtin.str(\"real\");\n\nSk.builtin.str.$abs = new Sk.builtin.str(\"__abs__\");\nSk.builtin.str.$call = new Sk.builtin.str(\"__call__\");\nSk.builtin.str.$cmp = new Sk.builtin.str(\"__cmp__\");\nSk.builtin.str.$complex = new Sk.builtin.str(\"__complex__\");\nSk.builtin.str.$contains = new Sk.builtin.str(\"__contains__\");\nSk.builtin.str.$copy = new Sk.builtin.str(\"__copy__\");\nSk.builtin.str.$dict = new Sk.builtin.str(\"__dict__\");\nSk.builtin.str.$dir = new Sk.builtin.str(\"__dir__\");\nSk.builtin.str.$enter = new Sk.builtin.str(\"__enter__\");\nSk.builtin.str.$eq = new Sk.builtin.str(\"__eq__\");\nSk.builtin.str.$exit = new Sk.builtin.str(\"__exit__\");\nSk.builtin.str.$index = new Sk.builtin.str(\"__index__\");\nSk.builtin.str.$init = new Sk.builtin.str(\"__init__\");\nSk.builtin.str.$int_ = new Sk.builtin.str(\"__int__\");\nSk.builtin.str.$iter = new Sk.builtin.str(\"__iter__\");\nSk.builtin.str.$float_ = new Sk.builtin.str(\"__float__\");\nSk.builtin.str.$format = new Sk.builtin.str(\"__format__\");\nSk.builtin.str.$ge = new Sk.builtin.str(\"__ge__\");\nSk.builtin.str.$getattr = new Sk.builtin.str(\"__getattr__\");\nSk.builtin.str.$getattribute = new Sk.builtin.str(\"__getattribute__\");\nSk.builtin.str.$getitem = new Sk.builtin.str(\"__getitem__\");\nSk.builtin.str.$gt = new Sk.builtin.str(\"__gt__\");\nSk.builtin.str.$le = new Sk.builtin.str(\"__le__\");\nSk.builtin.str.$len = new Sk.builtin.str(\"__len__\");\nSk.builtin.str.$lt = new Sk.builtin.str(\"__lt__\");\nSk.builtin.str.$name = new Sk.builtin.str(\"__name__\");\nSk.builtin.str.$ne = new Sk.builtin.str(\"__ne__\");\nSk.builtin.str.$new = new Sk.builtin.str(\"__new__\");\nSk.builtin.str.$next2 = new Sk.builtin.str(\"next\");\nSk.builtin.str.$next3 = new Sk.builtin.str(\"__next__\");\nSk.builtin.str.$path = new Sk.builtin.str(\"__path__\");\nSk.builtin.str.$repr = new Sk.builtin.str(\"__repr__\");\nSk.builtin.str.$reversed = new Sk.builtin.str(\"__reversed__\");\nSk.builtin.str.$round = new Sk.builtin.str(\"__round__\");\nSk.builtin.str.$setattr = new Sk.builtin.str(\"__setattr__\");\nSk.builtin.str.$setitem = new Sk.builtin.str(\"__setitem__\");\nSk.builtin.str.$str = new Sk.builtin.str(\"__str__\");\nSk.builtin.str.$trunc = new Sk.builtin.str(\"__trunc__\");\nSk.builtin.str.$write = new Sk.builtin.str(\"write\");\n\nSk.misceval.op2method_ = {\n    \"Eq\"   : Sk.builtin.str.$eq,\n    \"NotEq\": Sk.builtin.str.$ne,\n    \"Gt\"   : Sk.builtin.str.$gt,\n    \"GtE\"  : Sk.builtin.str.$ge,\n    \"Lt\"   : Sk.builtin.str.$lt,\n    \"LtE\"  : Sk.builtin.str.$le\n};\n\nvar builtinNames = [\n    \"int_\",\n    \"lng\",\n    \"sorted\",\n    \"range\",\n    \"round\",\n    \"len\",\n    \"min\",\n    \"max\",\n    \"sum\",\n    \"zip\",\n    \"abs\",\n    \"fabs\",\n    \"ord\",\n    \"chr\",\n    \"hex\",\n    \"oct\",\n    \"bin\",\n    \"dir\",\n    \"repr\",\n    \"open\",\n    \"isinstance\",\n    \"hash\",\n    \"getattr\",\n    \"hasattr\",\n    \"id\",\n    \"map\",\n    \"filter\",\n    \"reduce\",\n    \"sorted\",\n    \"any\",\n    \"all\",\n    \"input\",\n    \"raw_input\",\n    \"setattr\",\n    \"quit\",\n    \"quit\",\n    \"divmod\",\n    \"format\",\n    \"globals\",\n    \"issubclass\"\n];\n\nfor (var i = 0; i < builtinNames.length; i++) {\n    Sk.builtin[builtinNames[i]].co_name = new Sk.builtin.str(builtinNames[i]);\n}\n\n\n/***/ }),\n/* 56 */\n/***/ (function(module, exports) {\n\nSk.internalPy={\"files\":{\"src/classmethod.py\":\"class classmethod(object):\\n    \\\"Emulate PyClassMethod_Type() in Objects/funcobject.c\\\"\\n\\n    def __init__(self, f):\\n        self.f = f\\n\\n    def __get__(self, obj, klass=None):\\n        if klass is None:\\n            klass = type(obj)\\n        def newfunc(*args):\\n            return self.f(klass, *args)\\n        return newfunc\\n\",\"src/property.py\":\"class property(object):\\n    \\\"Emulate PyProperty_Type() in Objects/descrobject.c\\\"\\n\\n    def __init__(self, fget=None, fset=None, fdel=None, doc=None):\\n        self.fget = fget\\n        self.fset = fset\\n        self.fdel = fdel\\n        if doc is None and fget is not None:\\n            if hasattr(fget, '__doc__'):\\n                doc = fget.__doc__\\n            else:\\n                doc = None\\n        self.__doc__ = doc\\n\\n    def __get__(self, obj, objtype=None):\\n        if obj is None:\\n            return self\\n        if self.fget is None:\\n            raise AttributeError(\\\"unreadable attribute\\\")\\n        return self.fget(obj)\\n\\n    def __set__(self, obj, value):\\n        if self.fset is None:\\n            raise AttributeError(\\\"can't set attribute\\\")\\n        self.fset(obj, value)\\n\\n    def __delete__(self, obj):\\n        if self.fdel is None:\\n            raise AttributeError(\\\"can't delete attribute\\\")\\n        self.fdel(obj)\\n\\n    def getter(self, fget):\\n        return type(self)(fget, self.fset, self.fdel, self.__doc__)\\n\\n    def setter(self, fset):\\n        return type(self)(self.fget, fset, self.fdel, self.__doc__)\\n\\n    def deleter(self, fdel):\\n        return type(self)(self.fget, self.fset, fdel, self.__doc__)\\n\",\"src/staticmethod.py\":\"class staticmethod(object):\\n    \\\"Emulate PyStaticMethod_Type() in Objects/funcobject.c\\\"\\n\\n    def __init__(self, f):\\n        self.f = f\\n\\n    def __get__(self, obj, objtype=None):\\n        return self.f\\n\"}}\n\n/***/ })\n/******/ ]);"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 1);\n","var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function(\"return this\")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n","/* jshint ignore:start */\n\n// This file list is only used for testing.\n// It should be kept in sync with ../skulpt.py.\n// Order is important!\n\nrequire(\"./util.js\");\n\n// Global support functions\nSk.global[\"strftime\"] = require(\"strftime\");\nSk.global[\"strptime\"] = require(\"../support/time-helpers/strptime.js\");\nrequire(\"setimmediate\");\n\n// Skulpt\nrequire(\"assert\");\nrequire(\"./env.js\");\nrequire(\"./type.js\");\nrequire(\"./abstract.js\");\nrequire(\"./object.js\");\nrequire(\"./function.js\");\nrequire(\"./builtin.js\");\nrequire(\"./fromcodepoint.js\");\nrequire(\"./errors.js\");\nrequire(\"./method.js\");\nrequire(\"./misceval.js\");\nrequire(\"./seqtype.js\");\nrequire(\"./list.js\");\nrequire(\"./str.js\");\nrequire(\"./formatting.js\");\nrequire(\"./tuple.js\");\nrequire(\"./dict.js\");\nrequire(\"./numtype.js\");\nrequire(\"./biginteger.js\");\nrequire(\"./int.js\");\nrequire(\"./bool.js\");\nrequire(\"./float.js\");\nrequire(\"./number.js\");\nrequire(\"./long.js\");\nrequire(\"./complex.js\");\nrequire(\"./slice.js\");\nrequire(\"./set.js\");\nrequire(\"./print.js\");\nrequire(\"./module.js\");\nrequire(\"./structseq.js\");\nrequire(\"./generator.js\");\nrequire(\"./file.js\");\nrequire(\"./ffi.js\");\nrequire(\"./iterator.js\");\nrequire(\"./enumerate.js\");\nrequire(\"./token.js\");\nrequire(\"./tokenize.js\");\nrequire(\"../gen/parse_tables.js\");\nrequire(\"./parser.js\");\nrequire(\"../gen/astnodes.js\");\nrequire(\"./ast.js\");\nrequire(\"./symtable.js\");\nrequire(\"./compile.js\");\nrequire(\"./import.js\");\nrequire(\"./timsort.js\");\nrequire(\"./sorted.js\");\nrequire(\"./typeobject.js\");\nrequire(\"./builtindict.js\");\nrequire(\"./constants.js\");\nrequire(\"./internalpython.js\");\n\n/* jshint ignore:end */\n","// Global Sk object\nvar Sk = {}; // jshint ignore:line\n\nSk.build = {\n    githash: GITHASH,\n    date: BUILDDATE\n};\n\n/**\n * Global object no matter where we're running\n */\nSk.global =\n    typeof global !== \"undefined\" ? global : // jshint ignore:line\n    typeof self !== \"undefined\" ? self : // jshint ignore:line\n    typeof window !== \"undefined\" ? window : // jshint ignore:line\n    {};\n\n/**\n * Export \"object\" to global namespace as \"name\".\n *\n * @param {string} name name to export the object to\n * @param {*} object object to export\n */\nSk.exportSymbol = function (name, object) {\n    var parts = name.split(\".\");\n    var curobj = Sk.global;\n    var part, idx;\n\n    for (idx = 0; idx < (parts.length - 1); idx++) {\n        part = parts[idx];\n\n        if (curobj.hasOwnProperty(part)) {\n            curobj = curobj[part];\n        } else {\n            curobj = curobj[part] = {};\n        }\n    }\n\n    if (typeof object !== \"undefined\") {\n        part = parts[idx];\n        curobj[part] = object;\n    }\n};\n\nSk.isArrayLike = function (object) {\n    if ((object instanceof Array) || (object && object.length && (typeof object.length == \"number\"))) {\n        return true;\n    }\n    return false;\n};\n\nSk.js_beautify = function (x) {\n    return x;\n};\n\nSk.exportSymbol(\"Sk\", Sk);\nSk.exportSymbol(\"Sk.global\", Sk.global);\nSk.exportSymbol(\"Sk.build\", Sk.build);\nSk.exportSymbol(\"Sk.exportSymbol\", Sk.exportSymbol);\nSk.exportSymbol(\"Sk.isArrayLike\", Sk.isArrayLike);\nSk.exportSymbol(\"Sk.js_beautify\", Sk.js_beautify);\n","//\n// strftime\n// github.com/samsonjs/strftime\n// @_sjs\n//\n// Copyright 2010 - 2016 Sami Samhuri <sami@samhuri.net>\n//\n// MIT License\n// http://sjs.mit-license.org\n//\n\n;(function() {\n\n    var Locales = {\n        de_DE: {\n            days: ['Sonntag', 'Montag', 'Dienstag', 'Mittwoch', 'Donnerstag', 'Freitag', 'Samstag'],\n            shortDays: ['So', 'Mo', 'Di', 'Mi', 'Do', 'Fr', 'Sa'],\n            months: ['Januar', 'Februar', 'Mrz', 'April', 'Mai', 'Juni', 'Juli', 'August', 'September', 'Oktober', 'November', 'Dezember'],\n            shortMonths: ['Jan', 'Feb', 'Mr', 'Apr', 'Mai', 'Jun', 'Jul', 'Aug', 'Sep', 'Okt', 'Nov', 'Dez'],\n            AM: 'AM',\n            PM: 'PM',\n            am: 'am',\n            pm: 'pm',\n            formats: {\n                c: '%a %d %b %Y %X %Z',\n                D: '%d.%m.%Y',\n                F: '%Y-%m-%d',\n                R: '%H:%M',\n                r: '%I:%M:%S %p',\n                T: '%H:%M:%S',\n                v: '%e-%b-%Y',\n                X: '%T',\n                x: '%D'\n            }\n        },\n\n        en_CA: {\n            days: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday' ],\n            shortDays: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],\n            months: ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'],\n            shortMonths: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],\n            ordinalSuffixes: [\n                'st', 'nd', 'rd', 'th', 'th', 'th', 'th', 'th', 'th', 'th',\n                'th', 'th', 'th', 'th', 'th', 'th', 'th', 'th', 'th', 'th',\n                'st', 'nd', 'rd', 'th', 'th', 'th', 'th', 'th', 'th', 'th',\n                'st'\n            ],\n            AM: 'AM',\n            PM: 'PM',\n            am: 'am',\n            pm: 'pm',\n            formats: {\n                c: '%a %d %b %Y %X %Z',\n                D: '%d/%m/%y',\n                F: '%Y-%m-%d',\n                R: '%H:%M',\n                r: '%I:%M:%S %p',\n                T: '%H:%M:%S',\n                v: '%e-%b-%Y',\n                X: '%r',\n                x: '%D'\n            }\n        },\n\n        en_US: {\n            days: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday' ],\n            shortDays: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],\n            months: ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'],\n            shortMonths: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],\n            ordinalSuffixes: [\n                'st', 'nd', 'rd', 'th', 'th', 'th', 'th', 'th', 'th', 'th',\n                'th', 'th', 'th', 'th', 'th', 'th', 'th', 'th', 'th', 'th',\n                'st', 'nd', 'rd', 'th', 'th', 'th', 'th', 'th', 'th', 'th',\n                'st'\n            ],\n            AM: 'AM',\n            PM: 'PM',\n            am: 'am',\n            pm: 'pm',\n            formats: {\n                c: '%a %d %b %Y %X %Z',\n                D: '%m/%d/%y',\n                F: '%Y-%m-%d',\n                R: '%H:%M',\n                r: '%I:%M:%S %p',\n                T: '%H:%M:%S',\n                v: '%e-%b-%Y',\n                X: '%r',\n                x: '%D'\n            }\n        },\n\n        es_MX: {\n            days: ['domingo', 'lunes', 'martes', 'mircoles', 'jueves', 'viernes', 'sbado'],\n            shortDays: ['dom', 'lun', 'mar', 'mi', 'jue', 'vie', 'sb'],\n            months: ['enero', 'febrero', 'marzo', 'abril', 'mayo', 'junio', 'julio', 'agosto', 'septiembre', 'octubre', 'noviembre',' diciembre'],\n            shortMonths: ['ene', 'feb', 'mar', 'abr', 'may', 'jun', 'jul', 'ago', 'sep', 'oct', 'nov', 'dic'],\n            AM: 'AM',\n            PM: 'PM',\n            am: 'am',\n            pm: 'pm',\n            formats: {\n                c: '%a %d %b %Y %X %Z',\n                D: '%d/%m/%Y',\n                F: '%Y-%m-%d',\n                R: '%H:%M',\n                r: '%I:%M:%S %p',\n                T: '%H:%M:%S',\n                v: '%e-%b-%Y',\n                X: '%T',\n                x: '%D'\n            }\n        },\n\n        fr_FR: {\n            days: ['dimanche', 'lundi', 'mardi', 'mercredi', 'jeudi', 'vendredi', 'samedi'],\n            shortDays: ['dim.', 'lun.', 'mar.', 'mer.', 'jeu.', 'ven.', 'sam.'],\n            months: ['janvier', 'fvrier', 'mars', 'avril', 'mai', 'juin', 'juillet', 'aot', 'septembre', 'octobre', 'novembre', 'dcembre'],\n            shortMonths: ['janv.', 'fvr.', 'mars', 'avril', 'mai', 'juin', 'juil.', 'aot', 'sept.', 'oct.', 'nov.', 'dc.'],\n            AM: 'AM',\n            PM: 'PM',\n            am: 'am',\n            pm: 'pm',\n            formats: {\n                c: '%a %d %b %Y %X %Z',\n                D: '%d/%m/%Y',\n                F: '%Y-%m-%d',\n                R: '%H:%M',\n                r: '%I:%M:%S %p',\n                T: '%H:%M:%S',\n                v: '%e-%b-%Y',\n                X: '%T',\n                x: '%D'\n            }\n        },\n\n        it_IT: {\n            days: ['domenica', 'luned', 'marted', 'mercoled', 'gioved', 'venerd', 'sabato'],\n            shortDays: ['dom', 'lun', 'mar', 'mer', 'gio', 'ven', 'sab'],\n            months: ['gennaio', 'febbraio', 'marzo', 'aprile', 'maggio', 'giugno', 'luglio', 'agosto', 'settembre', 'ottobre', 'novembre', 'dicembre'],\n            shortMonths: ['pr', 'mag', 'giu', 'lug', 'ago', 'set', 'ott', 'nov', 'dic'],\n            AM: 'AM',\n            PM: 'PM',\n            am: 'am',\n            pm: 'pm',\n            formats: {\n                c: '%a %d %b %Y %X %Z',\n                D: '%d/%m/%Y',\n                F: '%Y-%m-%d',\n                R: '%H:%M',\n                r: '%I:%M:%S %p',\n                T: '%H:%M:%S',\n                v: '%e-%b-%Y',\n                X: '%T',\n                x: '%D'\n            }\n        },\n\n        nl_NL: {\n            days: ['zondag', 'maandag', 'dinsdag', 'woensdag', 'donderdag', 'vrijdag', 'zaterdag'],\n            shortDays: ['zo', 'ma', 'di', 'wo', 'do', 'vr', 'za'],\n            months: ['januari', 'februari', 'maart', 'april', 'mei', 'juni', 'juli', 'augustus', 'september', 'oktober', 'november', 'december'],\n            shortMonths: ['jan', 'feb', 'mrt', 'apr', 'mei', 'jun', 'jul', 'aug', 'sep', 'okt', 'nov', 'dec'],\n            AM: 'AM',\n            PM: 'PM',\n            am: 'am',\n            pm: 'pm',\n            formats: {\n                c: '%a %d %b %Y %X %Z',\n                D: '%d-%m-%y',\n                F: '%Y-%m-%d',\n                R: '%H:%M',\n                r: '%I:%M:%S %p',\n                T: '%H:%M:%S',\n                v: '%e-%b-%Y',\n                X: '%T',\n                x: '%D'\n            }\n        },\n\n        pt_BR: {\n            days: ['domingo', 'segunda', 'tera', 'quarta', 'quinta', 'sexta', 'sbado'],\n            shortDays: ['Dom', 'Seg', 'Ter', 'Qua', 'Qui', 'Sex', 'Sb'],\n            months: ['janeiro', 'fevereiro', 'maro', 'abril', 'maio', 'junho', 'julho', 'agosto', 'setembro', 'outubro', 'novembro', 'dezembro'],\n            shortMonths: ['Jan', 'Fev', 'Mar', 'Abr', 'Mai', 'Jun', 'Jul', 'Ago', 'Set', 'Out', 'Nov', 'Dez'],\n            AM: 'AM',\n            PM: 'PM',\n            am: 'am',\n            pm: 'pm',\n            formats: {\n                c: '%a %d %b %Y %X %Z',\n                D: '%d-%m-%Y',\n                F: '%Y-%m-%d',\n                R: '%H:%M',\n                r: '%I:%M:%S %p',\n                T: '%H:%M:%S',\n                v: '%e-%b-%Y',\n                X: '%T',\n                x: '%D'\n            }\n        },\n\n        ru_RU: {\n            days: ['', '', '', '', '', '', ''],\n            shortDays: ['', '', '', '', '', '', ''],\n            months: ['', '', '', '', '', '', '', '', '', '', '', ''],\n            shortMonths: ['', '', '', '', '', '', '', '', '', '', '', ''],\n            AM: 'AM',\n            PM: 'PM',\n            am: 'am',\n            pm: 'pm',\n            formats: {\n                c: '%a %d %b %Y %X',\n                D: '%d.%m.%y',\n                F: '%Y-%m-%d',\n                R: '%H:%M',\n                r: '%I:%M:%S %p',\n                T: '%H:%M:%S',\n                v: '%e-%b-%Y',\n                X: '%T',\n                x: '%D'\n            }\n        },\n\n        tr_TR: {\n            days: ['Pazar', 'Pazartesi', 'Sal','aramba', 'Perembe', 'Cuma', 'Cumartesi'],\n            shortDays: ['Paz', 'Pzt', 'Sal', 'r', 'Pr', 'Cum', 'Cts'],\n            months: ['Ocak', 'ubat', 'Mart', 'Nisan', 'Mays', 'Haziran', 'Temmuz', 'Austos', 'Eyll', 'Ekim', 'Kasm', 'Aralk'],\n            shortMonths: ['Oca', 'ub', 'Mar', 'Nis', 'May', 'Haz', 'Tem', 'Au', 'Eyl', 'Eki', 'Kas', 'Ara'],\n            AM: '',\n            PM: 'S',\n            am: '',\n            pm: 'S',\n            formats: {\n                c: '%a %d %b %Y %X %Z',\n                D: '%d-%m-%Y',\n                F: '%Y-%m-%d',\n                R: '%H:%M',\n                r: '%I:%M:%S %p',\n                T: '%H:%M:%S',\n                v: '%e-%b-%Y',\n                X: '%T',\n                x: '%D'\n            }\n        },\n\n        // By michaeljayt<michaeljayt@gmail.com>\n        // https://github.com/michaeljayt/strftime/commit/bcb4c12743811d51e568175aa7bff3fd2a77cef3\n        zh_CN: {\n            days: ['', '', '', '', '', '', ''],\n            shortDays: ['', '', '', '', '', '', ''],\n            months: ['', '', '', '', '', '', '', '', '', '', '', ''],\n            shortMonths: ['', '', '', '', '', '', '', '', '', '', '', ''],\n            AM: '',\n            PM: '',\n            am: '',\n            pm: '',\n            formats: {\n                c: '%a %d %b %Y %X %Z',\n                D: '%d/%m/%y',\n                F: '%Y-%m-%d',\n                R: '%H:%M',\n                r: '%I:%M:%S %p',\n                T: '%H:%M:%S',\n                v: '%e-%b-%Y',\n                X: '%r',\n                x: '%D'\n            }\n        }\n    };\n\n    var DefaultLocale = Locales['en_US'],\n        defaultStrftime = new Strftime(DefaultLocale, 0, false),\n        isCommonJS = typeof module !== 'undefined',\n        namespace;\n\n    // CommonJS / Node module\n    if (isCommonJS) {\n        namespace = module.exports = defaultStrftime;\n    }\n    // Browsers and other environments\n    else {\n        // Get the global object. Works in ES3, ES5, and ES5 strict mode.\n        namespace = (function() { return this || (1,eval)('this'); }());\n        namespace.strftime = defaultStrftime;\n    }\n\n    // Polyfill Date.now for old browsers.\n    if (typeof Date.now !== 'function') {\n        Date.now = function() {\n          return +new Date();\n        };\n    }\n\n    function Strftime(locale, customTimezoneOffset, useUtcTimezone) {\n        var _locale = locale || DefaultLocale,\n            _customTimezoneOffset = customTimezoneOffset || 0,\n            _useUtcBasedDate = useUtcTimezone || false,\n\n            // we store unix timestamp value here to not create new Date() each iteration (each millisecond)\n            // Date.now() is 2 times faster than new Date()\n            // while millisecond precise is enough here\n            // this could be very helpful when strftime triggered a lot of times one by one\n            _cachedDateTimestamp = 0,\n            _cachedDate;\n\n        function _strftime(format, date) {\n            var timestamp;\n\n            if (!date) {\n                var currentTimestamp = Date.now();\n                if (currentTimestamp > _cachedDateTimestamp) {\n                    _cachedDateTimestamp = currentTimestamp;\n                    _cachedDate = new Date(_cachedDateTimestamp);\n\n                    timestamp = _cachedDateTimestamp;\n\n                    if (_useUtcBasedDate) {\n                        // how to avoid duplication of date instantiation for utc here?\n                        // we tied to getTimezoneOffset of the current date\n                        _cachedDate = new Date(_cachedDateTimestamp + getTimestampToUtcOffsetFor(_cachedDate) + _customTimezoneOffset);\n                    }\n                }\n                else {\n                  timestamp = _cachedDateTimestamp;\n                }\n                date = _cachedDate;\n            }\n            else {\n                timestamp = date.getTime();\n\n                if (_useUtcBasedDate) {\n                    var utcOffset = getTimestampToUtcOffsetFor(date);\n                    date = new Date(timestamp + utcOffset + _customTimezoneOffset);\n                    // If we've crossed a DST boundary with this calculation we need to\n                    // adjust the new date accordingly or it will be off by an hour in UTC.\n                    if (getTimestampToUtcOffsetFor(date) !== utcOffset) {\n                        var newUTCOffset = getTimestampToUtcOffsetFor(date);\n                        date = new Date(timestamp + newUTCOffset + _customTimezoneOffset);\n                    }\n                }\n            }\n\n            return _processFormat(format, date, _locale, timestamp);\n        }\n\n        function _processFormat(format, date, locale, timestamp) {\n            var resultString = '',\n                padding = null,\n                isInScope = false,\n                length = format.length,\n                extendedTZ = false;\n\n            for (var i = 0; i < length; i++) {\n\n                var currentCharCode = format.charCodeAt(i);\n\n                if (isInScope === true) {\n                    // '-'\n                    if (currentCharCode === 45) {\n                        padding = '';\n                        continue;\n                    }\n                    // '_'\n                    else if (currentCharCode === 95) {\n                        padding = ' ';\n                        continue;\n                    }\n                    // '0'\n                    else if (currentCharCode === 48) {\n                        padding = '0';\n                        continue;\n                    }\n                    // ':'\n                    else if (currentCharCode === 58) {\n                      if (extendedTZ) {\n                          warn(\"[WARNING] detected use of unsupported %:: or %::: modifiers to strftime\");\n                      }\n                      extendedTZ = true;\n                      continue;\n                    }\n\n                    switch (currentCharCode) {\n\n                        // Examples for new Date(0) in GMT\n\n                        // '%'\n                        // case '%':\n                        case 37:\n                            resultString += '%';\n                            break;\n\n                        // 'Thursday'\n                        // case 'A':\n                        case 65:\n                            resultString += locale.days[date.getDay()];\n                            break;\n\n                        // 'January'\n                        // case 'B':\n                        case 66:\n                            resultString += locale.months[date.getMonth()];\n                            break;\n\n                        // '19'\n                        // case 'C':\n                        case 67:\n                            resultString += padTill2(Math.floor(date.getFullYear() / 100), padding);\n                            break;\n\n                        // '01/01/70'\n                        // case 'D':\n                        case 68:\n                            resultString += _processFormat(locale.formats.D, date, locale, timestamp);\n                            break;\n\n                        // '1970-01-01'\n                        // case 'F':\n                        case 70:\n                            resultString += _processFormat(locale.formats.F, date, locale, timestamp);\n                            break;\n\n                        // '00'\n                        // case 'H':\n                        case 72:\n                            resultString += padTill2(date.getHours(), padding);\n                            break;\n\n                        // '12'\n                        // case 'I':\n                        case 73:\n                            resultString += padTill2(hours12(date.getHours()), padding);\n                            break;\n\n                        // '000'\n                        // case 'L':\n                        case 76:\n                            resultString += padTill3(Math.floor(timestamp % 1000));\n                            break;\n\n                        // '00'\n                        // case 'M':\n                        case 77:\n                            resultString += padTill2(date.getMinutes(), padding);\n                            break;\n\n                        // 'am'\n                        // case 'P':\n                        case 80:\n                            resultString += date.getHours() < 12 ? locale.am : locale.pm;\n                            break;\n\n                        // '00:00'\n                        // case 'R':\n                        case 82:\n                            resultString += _processFormat(locale.formats.R, date, locale, timestamp);\n                            break;\n\n                        // '00'\n                        // case 'S':\n                        case 83:\n                            resultString += padTill2(date.getSeconds(), padding);\n                            break;\n\n                        // '00:00:00'\n                        // case 'T':\n                        case 84:\n                            resultString += _processFormat(locale.formats.T, date, locale, timestamp);\n                            break;\n\n                        // '00'\n                        // case 'U':\n                        case 85:\n                            resultString += padTill2(weekNumber(date, 'sunday'), padding);\n                            break;\n\n                        // '00'\n                        // case 'W':\n                        case 87:\n                            resultString += padTill2(weekNumber(date, 'monday'), padding);\n                            break;\n\n                        // '16:00:00'\n                        // case 'X':\n                        case 88:\n                            resultString += _processFormat(locale.formats.X, date, locale, timestamp);\n                            break;\n\n                        // '1970'\n                        // case 'Y':\n                        case 89:\n                            resultString += date.getFullYear();\n                            break;\n\n                        // 'GMT'\n                        // case 'Z':\n                        case 90:\n                            if (_useUtcBasedDate && _customTimezoneOffset === 0) {\n                                resultString += \"GMT\";\n                            }\n                            else {\n                                // fixme optimize\n                                var tzString = date.toString().match(/\\(([\\w\\s]+)\\)/);\n                                resultString += tzString && tzString[1] || '';\n                            }\n                            break;\n\n                        // 'Thu'\n                        // case 'a':\n                        case 97:\n                            resultString += locale.shortDays[date.getDay()];\n                            break;\n\n                        // 'Jan'\n                        // case 'b':\n                        case 98:\n                            resultString += locale.shortMonths[date.getMonth()];\n                            break;\n\n                        // ''\n                        // case 'c':\n                        case 99:\n                            resultString += _processFormat(locale.formats.c, date, locale, timestamp);\n                            break;\n\n                        // '01'\n                        // case 'd':\n                        case 100:\n                            resultString += padTill2(date.getDate(), padding);\n                            break;\n\n                        // ' 1'\n                        // case 'e':\n                        case 101:\n                            resultString += padTill2(date.getDate(), padding == null ? ' ' : padding);\n                            break;\n\n                        // 'Jan'\n                        // case 'h':\n                        case 104:\n                            resultString += locale.shortMonths[date.getMonth()];\n                            break;\n\n                        // '000'\n                        // case 'j':\n                        case 106:\n                            var y = new Date(date.getFullYear(), 0, 1);\n                            var day = Math.ceil((date.getTime() - y.getTime()) / (1000 * 60 * 60 * 24));\n                            resultString += padTill3(day);\n                            break;\n\n                        // ' 0'\n                        // case 'k':\n                        case 107:\n                            resultString += padTill2(date.getHours(), padding == null ? ' ' : padding);\n                            break;\n\n                        // '12'\n                        // case 'l':\n                        case 108:\n                            resultString += padTill2(hours12(date.getHours()), padding == null ? ' ' : padding);\n                            break;\n\n                        // '01'\n                        // case 'm':\n                        case 109:\n                            resultString += padTill2(date.getMonth() + 1, padding);\n                            break;\n\n                        // '\\n'\n                        // case 'n':\n                        case 110:\n                            resultString += '\\n';\n                            break;\n\n                        // '1st'\n                        // case 'o':\n                        case 111:\n                            // Try to use an ordinal suffix from the locale, but fall back to using the old\n                            // function for compatibility with old locales that lack them.\n                            var day = date.getDate();\n                            if (locale.ordinalSuffixes) {\n                                resultString += String(day) + (locale.ordinalSuffixes[day - 1] || ordinal(day));\n                            }\n                            else {\n                                resultString += String(day) + ordinal(day);\n                            }\n                            break;\n\n                        // 'AM'\n                        // case 'p':\n                        case 112:\n                            resultString += date.getHours() < 12 ? locale.AM : locale.PM;\n                            break;\n\n                        // '12:00:00 AM'\n                        // case 'r':\n                        case 114:\n                            resultString += _processFormat(locale.formats.r, date, locale, timestamp);\n                            break;\n\n                        // '0'\n                        // case 's':\n                        case 115:\n                            resultString += Math.floor(timestamp / 1000);\n                            break;\n\n                        // '\\t'\n                        // case 't':\n                        case 116:\n                            resultString += '\\t';\n                            break;\n\n                        // '4'\n                        // case 'u':\n                        case 117:\n                            var day = date.getDay();\n                            resultString += day === 0 ? 7 : day;\n                            break; // 1 - 7, Monday is first day of the week\n\n                        // ' 1-Jan-1970'\n                        // case 'v':\n                        case 118:\n                            resultString += _processFormat(locale.formats.v, date, locale, timestamp);\n                            break;\n\n                        // '4'\n                        // case 'w':\n                        case 119:\n                            resultString += date.getDay();\n                            break; // 0 - 6, Sunday is first day of the week\n\n                        // '12/31/69'\n                        // case 'x':\n                        case 120:\n                            resultString += _processFormat(locale.formats.x, date, locale, timestamp);\n                            break;\n\n                        // '70'\n                        // case 'y':\n                        case 121:\n                            resultString += ('' + date.getFullYear()).slice(2);\n                            break;\n\n                        // '+0000'\n                        // case 'z':\n                        case 122:\n                            if (_useUtcBasedDate && _customTimezoneOffset === 0) {\n                                resultString += extendedTZ ? \"+00:00\" : \"+0000\";\n                            }\n                            else {\n                                var off;\n                                if (_customTimezoneOffset !== 0) {\n                                    off = _customTimezoneOffset / (60 * 1000);\n                                }\n                                else {\n                                    off = -date.getTimezoneOffset();\n                                }\n                                var sign = off < 0 ? '-' : '+';\n                                var sep = extendedTZ ? ':' : '';\n                                var hours = Math.floor(Math.abs(off / 60));\n                                var mins = Math.abs(off % 60);\n                                resultString += sign + padTill2(hours) + sep + padTill2(mins);\n                            }\n                            break;\n\n                        default:\n                            if (isInScope) {\n                                resultString += '%';\n                            }\n                            resultString += format[i];\n                            break;\n                    }\n\n                    padding = null;\n                    isInScope = false;\n                    continue;\n                }\n\n                // '%'\n                if (currentCharCode === 37) {\n                    isInScope = true;\n                    continue;\n                }\n\n                resultString += format[i];\n            }\n\n            return resultString;\n        }\n\n        var strftime = _strftime;\n\n        strftime.localize = function(locale) {\n            return new Strftime(locale || _locale, _customTimezoneOffset, _useUtcBasedDate);\n        };\n\n        strftime.localizeByIdentifier = function(localeIdentifier) {\n            var locale = Locales[localeIdentifier];\n            if (!locale) {\n                warn('[WARNING] No locale found with identifier \"' + localeIdentifier + '\".');\n                return strftime;\n            }\n            return strftime.localize(locale);\n        };\n\n        strftime.timezone = function(timezone) {\n            var customTimezoneOffset = _customTimezoneOffset;\n            var useUtcBasedDate = _useUtcBasedDate;\n\n            var timezoneType = typeof timezone;\n            if (timezoneType === 'number' || timezoneType === 'string') {\n                useUtcBasedDate = true;\n\n                // ISO 8601 format timezone string, [-+]HHMM\n                if (timezoneType === 'string') {\n                    var sign = timezone[0] === '-' ? -1 : 1,\n                        hours = parseInt(timezone.slice(1, 3), 10),\n                        minutes = parseInt(timezone.slice(3, 5), 10);\n\n                    customTimezoneOffset = sign * ((60 * hours) + minutes) * 60 * 1000;\n                    // in minutes: 420\n                }\n                else if (timezoneType === 'number') {\n                    customTimezoneOffset = timezone * 60 * 1000;\n                }\n            }\n\n            return new Strftime(_locale, customTimezoneOffset, useUtcBasedDate);\n        };\n\n        strftime.utc = function() {\n            return new Strftime(_locale, _customTimezoneOffset, true);\n        };\n\n        return strftime;\n    }\n\n    function padTill2(numberToPad, paddingChar) {\n        if (paddingChar === '' || numberToPad > 9) {\n            return numberToPad;\n        }\n        if (paddingChar == null) {\n            paddingChar = '0';\n        }\n        return paddingChar + numberToPad;\n    }\n\n    function padTill3(numberToPad) {\n        if (numberToPad > 99) {\n            return numberToPad;\n        }\n        if (numberToPad > 9) {\n            return '0' + numberToPad;\n        }\n        return '00' + numberToPad;\n    }\n\n    function hours12(hour) {\n        if (hour === 0) {\n            return 12;\n        }\n        else if (hour > 12) {\n            return hour - 12;\n        }\n        return hour;\n    }\n\n    // firstWeekday: 'sunday' or 'monday', default is 'sunday'\n    //\n    // Pilfered & ported from Ruby's strftime implementation.\n    function weekNumber(date, firstWeekday) {\n        firstWeekday = firstWeekday || 'sunday';\n\n        // This works by shifting the weekday back by one day if we\n        // are treating Monday as the first day of the week.\n        var weekday = date.getDay();\n        if (firstWeekday === 'monday') {\n            if (weekday === 0) // Sunday\n                weekday = 6;\n            else\n                weekday--;\n        }\n\n        var firstDayOfYearUtc = Date.UTC(date.getFullYear(), 0, 1),\n            dateUtc = Date.UTC(date.getFullYear(), date.getMonth(), date.getDate()),\n            yday = Math.floor((dateUtc - firstDayOfYearUtc) / 86400000),\n            weekNum = (yday + 7 - weekday) / 7;\n\n        return Math.floor(weekNum);\n    }\n\n    // Get the ordinal suffix for a number: st, nd, rd, or th\n    function ordinal(number) {\n        var i = number % 10;\n        var ii = number % 100;\n\n        if ((ii >= 11 && ii <= 13) || i === 0 || i >= 4) {\n            return 'th';\n        }\n        switch (i) {\n            case 1: return 'st';\n            case 2: return 'nd';\n            case 3: return 'rd';\n        }\n    }\n\n    function getTimestampToUtcOffsetFor(date) {\n        return (date.getTimezoneOffset() || 0) * 60000;\n    }\n\n    function warn(message) {\n        if (typeof console !== 'undefined' && typeof console.warn == 'function') {\n            console.warn(message)\n        }\n    }\n\n}());\n","/* jshint -W067 */\n(function() {\n    'use strict';\n\n    /**\n * User: rikishi\n * Date: 07.07.13\n * Time: 19:17\n *\n */\n\n/**\n * @param {String} str\n * @param {String} format\n * @param {Boolean} [local]\n * @returns {Date|Null}\n */\n/*jshint -W079 */\nvar strptime = function(str, format, local) {\n    return strptime.parse(str, format, local);\n};\n\n\n    strptime.version = '0.0.1';\n\n    var namespace;\n\n    if (typeof module !== 'undefined') {\n        namespace = module.exports = strptime;\n    } else {\n        namespace = (function() {\n            return this || (1, eval)('this');\n        }());\n    }\n\n    namespace.strptime = strptime;\n\n    (function(strptime) {\n\n    strptime.locale = {\n        'a': ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],\n        'A': ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'],\n        'b': ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],\n        'B': ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'],\n        'f': ['Jan.', 'Feb.', 'Mar.', 'Apr.', 'May', 'Jun.', 'Jul.', 'Aug.', 'Sep.', 'Oct.', 'Nov.', 'Dec.'],\n        'c': '%Y-%m-%d %H:%M:%S',\n        'P': ['am', 'pm'],\n        'r': '%I:%M:%S %p',\n        'x': '%m/%d/%y',\n        'X': '%H:%M:%S',\n        'day': ['Yesterday', 'Today', 'Tomorrow'],\n\n        //      \n        'bg': ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],\n        'Bg': ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'],\n        'fg': ['Jan.', 'Feb.', 'Mar.', 'Apr.', 'May', 'Jun.', 'Jul.', 'Aug.', 'Sep.', 'Oct.', 'Nov.', 'Dec.'],\n\n        'Date_dBY_year_in_HM': '%#B %-d, %Y at %-H:%M',\n        'Date_dBY_year': '%#B %-d, %Y',\n        'Date_dBY': '%#B %-d, %Y',\n        'Date_AdBY': '%A, %#B %-d, %Y',\n        'Date_dBA': '%#B %-d, %A',\n        'Date_df_in_HM': '%#f, %-d at %-H:%M',\n        'Date_dfY': '%-d %#f %Y',\n        'Date_dB_in_HM': '%#B %-d at %-H:%M',\n        'Date_df': '%-d %#f'\n    };\n\n}(strptime));\n\n\n    (function(strptime) {\n\n    var inArray = Array.prototype.indexOf || function(el) {\n        var l = this.length;\n        var i = 0;\n        while (i < l) {\n            if (el == this[i]) {\n                return i;\n            }\n            i++;\n        }\n        return -1;\n    };\n\n    var locale = strptime.locale;\n\n    var strRegNum2 = '[\\\\d\\\\s]?\\\\d';\n    var strRegStr = '\\\\S+';\n\n    var specifiers = {\n        '%': '\\\\%',\n        //    ,     \n        'a': strRegStr,\n        //    ,     \n        'A': strRegStr,\n        //   ,     \n        'b': {\n            'reg': strRegStr,\n            'make': function(date, data, mod, gen) {\n                data = inArray.call(gen ? locale.bg : locale.b, toLetterCaseReverse(data, mod));\n                if (data === -1) {\n                    return false;\n                }\n\n                date.setUTCMonth(data);\n                return true;\n            }\n        },\n        //   ,      ( %b)\n        'h': {\n            'reg': strRegStr,\n            'make': function(date, data, mod, gen) {\n                data = inArray.call(gen ? locale.bg : locale.b, toLetterCaseReverse(data, mod));\n                if (data === -1) {\n                    return false;\n                }\n\n                date.setUTCMonth(data);\n                return true;\n            }\n        },\n        //   ,     \n        'B': {\n            'reg': strRegStr,\n            'make': function(date, data, mod, gen) {\n                data = inArray.call(gen ? locale.Bg : locale.B, toLetterCaseReverse(data, mod));\n                if (data === -1) {\n                    return false;\n                }\n\n                date.setUTCMonth(data);\n                return true;\n            }\n        },\n        //     ,     \n        'f': {\n            'reg': strRegStr,\n            'make': function(date, data, mod, gen) {\n                data = inArray.call(gen ? locale.fg : locale.f, toLetterCaseReverse(data, mod));\n                if (data === -1) {\n                    return false;\n                }\n\n                date.setUTCMonth(data);\n                return true;\n            }\n        },\n\n\n        //        ISO-8601:1988\n        'g': {\n            'reg': strRegNum2,\n            'make': function(date, data) {\n                data = parseInt(data, 10);\n                if (data < 0 || data > 99) {\n                    return false;\n                }\n\n                data = data + 100 * parseInt((new Date()).getUTCFullYear() / 100, 10);\n                date.setUTCFullYear(data);\n                return true;\n            }\n        },\n        //    %g\n        'G': {\n            'reg': '\\\\d{4}',\n            'make': function(date, data) {\n                data = parseInt(data, 10);\n                date.setUTCFullYear(data);\n                return true;\n            }\n        },\n        //     (  )\n        'd': {\n            'reg': strRegNum2,\n            'make': function(date, data) {\n                data = parseInt(data, 10);\n                if (data < 1 || data > 31) {\n                    return false;\n                }\n                date.setUTCDate(data);\n                return true;\n            }\n        },\n        //  ,   ,      \n        'e': {\n            'reg': strRegNum2,\n            'make': function(date, data) {\n                data = parseInt(data, 10);\n                if (data < 1 || data > 31) {\n                    return false;\n                }\n                date.setUTCDate(data);\n                return true;\n            }\n        },\n\n        //     24- \n        'H': {\n            'reg': strRegNum2,\n            'make': function(date, data) {\n                data = parseInt(data, 10);\n                if (data < 0 || data > 23) {\n                    return false;\n                }\n                date.setUTCHours(data);\n                return true;\n            }\n        },\n        //     12- \n        'I': {\n            'reg': strRegNum2,\n            'make': function(date, data) {\n                data = parseInt(data, 10);\n                if (data < 1 || data > 12) {\n                    return false;\n                }\n\n                date.setUTCHours(date.getUTCHours() + data);\n                return true;\n            }\n        },\n        //     (  )\n        'm': {\n            'reg': strRegNum2,\n            'make': function(date, data) {\n                data = parseInt(data, 10);\n                if (data < 1 || data > 12) {\n                    return false;\n                }\n                date.setUTCMonth(data - 1);\n                return true;\n            }\n        },\n        //    (  )\n        'M': {\n            'reg': strRegNum2,\n            'make': function(date, data) {\n                data = parseInt(data, 10);\n                if (data < 0 || data > 59) {\n                    return false;\n                }\n                date.setUTCMinutes(data);\n                return true;\n            }\n        },\n        'n': '\\\\n',\n        // 'AM'  'PM'   ,     \n        'p': {\n            'reg': strRegStr,\n            'make': function(date, data) {\n                data = inArray.call(locale.P, data.toLowerCase());\n                if (data === -1) {\n                    return false;\n                }\n\n                if (data === 1) {\n                    date.setUTCHours(date.getUTCHours() + 12);\n                }\n\n                return true;\n            }\n        },\n        // 'am'  'pm'     \n        'P': {\n            'reg': strRegStr,\n            'make': function(date, data) {\n                data = inArray.call(locale.P, data.toLowerCase());\n                if (data === -1) {\n                    return false;\n                }\n\n                if (data === 1) {\n                    date.setUTCHours(date.getUTCHours() + 12);\n                }\n\n                return true;\n            }\n        },\n\n        //    (  )\n        'S': {\n            'reg': strRegNum2,\n            'make': function(date, data) {\n                data = parseInt(data, 10);\n                if (data < 0 || data > 60) {\n                    return false;\n                }\n                date.setUTCSeconds(data);\n                return true;\n            }\n        },\n        't': '\\\\t',\n        'u': '\\\\d',\n        'U': strRegNum2,\n        'w': '\\\\d',\n        'W': strRegNum2,\n        //  2  \n        'y': {\n            'reg': strRegNum2,\n            'make': function(date, data) {\n                data = parseInt(data, 10);\n                if (data < 0 || data > 99) {\n                    return false;\n                }\n\n                data = data + 100 * parseInt((new Date()).getUTCFullYear() / 100, 10);\n                date.setUTCFullYear(data);\n                return true;\n            }\n        },\n        // \n        'Y': {\n            'reg': '\\\\d{4}',\n            'make': function(date, data) {\n                data = parseInt(data, 10);\n                date.setUTCFullYear(data);\n                return true;\n            }\n        },\n        'z': {\n            'reg': '[+\\\\-]\\\\d{4}',\n            'make': function(date, data) {\n                var m = data.match(/^([+\\-])(\\d{2})(\\d{2})$/);\n                if (!m) {\n                    return false;\n                }\n\n                var offset = (parseInt(m[2], 10) * 60 + parseInt(m[3], 10)) * 60000;\n                if (m[1] === '+') {\n                    offset = -offset;\n                }\n\n                date.setTime(date.getTime() + offset);\n\n                return true;\n            }\n        },\n        'l': {\n            'reg': strRegNum2,\n            'make': function(date, data) {\n                data = parseInt(data, 10);\n                if (data < 1 || data > 12) {\n                    return false;\n                }\n\n                date.setUTCHours(date.getUTCHours() + data);\n                return true;\n            }\n        },\n        //    Unix\n        's': {\n            'reg': '\\\\d+',\n            'make': function(date, data) {\n                data = parseInt(data, 10);\n                date.setTime(data * 1000);\n                return true;\n            }\n        },\n\n\n\n        'c': locale.c,\n        'r': locale.r,\n        'R': '%H:%M',\n        'T': '%H:%M:%S',\n        'x': locale.x,\n        'X': locale.X,\n        'D': '%m/%d/%y',\n        'F': '%Y-%m-%d',\n\n\n        'Date_iso': '%Y-%m-%dT%H:%M:%S',\n        'Date_dBY_year_in_HM': locale.Date_dBY_year_in_HM,\n        'Date_dBY_year': locale.Date_dBY_year,\n        'Date_dBY': locale.Date_dBY,\n        'Date_dBA': locale.Date_dBA,\n        'Date_AdBY': locale.Date_AdBY,\n        'Date_df_in_HM': locale.Date_df_in_HM,\n        'Date_dfY': locale.Date_dfY,\n        'Date_dB_in_HM': locale.Date_dB_in_HM,\n        'Date_dmY__dot': '%d.%m.%Y',\n        'Date_df': locale.Date_df,\n        'Date_FT': '%F %T',\n        'Date_dmY__minus': '%d-%m-%Y'\n    };\n\n    strptime.parse = function(str, format, local) {\n        str = String(str);\n        format = String(format);\n\n        var loop = 5;\n        while (/%(Date_[a-zA-Z0-9_]+|[cDFrRTxX])/g.test(format) && loop) {\n            format = format.replace(/%(Date_[a-zA-Z0-9_]+|[cDFrRTxX])/, formatTransform);\n            loop--;\n        }\n\n        formatTransform.make = [];\n        var reg = format.replace(/%(([#\\^!~]{0,2})[aAbBfh]|([0\\-_]?)[degHImMSVWyl]|[GnpPtuUwYzZs%])/g, formatTransform);\n\n        var match = str.match(new RegExp(reg));\n\n        if (!match || !formatTransform.make.length) {\n            return null;\n        }\n\n        var date = new Date(Date.UTC(0, 0));\n\n        for (var i = 0, l = formatTransform.make.length; i < l; i++) {\n            var build = formatTransform.make[i];\n            if (!build[0](date, match[i + 1], build[1], build[2])) {\n                return null;\n            }\n        }\n\n        if (local) {\n            date.setTime(date.getTime() + date.getTimezoneOffset() * 60000);\n        }\n\n        return date;\n    };\n\n    function formatTransform(_, spec, mod, numPad, pos, str) {\n        spec = String(spec);\n        mod = String(mod);\n        spec = spec.replace(/^[#_0\\^\\-!~]+/, '');\n\n        var s = specifiers[spec];\n\n        if (!s) {\n            return _;\n        }\n\n        var genitive = false;\n        if (mod.indexOf('!') === -1 && spec.length === 1 && (mod.indexOf('~') > -1 || ('bBf'.indexOf(spec) > -1 && /%[0\\-_]?d[\\s]+$/.test(str.substr(0, pos))))) {\n\n            genitive = true;\n        }\n\n        if ((spec === 'I' || spec === 'l') && !/%[pP]/.test(str)) {\n            throw new Error('Undefined AM/PM');\n        }\n\n        // TODO    \n\n        switch (typeof(s)) {\n        case 'function':\n            return s();\n        case 'string':\n            return s;\n        case 'object':\n            formatTransform.make.push([s.make, mod, genitive]);\n            return '(' + s.reg + ')';\n        default:\n            return _;\n        }\n    }\n\n    /**\n     * @param {String} str\n     * @param {String} [mode]\n     * @returns {String}\n     */\n    function toLetterCaseReverse(str, mode) {\n        str = String(str);\n        mode = String(mode);\n\n        if (mode.indexOf('#') !== -1) {\n            return str.substr(0, 1).toUpperCase() + str.substr(1);\n        }\n\n        if (mode.indexOf('^') !== -1) {\n            return str.substr(0, 1) + str.substr(1).toLowerCase();\n        }\n\n        return str;\n    }\n\n}(strptime));\n\n\n}());\n","(function (global, undefined) {\n    \"use strict\";\n\n    if (global.setImmediate) {\n        return;\n    }\n\n    var nextHandle = 1; // Spec says greater than zero\n    var tasksByHandle = {};\n    var currentlyRunningATask = false;\n    var doc = global.document;\n    var registerImmediate;\n\n    function setImmediate(callback) {\n      // Callback can either be a function or a string\n      if (typeof callback !== \"function\") {\n        callback = new Function(\"\" + callback);\n      }\n      // Copy function arguments\n      var args = new Array(arguments.length - 1);\n      for (var i = 0; i < args.length; i++) {\n          args[i] = arguments[i + 1];\n      }\n      // Store and register the task\n      var task = { callback: callback, args: args };\n      tasksByHandle[nextHandle] = task;\n      registerImmediate(nextHandle);\n      return nextHandle++;\n    }\n\n    function clearImmediate(handle) {\n        delete tasksByHandle[handle];\n    }\n\n    function run(task) {\n        var callback = task.callback;\n        var args = task.args;\n        switch (args.length) {\n        case 0:\n            callback();\n            break;\n        case 1:\n            callback(args[0]);\n            break;\n        case 2:\n            callback(args[0], args[1]);\n            break;\n        case 3:\n            callback(args[0], args[1], args[2]);\n            break;\n        default:\n            callback.apply(undefined, args);\n            break;\n        }\n    }\n\n    function runIfPresent(handle) {\n        // From the spec: \"Wait until any invocations of this algorithm started before this one have completed.\"\n        // So if we're currently running a task, we'll need to delay this invocation.\n        if (currentlyRunningATask) {\n            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a\n            // \"too much recursion\" error.\n            setTimeout(runIfPresent, 0, handle);\n        } else {\n            var task = tasksByHandle[handle];\n            if (task) {\n                currentlyRunningATask = true;\n                try {\n                    run(task);\n                } finally {\n                    clearImmediate(handle);\n                    currentlyRunningATask = false;\n                }\n            }\n        }\n    }\n\n    function installNextTickImplementation() {\n        registerImmediate = function(handle) {\n            process.nextTick(function () { runIfPresent(handle); });\n        };\n    }\n\n    function canUsePostMessage() {\n        // The test against `importScripts` prevents this implementation from being installed inside a web worker,\n        // where `global.postMessage` means something completely different and can't be used for this purpose.\n        if (global.postMessage && !global.importScripts) {\n            var postMessageIsAsynchronous = true;\n            var oldOnMessage = global.onmessage;\n            global.onmessage = function() {\n                postMessageIsAsynchronous = false;\n            };\n            global.postMessage(\"\", \"*\");\n            global.onmessage = oldOnMessage;\n            return postMessageIsAsynchronous;\n        }\n    }\n\n    function installPostMessageImplementation() {\n        // Installs an event handler on `global` for the `message` event: see\n        // * https://developer.mozilla.org/en/DOM/window.postMessage\n        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages\n\n        var messagePrefix = \"setImmediate$\" + Math.random() + \"$\";\n        var onGlobalMessage = function(event) {\n            if (event.source === global &&\n                typeof event.data === \"string\" &&\n                event.data.indexOf(messagePrefix) === 0) {\n                runIfPresent(+event.data.slice(messagePrefix.length));\n            }\n        };\n\n        if (global.addEventListener) {\n            global.addEventListener(\"message\", onGlobalMessage, false);\n        } else {\n            global.attachEvent(\"onmessage\", onGlobalMessage);\n        }\n\n        registerImmediate = function(handle) {\n            global.postMessage(messagePrefix + handle, \"*\");\n        };\n    }\n\n    function installMessageChannelImplementation() {\n        var channel = new MessageChannel();\n        channel.port1.onmessage = function(event) {\n            var handle = event.data;\n            runIfPresent(handle);\n        };\n\n        registerImmediate = function(handle) {\n            channel.port2.postMessage(handle);\n        };\n    }\n\n    function installReadyStateChangeImplementation() {\n        var html = doc.documentElement;\n        registerImmediate = function(handle) {\n            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted\n            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.\n            var script = doc.createElement(\"script\");\n            script.onreadystatechange = function () {\n                runIfPresent(handle);\n                script.onreadystatechange = null;\n                html.removeChild(script);\n                script = null;\n            };\n            html.appendChild(script);\n        };\n    }\n\n    function installSetTimeoutImplementation() {\n        registerImmediate = function(handle) {\n            setTimeout(runIfPresent, 0, handle);\n        };\n    }\n\n    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.\n    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);\n    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;\n\n    // Don't get fooled by e.g. browserify environments.\n    if ({}.toString.call(global.process) === \"[object process]\") {\n        // For Node.js before 0.9\n        installNextTickImplementation();\n\n    } else if (canUsePostMessage()) {\n        // For non-IE10 modern browsers\n        installPostMessageImplementation();\n\n    } else if (global.MessageChannel) {\n        // For web workers, where supported\n        installMessageChannelImplementation();\n\n    } else if (doc && \"onreadystatechange\" in doc.createElement(\"script\")) {\n        // For IE 68\n        installReadyStateChangeImplementation();\n\n    } else {\n        // For older browsers\n        installSetTimeoutImplementation();\n    }\n\n    attachTo.setImmediate = setImmediate;\n    attachTo.clearImmediate = clearImmediate;\n}(typeof self === \"undefined\" ? typeof global === \"undefined\" ? this : global : self));\n","// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n","Sk.asserts = {};\n\n/**\n * Cause assertion failure when condition is false.\n * \n * @param {*} condition condition to check\n * @param {string=} message error message\n */\nSk.asserts.assert = function (condition, message) {\n    return condition;\n};\nSk.exportSymbol(\"Sk.asserts.assert\", Sk.asserts.assert);\n\n/**\n * Cause assertion failure.\n * \n * @param {string=} message error message\n */\nSk.asserts.fail = function (message) {\n};\nSk.exportSymbol(\"Sk.asserts.fail\", Sk.asserts.fail);\n","/**\n * Base namespace for Skulpt. This is the only symbol that Skulpt adds to the\n * global namespace. Other user accessible symbols are noted and described\n * below.\n */\n\n/**\n *\n * Set various customizable parts of Skulpt.\n *\n * output: Replacable output redirection (called from print, etc.).\n * read: Replacable function to load modules with (called via import, etc.)\n * sysargv: Setable to emulate arguments to the script. Should be an array of JS\n * strings.\n * syspath: Setable to emulate PYTHONPATH environment variable (for finding\n * modules). Should be an array of JS strings.\n * nonreadopen: Boolean - set to true to allow non-read file operations\n * fileopen: Optional function to call any time a file is opened\n * filewrite: Optional function to call when writing to a file\n *\n * Any variables that aren't set will be left alone.\n */\n\nSk.bool_check = function(variable, name) {\n    if (variable === undefined || variable === null || typeof variable !== \"boolean\") {\n        throw new Error(\"must specify \" + name + \" and it must be a boolean\");\n    }\n};\n\nSk.python2 = {\n    print_function: false,\n    division: false,\n    absolute_import: null,\n    unicode_literals: false,\n    // skulpt specific\n    python3: false,\n    set_repr: false,\n    class_repr: false,\n    inherit_from_object: false,\n    super_args: false,\n    octal_number_literal: false,\n    bankers_rounding: false,\n    python_version: false,\n    dunder_next: false,\n    dunder_round: false,    \n    list_clear: false,\n    exceptions: false,\n    no_long_type: false,\n    ceil_floor_int: false,\n    l_suffix: true,\n    silent_octal_literal: true\n};\n\nSk.python3 = {\n    print_function: true,\n    division: true,\n    absolute_import: null,\n    unicode_literals: true,\n    // skulpt specific\n    python3: true,\n    set_repr: true,\n    class_repr: true,\n    inherit_from_object: true,\n    super_args: true,\n    octal_number_literal: true,\n    bankers_rounding: true,\n    python_version: true,\n    dunder_next: true,\n    dunder_round: true,\n    list_clear: true,\n    exceptions: true,\n    no_long_type: true,\n    ceil_floor_int: true,\n    l_suffix: false,\n    silent_octal_literal: false\n};\n\nSk.configure = function (options) {\n    \"use strict\";\n    Sk.output = options[\"output\"] || Sk.output;\n    Sk.asserts.assert(typeof Sk.output === \"function\");\n\n    Sk.debugout = options[\"debugout\"] || Sk.debugout;\n    Sk.asserts.assert(typeof Sk.debugout === \"function\");\n\n    Sk.uncaughtException = options[\"uncaughtException\"] || Sk.uncaughtException;\n    Sk.asserts.assert(typeof Sk.uncaughtException === \"function\");\n\n    Sk.read = options[\"read\"] || Sk.read;\n    Sk.asserts.assert(typeof Sk.read === \"function\");\n\n    Sk.nonreadopen = options[\"nonreadopen\"] || false;\n    Sk.asserts.assert(typeof Sk.nonreadopen === \"boolean\");\n\n    Sk.fileopen = options[\"fileopen\"] || undefined;\n    Sk.asserts.assert(typeof Sk.fileopen === \"function\" || typeof Sk.fileopen === \"undefined\");\n\n    Sk.filewrite = options[\"filewrite\"] || undefined;\n    Sk.asserts.assert(typeof Sk.filewrite === \"function\" || typeof Sk.filewrite === \"undefined\");\n\n    Sk.timeoutMsg = options[\"timeoutMsg\"] || Sk.timeoutMsg;\n    Sk.asserts.assert(typeof Sk.timeoutMsg === \"function\");\n    Sk.exportSymbol(\"Sk.timeoutMsg\", Sk.timeoutMsg);\n\n    Sk.sysargv = options[\"sysargv\"] || Sk.sysargv;\n    Sk.asserts.assert(Sk.isArrayLike(Sk.sysargv));\n\n    Sk.__future__ = options[\"__future__\"] || Sk.python2;\n\n    Sk.bool_check(Sk.__future__.print_function, \"Sk.__future__.print_function\");\n    Sk.bool_check(Sk.__future__.division, \"Sk.__future__.division\");\n    Sk.bool_check(Sk.__future__.unicode_literals, \"Sk.__future__.unicode_literals\");\n    Sk.bool_check(Sk.__future__.set_repr, \"Sk.__future__.set_repr\");\n    Sk.bool_check(Sk.__future__.class_repr, \"Sk.__future__.class_repr\");\n    Sk.bool_check(Sk.__future__.inherit_from_object, \"Sk.__future__.inherit_from_object\");\n    Sk.bool_check(Sk.__future__.super_args, \"Sk.__future__.super_args\");\n    Sk.bool_check(Sk.__future__.octal_number_literal, \"Sk.__future__.octal_number_literal\");\n    Sk.bool_check(Sk.__future__.bankers_rounding, \"Sk.__future__.bankers_rounding\");\n    Sk.bool_check(Sk.__future__.python_version, \"Sk.__future__.python_version\");\n    Sk.bool_check(Sk.__future__.dunder_next, \"Sk.__future__.dunder_next\");\n    Sk.bool_check(Sk.__future__.dunder_round, \"Sk.__future__.dunder_round\");\n    Sk.bool_check(Sk.__future__.list_clear, \"Sk.__future__.list_clear\");\n    Sk.bool_check(Sk.__future__.exceptions, \"Sk.__future__.exceptions\");\n    Sk.bool_check(Sk.__future__.no_long_type, \"Sk.__future__.no_long_type\");\n    Sk.bool_check(Sk.__future__.ceil_floor_int, \"Sk.__future__.ceil_floor_int\");\n    Sk.bool_check(Sk.__future__.silent_octal_literal, \"Sk.__future__.silent_octal_literal\");\n    Sk.bool_check(Sk.__future__.l_suffix, \"Sk.__future__.l_suffix\");\n\n    // in __future__ add checks for absolute_import\n\n    Sk.imageProxy = options[\"imageProxy\"] || \"http://localhost:8080/320x\";\n    Sk.asserts.assert(typeof Sk.imageProxy === \"string\" || typeof Sk.imageProxy === \"function\");\n\n    Sk.inputfun = options[\"inputfun\"] || Sk.inputfun;\n    Sk.asserts.assert(typeof Sk.inputfun === \"function\");\n\n    Sk.inputfunTakesPrompt = options[\"inputfunTakesPrompt\"] || false;\n    Sk.asserts.assert(typeof Sk.inputfunTakesPrompt === \"boolean\");\n\n    //add turtle_input\n    Sk.turtle_textinput = options[\"turtle_textinput\"] || Sk.turtle_textinput;\n    Sk.asserts.assert(typeof Sk.turtle_textinput === \"function\");\n\n    Sk.retainGlobals = options[\"retainglobals\"] || false;\n    Sk.asserts.assert(typeof Sk.retainGlobals === \"boolean\");\n\n    Sk.debugging = options[\"debugging\"] || false;\n    Sk.asserts.assert(typeof Sk.debugging === \"boolean\");\n\n    Sk.killableWhile = options[\"killableWhile\"] || false;\n    Sk.asserts.assert(typeof Sk.killableWhile === \"boolean\");\n\n    Sk.killableFor = options[\"killableFor\"] || false;\n    Sk.asserts.assert(typeof Sk.killableFor === \"boolean\");\n\n    Sk.signals = typeof options[\"signals\"] !== undefined ? options[\"signals\"] : null;\n    if (Sk.signals === true) {\n        Sk.signals = {\n            listeners: [],\n            addEventListener: function (handler) {\n                Sk.signals.listeners.push(handler);\n            },\n            removeEventListener: function (handler) {\n                var index = Sk.signals.listeners.indexOf(handler);\n                if (index >= 0) {\n                    Sk.signals.listeners.splice(index, 1); // Remove items\n                }\n            },\n            signal: function (signal, data) {\n                for (var i = 0; i < Sk.signals.listeners.length; i++) {\n                    Sk.signals.listeners[i].call(null, signal, data);\n                }\n            }\n        };\n    } else {\n        Sk.signals = null;\n    }\n    Sk.asserts.assert(typeof Sk.signals === \"object\");\n\n    Sk.breakpoints = options[\"breakpoints\"] || function() { return true; };\n    Sk.asserts.assert(typeof Sk.breakpoints === \"function\");\n\n    Sk.setTimeout = options[\"setTimeout\"];\n    if (Sk.setTimeout === undefined) {\n        if (typeof setTimeout === \"function\") {\n            Sk.setTimeout = function(func, delay) { setTimeout(func, delay); };\n        } else {\n            Sk.setTimeout = function(func, delay) { func(); };\n        }\n    }\n    Sk.asserts.assert(typeof Sk.setTimeout === \"function\");\n\n    if (\"execLimit\" in options) {\n        Sk.execLimit = options[\"execLimit\"];\n    }\n\n    if (\"yieldLimit\" in options) {\n        Sk.yieldLimit = options[\"yieldLimit\"];\n    }\n\n    if (options[\"syspath\"]) {\n        Sk.syspath = options[\"syspath\"];\n        Sk.asserts.assert(Sk.isArrayLike(Sk.syspath));\n        // assume that if we're changing syspath we want to force reimports.\n        // not sure how valid this is, perhaps a separate api for that.\n        Sk.realsyspath = undefined;\n        Sk.sysmodules = new Sk.builtin.dict([]);\n    }\n\n    Sk.misceval.softspace_ = false;\n\n    Sk.switch_version(\"round$\", Sk.__future__.dunder_round);\n    Sk.switch_version(\"next$\", Sk.__future__.dunder_next);\n    Sk.switch_version(\"clear$\", Sk.__future__.list_clear);\n\n    Sk.builtin.lng.tp$name = Sk.__future__.no_long_type ? \"int\" : \"long\";\n};\n\nSk.exportSymbol(\"Sk.configure\", Sk.configure);\n\n/*\n* Replaceable handler for uncaught exceptions\n*/\nSk.uncaughtException = function(err) {\n    throw err;\n};\n\n/*\n * Replaceable handler for uncaught exceptions\n */\nSk.uncaughtException = function(err) {\n    throw err;\n};\nSk.exportSymbol(\"Sk.uncaughtException\", Sk.uncaughtException);\n\n/*\n *      Replaceable message for message timeouts\n */\nSk.timeoutMsg = function () {\n    return \"Program exceeded run time limit.\";\n};\nSk.exportSymbol(\"Sk.timeoutMsg\", Sk.timeoutMsg);\n\n/*\n *  Hard execution timeout, throws an error. Set to null to disable\n */\nSk.execLimit = Number.POSITIVE_INFINITY;\n\n/*\n *  Soft execution timeout, returns a Suspension. Set to null to disable\n */\nSk.yieldLimit = Number.POSITIVE_INFINITY;\n\n/*\n * Replacable output redirection (called from print, etc).\n */\nSk.output = function (x) {\n};\n\n/*\n * Replacable function to load modules with (called via import, etc.)\n * todo; this should be an async api\n */\nSk.read = function (x) {\n    throw \"Sk.read has not been implemented\";\n};\n\n/*\n * Setable to emulate arguments to the script. Should be array of JS strings.\n */\nSk.sysargv = [];\n\n// lame function for sys module\nSk.getSysArgv = function () {\n    return Sk.sysargv;\n};\nSk.exportSymbol(\"Sk.getSysArgv\", Sk.getSysArgv);\n\n\n/**\n * Setable to emulate PYTHONPATH environment variable (for finding modules).\n * Should be an array of JS strings.\n */\nSk.syspath = [];\n\nSk.inBrowser = Sk.global[\"document\"] !== undefined;\n\n/**\n * Internal function used for debug output.\n * @param {...} args\n */\nSk.debugout = function (args) {\n};\n\n(function () {\n    // set up some sane defaults based on availability\n    if (Sk.global[\"write\"] !== undefined) {\n        Sk.output = Sk.global[\"write\"];\n    } else if (Sk.global[\"console\"] !== undefined && Sk.global[\"console\"][\"log\"] !== undefined) {\n        Sk.output = function (x) {\n            Sk.global[\"console\"][\"log\"](x);\n        };\n    } else if (Sk.global[\"print\"] !== undefined) {\n        Sk.output = Sk.global[\"print\"];\n    }\n    if (Sk.global[\"console\"] !== undefined && Sk.global[\"console\"][\"log\"] !== undefined) {\n        Sk.debugout = function (x) {\n            Sk.global[\"console\"][\"log\"](x);\n        };\n    } else if (Sk.global[\"print\"] !== undefined) {\n        Sk.debugout = Sk.global[\"print\"];\n    }\n}());\n\nSk.inputfun = function (args) {\n    return window.prompt(args);\n};\n// Sk add function\nSk.turtle_textinput = function(title, prompt){\n    return new Promise(function(resolve){\n        var cover = document.createElement(\"div\");\n        cover.id = \"cover\";\n        cover.style.position = \"fixed\";\n        cover.style.width = \"100%\";\n        cover.style.height = \"100%\";\n        cover.style.top = \"0px\";\n        cover.style.left = \"0px\";\n        cover.style.background = \"rgba(0,0,0,0.4)\";\n        cover.style.display = \"flex\";\n        cover.style.alignItems = \"center\";\n        cover.style.justifyContent = \"center\";\n        cover.style.zIndex = \"99\";\n        document.body.appendChild(cover);\n        var inputModal = document.createElement(\"div\");\n        inputModal.style.width = \"400px\";\n        inputModal.style.height = \"200px\";\n        inputModal.style.border=\"1px solid #666\";\n        inputModal.style.zIndex = \"1000\";\n        inputModal.style.background=\"#fff\";\n        cover.appendChild(inputModal);\n        var modal_header = document.createElement(\"div\");\n        var titleDom = document.createElement(\"span\");\n        titleDom.innerHTML = title;\n        var closeBtn = document.createElement(\"button\");\n        closeBtn.innerHTML = \"X\";\n        closeBtn.style.border = \"none\";\n        closeBtn.style.background = \"#cee2ff\";\n        modal_header.style.display=\"flex\";\n        modal_header.style.alignItems=\"center\";\n        modal_header.style.justifyContent=\"space-between\";\n        modal_header.style.paddingLeft = \"10px\";\n        modal_header.style.paddingRight = \"10px\";\n        modal_header.style.background = \"#cee2ff\";\n        modal_header.style.lineHeight = \"40px\";\n        modal_header.appendChild(titleDom);\n        modal_header.appendChild(closeBtn);\n        inputModal.appendChild(modal_header);\n        var modal_body = document.createElement(\"div\");\n        modal_body.style.textAlign=\"center\";\n        modal_body.style.marginBottom=\"20px\";\n        var content = document.createElement(\"span\");\n        content.innerHTML = prompt;\n        content.style.display=\"block\";\n        content.style.marginBottom=\"10px\";\n        content.style.marginTop=\"10px\";\n        modal_body.appendChild(content);\n        var input = document.createElement(\"input\");\n        input.type = \"text\";\n        input.id=\"text_input\";\n        input.style.width=\"180px\";\n        input.style.height=\"25px\";\n        input.style.border=\"1px solid #cee2ff\";\n        modal_body.appendChild(input);\n        inputModal.appendChild(modal_body);\n        var modal_footer = document.createElement(\"div\");\n        modal_footer.style.textAlign=\"center\";\n        var cancelBtn = document.createElement(\"button\");\n        cancelBtn.type=\"button\";\n        cancelBtn.id = \"cancel\";\n        cancelBtn.style.border=\"1px solid #898989\";\n        cancelBtn.style.width=\"60px\";\n        cancelBtn.style.height = \"30px\";\n        cancelBtn.style.fontWeight=\"bold\";\n        cancelBtn.innerHTML = \"\";\n        var primaryBtn = document.createElement(\"button\");\n        primaryBtn.type = \"button\";\n        primaryBtn.id = \"confirm\";\n        primaryBtn.innerHTML = \"\";\n        primaryBtn.style.marginLeft=\"40px\";\n        primaryBtn.style.width=\"60px\";\n        primaryBtn.style.height=\"30px\";\n        primaryBtn.style.background=\"#4d97ff\";\n        primaryBtn.style.fontWeight=\"bold\";\n        modal_footer.appendChild(cancelBtn);\n        modal_footer.appendChild(primaryBtn);\n        inputModal.appendChild(modal_footer);\n        var text_input = 0;\n        cancelBtn.onclick = function(){\n            document.body.removeChild(cover);\n            resolve(text_input);\n        };\n        closeBtn.onclick = function(){\n            document.body.removeChild(cover);\n            resolve(text_input);\n        };\n        primaryBtn.onclick = function(){\n            text_input = input.value;\n            document.body.removeChild(cover);\n            resolve(text_input);\n        };\n    });\n};\n\nSk.turtle_numinput = function(title, prompt, defaultVal, minval, maxval){\n    return new Promise(function(resolve){\n        var cover = document.createElement(\"div\");\n        cover.id = \"cover\";\n        cover.style.position = \"fixed\";\n        cover.style.width = \"100%\";\n        cover.style.height = \"100%\";\n        cover.style.top = \"0px\";\n        cover.style.left = \"0px\";\n        cover.style.background = \"rgba(0,0,0,0.4)\";\n        cover.style.display = \"flex\";\n        cover.style.alignItems = \"center\";\n        cover.style.justifyContent = \"center\";\n        cover.style.zIndex = \"99\";\n        document.body.appendChild(cover);\n        var inputModal = document.createElement(\"div\");\n        inputModal.style.width = \"400px\";\n        inputModal.style.height = \"200px\";\n        inputModal.style.border=\"1px solid #666\";\n        inputModal.style.zIndex = \"1000\";\n        inputModal.style.background=\"#fff\";\n        cover.appendChild(inputModal);\n        var modal_header = document.createElement(\"div\");\n        var titleDom = document.createElement(\"span\");\n        titleDom.innerHTML = title;\n        var closeBtn = document.createElement(\"button\");\n        closeBtn.innerHTML = \"X\";\n        closeBtn.style.border = \"none\";\n        closeBtn.style.background = \"#cee2ff\";\n        modal_header.style.display=\"flex\";\n        modal_header.style.alignItems=\"center\";\n        modal_header.style.justifyContent=\"space-between\";\n        modal_header.style.paddingLeft = \"10px\";\n        modal_header.style.paddingRight = \"10px\";\n        modal_header.style.background = \"#cee2ff\";\n        modal_header.style.lineHeight = \"40px\";\n        modal_header.appendChild(titleDom);\n        modal_header.appendChild(closeBtn);\n        inputModal.appendChild(modal_header);\n        var modal_body = document.createElement(\"div\");\n        modal_body.style.textAlign=\"center\";\n        modal_body.style.marginBottom=\"10px\";\n        var content = document.createElement(\"span\");\n        content.innerHTML = prompt;\n        content.style.display=\"block\";\n        content.style.marginBottom=\"10px\";\n        content.style.marginTop=\"10px\";\n        modal_body.appendChild(content);\n        var input = document.createElement(\"input\");\n        input.type = \"number\";\n        input.id=\"text_input\";\n        input.style.width=\"180px\";\n        input.style.height=\"25px\";\n        input.style.border=\"1px solid #cee2ff\";\n        input.value = defaultVal;\n        modal_body.appendChild(input);\n        inputModal.appendChild(modal_body);\n        var modal_footer = document.createElement(\"div\");\n        modal_footer.style.textAlign=\"center\";\n        var cancelBtn = document.createElement(\"button\");\n        cancelBtn.type=\"button\";\n        cancelBtn.id = \"cancel\";\n        cancelBtn.style.border=\"1px solid #898989\";\n        cancelBtn.style.width=\"60px\";\n        cancelBtn.style.height = \"30px\";\n        cancelBtn.style.fontWeight=\"bold\";\n        cancelBtn.innerHTML = \"\";\n        var primaryBtn = document.createElement(\"button\");\n        primaryBtn.type = \"button\";\n        primaryBtn.id = \"confirm\";\n        primaryBtn.innerHTML = \"\";\n        primaryBtn.style.marginLeft=\"40px\";\n        primaryBtn.style.width=\"60px\";\n        primaryBtn.style.height=\"30px\";\n        primaryBtn.style.background=\"#4d97ff\";\n        primaryBtn.style.fontWeight=\"bold\";\n        modal_footer.appendChild(cancelBtn);\n        modal_footer.appendChild(primaryBtn);\n        inputModal.appendChild(modal_footer);\n        var text_input = 0;\n        cancelBtn.onclick = function(){\n            document.body.removeChild(cover);\n            resolve(text_input);\n        };\n        closeBtn.onclick = function(){\n            document.body.removeChild(cover);\n            resolve(text_input);\n        };\n        primaryBtn.onclick = function(){\n            text_input = input.value;\n            var errorDom = document.getElementById(\"tip\");\n            if ((text_input < minval || text_input > maxval)){\n                if(!errorDom){\n                    var errorText = document.createElement(\"span\");\n                    errorText.id = \"tip\";\n                    errorText.innerHTML = \"\"+minval+\"~\"+maxval+\"\";\n                    errorText.style.fontSize=\"14px\";\n                    errorText.style.color=\"red\";\n                    errorText.style.display = \"block\";\n                    errorText.style.marginTop=\"5px\";\n                    modal_body.appendChild(errorText);\n                }\n                return;\n            } else if(text_input > minval && text_input < maxval && errorDom){\n                modal_body.removeChild(errorDom);\n            }\n            document.body.removeChild(cover);\n            resolve(text_input);\n        };\n    });\n};\n\n\n\n// Information about method names and their internal functions for\n// methods that differ (in visibility or name) between Python 2 and 3.\n//\n// Format:\n//   internal function: {\n//     \"classes\" : <array of affected classes>,\n//     2 : <visible Python 2 method name> or null if none\n//     3 : <visible Python 3 method name> or null if none\n//   },\n//   ...\n\nSk.setup_method_mappings = function () {\n    return {\n        \"round$\": {\n            \"classes\": [Sk.builtin.float_,\n                        Sk.builtin.int_,\n                        Sk.builtin.nmber],\n            2: null,\n            3: \"__round__\"\n        },\n        \"clear$\": {\n            \"classes\": [Sk.builtin.list],\n            2: null,\n            3: \"clear\"\n        },\n        \"next$\": {\n            \"classes\": [Sk.builtin.dict_iter_,\n                        Sk.builtin.list_iter_,\n                        Sk.builtin.set_iter_,\n                        Sk.builtin.str_iter_,\n                        Sk.builtin.tuple_iter_,\n                        Sk.builtin.generator,\n                        Sk.builtin.enumerate,\n                        Sk.builtin.iterator],\n            2: \"next\",\n            3: \"__next__\"\n        }\n    };\n};\n\nSk.switch_version = function (method_to_map, python3) {\n    var mapping, klass, classes, idx, len, newmeth, oldmeth, mappings;\n\n    mappings = Sk.setup_method_mappings();\n\n    mapping = mappings[method_to_map];\n\n    if (python3) {\n        newmeth = mapping[3];\n        oldmeth = mapping[2];\n    } else {\n        newmeth = mapping[2];\n        oldmeth = mapping[3];\n    }\n\n    classes = mapping[\"classes\"];\n    len = classes.length;\n    for (idx = 0; idx < len; idx++) {\n        klass = classes[idx];\n        if (oldmeth && klass.prototype.hasOwnProperty(oldmeth)) {\n            delete klass.prototype[oldmeth];\n        }\n        if (newmeth) {\n            klass.prototype[newmeth] = new Sk.builtin.func(klass.prototype[method_to_map]);\n        }\n    }\n};\n\nSk.exportSymbol(\"Sk.python3\", Sk.python3);\nSk.exportSymbol(\"Sk.inputfun\", Sk.inputfun);\nSk.exportSymbol(\"Sk.turtle_textinput\", Sk.turtle_textinput);\n\nSk.exportSymbol(\"Sk.__future__\", Sk.__future__);\nSk.exportSymbol(\"Sk.inputfun\", Sk.inputfun);\n","if(Sk.builtin === undefined) {\n    Sk.builtin = {};\n}\n\n/**\n * Maps Python dunder names to the Skulpt Javascript function names that\n * implement them.\n *\n * Note: __add__, __mul__, and __rmul__ can be used for either numeric or\n * sequence types. Here, they default to the numeric versions (i.e. nb$add,\n * nb$multiply, and nb$reflected_multiply). This works because Sk.abstr.binary_op_\n * checks for the numeric shortcuts and not the sequence shortcuts when computing\n * a binary operation.\n *\n * Because many of these functions are used in contexts in which Skulpt does not\n * [yet] handle suspensions, the assumption is that they must not suspend. However,\n * some of these built-in functions are acquiring 'canSuspend' arguments to signal\n * where this is not the case. These need to be spliced out of the argument list before\n * it is passed to python. Array values in this map contain [dunderName, argumentIdx],\n * where argumentIdx specifies the index of the 'canSuspend' boolean argument.\n *\n * @type {Object}\n */\nSk.dunderToSkulpt = {\n    \"__eq__\": \"ob$eq\",\n    \"__ne__\": \"ob$ne\",\n    \"__lt__\": \"ob$lt\",\n    \"__le__\": \"ob$le\",\n    \"__gt__\": \"ob$gt\",\n    \"__ge__\": \"ob$ge\",\n    \"__hash__\": \"tp$hash\",\n    \"__abs__\": \"nb$abs\",\n    \"__neg__\": \"nb$negative\",\n    \"__pos__\": \"nb$positive\",\n    \"__int__\": \"nb$int_\",\n    \"__long__\": \"nb$lng\",\n    \"__float__\": \"nb$float_\",\n    \"__add__\": \"nb$add\",\n    \"__radd__\": \"nb$reflected_add\",\n    \"__sub__\": \"nb$subtract\",\n    \"__rsub__\": \"nb$reflected_subtract\",\n    \"__mul__\": \"nb$multiply\",\n    \"__rmul__\": \"nb$reflected_multiply\",\n    \"__div__\": \"nb$divide\",\n    \"__rdiv__\": \"nb$reflected_divide\",\n    \"__floordiv__\": \"nb$floor_divide\",\n    \"__rfloordiv__\": \"nb$reflected_floor_divide\",\n    \"__mod__\": \"nb$remainder\",\n    \"__rmod__\": \"nb$reflected_remainder\",\n    \"__divmod__\": \"nb$divmod\",\n    \"__rdivmod__\": \"nb$reflected_divmod\",\n    \"__pow__\": \"nb$power\",\n    \"__rpow__\": \"nb$reflected_power\",\n    \"__contains__\": \"sq$contains\",\n    \"__len__\": [\"sq$length\", 1],\n    \"__get__\": [\"tp$descr_get\", 3],\n    \"__set__\": [\"tp$descr_set\", 3]\n};\n\n/**\n *\n * @constructor\n *\n * @param {*} name name or object to get type of, if only one arg\n *\n * @param {Sk.builtin.tuple=} bases\n *\n * @param {Object=} dict\n *\n *\n * This type represents the type of `type'. *Calling* an instance of\n * this builtin type named \"type\" creates class objects. The resulting\n * class objects will have various tp$xyz attributes on them that allow\n * for the various operations on that object.\n *\n * calling the type or calling an instance of the type? or both?\n */\nSk.builtin.type = function (name, bases, dict) {\n    var mro;\n    var obj;\n    var klass;\n    var v;\n    if (bases === undefined && dict === undefined) {\n        // 1 arg version of type()\n        // the argument is an object, not a name and returns a type object\n        obj = name;\n        return obj.ob$type;\n    } else {\n\n        // argument dict must be of type dict\n        if(dict.tp$name !== \"dict\") {\n            throw new Sk.builtin.TypeError(\"type() argument 3 must be dict, not \" + Sk.abstr.typeName(dict));\n        }\n\n        // checks if name must be string\n        if(!Sk.builtin.checkString(name)) {\n            throw new Sk.builtin.TypeError(\"type() argument 1 must be str, not \" + Sk.abstr.typeName(name));\n        }\n\n        // argument bases must be of type tuple\n        if(bases.tp$name !== \"tuple\") {\n            throw new Sk.builtin.TypeError(\"type() argument 2 must be tuple, not \" + Sk.abstr.typeName(bases));\n        }\n\n        // type building version of type\n\n        // dict is the result of running the classes code object\n        // (basically the dict of functions). those become the prototype\n        // object of the class).\n\n        /**\n        * The constructor is a stub, that gets called from object.__new__\n        * @constructor\n        */\n        klass = function (args, kws) {\n            var args_copy;\n\n            // Call up through the chain in case there's a built-in object\n            // whose constructor we need to initialise\n            if (klass.prototype.tp$base !== undefined) {\n                if (klass.prototype.tp$base.sk$klass) {\n                    klass.prototype.tp$base.call(this, args, kws);\n                } else {\n                    // Call super constructor if subclass of a builtin\n                    args_copy = args.slice();\n                    args_copy.unshift(klass, this);\n                    Sk.abstr.superConstructor.apply(undefined, args_copy);\n                }\n            }\n\n            this[\"$d\"] = new Sk.builtin.dict([]);\n            this[\"$d\"].mp$ass_subscript(new Sk.builtin.str(\"__dict__\"), this[\"$d\"]);\n        };\n\n        var _name = Sk.ffi.remapToJs(name); // unwrap name string to js for latter use\n\n        var inheritsBuiltin = false;\n\n        // Invoking the class object calls __new__() to generate a new instance,\n        // then __init__() to initialise it\n        klass.tp$call = function(args, kws) {\n            var newf = Sk.builtin.type.typeLookup(klass, Sk.builtin.str.$new), newargs;\n            var self;\n\n            args = args || [];\n            kws = kws || [];\n\n            if (newf === undefined || newf === Sk.builtin.object.prototype[\"__new__\"]) {\n                // No override -> just call the constructor\n                self = new klass(args, kws);\n                newf = undefined;\n            } else {\n                newargs = args.slice();\n                newargs.unshift(klass);\n                self = Sk.misceval.applyOrSuspend(newf, undefined, undefined, kws, newargs);\n            }\n\n            return Sk.misceval.chain(self, function(s) {\n                var init = Sk.builtin.type.typeLookup(s.ob$type, Sk.builtin.str.$init);\n\n                self = s; // in case __new__ suspended\n\n                if (init !== undefined) {\n                    args.unshift(self);\n                    return Sk.misceval.applyOrSuspend(init, undefined, undefined, kws, args);\n                } else if (newf === undefined && (args.length !== 0 || kws.length !== 0) && !inheritsBuiltin) {\n                    // We complain about spurious constructor arguments if neither __new__\n                    // nor __init__ were overridden\n                    throw new Sk.builtin.TypeError(\"__init__() got unexpected argument(s)\");\n                }\n            }, function(r) {\n                if (r !== Sk.builtin.none.none$ && r !== undefined) {\n                    throw new Sk.builtin.TypeError(\"__init__() should return None, not \" + Sk.abstr.typeName(r));\n                } else {\n                    return self;\n                }\n            });\n        };\n\n        if (bases.v.length === 0 && Sk.__future__.inherit_from_object) {\n            // new style class, inherits from object by default\n            bases.v.push(Sk.builtin.object);\n            Sk.abstr.setUpInheritance(_name, klass, Sk.builtin.object);\n        }\n\n        var parent, it, firstAncestor, builtin_bases = [];\n        // Set up inheritance from any builtins\n        for (it = bases.tp$iter(), parent = it.tp$iternext(); parent !== undefined; parent = it.tp$iternext()) {\n            if (firstAncestor === undefined) {\n                firstAncestor = parent;\n            }\n\n            while (parent.sk$klass && parent.prototype.tp$base) {\n                parent = parent.prototype.tp$base;\n            }\n\n            if (!parent.sk$klass && builtin_bases.indexOf(parent) < 0) {\n                builtin_bases.push(parent);\n                inheritsBuiltin = true;\n            }\n        }\n\n        if (builtin_bases.length > 1) {\n            throw new Sk.builtin.TypeError(\"Multiple inheritance with more than one builtin type is unsupported\");\n        }\n\n        // Javascript does not support multiple inheritance, so only the first\n        // base (if any) will directly inherit in Javascript\n        if (firstAncestor !== undefined) {\n            Sk.abstr.inherits(klass, firstAncestor);\n\n            if (firstAncestor.prototype instanceof Sk.builtin.object || firstAncestor === Sk.builtin.object) {\n                klass.prototype.tp$base = firstAncestor;\n            }\n        }\n\n        klass.prototype.tp$name = _name;\n        klass.prototype.ob$type = Sk.builtin.type.makeIntoTypeObj(_name, klass);\n\n        // set __module__ if not present (required by direct type(name, bases, dict) calls)\n        var module_lk = new Sk.builtin.str(\"__module__\");\n        if(dict.mp$lookup(module_lk) === undefined) {\n            dict.mp$ass_subscript(module_lk, Sk.globals[\"__name__\"]);\n        }\n\n        // copy properties into our klass object\n        // uses python iter methods\n        var k;\n        for (it = dict.tp$iter(), k = it.tp$iternext(); k !== undefined; k = it.tp$iternext()) {\n            v = dict.mp$subscript(k);\n            if (v === undefined) {\n                v = null;\n            }\n            klass.prototype[k.v] = v;\n            klass[k.v] = v;\n        }\n\n        klass[\"__class__\"] = klass;\n        klass[\"__name__\"] = name;\n        klass.sk$klass = true;\n        klass.prototype[\"$r\"] = function () {\n            var cname;\n            var mod;\n            var reprf = this.tp$getattr(Sk.builtin.str.$repr);\n            if (reprf !== undefined && reprf.im_func !== Sk.builtin.object.prototype[\"__repr__\"]) {\n                return Sk.misceval.apply(reprf, undefined, undefined, undefined, []);\n            }\n\n            if ((klass.prototype.tp$base !== undefined) &&\n                (klass.prototype.tp$base !== Sk.builtin.object) &&\n                (klass.prototype.tp$base.prototype[\"$r\"] !== undefined)) {\n                // If subclass of a builtin which is not object, use that class' repr\n                return klass.prototype.tp$base.prototype[\"$r\"].call(this);\n            } else {\n                // Else, use default repr for a user-defined class instance\n                mod = dict.mp$subscript(module_lk); // lookup __module__\n                cname = \"\";\n                if (mod) {\n                    cname = mod.v + \".\";\n                }\n                return new Sk.builtin.str(\"<\" + cname + _name + \" object>\");\n            }\n        };\n\n        klass.prototype.tp$setattr = function(pyName, data, canSuspend) {\n            var r, setf = Sk.builtin.object.prototype.GenericGetAttr.call(this, Sk.builtin.str.$setattr);\n            if (setf !== undefined) {\n                var f = /** @type {?} */ (setf);\n                r = Sk.misceval.callsimOrSuspendArray(f, [pyName, data]);\n                return canSuspend ? r : Sk.misceval.retryOptionalSuspensionOrThrow(r);\n            }\n\n            return Sk.builtin.object.prototype.GenericSetAttr.call(this, pyName, data, canSuspend);\n        };\n\n        klass.prototype.tp$getattr = function(pyName, canSuspend) {\n            var r, descr, /** @type {(Object|undefined)} */ getf;\n            // Find __getattribute__ on this type if we can\n            descr = Sk.builtin.type.typeLookup(klass, Sk.builtin.str.$getattribute);\n\n            if (descr !== undefined && descr !== null && descr.tp$descr_get !== undefined) {\n                getf = descr.tp$descr_get.call(descr, this, klass);\n            }\n\n            if (getf === undefined) {\n                getf = Sk.builtin.object.prototype.GenericPythonGetAttr.bind(null, this);\n            }\n\n            // Convert AttributeErrors back into 'undefined' returns to match the tp$getattr\n            // convention\n            r = Sk.misceval.tryCatch(function() {\n                return Sk.misceval.callsimOrSuspendArray(/** @type {Object} */ (getf), [pyName]);\n            }, function (e) {\n                if (e instanceof Sk.builtin.AttributeError) {\n                    return undefined;\n                } else {\n                    throw e;\n                }\n            });\n\n            return canSuspend ? r : Sk.misceval.retryOptionalSuspensionOrThrow(r);\n        };\n\n        klass.prototype.tp$str = function () {\n            var strf = this.tp$getattr(Sk.builtin.str.$str);\n            if (strf !== undefined && strf.im_func !== Sk.builtin.object.prototype[\"__str__\"]) {\n                return Sk.misceval.apply(strf, undefined, undefined, undefined, []);\n            }\n            if ((klass.prototype.tp$base !== undefined) &&\n                (klass.prototype.tp$base !== Sk.builtin.object) &&\n                (klass.prototype.tp$base.prototype.tp$str !== undefined)) {\n                // If subclass of a builtin which is not object, use that class' repr\n                return klass.prototype.tp$base.prototype.tp$str.call(this);\n            }\n            return this[\"$r\"]();\n        };\n        klass.prototype.tp$length = function (canSuspend) {\n            var r = Sk.misceval.chain(Sk.abstr.gattr(this, Sk.builtin.str.$len, canSuspend), function(lenf) {\n                return Sk.misceval.applyOrSuspend(lenf, undefined, undefined, undefined, []);\n            });\n            return canSuspend ? r : Sk.misceval.retryOptionalSuspensionOrThrow(r);\n        };\n        klass.prototype.tp$call = function (args, kw) {\n            return Sk.misceval.chain(this.tp$getattr(Sk.builtin.str.$call, true), function(callf) {\n                if (callf === undefined) {\n                    throw new Sk.builtin.TypeError(\"'\" + Sk.abstr.typeName(this) + \"' object is not callable\");\n                }\n                return Sk.misceval.applyOrSuspend(callf, undefined, undefined, kw, args);\n            });\n        };\n        klass.prototype.tp$iter = function () {\n            var iterf = this.tp$getattr(Sk.builtin.str.$iter);\n            if (iterf === undefined) {\n                throw new Sk.builtin.TypeError(\"'\" + Sk.abstr.typeName(this) + \"' object is not iterable\");\n            }\n            return Sk.misceval.callsimArray(iterf);\n        };\n        klass.prototype.tp$iternext = function (canSuspend) {\n            var self = this;\n            var next;\n\n            if (Sk.__future__.dunder_next) {\n                next = Sk.builtin.str.$next3;\n            } else {\n                next = Sk.builtin.str.$next2;\n            }\n            var r = Sk.misceval.chain(self.tp$getattr(next, canSuspend), function(iternextf) {\n                if (iternextf === undefined) {\n                    throw new Sk.builtin.TypeError(\"'\" + Sk.abstr.typeName(self) + \"' object is not iterable\");\n                }\n\n                return Sk.misceval.tryCatch(function() {\n                    return Sk.misceval.callsimOrSuspendArray(iternextf);\n                }, function(e) {\n                    if (e instanceof Sk.builtin.StopIteration) {\n                        return undefined;\n                    } else {\n                        throw e;\n                    }\n                });\n            });\n\n            return canSuspend ? r : Sk.misceval.retryOptionalSuspensionOrThrow(r);\n        };\n\n        klass.prototype.tp$getitem = function (key, canSuspend) {\n            var getf = this.tp$getattr(Sk.builtin.str.$getitem, canSuspend), r;\n            if (getf !== undefined) {\n                r = Sk.misceval.applyOrSuspend(getf, undefined, undefined, undefined, [key]);\n                return canSuspend ? r : Sk.misceval.retryOptionalSuspensionOrThrow(r);\n            }\n            throw new Sk.builtin.TypeError(\"'\" + Sk.abstr.typeName(this) + \"' object does not support indexing\");\n        };\n        klass.prototype.tp$setitem = function (key, value, canSuspend) {\n            var setf = this.tp$getattr(Sk.builtin.str.$setitem, canSuspend), r;\n            if (setf !== undefined) {\n                r = Sk.misceval.applyOrSuspend(setf, undefined, undefined, undefined, [key, value]);\n                return canSuspend ? r : Sk.misceval.retryOptionalSuspensionOrThrow(r);\n            }\n            throw new Sk.builtin.TypeError(\"'\" + Sk.abstr.typeName(this) + \"' object does not support item assignment\");\n        };\n\n        if (bases) {\n            //print(\"building mro for\", name);\n            //for (var i = 0; i < bases.length; ++i)\n            //print(\"base[\" + i + \"]=\" + bases[i].tp$name);\n            klass[\"$d\"] = new Sk.builtin.dict([]);\n            klass[\"$d\"].mp$ass_subscript(Sk.builtin.type.basesStr_, bases);\n            mro = Sk.builtin.type.buildMRO(klass);\n            klass[\"$d\"].mp$ass_subscript(Sk.builtin.type.mroStr_, mro);\n            klass.tp$mro = mro;\n            //print(\"mro result\", Sk.builtin.repr(mro).v);\n        }\n\n        // fix for class attributes\n        klass.tp$setattr = Sk.builtin.type.prototype.tp$setattr;\n\n        var shortcutDunder = function (skulpt_name, magic_name, magic_func, canSuspendIdx) {\n            klass.prototype[skulpt_name] = function () {\n                var canSuspend = false;\n                var len = arguments.length;\n                var args, i, j;\n                if ((canSuspendIdx !== null) && (canSuspendIdx <= len)) {\n                    args = new Array(len);\n                } else {\n                    args = new Array(len+1);\n                }\n\n                args[0] = this;\n                j = 1;\n                for (i = 0; i < len; i++) {\n                    if (i === (canSuspendIdx-1)) {\n                        canSuspend = arguments[i];\n                    } else {\n                        args[j] = arguments[i];\n                        j += 1;\n                    }\n                }\n\n                if (canSuspend) {\n                    return Sk.misceval.callsimOrSuspendArray(magic_func, args);\n                } else {\n                    return Sk.misceval.callsimArray(magic_func, args);\n                }\n            };\n        };\n\n        // Register skulpt shortcuts to magic methods defined by this class.\n        // Dynamically deflined methods (eg those returned by __getattr__())\n        // cannot be used by these magic functions; this is consistent with\n        // how CPython handles \"new-style\" classes:\n        // https://docs.python.org/2/reference/datamodel.html#special-method-lookup-for-old-style-classes\n        var dunder, skulpt_name, canSuspendIdx;\n        for (dunder in Sk.dunderToSkulpt) {\n            skulpt_name = Sk.dunderToSkulpt[dunder];\n            if (typeof(skulpt_name) === \"string\") {\n                canSuspendIdx = null;\n            } else {\n                canSuspendIdx = skulpt_name[1];\n                skulpt_name = skulpt_name[0];\n            }\n\n            if (klass[dunder]) {\n                // scope workaround\n                shortcutDunder(skulpt_name, dunder, klass[dunder], canSuspendIdx);\n            }\n        }\n\n        return klass;\n    }\n\n};\n\n/**\n *\n */\nSk.builtin.type.makeTypeObj = function (name, newedInstanceOfType) {\n    Sk.builtin.type.makeIntoTypeObj(name, newedInstanceOfType);\n    return newedInstanceOfType;\n};\n\nSk.builtin.type.makeIntoTypeObj = function (name, t) {\n    Sk.asserts.assert(name !== undefined);\n    Sk.asserts.assert(t !== undefined);\n    t.ob$type = Sk.builtin.type;\n    t.tp$name = name;\n    t[\"$r\"] = function () {\n        var ctype;\n        var mod = t.__module__;\n        var cname = \"\";\n        if (mod) {\n            cname = mod.v + \".\";\n        }\n        ctype = \"class\";\n        if (!mod && !t.sk$klass && !Sk.__future__.class_repr) {\n            ctype = \"type\";\n        }\n        return new Sk.builtin.str(\"<\" + ctype + \" '\" + cname + t.tp$name + \"'>\");\n    };\n    t.tp$str = undefined;\n    t.tp$getattr = Sk.builtin.type.prototype.tp$getattr;\n    t.tp$setattr = Sk.builtin.object.prototype.GenericSetAttr;\n    t.tp$richcompare = Sk.builtin.type.prototype.tp$richcompare;\n    t.sk$type = true;\n\n    return t;\n};\n\nSk.builtin.type.ob$type = Sk.builtin.type;\nSk.builtin.type.tp$name = \"type\";\nSk.builtin.type.sk$type = true;\nSk.builtin.type[\"$r\"] = function () {\n    if(Sk.__future__.class_repr) {\n        return new Sk.builtin.str(\"<class 'type'>\");\n    } else {\n        return new Sk.builtin.str(\"<type 'type'>\");\n    }\n};\n\n//Sk.builtin.type.prototype.tp$descr_get = function() { print(\"in type descr_get\"); };\n\n//Sk.builtin.type.prototype.tp$name = \"type\";\n\n// basically the same as GenericGetAttr except looks in the proto instead\nSk.builtin.type.prototype.tp$getattr = function (pyName, canSuspend) {\n    var res;\n    var tp = this;\n    var descr;\n    var f;\n\n    if (this[\"$d\"]) {\n        res = this[\"$d\"].mp$lookup(pyName);\n        if (res !== undefined) {\n            return res;\n        }\n    }\n\n    descr = Sk.builtin.type.typeLookup(tp, pyName);\n\n    //print(\"type.tpgetattr descr\", descr, descr.tp$name, descr.func_code, name);\n    if (descr !== undefined && descr !== null && descr.ob$type !== undefined) {\n        f = descr.tp$descr_get;\n        // todo;if (f && descr.tp$descr_set) // is a data descriptor if it has a set\n        // return f.call(descr, this, this.ob$type);\n    }\n\n    if (f) {\n        // non-data descriptor\n        return f.call(descr, Sk.builtin.none.none$, tp, canSuspend);\n    }\n\n    if (descr !== undefined) {\n        return descr;\n    }\n\n    return undefined;\n};\n\nSk.builtin.type.prototype.tp$setattr = function (pyName, value) {\n    // class attributes are direct properties of the object\n    var jsName = pyName.$jsstr();\n    this[jsName] = value;\n};\n\nSk.builtin.type.typeLookup = function (type, pyName) {\n    var mro = type.tp$mro;\n    var base;\n    var res;\n    var i;\n    var jsName = pyName.$jsstr();\n\n    // todo; probably should fix this, used for builtin types to get stuff\n    // from prototype\n    if (!mro) {\n        if (type.prototype) {\n            return type.prototype[jsName];\n        }\n        return undefined;\n    }\n\n    for (i = 0; i < mro.v.length; ++i) {\n        base = mro.v[i];\n        if (base.hasOwnProperty(jsName)) {\n            return base[jsName];\n        }\n        res = base[\"$d\"].mp$lookup(pyName);\n        if (res !== undefined) {\n            return res;\n        }\n        if (base.prototype && base.prototype[jsName] !== undefined) {\n            return base.prototype[jsName];\n        }\n    }\n\n    return undefined;\n};\n\nSk.builtin.type.mroMerge_ = function (seqs) {\n    /*\n     var tmp = [];\n     for (var i = 0; i < seqs.length; ++i)\n     {\n     tmp.push(new Sk.builtin.list(seqs[i]));\n     }\n     print(Sk.builtin.repr(new Sk.builtin.list(tmp)).v);\n     */\n    var seq;\n    var i;\n    var next;\n    var k;\n    var sseq;\n    var j;\n    var cand;\n    var cands;\n    var res = [];\n    for (; ;) {\n        for (i = 0; i < seqs.length; ++i) {\n            seq = seqs[i];\n            if (seq.length !== 0) {\n                break;\n            }\n        }\n        if (i === seqs.length) { // all empty\n            return res;\n        }\n        cands = [];\n        for (i = 0; i < seqs.length; ++i) {\n            seq = seqs[i];\n            //print(\"XXX\", Sk.builtin.repr(new Sk.builtin.list(seq)).v);\n            if (seq.length !== 0) {\n                cand = seq[0];\n                //print(\"CAND\", Sk.builtin.repr(cand).v);\n\n                /* eslint-disable */\n                OUTER:\n                    for (j = 0; j < seqs.length; ++j) {\n                        sseq = seqs[j];\n                        for (k = 1; k < sseq.length; ++k) {\n                            if (sseq[k] === cand) {\n                                break OUTER;\n                            }\n                        }\n                    }\n                /* eslint-enable */\n\n                // cand is not in any sequences' tail -> constraint-free\n                if (j === seqs.length) {\n                    cands.push(cand);\n                }\n            }\n        }\n\n        if (cands.length === 0) {\n            throw new Sk.builtin.TypeError(\"Inconsistent precedences in type hierarchy\");\n        }\n\n        next = cands[0];\n        // append next to result and remove from sequences\n        res.push(next);\n        for (i = 0; i < seqs.length; ++i) {\n            seq = seqs[i];\n            if (seq.length > 0 && seq[0] === next) {\n                seq.splice(0, 1);\n            }\n        }\n    }\n};\n\nSk.builtin.type.buildMRO_ = function (klass) {\n    // MERGE(klass + mro(bases) + bases)\n    var i;\n    var bases;\n    var all = [\n        [klass]\n    ];\n\n    //Sk.debugout(\"buildMRO for\", klass.tp$name);\n\n    var kbases = klass[\"$d\"].mp$subscript(Sk.builtin.type.basesStr_);\n    for (i = 0; i < kbases.v.length; ++i) {\n        all.push(Sk.builtin.type.buildMRO_(kbases.v[i]));\n    }\n\n    bases = [];\n    for (i = 0; i < kbases.v.length; ++i) {\n        bases.push(kbases.v[i]);\n    }\n    all.push(bases);\n\n    return Sk.builtin.type.mroMerge_(all);\n};\n\n/*\n * C3 MRO (aka CPL) linearization. Figures out which order to search through\n * base classes to determine what should override what. C3 does the \"right\n * thing\", and it's what Python has used since 2.3.\n *\n * Kind of complicated to explain, but not really that complicated in\n * implementation. Explanations:\n *\n * http://people.csail.mit.edu/jrb/goo/manual.43/goomanual_55.html\n * http://www.python.org/download/releases/2.3/mro/\n * http://192.220.96.201/dylan/linearization-oopsla96.html\n *\n * This implementation is based on a post by Samuele Pedroni on python-dev\n * (http://mail.python.org/pipermail/python-dev/2002-October/029176.html) when\n * discussing its addition to Python.\n */\nSk.builtin.type.buildMRO = function (klass) {\n    return new Sk.builtin.tuple(Sk.builtin.type.buildMRO_(klass));\n};\n\nSk.builtin.type.prototype.tp$richcompare = function (other, op) {\n    var r2;\n    var r1;\n    if (other.ob$type != Sk.builtin.type) {\n        return undefined;\n    }\n    if (!this[\"$r\"] || !other[\"$r\"]) {\n        return undefined;\n    }\n\n    r1 = this[\"$r\"]();\n    r2 = other[\"$r\"]();\n\n    return r1.tp$richcompare(r2, op);\n};\n\nSk.builtin.type.prototype[\"__format__\"] = function(self, format_spec) {\n    Sk.builtin.pyCheckArgsLen(\"__format__\", arguments.length, 1, 2);\n    return new Sk.builtin.str(self);\n};\n\nSk.builtin.type.pythonFunctions = [\"__format__\"];\n","/**\n * @namespace Sk.abstr\n *\n */\nSk.abstr = {};\n\n//\n// Number\n//\n\nSk.abstr.typeName = function (v) {\n    var vtypename;\n    if (v.tp$name !== undefined) {\n        vtypename = v.tp$name;\n    } else {\n        vtypename = \"<invalid type>\";\n    }\n    return vtypename;\n};\n\nSk.abstr.binop_type_error = function (v, w, name) {\n    var vtypename = Sk.abstr.typeName(v),\n        wtypename = Sk.abstr.typeName(w);\n\n    throw new Sk.builtin.TypeError(\"unsupported operand type(s) for \" + name + \": '\" + vtypename + \"' and '\" + wtypename + \"'\");\n};\n\nSk.abstr.unop_type_error = function (v, name) {\n    var vtypename = Sk.abstr.typeName(v),\n        uop = {\n            \"UAdd\"  : \"+\",\n            \"USub\"  : \"-\",\n            \"Invert\": \"~\"\n        }[name];\n\n    throw new Sk.builtin.TypeError(\"bad operand type for unary \" + uop + \": '\" + vtypename + \"'\");\n};\n\n/**\n * lookup and return the LHS object slot function method.  This coudl be either a builtin slot function or a dunder method defined by the user.\n * @param obj\n * @param name\n * @returns {Object|null|undefined}\n * @private\n */\nSk.abstr.boNameToSlotFuncLhs_ = function (obj, name) {\n    if (obj === null) {\n        return undefined;\n    }\n\n    switch (name) {\n        case \"Add\":\n            return obj.nb$add ? obj.nb$add : obj[\"__add__\"];\n        case \"Sub\":\n            return obj.nb$subtract ? obj.nb$subtract : obj[\"__sub__\"];\n        case \"Mult\":\n            return obj.nb$multiply ? obj.nb$multiply : obj[\"__mul__\"];\n        case \"Div\":\n            return obj.nb$divide ? obj.nb$divide : obj[\"__div__\"];\n        case \"FloorDiv\":\n            return obj.nb$floor_divide ? obj.nb$floor_divide : obj[\"__floordiv__\"];\n        case \"Mod\":\n            return obj.nb$remainder ? obj.nb$remainder : obj[\"__mod__\"];\n        case \"DivMod\":\n            return obj.nb$divmod ? obj.nb$divmod : obj[\"__divmod__\"];\n        case \"Pow\":\n            return obj.nb$power ? obj.nb$power : obj[\"__pow__\"];\n        case \"LShift\":\n            return obj.nb$lshift ? obj.nb$lshift : obj[\"__lshift__\"];\n        case \"RShift\":\n            return obj.nb$rshift ? obj.nb$rshift : obj[\"__rshift__\"];\n        case \"BitAnd\":\n            return obj.nb$and ? obj.nb$and : obj[\"__and__\"];\n        case \"BitXor\":\n            return obj.nb$xor ? obj.nb$xor : obj[\"__xor__\"];\n        case \"BitOr\":\n            return obj.nb$or ? obj.nb$or : obj[\"__or__\"];\n    }\n};\n\nSk.abstr.boNameToSlotFuncRhs_ = function (obj, name) {\n    if (obj === null) {\n        return undefined;\n    }\n\n    switch (name) {\n        case \"Add\":\n            return obj.nb$reflected_add ? obj.nb$reflected_add : obj[\"__radd__\"];\n        case \"Sub\":\n            return obj.nb$reflected_subtract ? obj.nb$reflected_subtract : obj[\"__rsub__\"];\n        case \"Mult\":\n            return obj.nb$reflected_multiply ? obj.nb$reflected_multiply : obj[\"__rmul__\"];\n        case \"Div\":\n            return obj.nb$reflected_divide ? obj.nb$reflected_divide : obj[\"__rdiv__\"];\n        case \"FloorDiv\":\n            return obj.nb$reflected_floor_divide ? obj.nb$reflected_floor_divide : obj[\"__rfloordiv__\"];\n        case \"Mod\":\n            return obj.nb$reflected_remainder ? obj.nb$reflected_remainder : obj[\"__rmod__\"];\n        case \"DivMod\":\n            return obj.nb$reflected_divmod ? obj.nb$reflected_divmod : obj[\"__rdivmod__\"];\n        case \"Pow\":\n            return obj.nb$reflected_power ? obj.nb$reflected_power : obj[\"__rpow__\"];\n        case \"LShift\":\n            return obj.nb$reflected_lshift ? obj.nb$reflected_lshift : obj[\"__rlshift__\"];\n        case \"RShift\":\n            return obj.nb$reflected_rshift ? obj.nb$reflected_rshift : obj[\"__rrshift__\"];\n        case \"BitAnd\":\n            return obj.nb$reflected_and ? obj.nb$reflected_and : obj[\"__rand__\"];\n        case \"BitXor\":\n            return obj.nb$reflected_xor ? obj.nb$reflected_xor : obj[\"__rxor__\"];\n        case \"BitOr\":\n            return obj.nb$reflected_or ? obj.nb$reflected_or : obj[\"__ror__\"];\n    }\n};\n\nSk.abstr.iboNameToSlotFunc_ = function (obj, name) {\n    switch (name) {\n        case \"Add\":\n            return obj.nb$inplace_add ? obj.nb$inplace_add : obj[\"__iadd__\"];\n        case \"Sub\":\n            return obj.nb$inplace_subtract ? obj.nb$inplace_subtract : obj[\"__isub__\"];\n        case \"Mult\":\n            return obj.nb$inplace_multiply ? obj.nb$inplace_multiply : obj[\"__imul__\"];\n        case \"Div\":\n            return obj.nb$inplace_divide ? obj.nb$inplace_divide : obj[\"__idiv__\"];\n        case \"FloorDiv\":\n            return obj.nb$inplace_floor_divide ? obj.nb$inplace_floor_divide : obj[\"__ifloordiv__\"];\n        case \"Mod\":\n            return obj.nb$inplace_remainder;\n        case \"Pow\":\n            return obj.nb$inplace_power;\n        case \"LShift\":\n            return obj.nb$inplace_lshift ? obj.nb$inplace_lshift : obj[\"__ilshift__\"];\n        case \"RShift\":\n            return obj.nb$inplace_rshift ? obj.nb$inplace_rshift : obj[\"__irshift__\"];\n        case \"BitAnd\":\n            return obj.nb$inplace_and;\n        case \"BitOr\":\n            return obj.nb$inplace_or;\n        case \"BitXor\":\n            return obj.nb$inplace_xor ? obj.nb$inplace_xor : obj[\"__ixor__\"];\n    }\n};\nSk.abstr.uoNameToSlotFunc_ = function (obj, name) {\n    if (obj === null) {\n        return undefined;\n    }\n    switch (name) {\n        case \"USub\":\n            return obj.nb$negative ? obj.nb$negative : obj[\"__neg__\"];\n        case \"UAdd\":\n            return obj.nb$positive ? obj.nb$positive : obj[\"__pos__\"];\n        case \"Invert\":\n            return obj.nb$invert ? obj.nb$invert : obj[\"__invert__\"];\n    }\n};\n\nSk.abstr.binary_op_ = function (v, w, opname) {\n    var wop;\n    var ret;\n    var vop;\n\n    // All Python inheritance is now enforced with Javascript inheritance\n    // (see Sk.abstr.setUpInheritance). This checks if w's type is a strict\n    // subclass of v's type\n    var w_is_subclass = w.constructor.prototype instanceof v.constructor;\n\n    // From the Python 2.7 docs:\n    //\n    // \"If the right operands type is a subclass of the left operands type and\n    // that subclass provides the reflected method for the operation, this\n    // method will be called before the left operands non-reflected method.\n    // This behavior allows subclasses to override their ancestors operations.\"\n    //\n    // -- https://docs.python.org/2/reference/datamodel.html#index-92\n\n    if (w_is_subclass) {\n        wop = Sk.abstr.boNameToSlotFuncRhs_(w, opname);\n        if (wop !== undefined) {\n            if (wop.call) {\n                ret = wop.call(w, v);\n            } else {\n                ret = Sk.misceval.callsimArray(wop, [w, v]);\n            }\n            if (ret !== undefined && ret !== Sk.builtin.NotImplemented.NotImplemented$) {\n                return ret;\n            }\n        }\n    }\n\n    vop = Sk.abstr.boNameToSlotFuncLhs_(v, opname);\n    if (vop !== undefined) {\n        if (vop.call) {\n            ret = vop.call(v, w);\n        } else {\n            ret = Sk.misceval.callsimArray(vop, [v, w]);\n        }\n        if (ret !== undefined && ret !== Sk.builtin.NotImplemented.NotImplemented$) {\n            return ret;\n        }\n    }\n    // Don't retry RHS if failed above\n    if (!w_is_subclass) {\n        wop = Sk.abstr.boNameToSlotFuncRhs_(w, opname);\n        if (wop !== undefined) {\n            if (wop.call) {\n                ret = wop.call(w, v);\n            } else {\n                ret = Sk.misceval.callsimArray(wop, [w, v]);\n            }\n            if (ret !== undefined && ret !== Sk.builtin.NotImplemented.NotImplemented$) {\n                return ret;\n            }\n        }\n    }\n    Sk.abstr.binop_type_error(v, w, opname);\n};\n\nSk.abstr.binary_iop_ = function (v, w, opname) {\n    var wop;\n    var ret;\n    var vop = Sk.abstr.iboNameToSlotFunc_(v, opname);\n    if (vop !== undefined) {\n        if (vop.call) {\n            ret = vop.call(v, w);\n        } else {  // assume that vop is an __xxx__ type method\n            ret = Sk.misceval.callsimArray(vop, [v, w]);\n        }\n        if (ret !== undefined && ret !== Sk.builtin.NotImplemented.NotImplemented$) {\n            return ret;\n        }\n    }\n    // If there wasn't an in-place operation, fall back to the binop\n    return Sk.abstr.binary_op_(v, w, opname);\n};\nSk.abstr.unary_op_ = function (v, opname) {\n    var ret;\n    var vop = Sk.abstr.uoNameToSlotFunc_(v, opname);\n    if (vop !== undefined) {\n        if (vop.call) {\n            ret = vop.call(v);\n        } else {  // assume that vop is an __xxx__ type method\n            ret = Sk.misceval.callsimArray(vop, [v]); //  added to be like not-in-place... is this okay?\n        }\n        if (ret !== undefined) {\n            return ret;\n        }\n    }\n    Sk.abstr.unop_type_error(v, opname);\n};\n\n//\n// handle upconverting a/b from number to long if op causes too big/small a\n// result, or if either of the ops are already longs\nSk.abstr.numOpAndPromote = function (a, b, opfn) {\n    var tmp;\n    var ans;\n    if (a === null || b === null) {\n        return undefined;\n    }\n\n    if (typeof a === \"number\" && typeof b === \"number\") {\n        ans = opfn(a, b);\n        // todo; handle float   Removed RNL (bugs in lng, and it should be a question of precision, not magnitude -- this was just wrong)\n        if ((ans > Sk.builtin.int_.threshold$ || ans < -Sk.builtin.int_.threshold$) && Math.floor(ans) === ans) {\n            return [Sk.builtin.lng.fromInt$(a), Sk.builtin.lng.fromInt$(b)];\n        } else {\n            return ans;\n        }\n    } else if (a === undefined || b === undefined) {\n        throw new Sk.builtin.NameError(\"Undefined variable in expression\");\n    }\n\n    if (a.constructor === Sk.builtin.lng) {\n        return [a, b];\n    } else if ((a.constructor === Sk.builtin.int_ ||\n                a.constructor === Sk.builtin.float_) &&\n                b.constructor === Sk.builtin.complex) {\n        // special case of upconverting nmber and complex\n        // can we use here the Sk.builtin.checkComplex() method?\n        tmp = new Sk.builtin.complex(a);\n        return [tmp, b];\n    } else if (a.constructor === Sk.builtin.int_ ||\n               a.constructor === Sk.builtin.float_) {\n        return [a, b];\n    } else if (typeof a === \"number\") {\n        tmp = Sk.builtin.assk$(a);\n        return [tmp, b];\n    } else {\n        return undefined;\n    }\n};\n\nSk.abstr.boNumPromote_ = {\n    \"Add\"     : function (a, b) {\n        return a + b;\n    },\n    \"Sub\"     : function (a, b) {\n        return a - b;\n    },\n    \"Mult\"    : function (a, b) {\n        return a * b;\n    },\n    \"Mod\"     : function (a, b) {\n        var m;\n        if (b === 0) {\n            throw new Sk.builtin.ZeroDivisionError(\"division or modulo by zero\");\n        }\n        m = a % b;\n        return ((m * b) < 0 ? (m + b) : m);\n    },\n    \"Div\"     : function (a, b) {\n        if (b === 0) {\n            throw new Sk.builtin.ZeroDivisionError(\"division or modulo by zero\");\n        } else {\n            return a / b;\n        }\n    },\n    \"FloorDiv\": function (a, b) {\n        if (b === 0) {\n            throw new Sk.builtin.ZeroDivisionError(\"division or modulo by zero\");\n        } else {\n            return Math.floor(a / b);\n        } // todo; wrong? neg?\n    },\n    \"Pow\"     : Math.pow,\n    \"BitAnd\"  : function (a, b) {\n        var m = a & b;\n        if (m < 0) {\n            m = m + 4294967296; // convert back to unsigned\n        }\n        return m;\n    },\n    \"BitOr\"   : function (a, b) {\n        var m = a | b;\n        if (m < 0) {\n            m = m + 4294967296; // convert back to unsigned\n        }\n        return m;\n    },\n    \"BitXor\"  : function (a, b) {\n        var m = a ^ b;\n        if (m < 0) {\n            m = m + 4294967296; // convert back to unsigned\n        }\n        return m;\n    },\n    \"LShift\"  : function (a, b) {\n        var m;\n        if (b < 0) {\n            throw new Sk.builtin.ValueError(\"negative shift count\");\n        }\n        m = a << b;\n        if (m > a) {\n            return m;\n        } else {\n            // Fail, this will get recomputed with longs\n            return a * Math.pow(2, b);\n        }\n    },\n    \"RShift\"  : function (a, b) {\n        var m;\n        if (b < 0) {\n            throw new Sk.builtin.ValueError(\"negative shift count\");\n        }\n        m = a >> b;\n        if ((a > 0) && (m < 0)) {\n            // fix incorrect sign extension\n            m = m & (Math.pow(2, 32 - b) - 1);\n        }\n        return m;\n    }\n};\n\nSk.abstr.numberBinOp = function (v, w, op) {\n    var tmp;\n    var numPromoteFunc = Sk.abstr.boNumPromote_[op];\n    if (numPromoteFunc !== undefined) {\n        tmp = Sk.abstr.numOpAndPromote(v, w, numPromoteFunc);\n        if (typeof tmp === \"number\") {\n            return tmp;\n        } else if (tmp !== undefined && tmp.constructor === Sk.builtin.int_) {\n            return tmp;\n        } else if (tmp !== undefined && tmp.constructor === Sk.builtin.float_) {\n            return tmp;\n        } else if (tmp !== undefined && tmp.constructor === Sk.builtin.lng) {\n            return tmp;\n        } else if (tmp !== undefined) {\n            v = tmp[0];\n            w = tmp[1];\n        }\n    }\n\n    return Sk.abstr.binary_op_(v, w, op);\n};\nSk.exportSymbol(\"Sk.abstr.numberBinOp\", Sk.abstr.numberBinOp);\n\nSk.abstr.numberInplaceBinOp = function (v, w, op) {\n    var tmp;\n    var numPromoteFunc = Sk.abstr.boNumPromote_[op];\n    if (numPromoteFunc !== undefined) {\n        tmp = Sk.abstr.numOpAndPromote(v, w, numPromoteFunc);\n        if (typeof tmp === \"number\") {\n            return tmp;\n        } else if (tmp !== undefined && tmp.constructor === Sk.builtin.int_) {\n            return tmp;\n        } else if (tmp !== undefined && tmp.constructor === Sk.builtin.float_) {\n            return tmp;\n        } else if (tmp !== undefined && tmp.constructor === Sk.builtin.lng) {\n            return tmp;\n        } else if (tmp !== undefined) {\n            v = tmp[0];\n            w = tmp[1];\n        }\n    }\n\n    return Sk.abstr.binary_iop_(v, w, op);\n};\nSk.exportSymbol(\"Sk.abstr.numberInplaceBinOp\", Sk.abstr.numberInplaceBinOp);\n\nSk.abstr.numberUnaryOp = function (v, op) {\n    var value;\n    if (op === \"Not\") {\n        return Sk.misceval.isTrue(v) ? Sk.builtin.bool.false$ : Sk.builtin.bool.true$;\n    } else if (v instanceof Sk.builtin.bool) {\n        value = Sk.builtin.asnum$(v);\n        if (op === \"USub\") {\n            return new Sk.builtin.int_(-value);\n        }\n        if (op === \"UAdd\") {\n            return new Sk.builtin.int_(value);\n        }\n        if (op === \"Invert\") {\n            return new Sk.builtin.int_(~value);\n        }\n    } else {\n        if (op === \"USub\" && v.nb$negative) {\n            return v.nb$negative();\n        }\n        if (op === \"UAdd\" && v.nb$positive) {\n            return v.nb$positive();\n        }\n        if (op === \"Invert\" && v.nb$invert) {\n            return v.nb$invert();\n        }\n    }\n\n    return Sk.abstr.unary_op_(v, op);\n};\nSk.exportSymbol(\"Sk.abstr.numberUnaryOp\", Sk.abstr.numberUnaryOp);\n\n//\n// Sequence\n//\n\nSk.abstr.fixSeqIndex_ = function (seq, i) {\n    i = Sk.builtin.asnum$(i);\n    if (i < 0 && seq.sq$length) {\n        i += seq.sq$length();\n    }\n    return i;\n};\n\n/**\n * @param {*} seq\n * @param {*} ob\n * @param {boolean=} canSuspend\n */\nSk.abstr.sequenceContains = function (seq, ob, canSuspend) {\n    var seqtypename;\n    var special;\n    var r;\n\n    if (seq.sq$contains) {\n        return seq.sq$contains(ob);\n    }\n\n    /**\n     *  Look for special method and call it, we have to distinguish between built-ins and\n     *  python objects\n     */\n    special = Sk.abstr.lookupSpecial(seq, Sk.builtin.str.$contains);\n    if (special != null) {\n        // method on builtin, provide this arg\n        return Sk.misceval.isTrue(Sk.misceval.callsimArray(special, [seq, ob]));\n    }\n\n    if (!Sk.builtin.checkIterable(seq)) {\n        seqtypename = Sk.abstr.typeName(seq);\n        throw new Sk.builtin.TypeError(\"argument of type '\" + seqtypename + \"' is not iterable\");\n    }\n\n    r = Sk.misceval.iterFor(Sk.abstr.iter(seq), function(i) {\n        if (Sk.misceval.richCompareBool(i, ob, \"Eq\")) {\n            return new Sk.misceval.Break(true);\n        } else {\n            return false;\n        }\n    }, false);\n\n    return canSuspend ? r : Sk.misceval.retryOptionalSuspensionOrThrow(r);\n};\n\nSk.abstr.sequenceConcat = function (seq1, seq2) {\n    var seq1typename;\n    if (seq1.sq$concat) {\n        return seq1.sq$concat(seq2);\n    }\n    seq1typename = Sk.abstr.typeName(seq1);\n    throw new Sk.builtin.TypeError(\"'\" + seq1typename + \"' object can't be concatenated\");\n};\n\nSk.abstr.sequenceGetIndexOf = function (seq, ob) {\n    var seqtypename;\n    var i, it;\n    var index;\n    if (seq.index) {\n        return Sk.misceval.callsimArray(seq.index, [seq, ob]);\n    }\n    if (Sk.builtin.checkIterable(seq)) {\n        index = 0;\n        for (it = Sk.abstr.iter(seq), i = it.tp$iternext();\n            i !== undefined; i = it.tp$iternext()) {\n            if (Sk.misceval.richCompareBool(ob, i, \"Eq\")) {\n                return new Sk.builtin.int_(index);\n            }\n            index += 1;\n        }\n        throw new Sk.builtin.ValueError(\"sequence.index(x): x not in sequence\");\n    }\n\n    seqtypename = Sk.abstr.typeName(seq);\n    throw new Sk.builtin.TypeError(\"argument of type '\" + seqtypename + \"' is not iterable\");\n};\n\nSk.abstr.sequenceGetCountOf = function (seq, ob) {\n    var seqtypename;\n    var i, it;\n    var count;\n    if (seq.count) {\n        return Sk.misceval.callsimArray(seq.count, [seq, ob]);\n    }\n    if (Sk.builtin.checkIterable(seq)) {\n        count = 0;\n        for (it = Sk.abstr.iter(seq), i = it.tp$iternext();\n            i !== undefined; i = it.tp$iternext()) {\n            if (Sk.misceval.richCompareBool(ob, i, \"Eq\")) {\n                count += 1;\n            }\n        }\n        return new Sk.builtin.int_(count);\n    }\n\n    seqtypename = Sk.abstr.typeName(seq);\n    throw new Sk.builtin.TypeError(\"argument of type '\" + seqtypename + \"' is not iterable\");\n};\n\nSk.abstr.sequenceGetItem = function (seq, i, canSuspend) {\n    var seqtypename;\n    if (seq.mp$subscript) {\n        return seq.mp$subscript(i);\n    }\n\n    seqtypename = Sk.abstr.typeName(seq);\n    throw new Sk.builtin.TypeError(\"'\" + seqtypename + \"' object is unsubscriptable\");\n};\n\nSk.abstr.sequenceSetItem = function (seq, i, x, canSuspend) {\n    var seqtypename;\n    if (seq.mp$ass_subscript) {\n        return seq.mp$ass_subscript(i, x);\n    }\n\n    seqtypename = Sk.abstr.typeName(seq);\n    throw new Sk.builtin.TypeError(\"'\" + seqtypename + \"' object does not support item assignment\");\n};\n\nSk.abstr.sequenceDelItem = function (seq, i) {\n    var seqtypename;\n    if (seq.sq$del_item) {\n        i = Sk.abstr.fixSeqIndex_(seq, i);\n        seq.sq$del_item(i);\n        return;\n    }\n\n    seqtypename = Sk.abstr.typeName(seq);\n    throw new Sk.builtin.TypeError(\"'\" + seqtypename + \"' object does not support item deletion\");\n};\n\nSk.abstr.sequenceRepeat = function (f, seq, n) {\n    var ntypename;\n    var count;\n    n = Sk.builtin.asnum$(n);\n    count = Sk.misceval.asIndex(n);\n    if (count === undefined) {\n        ntypename = Sk.abstr.typeName(n);\n        throw new Sk.builtin.TypeError(\"can't multiply sequence by non-int of type '\" + ntypename + \"'\");\n    }\n    return f.call(seq, n);\n};\n\nSk.abstr.sequenceGetSlice = function (seq, i1, i2) {\n    var seqtypename;\n    if (seq.sq$slice) {\n        i1 = Sk.abstr.fixSeqIndex_(seq, i1);\n        i2 = Sk.abstr.fixSeqIndex_(seq, i2);\n        return seq.sq$slice(i1, i2);\n    } else if (seq.mp$subscript) {\n        return seq.mp$subscript(new Sk.builtin.slice(i1, i2));\n    }\n\n    seqtypename = Sk.abstr.typeName(seq);\n    throw new Sk.builtin.TypeError(\"'\" + seqtypename + \"' object is unsliceable\");\n};\n\nSk.abstr.sequenceDelSlice = function (seq, i1, i2) {\n    var seqtypename;\n    if (seq.sq$del_slice) {\n        i1 = Sk.abstr.fixSeqIndex_(seq, i1);\n        i2 = Sk.abstr.fixSeqIndex_(seq, i2);\n        seq.sq$del_slice(i1, i2);\n        return;\n    }\n\n    seqtypename = Sk.abstr.typeName(seq);\n    throw new Sk.builtin.TypeError(\"'\" + seqtypename + \"' doesn't support slice deletion\");\n};\n\nSk.abstr.sequenceSetSlice = function (seq, i1, i2, x) {\n    var seqtypename;\n    if (seq.sq$ass_slice) {\n        i1 = Sk.abstr.fixSeqIndex_(seq, i1);\n        i2 = Sk.abstr.fixSeqIndex_(seq, i2);\n        seq.sq$ass_slice(i1, i2, x);\n    } else if (seq.mp$ass_subscript) {\n        seq.mp$ass_subscript(new Sk.builtin.slice(i1, i2), x);\n    } else {\n        seqtypename = Sk.abstr.typeName(seq);\n        throw new Sk.builtin.TypeError(\"'\" + seqtypename + \"' object doesn't support slice assignment\");\n    }\n};\n\n// seq - Python object to unpack\n// n   - JavaScript number of items to unpack\nSk.abstr.sequenceUnpack = function (seq, n) {\n    var res = [];\n    var it, i;\n\n    if (!Sk.builtin.checkIterable(seq)) {\n        throw new Sk.builtin.TypeError(\"'\" + Sk.abstr.typeName(seq) + \"' object is not iterable\");\n    }\n\n    for (it = Sk.abstr.iter(seq), i = it.tp$iternext();\n        (i !== undefined) && (res.length < n);\n        i = it.tp$iternext()) {\n        res.push(i);\n    }\n\n    if (res.length < n) {\n        throw new Sk.builtin.ValueError(\"need more than \" + res.length + \" values to unpack\");\n    }\n    if (i !== undefined) {\n        throw new Sk.builtin.ValueError(\"too many values to unpack\");\n    }\n\n    // Return Javascript array of items\n    return res;\n};\n\n// Unpack mapping into a JS array of alternating keys/values, possibly suspending\n// Skulpt uses a slightly grungy format for keyword args\n// into misceval.apply() and friends (alternating JS strings and Python values).\n// We should probably migrate that interface to using Python strings\n// at some point, but in the meantime we have this function to\n// unpack keyword dictionaries into our special format\nSk.abstr.mappingUnpackIntoKeywordArray = function(jsArray, pyMapping, pyCodeObject) {\n    return Sk.misceval.chain(pyMapping.tp$getattr(new Sk.builtin.str(\"items\")), function(itemfn) {\n        if (!itemfn) { throw new Sk.builtin.TypeError(\"Object is not a mapping\"); }\n        return Sk.misceval.callsimOrSuspend(itemfn);\n    }, function(items) {\n        return Sk.misceval.iterFor(Sk.abstr.iter(items), function(item) {\n            if (!item || !item.v) { throw new Sk.builtin.TypeError(\"Object is not a mapping; items() does not return tuples\"); }\n            if (!(item.v[0] instanceof Sk.builtin.str)) {\n                throw new Sk.builtin.TypeError((pyCodeObject.tp$name ? pyCodeObject.tp$name +\":\" : \"\") + \"keywords must be strings\");\n            }\n            jsArray.push(item.v[0].v, item.v[1]);\n        });\n    });\n};\n\n//\n// Object\n//\n\nSk.abstr.objectFormat = function (obj, format_spec) {\n    var meth; // PyObject\n    var result; // PyObject\n\n    // Find the (unbound!) __format__ method (a borrowed reference)\n    meth = Sk.abstr.lookupSpecial(obj, Sk.builtin.str.$format);\n    if (meth == null) {\n        throw new Sk.builtin.TypeError(\"Type \" + Sk.abstr.typeName(obj) + \" doesn't define __format__\");\n    }\n\n    // And call it\n    result = Sk.misceval.callsimArray(meth, [obj, format_spec]);\n    if (!Sk.builtin.checkString(result)) {\n        throw new Sk.builtin.TypeError(\"__format__ must return a str, not \" + Sk.abstr.typeName(result));\n    }\n\n    return result;\n};\n\nSk.abstr.objectAdd = function (a, b) {\n    var btypename;\n    var atypename;\n    if (a.nb$add) {\n        return a.nb$add(b);\n    }\n\n    atypename = Sk.abstr.typeName(a);\n    btypename = Sk.abstr.typeName(b);\n    throw new Sk.builtin.TypeError(\"unsupported operand type(s) for +: '\" + atypename + \"' and '\" + btypename + \"'\");\n};\n\n// in Python 2.6, this behaviour seems to be defined for numbers and bools (converts bool to int)\nSk.abstr.objectNegative = function (obj) {\n    var objtypename;\n    var obj_asnum = Sk.builtin.asnum$(obj); // this will also convert bool type to int\n\n    if (obj instanceof Sk.builtin.bool) {\n        obj = new Sk.builtin.int_(obj_asnum);\n    }\n\n    if (obj.nb$negative) {\n        return obj.nb$negative();\n    }\n\n    objtypename = Sk.abstr.typeName(obj);\n    throw new Sk.builtin.TypeError(\"bad operand type for unary -: '\" + objtypename + \"'\");\n};\n\n// in Python 2.6, this behaviour seems to be defined for numbers and bools (converts bool to int)\nSk.abstr.objectPositive = function (obj) {\n    var objtypename = Sk.abstr.typeName(obj);\n    var obj_asnum = Sk.builtin.asnum$(obj); // this will also convert bool type to int\n\n    if (obj instanceof Sk.builtin.bool) {\n        obj = new Sk.builtin.int_(obj_asnum);\n    }\n\n    if (obj.nb$negative) {\n        return obj.nb$positive();\n    }\n\n    throw new Sk.builtin.TypeError(\"bad operand type for unary +: '\" + objtypename + \"'\");\n};\n\nSk.abstr.objectDelItem = function (o, key) {\n    var otypename;\n    var keytypename;\n    var keyValue;\n    if (o !== null) {\n        if (o.mp$del_subscript) {\n            o.mp$del_subscript(key);\n            return;\n        }\n        if (o.sq$ass_item) {\n            keyValue = Sk.misceval.asIndex(key);\n            if (keyValue === undefined) {\n                keytypename = Sk.abstr.typeName(key);\n                throw new Sk.builtin.TypeError(\"sequence index must be integer, not '\" + keytypename + \"'\");\n            }\n            Sk.abstr.sequenceDelItem(o, keyValue);\n            return;\n        }\n        // if o is a slice do something else...\n    }\n\n    otypename = Sk.abstr.typeName(o);\n    throw new Sk.builtin.TypeError(\"'\" + otypename + \"' object does not support item deletion\");\n};\nSk.exportSymbol(\"Sk.abstr.objectDelItem\", Sk.abstr.objectDelItem);\n\nSk.abstr.objectGetItem = function (o, key, canSuspend) {\n    var otypename;\n    if (o !== null) {\n        if (o.tp$getitem) {\n            return o.tp$getitem(key, canSuspend);\n        } else if (o.mp$subscript) {\n            return o.mp$subscript(key, canSuspend);\n        } else if (Sk.misceval.isIndex(key) && o.sq$item) {\n            return Sk.abstr.sequenceGetItem(o, Sk.misceval.asIndex(key), canSuspend);\n        }\n    }\n\n    otypename = Sk.abstr.typeName(o);\n    throw new Sk.builtin.TypeError(\"'\" + otypename + \"' does not support indexing\");\n};\nSk.exportSymbol(\"Sk.abstr.objectGetItem\", Sk.abstr.objectGetItem);\n\nSk.abstr.objectSetItem = function (o, key, v, canSuspend) {\n    var otypename;\n    if (o !== null) {\n        if (o.tp$setitem) {\n            return o.tp$setitem(key, v, canSuspend);\n        } else if (o.mp$ass_subscript) {\n            return o.mp$ass_subscript(key, v, canSuspend);\n        } else if (Sk.misceval.isIndex(key) && o.sq$ass_item) {\n            return Sk.abstr.sequenceSetItem(o, Sk.misceval.asIndex(key), v, canSuspend);\n        }\n    }\n\n    otypename = Sk.abstr.typeName(o);\n    throw new Sk.builtin.TypeError(\"'\" + otypename + \"' does not support item assignment\");\n};\nSk.exportSymbol(\"Sk.abstr.objectSetItem\", Sk.abstr.objectSetItem);\n\n\nSk.abstr.gattr = function (obj, pyName, canSuspend) {\n    var ret, f;\n    var objname = Sk.abstr.typeName(obj);\n    var jsName = pyName.$jsstr();\n\n    if (obj === null) {\n        throw new Sk.builtin.AttributeError(\"'\" + objname + \"' object has no attribute '\" + jsName + \"'\");\n    }\n\n    if (obj.tp$getattr !== undefined) {\n        ret = obj.tp$getattr(pyName, canSuspend);\n    }\n\n    ret = Sk.misceval.chain(ret, function(r) {\n        if (r === undefined) {\n            throw new Sk.builtin.AttributeError(\"'\" + objname + \"' object has no attribute '\" + jsName + \"'\");\n        }\n        return r;\n    });\n\n    return canSuspend ? ret : Sk.misceval.retryOptionalSuspensionOrThrow(ret);\n};\nSk.exportSymbol(\"Sk.abstr.gattr\", Sk.abstr.gattr);\n\n\nSk.abstr.sattr = function (obj, pyName, data, canSuspend) {\n    var objname = Sk.abstr.typeName(obj), r, setf;\n    var jsName = pyName.$jsstr();\n\n    if (obj === null) {\n        throw new Sk.builtin.AttributeError(\"'\" + objname + \"' object has no attribute '\" + jsName + \"'\");\n    }\n\n    if (obj.tp$setattr !== undefined) {\n        return obj.tp$setattr(pyName, data, canSuspend);\n    } else {\n        throw new Sk.builtin.AttributeError(\"'\" + objname + \"' object has no attribute '\" + jsName + \"'\");\n    }\n};\nSk.exportSymbol(\"Sk.abstr.sattr\", Sk.abstr.sattr);\n\n\nSk.abstr.iternext = function (it, canSuspend) {\n    return it.tp$iternext(canSuspend);\n};\nSk.exportSymbol(\"Sk.abstr.iternext\", Sk.abstr.iternext);\n\n\n/**\n * Get the iterator for a Python object  This iterator could be one of the following.\n * This is the preferred mechanism for consistently getting the correct iterator.  You should\n * not just use tp$iter because that could lead to incorrect behavior of a user created class.\n *\n * - tp$iter\n * - A user defined `__iter__` method\n * - A user defined `__getitem__` method\n *\n * @param obj\n *\n * @throws {Sk.builtin.TypeError}\n * @returns {Object}\n */\n\nSk.abstr.iter = function(obj) {\n    var iter;\n    var getit;\n    var ret;\n\n    /**\n     * Builds an iterator around classes that have a __getitem__ method.\n     *\n     * @constructor\n     */\n    var seqIter = function (obj) {\n        this.idx = 0;\n        this.myobj = obj;\n        this.getitem = Sk.abstr.lookupSpecial(obj, Sk.builtin.str.$getitem);\n        this.tp$iternext = function () {\n            var ret;\n            try {\n                ret = Sk.misceval.callsimArray(this.getitem, [this.myobj, Sk.ffi.remapToPy(this.idx)]);\n            } catch (e) {\n                if (e instanceof Sk.builtin.IndexError || e instanceof Sk.builtin.StopIteration) {\n                    return undefined;\n                } else {\n                    throw e;\n                }\n            }\n            this.idx++;\n            return ret;\n        };\n    };\n\n    if (obj.tp$getattr) {\n        iter =  Sk.abstr.lookupSpecial(obj, Sk.builtin.str.$iter);\n        if (iter) {\n            ret = Sk.misceval.callsimArray(iter, [obj]);\n            if (ret.tp$iternext) {\n                return ret;\n            }\n        }\n    }\n    if (obj.tp$iter) {\n        try {  // catch and ignore not iterable error here.\n            ret = obj.tp$iter();\n            if (ret.tp$iternext) {\n                return ret;\n            }\n        } catch (e) { }\n    }\n    getit = Sk.abstr.lookupSpecial(obj, Sk.builtin.str.$getitem);\n    if (getit) {\n        // create internal iterobject if __getitem__\n        return new seqIter(obj);\n    }\n    throw new Sk.builtin.TypeError(\"'\" + Sk.abstr.typeName(obj) + \"' object is not iterable\");\n};\nSk.exportSymbol(\"Sk.abstr.iter\", Sk.abstr.iter);\n\n/**\n * Special method look up. First try getting the method via\n * internal dict and getattr. If getattr is not present (builtins)\n * try if method is defined on the object itself\n *\n * @returns {null|Object} Return null if not found or the function\n */\nSk.abstr.lookupSpecial = function(op, pyName) {\n    var res;\n    var obtp;\n    if (op.ob$type) {\n        obtp = op.ob$type;\n    } else {\n        return null;\n    }\n\n    return Sk.builtin.type.typeLookup(obtp, pyName);\n};\nSk.exportSymbol(\"Sk.abstr.lookupSpecial\", Sk.abstr.lookupSpecial);\n\n/**\n * Mark a class as unhashable and prevent its `__hash__` function from being called.\n * @param  {*} thisClass The class to mark as unhashable.\n * @return {undefined}\n */\nSk.abstr.markUnhashable = function (thisClass) {\n    var proto = thisClass.prototype;\n    proto.__hash__ = Sk.builtin.none.none$;\n    proto.tp$hash = Sk.builtin.none.none$;\n};\n\n/**\n * Code taken from goog.inherits\n *\n * Newer versions of the closure library add a \"base\"attribute,\n * which we don't want/need.  So, this code is the remainder of\n * the goog.inherits function.\n */\nSk.abstr.inherits = function (childCtor, parentCtor) {\n    /** @constructor */\n    function tempCtor() {}\n    tempCtor.prototype = parentCtor.prototype;\n    childCtor.superClass_ = parentCtor.prototype;\n    childCtor.prototype = new tempCtor();\n    /** @override */\n    childCtor.prototype.constructor = childCtor;\n};\n\n/**\n * Set up inheritance between two Python classes. This allows only for single\n * inheritance -- multiple inheritance is not supported by Javascript.\n *\n * Javascript's inheritance is prototypal. This means that properties must\n * be defined on the superclass' prototype in order for subclasses to inherit\n * them.\n *\n * ```\n * Sk.superclass.myProperty                 # will NOT be inherited\n * Sk.superclass.prototype.myProperty       # will be inherited\n * ```\n *\n * In order for a class to be subclassable, it must (directly or indirectly)\n * inherit from Sk.builtin.object so that it will be properly initialized in\n * {@link Sk.doOneTimeInitialization} (in src/import.js). Further, all Python\n * builtins should inherit from Sk.builtin.object.\n *\n * @param {string} childName The Python name of the child (subclass).\n * @param {*} child     The subclass.\n * @param {*} parent    The superclass.\n * @return {undefined}\n */\nSk.abstr.setUpInheritance = function (childName, child, parent) {\n    Sk.abstr.inherits(child, parent);\n    child.prototype.tp$base = parent;\n    child.prototype.tp$name = childName;\n    child.prototype.ob$type = Sk.builtin.type.makeIntoTypeObj(childName, child);\n};\n\n/**\n * Call the super constructor of the provided class, with the object `self` as\n * the `this` value of that constructor. Any arguments passed to this function\n * after `self` will be passed as-is to the constructor.\n *\n * @param  {*} thisClass The subclass.\n * @param  {Object} self      The instance of the subclas.\n * @param  {...?} args Arguments to pass to the constructor.\n * @return {undefined}\n */\nSk.abstr.superConstructor = function (thisClass, self, args) {\n    var argumentsForConstructor = Array.prototype.slice.call(arguments, 2);\n    thisClass.prototype.tp$base.apply(self, argumentsForConstructor);\n};\n","/**\n * @constructor\n * Sk.builtin.object\n *\n * @description\n * Constructor for Python object. All Python classes (builtin and user-defined)\n * should inherit from this class.\n *\n * @return {Sk.builtin.object} Python object\n */\nSk.builtin.object = function () {\n    if (!(this instanceof Sk.builtin.object)) {\n        return new Sk.builtin.object();\n    }\n\n    return this;\n};\n\nSk.builtin.object.prototype.__init__ = function __init__() {\n    return Sk.builtin.none.none$;\n};\nSk.builtin.object.prototype.__init__.co_kwargs = 1;\n\nSk.builtin._tryGetSubscript = function(dict, pyName) {\n    try {\n        return dict.mp$subscript(pyName);\n    } catch (x) {\n        return undefined;\n    }\n};\nSk.exportSymbol(\"Sk.builtin._tryGetSubscript\", Sk.builtin._tryGetSubscript);\n\n\n/**\n * Get an attribute\n * @param {Object} pyName Python string name of the attribute\n * @param {boolean=} canSuspend Can we return a suspension?\n * @return {undefined}\n */\nSk.builtin.object.prototype.GenericGetAttr = function (pyName, canSuspend) {\n    var res;\n    var f;\n    var descr;\n    var tp;\n    var dict;\n    var getf;\n    var jsName = pyName.$jsstr();\n\n    tp = this.ob$type;\n    Sk.asserts.assert(tp !== undefined, \"object has no ob$type!\");\n\n    dict = this[\"$d\"] || this.constructor[\"$d\"];\n    //print(\"getattr\", tp.tp$name, name);\n\n    // todo; assert? force?\n    if (dict) {\n        if (dict.mp$lookup) {\n            res = dict.mp$lookup(pyName);\n        } else if (dict.mp$subscript) {\n            res = Sk.builtin._tryGetSubscript(dict, pyName);\n        } else if (typeof dict === \"object\") {\n            res = dict[jsName];\n        }\n        if (res !== undefined) {\n            return res;\n        }\n    }\n\n    descr = Sk.builtin.type.typeLookup(tp, pyName);\n\n    // otherwise, look in the type for a descr\n    if (descr !== undefined && descr !== null) {\n        f = descr.tp$descr_get;\n        // todo - data descriptors (ie those with tp$descr_set too) get a different lookup priority\n\n        if (f) {\n            // non-data descriptor\n            return f.call(descr, this, this.ob$type, canSuspend);\n        }\n    }\n\n    if (descr !== undefined) {\n        return descr;\n    }\n\n    // OK, try __getattr__\n\n    descr = Sk.builtin.type.typeLookup(tp, Sk.builtin.str.$getattr);\n    if (descr !== undefined && descr !== null) {\n        f = descr.tp$descr_get;\n        if (f) {\n            getf = f.call(descr, this, this.ob$type);\n        } else {\n            getf = descr;\n        }\n\n        res = Sk.misceval.tryCatch(function() {\n            return Sk.misceval.callsimOrSuspendArray(getf, [pyName]);\n        }, function(e) {\n            if (e instanceof Sk.builtin.AttributeError) {\n                return undefined;\n            } else {\n                throw e;\n            }\n        });\n        return canSuspend ? res : Sk.misceval.retryOptionalSuspensionOrThrow(res);\n    }\n\n\n    return undefined;\n};\nSk.exportSymbol(\"Sk.builtin.object.prototype.GenericGetAttr\", Sk.builtin.object.prototype.GenericGetAttr);\n\nSk.builtin.object.prototype.GenericPythonGetAttr = function(self, pyName) {\n    var r = Sk.builtin.object.prototype.GenericGetAttr.call(self, pyName, true);\n    if (r === undefined) {\n        throw new Sk.builtin.AttributeError(pyName);\n    }\n    return r;\n};\nSk.exportSymbol(\"Sk.builtin.object.prototype.GenericPythonGetAttr\", Sk.builtin.object.prototype.GenericPythonGetAttr);\n\n/**\n * @param {Object} pyName\n * @param {Object} value\n * @param {boolean=} canSuspend\n * @return {undefined}\n */\nSk.builtin.object.prototype.GenericSetAttr = function (pyName, value, canSuspend) {\n    var objname = Sk.abstr.typeName(this);\n    var jsName = pyName.$jsstr();\n    var dict;\n    var tp = this.ob$type;\n    var descr;\n    var f;\n\n    Sk.asserts.assert(tp !== undefined, \"object has no ob$type!\");\n\n    dict = this[\"$d\"] || this.constructor[\"$d\"];\n\n    if (jsName == \"__class__\") {\n        if (value.tp$mro === undefined || value.tp$name === undefined) {\n            throw new Sk.builtin.TypeError(\n                \"attempted to assign non-class to __class__\");\n        }\n        this.ob$type = value;\n        this.tp$name = value.tp$name;\n        return;\n    }\n\n    descr = Sk.builtin.type.typeLookup(tp, pyName);\n\n    // otherwise, look in the type for a descr\n    if (descr !== undefined && descr !== null) {\n        f = descr.tp$descr_set;\n        // todo; is this the right lookup priority for data descriptors?\n        if (f) {\n            return f.call(descr, this, value, canSuspend);\n        }\n    }\n\n    if (dict.mp$ass_subscript) {\n        if (this instanceof Sk.builtin.object && !(this.ob$type.sk$klass) &&\n            dict.mp$lookup(pyName) === undefined) {\n            // Cannot add new attributes to a builtin object\n            throw new Sk.builtin.AttributeError(\"'\" + objname + \"' object has no attribute '\" + Sk.unfixReserved(jsName) + \"'\");\n        }\n        dict.mp$ass_subscript(pyName, value);\n    } else if (typeof dict === \"object\") {\n        dict[jsName] = value;\n    }\n};\nSk.exportSymbol(\"Sk.builtin.object.prototype.GenericSetAttr\", Sk.builtin.object.prototype.GenericSetAttr);\n\nSk.builtin.object.prototype.GenericPythonSetAttr = function(self, pyName, value) {\n    return Sk.builtin.object.prototype.GenericSetAttr.call(self, pyName, value, true);\n};\nSk.exportSymbol(\"Sk.builtin.object.prototype.GenericPythonSetAttr\", Sk.builtin.object.prototype.GenericPythonSetAttr);\n\nSk.builtin.object.prototype.HashNotImplemented = function () {\n    throw new Sk.builtin.TypeError(\"unhashable type: '\" + Sk.abstr.typeName(this) + \"'\");\n};\n\nSk.builtin.object.prototype.tp$getattr = Sk.builtin.object.prototype.GenericGetAttr;\nSk.builtin.object.prototype.tp$setattr = Sk.builtin.object.prototype.GenericSetAttr;\n\n// Although actual attribute-getting happens in pure Javascript via tp$getattr, classes\n// overriding __getattribute__ etc need to be able to call object.__getattribute__ etc from Python\nSk.builtin.object.prototype[\"__getattribute__\"] = Sk.builtin.object.prototype.GenericPythonGetAttr;\nSk.builtin.object.prototype[\"__setattr__\"] = Sk.builtin.object.prototype.GenericPythonSetAttr;\n\n/**\n * The name of this class.\n * @type {string}\n */\nSk.builtin.object.prototype.tp$name = \"object\";\n\n/**\n * The type object of this class.\n * @type {Sk.builtin.type|Object}\n */\nSk.builtin.object.prototype.ob$type = Sk.builtin.type.makeIntoTypeObj(\"object\", Sk.builtin.object);\nSk.builtin.object.prototype.ob$type.sk$klass = undefined;   // Nonsense for closure compiler\nSk.builtin.object.prototype.tp$descr_set = undefined;   // Nonsense for closure compiler\n\n/** Default implementations of dunder methods found in all Python objects */\n/**\n * Default implementation of __new__ just calls the class constructor\n * @name  __new__\n * @memberOf Sk.builtin.object.prototype\n * @instance\n */\nSk.builtin.object.prototype[\"__new__\"] = function (cls) {\n    Sk.builtin.pyCheckArgsLen(\"__new__\", arguments.length, 1, 1, false, false);\n\n    return new cls([], []);\n};\n\n/**\n * Python wrapper for `__repr__` method.\n * @name  __repr__\n * @memberOf Sk.builtin.object.prototype\n * @instance\n */\nSk.builtin.object.prototype[\"__repr__\"] = function (self) {\n    Sk.builtin.pyCheckArgsLen(\"__repr__\", arguments.length, 0, 0, false, true);\n\n    return self[\"$r\"]();\n};\n\n\nSk.builtin.object.prototype[\"__format__\"] = function (self, format_spec) {\n    var formatstr;\n    Sk.builtin.pyCheckArgsLen(\"__format__\", arguments.length, 2, 2);\n\n    if (!Sk.builtin.checkString(format_spec)) {\n        if (Sk.__future__.exceptions) {\n            throw new Sk.builtin.TypeError(\"format() argument 2 must be str, not \" + Sk.abstr.typeName(format_spec));\n        } else {\n            throw new Sk.builtin.TypeError(\"format expects arg 2 to be string or unicode, not \" + Sk.abstr.typeName(format_spec));\n        }\n    } else {\n        formatstr = Sk.ffi.remapToJs(format_spec);\n        if (formatstr !== \"\") {\n            throw new Sk.builtin.NotImplementedError(\"format spec is not yet implemented\");\n        }\n    }\n\n    return new Sk.builtin.str(self);\n};\n\n\n/**\n * Python wrapper for `__str__` method.\n * @name  __str__\n * @memberOf Sk.builtin.object.prototype\n * @instance\n */\nSk.builtin.object.prototype[\"__str__\"] = function (self) {\n    Sk.builtin.pyCheckArgsLen(\"__str__\", arguments.length, 0, 0, false, true);\n\n    return self[\"$r\"]();\n};\n\n/**\n * Python wrapper for `__hash__` method.\n * @name  __hash__\n * @memberOf Sk.builtin.object.prototype\n * @instance\n */\nSk.builtin.object.prototype[\"__hash__\"] = function (self) {\n    Sk.builtin.pyCheckArgsLen(\"__hash__\", arguments.length, 0, 0, false, true);\n\n    return self.tp$hash();\n};\n\n/**\n * Python wrapper for `__eq__` method.\n * @name  __eq__\n * @memberOf Sk.builtin.object.prototype\n * @instance\n */\nSk.builtin.object.prototype[\"__eq__\"] = function (self, other) {\n    Sk.builtin.pyCheckArgsLen(\"__eq__\", arguments.length, 1, 1, false, true);\n\n    return self.ob$eq(other);\n};\n\n/**\n * Python wrapper for `__ne__` method.\n * @name  __ne__\n * @memberOf Sk.builtin.object.prototype\n * @instance\n */\nSk.builtin.object.prototype[\"__ne__\"] = function (self, other) {\n    Sk.builtin.pyCheckArgsLen(\"__ne__\", arguments.length, 1, 1, false, true);\n\n    return self.ob$ne(other);\n};\n\n/**\n * Python wrapper for `__lt__` method.\n * @name  __lt__\n * @memberOf Sk.builtin.object.prototype\n * @instance\n */\nSk.builtin.object.prototype[\"__lt__\"] = function (self, other) {\n    Sk.builtin.pyCheckArgsLen(\"__lt__\", arguments.length, 1, 1, false, true);\n\n    return self.ob$lt(other);\n};\n\n/**\n * Python wrapper for `__le__` method.\n * @name  __le__\n * @memberOf Sk.builtin.object.prototype\n * @instance\n */\nSk.builtin.object.prototype[\"__le__\"] = function (self, other) {\n    Sk.builtin.pyCheckArgsLen(\"__le__\", arguments.length, 1, 1, false, true);\n\n    return self.ob$le(other);\n};\n\n/**\n * Python wrapper for `__gt__` method.\n * @name  __gt__\n * @memberOf Sk.builtin.object.prototype\n * @instance\n */\nSk.builtin.object.prototype[\"__gt__\"] = function (self, other) {\n    Sk.builtin.pyCheckArgsLen(\"__gt__\", arguments.length, 1, 1, false, true);\n\n    return self.ob$gt(other);\n};\n\n/**\n * Python wrapper for `__ge__` method.\n * @name  __ge__\n * @memberOf Sk.builtin.object.prototype\n * @instance\n */\nSk.builtin.object.prototype[\"__ge__\"] = function (self, other) {\n    Sk.builtin.pyCheckArgsLen(\"__ge__\", arguments.length, 1, 1, false, true);\n\n    return self.ob$ge(other);\n};\n\n/** Default implementations of Javascript functions used in dunder methods */\n\n/**\n * Return the string representation of this instance.\n *\n * Javascript function, returns Python object.\n *\n * @name  $r\n * @memberOf Sk.builtin.object.prototype\n * @return {Sk.builtin.str} The Python string representation of this instance.\n */\nSk.builtin.object.prototype[\"$r\"] = function () {\n    return new Sk.builtin.str(\"<object>\");\n};\n\nSk.builtin.hashCount = 1;\nSk.builtin.idCount = 1;\n\n/**\n * Return the hash value of this instance.\n *\n * Javascript function, returns Python object.\n *\n * @return {Sk.builtin.int_} The hash value\n */\nSk.builtin.object.prototype.tp$hash = function () {\n    if (!this.$savedHash_) {\n        this.$savedHash_ = new Sk.builtin.int_(Sk.builtin.hashCount++);\n    }\n\n    return this.$savedHash_;\n};\n\n/**\n * Perform equality check between this instance and a Python object (i.e. this == other).\n *\n * Implements `__eq__` dunder method.\n *\n * Javascript function, returns Python object.\n *\n * @param  {Object} other The Python object to check for equality.\n * @return {(Sk.builtin.bool|Sk.builtin.NotImplemented)} true if equal, false otherwise\n */\nSk.builtin.object.prototype.ob$eq = function (other) {\n    if (this === other) {\n        return Sk.builtin.bool.true$;\n    }\n\n    return Sk.builtin.NotImplemented.NotImplemented$;\n};\n\n/**\n * Perform non-equality check between this instance and a Python object (i.e. this != other).\n *\n * Implements `__ne__` dunder method.\n *\n * Javascript function, returns Python object.\n *\n * @param  {Object} other The Python object to check for non-equality.\n * @return {(Sk.builtin.bool|Sk.builtin.NotImplemented)} true if not equal, false otherwise\n */\nSk.builtin.object.prototype.ob$ne = function (other) {\n    if (this === other) {\n        return Sk.builtin.bool.false$;\n    }\n\n    return Sk.builtin.NotImplemented.NotImplemented$;\n};\n\n/**\n * Determine if this instance is less than a Python object (i.e. this < other).\n *\n * Implements `__lt__` dunder method.\n *\n * Javascript function, returns Python object.\n *\n * @param  {Object} other The Python object to compare.\n * @return {(Sk.builtin.bool|Sk.builtin.NotImplemented)} true if this < other, false otherwise\n */\nSk.builtin.object.prototype.ob$lt = function (other) {\n    return Sk.builtin.NotImplemented.NotImplemented$;\n};\n\n/**\n * Determine if this instance is less than or equal to a Python object (i.e. this <= other).\n *\n * Implements `__le__` dunder method.\n *\n * Javascript function, returns Python object.\n *\n * @param  {Object} other The Python object to compare.\n * @return {(Sk.builtin.bool|Sk.builtin.NotImplemented)} true if this <= other, false otherwise\n */\nSk.builtin.object.prototype.ob$le = function (other) {\n    return Sk.builtin.NotImplemented.NotImplemented$;\n};\n\n/**\n * Determine if this instance is greater than a Python object (i.e. this > other).\n *\n * Implements `__gt__` dunder method.\n *\n * Javascript function, returns Python object.\n *\n * @param  {Object} other The Python object to compare.\n * @return {(Sk.builtin.bool|Sk.builtin.NotImplemented)} true if this > other, false otherwise\n */\nSk.builtin.object.prototype.ob$gt = function (other) {\n    return Sk.builtin.NotImplemented.NotImplemented$;\n};\n\n/**\n * Determine if this instance is greater than or equal to a Python object (i.e. this >= other).\n *\n * Implements `__ge__` dunder method.\n *\n * Javascript function, returns Python object.\n *\n * @param  {Object} other The Python object to compare.\n * @return {(Sk.builtin.bool|Sk.builtin.NotImplemented)} true if this >= other, false otherwise\n */\nSk.builtin.object.prototype.ob$ge = function (other) {\n    return Sk.builtin.NotImplemented.NotImplemented$;\n};\n\n// Wrap the following functions in Sk.builtin.func once that class is initialized\n/**\n * Array of all the Python functions which are methods of this class.\n * @type {Array}\n */\nSk.builtin.object.pythonFunctions = [\n    \"__repr__\", \"__str__\", \"__hash__\",\n    \"__eq__\", \"__ne__\", \"__lt__\", \"__le__\",\n    \"__gt__\", \"__ge__\", \"__getattribute__\",\n    \"__setattr__\", \"__format__\"\n];\n\n/**\n * @constructor\n * Sk.builtin.none\n *\n * @extends {Sk.builtin.object}\n */\nSk.builtin.none = function () {\n    this.v = null;\n};\nSk.abstr.setUpInheritance(\"NoneType\", Sk.builtin.none, Sk.builtin.object);\n\n/** @override */\nSk.builtin.none.prototype[\"$r\"] = function () { return new Sk.builtin.str(\"None\"); };\n\n/** @override */\nSk.builtin.none.prototype.tp$hash = function () {\n    return new Sk.builtin.int_(0);\n};\n\n/**\n * Python None constant.\n * @type {Sk.builtin.none}\n */\nSk.builtin.none.none$ = new Sk.builtin.none();\n\n/**\n * @constructor\n * Sk.builtin.NotImplemented\n *\n * @extends {Sk.builtin.object}\n */\nSk.builtin.NotImplemented = function() { };\nSk.abstr.setUpInheritance(\"NotImplementedType\", Sk.builtin.NotImplemented, Sk.builtin.object);\n\n/** @override */\nSk.builtin.NotImplemented.prototype[\"$r\"] = function () { return new Sk.builtin.str(\"NotImplemented\"); };\n\n/**\n * Python NotImplemented constant.\n * @type {Sk.builtin.NotImplemented}\n */\nSk.builtin.NotImplemented.NotImplemented$ = new Sk.builtin.NotImplemented();\n\nSk.exportSymbol(\"Sk.builtin.none\", Sk.builtin.none);\nSk.exportSymbol(\"Sk.builtin.NotImplemented\", Sk.builtin.NotImplemented);\n","/**\n * @namespace Sk.builtin\n */\n\n\n/**\n * Check arguments to Python functions to ensure the correct number of\n * arguments are passed.\n *\n * @param {string} name the name of the function\n * @param {Object} args the args passed to the function\n * @param {number} minargs the minimum number of allowable arguments\n * @param {number=} maxargs optional maximum number of allowable\n * arguments (default: Infinity)\n * @param {boolean=} kwargs optional true if kwargs, false otherwise\n * (default: false)\n * @param {boolean=} free optional true if free vars, false otherwise\n * (default: false)\n */\nSk.builtin.pyCheckArgs = function (name, args, minargs, maxargs, kwargs, free) {\n    var nargs = args.length;\n    var msg = \"\";\n\n    if (maxargs === undefined) {\n        maxargs = Infinity;\n    }\n    if (kwargs) {\n        nargs -= 1;\n    }\n    if (free) {\n        nargs -= 1;\n    }\n    if ((nargs < minargs) || (nargs > maxargs)) {\n        if (minargs === maxargs) {\n            msg = name + \"() takes exactly \" + minargs + \" arguments\";\n        } else if (nargs < minargs) {\n            msg = name + \"() takes at least \" + minargs + \" arguments\";\n        } else {\n            msg = name + \"() takes at most \" + maxargs + \" arguments\";\n        }\n        msg += \" (\" + nargs + \" given)\";\n        throw new Sk.builtin.TypeError(msg);\n    }\n};\nSk.exportSymbol(\"Sk.builtin.pyCheckArgs\", Sk.builtin.pyCheckArgs);\n\n/**\n * Check arguments to Python functions to ensure the correct number of\n * arguments are passed.\n *\n * @param {string} name the name of the function\n * @param {number} nargs the args passed to the function\n * @param {number} minargs the minimum number of allowable arguments\n * @param {number=} maxargs optional maximum number of allowable\n * arguments (default: Infinity)\n * @param {boolean=} kwargs optional true if kwargs, false otherwise\n * (default: false)\n * @param {boolean=} free optional true if free vars, false otherwise\n * (default: false)\n */\nSk.builtin.pyCheckArgsLen = function (name, nargs, minargs, maxargs, kwargs, free) {\n    var msg = \"\";\n\n    if (maxargs === undefined) {\n        maxargs = Infinity;\n    }\n    if (kwargs) {\n        nargs -= 1;\n    }\n    if (free) {\n        nargs -= 1;\n    }\n    if ((nargs < minargs) || (nargs > maxargs)) {\n        if (minargs === maxargs) {\n            msg = name + \"() takes exactly \" + minargs + \" arguments\";\n        } else if (nargs < minargs) {\n            msg = name + \"() takes at least \" + minargs + \" arguments\";\n        } else {\n            msg = name + \"() takes at most \" + maxargs + \" arguments\";\n        }\n        msg += \" (\" + nargs + \" given)\";\n        throw new Sk.builtin.TypeError(msg);\n    }\n};\n\n/**\n * Check type of argument to Python functions.\n *\n * @param {string} name the name of the argument\n * @param {string} exptype string of the expected type name\n * @param {boolean} check truthy if type check passes, falsy otherwise\n */\nSk.builtin.pyCheckType = function (name, exptype, check) {\n    if (!check) {\n        throw new Sk.builtin.TypeError(name + \" must be a \" + exptype);\n    }\n};\nSk.exportSymbol(\"Sk.builtin.pyCheckType\", Sk.builtin.pyCheckType);\n\nSk.builtin.checkSequence = function (arg) {\n    return (arg !== null && arg.mp$subscript !== undefined);\n};\nSk.exportSymbol(\"Sk.builtin.checkSequence\", Sk.builtin.checkSequence);\n\n/**\n * Use this to test whether or not a Python object is iterable.  You should **not** rely\n * on the presence of tp$iter on the object as a good test, as it could be a user defined\n * class with `__iter__` defined or ``__getitem__``  This tests for all of those cases\n *\n * @param arg {Object}   A Python object\n * @returns {boolean} true if the object is iterable\n */\nSk.builtin.checkIterable = function (arg) {\n    var ret = false;\n    if (arg !== null ) {\n        try {\n            ret = Sk.abstr.iter(arg);\n            if (ret) {\n                return true;\n            } else {\n                return false;\n            }\n        } catch (e) {\n            if (e instanceof Sk.builtin.TypeError) {\n                return false;\n            } else {\n                throw e;\n            }\n        }\n    }\n    return ret;\n};\nSk.exportSymbol(\"Sk.builtin.checkIterable\", Sk.builtin.checkIterable);\n\nSk.builtin.checkCallable = function (obj) {\n    // takes care of builtin functions and methods, builtins\n    if (typeof obj === \"function\") {\n        return true;\n    }\n    // takes care of python function, methods and lambdas\n    if (obj instanceof Sk.builtin.func) {\n        return true;\n    }\n    // takes care of instances of methods\n    if (obj instanceof Sk.builtin.method) {\n        return true;\n    }\n    // go up the prototype chain to see if the class has a __call__ method\n    if (Sk.abstr.lookupSpecial(obj, Sk.builtin.str.$call) !== undefined) {\n        return true;\n    }\n    return false;\n};\n\nSk.builtin.checkNumber = function (arg) {\n    return (arg !== null && (typeof arg === \"number\" ||\n        arg instanceof Sk.builtin.int_ ||\n        arg instanceof Sk.builtin.float_ ||\n        arg instanceof Sk.builtin.lng));\n};\nSk.exportSymbol(\"Sk.builtin.checkNumber\", Sk.builtin.checkNumber);\n\n/**\n * Checks for complex type, delegates to internal method\n * Most skulpt users would search here!\n */\nSk.builtin.checkComplex = function (arg) {\n    return Sk.builtin.complex._complex_check(arg);\n};\nSk.exportSymbol(\"Sk.builtin.checkComplex\", Sk.builtin.checkComplex);\n\nSk.builtin.checkInt = function (arg) {\n    return (arg !== null) && ((typeof arg === \"number\" && arg === (arg | 0)) ||\n        arg instanceof Sk.builtin.int_ ||\n        arg instanceof Sk.builtin.lng);\n};\nSk.exportSymbol(\"Sk.builtin.checkInt\", Sk.builtin.checkInt);\n\nSk.builtin.checkFloat = function (arg) {\n    return (arg !== null) && (arg instanceof Sk.builtin.float_);\n};\nSk.exportSymbol(\"Sk.builtin.checkFloat\", Sk.builtin.checkFloat);\n\nSk.builtin.checkString = function (arg) {\n    return (arg !== null && arg.__class__ == Sk.builtin.str);\n};\nSk.exportSymbol(\"Sk.builtin.checkString\", Sk.builtin.checkString);\n\nSk.builtin.checkClass = function (arg) {\n    return (arg !== null && arg.sk$type);\n};\nSk.exportSymbol(\"Sk.builtin.checkClass\", Sk.builtin.checkClass);\n\nSk.builtin.checkBool = function (arg) {\n    return (arg instanceof Sk.builtin.bool);\n};\nSk.exportSymbol(\"Sk.builtin.checkBool\", Sk.builtin.checkBool);\n\nSk.builtin.checkNone = function (arg) {\n    return (arg instanceof Sk.builtin.none);\n};\nSk.exportSymbol(\"Sk.builtin.checkNone\", Sk.builtin.checkNone);\n\nSk.builtin.checkFunction = function (arg) {\n    return (arg !== null && arg.tp$call !== undefined);\n};\nSk.exportSymbol(\"Sk.builtin.checkFunction\", Sk.builtin.checkFunction);\n\n/**\n * @constructor\n * Sk.builtin.func\n *\n * @description\n * This function converts a Javascript function into a Python object that is callable.  Or just\n * think of it as a Python function rather than a Javascript function now.  This is an important\n * distinction in skulpt because once you have Python function you cannot just call it.\n * You must now use Sk.misceval.callsim to call the Python function.\n *\n * @param {Function} code the javascript implementation of this function\n * @param {Object=} globals the globals where this function was defined.\n * Can be undefined (which will be stored as null) for builtins. (is\n * that ok?)\n * @param {Object=} closure dict of free variables\n * @param {Object=} closure2 another dict of free variables that will be\n * merged into 'closure'. there's 2 to simplify generated code (one is $free,\n * the other is $cell)\n *\n * closure is the cell variables from the parent scope that we need to close\n * over. closure2 is the free variables in the parent scope that we also might\n * need to access.\n *\n * NOTE: co_varnames and co_name are defined by compiled code only, so we have\n * to access them via dict-style lookup for closure.\n *\n */\nSk.builtin.func = function (code, globals, closure, closure2) {\n    if (!(this instanceof Sk.builtin.func)) {\n        // otherwise it assigned .func_code and .func_globals somewhere and in certain\n        // situations that will cause a lot of strange errors.\n        throw new Error(\"builtin func should be called as a class with `new`\");\n    }\n\n    var k;\n    this.func_code = code;\n    this.func_globals = globals || null;\n    if (closure2 !== undefined) {\n        // todo; confirm that modification here can't cause problems\n        for (k in closure2) {\n            closure[k] = closure2[k];\n        }\n    }\n\n    this[\"$d\"] = {\n        \"__name__\": code[\"co_name\"],\n        \"__class__\": Sk.builtin.func\n    };\n    this.func_closure = closure;\n    this.tp$name = (this.func_code && this.func_code[\"co_name\"] && this.func_code[\"co_name\"].v) || this.func_code.name || \"<native JS>\";\n    return this;\n};\n\nSk.abstr.setUpInheritance(\"function\", Sk.builtin.func, Sk.builtin.object);\n\nSk.exportSymbol(\"Sk.builtin.func\", Sk.builtin.func);\n\nSk.builtin.func.prototype.tp$name = \"function\";\n\nSk.builtin.func.prototype.tp$descr_get = function (obj, objtype) {\n    Sk.asserts.assert(!(obj === undefined && objtype === undefined));\n    if (objtype && objtype.tp$name in Sk.builtin && Sk.builtin[objtype.tp$name] === objtype) {\n        // it's a builtin\n        return new Sk.builtin.method(this, obj, objtype, true);\n    }\n    return new Sk.builtin.method(this, obj, objtype);\n};\n\nSk.builtin.func.pythonFunctions = [\"__get__\"];\n\nSk.builtin.func.prototype.__get__ = function __get__(self, instance, owner) {\n    Sk.builtin.pyCheckArgsLen(\"__get__\", arguments.length, 1, 2, false, true);\n    if (instance === Sk.builtin.none.none$ && owner === Sk.builtin.none.none$) {\n        throw new Sk.builtin.TypeError(\"__get__(None, None) is invalid\");\n    }\n\n    return self.tp$descr_get(instance, owner);\n};\n\nSk.builtin.func.prototype.tp$getname = function () {\n    return (this.func_code && this.func_code[\"co_name\"] && this.func_code[\"co_name\"].v) || this.func_code.name || \"<native JS>\";\n};\n\nSk.builtin.func.prototype.tp$call = function (posargs, kw) {\n    // This function is a logical Javascript port of\n    // _PyEval_EvalCodeWithName, and follows its logic.\n\n    let co_argcount = this.func_code.co_argcount;\n\n    if (co_argcount === undefined) {\n        co_argcount = this.func_code.co_varnames ? this.func_code.co_varnames.length : posargs.length;\n    }\n    let varnames = this.func_code.co_varnames || [];\n    let co_kwonlyargcount = this.func_code.co_kwonlyargcount || 0;\n    let totalArgs = co_argcount + co_kwonlyargcount;\n    let kwargs;\n\n    /* Create a NOT-a-dictionary for keyword parameters (**kwags) */\n    if (this.func_code.co_kwargs) {\n        kwargs = [];\n    }\n\n    /* Copy positional arguments into arguments to our JS function*/\n    let nposargs = posargs.length;\n    let args = (posargs.length <= co_argcount) ? posargs : posargs.slice(0, co_argcount);\n\n\n    /* Pack other positional arguments into the *args argument */\n    if (this.func_code.co_varargs) {\n        let vararg = (posargs.length > args.length) ? posargs.slice(args.length) : [];\n        args[totalArgs] = new Sk.builtin.tuple(vararg);\n    } else if (nposargs > co_argcount) {\n        throw new Sk.builtin.TypeError(this.tp$getname() + \"() takes \" + co_argcount + \" positional argument\" + (co_argcount == 1 ? \"\" : \"s\") + \" but \" + nposargs + (nposargs == 1 ? \" was \" : \" were \") + \" given\");\n    }\n\n    /* Handle keyword arguments */\n    if (kw) {\n        if (this.func_code[\"no_kw\"]) {\n            throw new Sk.builtin.TypeError(this.tp$getname() + \"() takes no keyword arguments\");\n        }\n\n        for (let i = 0; i < kw.length; i += 2) {\n            let name = kw[i]; // JS string\n            let value = kw[i+1]; // Python value\n            let idx = varnames.indexOf(name);\n\n            if (idx >= 0) {\n                if (args[idx] !== undefined) {\n                    throw new Sk.builtin.TypeError(this.tp$getname() + \"() got multiple values for argument '\" + name + \"'\");\n                }\n                args[idx] = value;\n            } else if (kwargs) {\n                kwargs.push(new Sk.builtin.str(name), value);\n            } else {\n                throw new Sk.builtin.TypeError(this.tp$getname() + \"() got an unexpected keyword argument '\" + name + \"'\");\n            }\n        }\n    }\n\n    /* \"Check the number of positional arguments\" (which only checks for too many)\n       has been handled before keywords */\n\n    /* Add missing positional arguments (copy default values from defs)\n       (also checks for missing args where no defaults) */\n    {\n        let defaults = this.func_code.$defaults || [];\n        let i = 0, missing = [], missingUnnamed = false;\n        // Positional args for which we *don't* have a default\n        let defaultStart = co_argcount - defaults.length;\n        for (; i < defaultStart; i++) {\n            if (args[i] === undefined) {\n                missing.push(varnames[i]);\n                if (varnames[i] === undefined) {\n                    missingUnnamed = true;\n                }\n            }\n        }\n        if (missing.length != 0 && (this.func_code.co_argcount || this.func_code.co_varnames)) {\n            throw new Sk.builtin.TypeError(this.tp$getname() + \"() missing \" + missing.length + \" required argument\" + (missing.length==1?\"\":\"s\") + (missingUnnamed ? \"\" : (\": \" + missing.join(\", \"))));\n        }\n        for (; i < co_argcount; i++) {\n            if (args[i] === undefined) {\n                args[i] = defaults[i - defaultStart];\n            }\n        }\n    }\n\n    /* Add missing keyword arguments (copy default values from kwdefs) */\n\n    if (co_kwonlyargcount > 0) {\n        let missing = [];\n        let kwdefs = this.func_code.$kwdefs;\n\n        for (let i = co_argcount; i < totalArgs; i++) {\n            if (args[i] === undefined) {\n                if (kwdefs[i-co_argcount] !== undefined) {\n                    args[i] = kwdefs[i-co_argcount];\n                } else {\n                    missing.push(varnames[i]);\n                }\n            }\n        }\n        if (missing.length !== 0) {\n            throw new Sk.builtin.TypeError(this.tp$getname() + \"() missing \" + missing.length + \" required keyword argument\" + (missing.length==1?\"\":\"s\") + \": \" + missing.join(\", \"));\n        }\n    }\n\n    if (this.func_closure) {\n        // todo; OK to modify?\n        if (varnames) {\n            // Make sure all default arguments are in args before adding closure\n            for (let i = args.length; i < varnames.length; i++) {\n                args.push(undefined);\n            }\n        }\n\n        args.push(this.func_closure);\n    }\n\n    if (kwargs) {\n        args.unshift(kwargs);\n    }\n\n    // note: functions expect 'this' to be globals to avoid having to\n    // slice/unshift onto the main args\n    return this.func_code.apply(this.func_globals, args);\n\n};\n\nSk.builtin.func.prototype[\"$r\"] = function () {\n    var name = this.tp$getname();\n    if (name in Sk.builtins && this === Sk.builtins[name]) {\n        return new Sk.builtin.str(\"<built-in function \" + name + \">\");\n    } else {\n        return new Sk.builtin.str(\"<function \" + name + \">\");\n    }\n};\n","/**\n * builtins are supposed to come from the __builtin__ module, but we don't do\n * that yet.\n * todo; these should all be func objects too, otherwise str() of them won't\n * work, etc.\n */\n\nSk.builtin.range = function range (start, stop, step) {\n    this.start = start;\n    this.stop = stop;\n    this.step = step;\n\n    var ret = [];\n    var i;\n\n    Sk.builtin.pyCheckArgsLen(\"range\", arguments.length, 1, 3);\n    Sk.builtin.pyCheckType(\"start\", \"integer\", Sk.builtin.checkInt(start));\n    if (stop !== undefined) {\n        Sk.builtin.pyCheckType(\"stop\", \"integer\", Sk.builtin.checkInt(stop));\n    }\n    if (step !== undefined) {\n        Sk.builtin.pyCheckType(\"step\", \"integer\", Sk.builtin.checkInt(step));\n    }\n\n    start = Sk.builtin.asnum$(start);\n    stop = Sk.builtin.asnum$(stop);\n    step = Sk.builtin.asnum$(step);\n\n    if ((stop === undefined) && (step === undefined)) {\n        stop = start;\n        start = 0;\n        step = 1;\n    } else if (step === undefined) {\n        step = 1;\n    }\n\n    if (step === 0) {\n        throw new Sk.builtin.ValueError(\"range() step argument must not be zero\");\n    }\n\n    if (step > 0) {\n        for (i = start; i < stop; i += step) {\n            ret.push(new Sk.builtin.int_(i));\n        }\n    } else {\n        for (i = start; i > stop; i += step) {\n            ret.push(new Sk.builtin.int_(i));\n        }\n    }\n    return new Sk.builtin.list(ret); \n};\n\nSk.builtin.asnum$ = function (a) {\n    if (a === undefined) {\n        return a;\n    }\n    if (a === null) {\n        return a;\n    }\n    if (a instanceof Sk.builtin.none) {\n        return null;\n    }\n    if (a instanceof Sk.builtin.bool) {\n        if (a.v) {\n            return 1;\n        }\n        return 0;\n    }\n    if (typeof a === \"number\") {\n        return a;\n    }\n    if (typeof a === \"string\") {\n        return a;\n    }\n    if (a instanceof Sk.builtin.int_) {\n        return a.v;\n    }\n    if (a instanceof Sk.builtin.float_) {\n        return a.v;\n    }\n    if (a instanceof Sk.builtin.lng) {\n        if (a.cantBeInt()) {\n            return a.str$(10, true);\n        }\n        return a.toInt$();\n    }\n    if (a.constructor === Sk.builtin.biginteger) {\n        if ((a.trueCompare(new Sk.builtin.biginteger(Sk.builtin.int_.threshold$)) > 0) ||\n            (a.trueCompare(new Sk.builtin.biginteger(-Sk.builtin.int_.threshold$)) < 0)) {\n            return a.toString();\n        }\n        return a.intValue();\n    }\n\n    return a;\n};\n\nSk.exportSymbol(\"Sk.builtin.asnum$\", Sk.builtin.asnum$);\n\n/**\n * Return a Python number (either float or int) from a Javascript number.\n *\n * Javacsript function, returns Python object.\n *\n * @param  {number} a Javascript number to transform into Python number.\n * @return {(Sk.builtin.int_|Sk.builtin.float_)} A Python number.\n */\nSk.builtin.assk$ = function (a) {\n    if (a % 1 === 0) {\n        return new Sk.builtin.int_(a);\n    } else {\n        return new Sk.builtin.float_(a);\n    }\n};\nSk.exportSymbol(\"Sk.builtin.assk$\", Sk.builtin.assk$);\n\nSk.builtin.asnum$nofloat = function (a) {\n    var decimal;\n    var mantissa;\n    var expon;\n    if (a === undefined) {\n        return a;\n    }\n    if (a === null) {\n        return a;\n    }\n    if (a.constructor === Sk.builtin.none) {\n        return null;\n    }\n    if (a.constructor === Sk.builtin.bool) {\n        if (a.v) {\n            return 1;\n        }\n        return 0;\n    }\n    if (typeof a === \"number\") {\n        a = a.toString();\n    }\n    if (a.constructor === Sk.builtin.int_) {\n        a = a.v.toString();\n    }\n    if (a.constructor === Sk.builtin.float_) {\n        a = a.v.toString();\n    }\n    if (a.constructor === Sk.builtin.lng) {\n        a = a.str$(10, true);\n    }\n    if (a.constructor === Sk.builtin.biginteger) {\n        a = a.toString();\n    }\n\n    //  Sk.debugout(\"INITIAL: \" + a);\n\n    //  If not a float, great, just return this\n    if (a.indexOf(\".\") < 0 && a.indexOf(\"e\") < 0 && a.indexOf(\"E\") < 0) {\n        return a;\n    }\n\n    expon = 0;\n\n    if (a.indexOf(\"e\") >= 0) {\n        mantissa = a.substr(0, a.indexOf(\"e\"));\n        expon = a.substr(a.indexOf(\"e\") + 1);\n    } else if (a.indexOf(\"E\") >= 0) {\n        mantissa = a.substr(0, a.indexOf(\"e\"));\n        expon = a.substr(a.indexOf(\"E\") + 1);\n    } else {\n        mantissa = a;\n    }\n\n    expon = parseInt(expon, 10);\n\n    decimal = mantissa.indexOf(\".\");\n\n    //  Simplest case, no decimal\n    if (decimal < 0) {\n        if (expon >= 0) {\n            // Just add more zeroes and we're done\n            while (expon-- > 0) {\n                mantissa += \"0\";\n            }\n            return mantissa;\n        } else {\n            if (mantissa.length > -expon) {\n                return mantissa.substr(0, mantissa.length + expon);\n            } else {\n                return 0;\n            }\n        }\n    }\n\n    //  Negative exponent OR decimal (neg or pos exp)\n    if (decimal === 0) {\n        mantissa = mantissa.substr(1);\n    } else if (decimal < mantissa.length) {\n        mantissa = mantissa.substr(0, decimal) + mantissa.substr(decimal + 1);\n    } else {\n        mantissa = mantissa.substr(0, decimal);\n    }\n\n    decimal = decimal + expon;\n    while (decimal > mantissa.length) {\n        mantissa += \"0\";\n    }\n\n    if (decimal <= 0) {\n        mantissa = 0;\n    } else {\n        mantissa = mantissa.substr(0, decimal);\n    }\n\n    return mantissa;\n};\nSk.exportSymbol(\"Sk.builtin.asnum$nofloat\", Sk.builtin.asnum$nofloat);\n\nSk.builtin.round = function round (number, ndigits) {\n    var special;\n    Sk.builtin.pyCheckArgsLen(\"round\", arguments.length, 1, 2);\n\n    if (!Sk.builtin.checkNumber(number)) {\n        if (!Sk.builtin.checkFunction(number)) {\n            throw new Sk.builtin.TypeError(\"a float is required\");\n        } else {\n            if (!Sk.__future__.exceptions) {\n                throw new Sk.builtin.AttributeError(Sk.abstr.typeName(number) + \" instance has no attribute '__float__'\");\n            }\n        }\n    }\n\n    if ((ndigits !== undefined) && !Sk.misceval.isIndex(ndigits)) {\n        throw new Sk.builtin.TypeError(\"'\" + Sk.abstr.typeName(ndigits) + \"' object cannot be interpreted as an index\");\n    }\n\n    if (!Sk.__future__.dunder_round && number.round$) {\n        return number.round$(number, ndigits);\n    }\n\n    // try calling internal magic method\n    special = Sk.abstr.lookupSpecial(number, Sk.builtin.str.$round);\n    if (special != null) {\n        // method on builtin, provide this arg\n        if (!Sk.builtin.checkFunction(number)) {\n            return Sk.misceval.callsimArray(special, [number, ndigits]);\n        } else {\n            return Sk.misceval.callsimArray(special, [number]);\n        }\n    } else {\n        throw new Sk.builtin.TypeError(\"a float is required\");\n    }\n};\n\nSk.builtin.len = function len (item) {\n    var intcheck;\n    var special;\n    Sk.builtin.pyCheckArgsLen(\"len\", arguments.length, 1, 1);\n\n    var int_ = function(i) { return new Sk.builtin.int_(i); };\n    intcheck = function(j) {\n        if (Sk.builtin.checkInt(j)) {\n            return int_(j);\n        } else {\n            if (Sk.__future__.exceptions) {\n                throw new Sk.builtin.TypeError(\"'\" + Sk.abstr.typeName(j) + \"' object cannot be interpreted as an integer\");\n            } else {\n                throw new Sk.builtin.TypeError(\"__len__() should return an int\");\n            }\n        }\n    };\n\n    if (item.sq$length) {\n        return Sk.misceval.chain(item.sq$length(true), intcheck);\n    }\n\n    if (item.mp$length) {\n        return Sk.misceval.chain(item.mp$length(), int_);\n    }\n\n    if (item.tp$length) {\n        if (Sk.builtin.checkFunction(item)) {\n            special = Sk.abstr.lookupSpecial(item, Sk.builtin.str.$len);\n            if (special != null) {\n                return Sk.misceval.callsimArray(special, [item]);\n            } else {\n                if (Sk.__future__.exceptions) {\n                    throw new Sk.builtin.TypeError(\"object of type '\" + Sk.abstr.typeName(item) + \"' has no len()\");\n                } else {\n                    throw new Sk.builtin.AttributeError(Sk.abstr.typeName(item) + \" instance has no attribute '__len__'\");\n                }\n            }\n        } else {\n            return Sk.misceval.chain(item.tp$length(true), intcheck);\n        }\n    }\n\n    throw new Sk.builtin.TypeError(\"object of type '\" + Sk.abstr.typeName(item) + \"' has no len()\");\n};\n\nSk.builtin.min = function min () {\n    var i;\n    var lowest;\n    var args;\n    Sk.builtin.pyCheckArgsLen(\"min\", arguments.length, 1);\n\n    args = Sk.misceval.arrayFromArguments(arguments);\n    lowest = args[0];\n\n    if (lowest === undefined) {\n        throw new Sk.builtin.ValueError(\"min() arg is an empty sequence\");\n    }\n\n    for (i = 1; i < args.length; ++i) {\n        if (Sk.misceval.richCompareBool(args[i], lowest, \"Lt\")) {\n            lowest = args[i];\n        }\n    }\n    return lowest;\n};\n\nSk.builtin.max = function max () {\n    var i;\n    var highest;\n    var args;\n    Sk.builtin.pyCheckArgsLen(\"max\", arguments.length, 1);\n\n    args = Sk.misceval.arrayFromArguments(arguments);\n    highest = args[0];\n\n    if (highest === undefined) {\n        throw new Sk.builtin.ValueError(\"max() arg is an empty sequence\");\n    }\n\n    for (i = 1; i < args.length; ++i) {\n        if (Sk.misceval.richCompareBool(args[i], highest, \"Gt\")) {\n            highest = args[i];\n        }\n    }\n    return highest;\n};\n\nSk.builtin.any = function any (iter) {\n    var it, i;\n\n    Sk.builtin.pyCheckArgsLen(\"any\", arguments.length, 1, 1);\n    if (!Sk.builtin.checkIterable(iter)) {\n        throw new Sk.builtin.TypeError(\"'\" + Sk.abstr.typeName(iter) +\n            \"' object is not iterable\");\n    }\n\n    it = Sk.abstr.iter(iter);\n    for (i = it.tp$iternext(); i !== undefined; i = it.tp$iternext()) {\n        if (Sk.misceval.isTrue(i)) {\n            return Sk.builtin.bool.true$;\n        }\n    }\n\n    return Sk.builtin.bool.false$;\n};\n\nSk.builtin.all = function all (iter) {\n    var it, i;\n\n    Sk.builtin.pyCheckArgsLen(\"all\", arguments.length, 1, 1);\n    if (!Sk.builtin.checkIterable(iter)) {\n        throw new Sk.builtin.TypeError(\"'\" + Sk.abstr.typeName(iter) +\n            \"' object is not iterable\");\n    }\n\n    it = Sk.abstr.iter(iter);\n    for (i = it.tp$iternext(); i !== undefined; i = it.tp$iternext()) {\n        if (!Sk.misceval.isTrue(i)) {\n            return Sk.builtin.bool.false$;\n        }\n    }\n\n    return Sk.builtin.bool.true$;\n};\n\nSk.builtin.sum = function sum (iter, start) {\n    var tot;\n    var intermed;\n    var it, i;\n    var has_float;\n\n    Sk.builtin.pyCheckArgsLen(\"sum\", arguments.length, 1, 2);\n    Sk.builtin.pyCheckType(\"iter\", \"iterable\", Sk.builtin.checkIterable(iter));\n    if (start !== undefined && Sk.builtin.checkString(start)) {\n        throw new Sk.builtin.TypeError(\"sum() can't sum strings [use ''.join(seq) instead]\");\n    }\n    if (start === undefined) {\n        tot = new Sk.builtin.int_(0);\n    } else {\n        tot = start;\n    }\n\n    it = Sk.abstr.iter(iter);\n    for (i = it.tp$iternext(); i !== undefined; i = it.tp$iternext()) {\n        if (i instanceof Sk.builtin.float_) {\n            has_float = true;\n            if (!(tot instanceof Sk.builtin.float_)) {\n                tot = new Sk.builtin.float_(Sk.builtin.asnum$(tot));\n            }\n        } else if (i instanceof Sk.builtin.lng) {\n            if (!has_float) {\n                if (!(tot instanceof Sk.builtin.lng)) {\n                    tot = new Sk.builtin.lng(tot);\n                }\n            }\n        }\n\n        if (tot.nb$add !== undefined) {\n            intermed = tot.nb$add(i);\n            if ((intermed !== undefined) && (intermed !== Sk.builtin.NotImplemented.NotImplemented$)) {\n                tot = tot.nb$add(i);\n                continue;\n            }\n        }\n\n        throw new Sk.builtin.TypeError(\"unsupported operand type(s) for +: '\" +\n                    Sk.abstr.typeName(tot) + \"' and '\" +\n                    Sk.abstr.typeName(i) + \"'\");\n    }\n\n    return tot;\n};\n\nSk.builtin.zip = function zip () {\n    var el;\n    var tup;\n    var done;\n    var res;\n    var i;\n    var iters;\n    if (arguments.length === 0) {\n        return new Sk.builtin.list([]);\n    }\n\n    iters = [];\n    for (i = 0; i < arguments.length; i++) {\n        if (Sk.builtin.checkIterable(arguments[i])) {\n            iters.push(Sk.abstr.iter(arguments[i]));\n        } else {\n            throw new Sk.builtin.TypeError(\"argument \" + i + \" must support iteration\");\n        }\n    }\n    res = [];\n    done = false;\n    while (!done) {\n        tup = [];\n        for (i = 0; i < arguments.length; i++) {\n            el = iters[i].tp$iternext();\n            if (el === undefined) {\n                done = true;\n                break;\n            }\n            tup.push(el);\n        }\n        if (!done) {\n            res.push(new Sk.builtin.tuple(tup));\n        }\n    }\n    return new Sk.builtin.list(res);\n};\n\nSk.builtin.abs = function abs (x) {\n    Sk.builtin.pyCheckArgsLen(\"abs\", arguments.length, 1, 1);\n\n    if (x instanceof Sk.builtin.int_) {\n        return new Sk.builtin.int_(Math.abs(x.v));\n    }\n    if (x instanceof Sk.builtin.float_) {\n        return new Sk.builtin.float_(Math.abs(x.v));\n    }\n    if (Sk.builtin.checkNumber(x)) {\n        return Sk.builtin.assk$(Math.abs(Sk.builtin.asnum$(x)));\n    } else if (Sk.builtin.checkComplex(x)) {\n        return Sk.misceval.callsimArray(x.__abs__, [x]);\n    }\n\n    // call custom __abs__ methods\n    if (x.tp$getattr) {\n        var f = x.tp$getattr(Sk.builtin.str.$abs);\n        return Sk.misceval.callsimArray(f);\n    }\n\n    throw new TypeError(\"bad operand type for abs(): '\" + Sk.abstr.typeName(x) + \"'\");\n};\n\n// fabs belongs in the math module but has been a Skulpt builtin since 41665a97d (2012).\n// Left in for backwards compatibility for now\nSk.builtin.fabs = function fabs(x) {\n    return Sk.builtin.abs(x);\n};\n\nSk.builtin.ord = function ord (x) {\n    Sk.builtin.pyCheckArgsLen(\"ord\", arguments.length, 1, 1);\n\n    if (!Sk.builtin.checkString(x)) {\n        throw new Sk.builtin.TypeError(\"ord() expected a string of length 1, but \" + Sk.abstr.typeName(x) + \" found\");\n    } else if (x.v.length !== 1) {\n        throw new Sk.builtin.TypeError(\"ord() expected a character, but string of length \" + x.v.length + \" found\");\n    }\n    return new Sk.builtin.int_((x.v).charCodeAt(0));\n};\n\nSk.builtin.chr = function chr (x) {\n    Sk.builtin.pyCheckArgsLen(\"chr\", arguments.length, 1, 1);\n    if (!Sk.builtin.checkInt(x)) {\n        throw new Sk.builtin.TypeError(\"an integer is required\");\n    }\n    x = Sk.builtin.asnum$(x);\n\n\n    if ((x < 0) || (x > 255)) {\n        throw new Sk.builtin.ValueError(\"chr() arg not in range(256)\");\n    }\n\n    return new Sk.builtin.str(String.fromCharCode(x));\n};\n\nSk.builtin.unichr = function unichr (x) {\n    Sk.builtin.pyCheckArgsLen(\"chr\", arguments.length, 1, 1);\n    if (!Sk.builtin.checkInt(x)) {\n        throw new Sk.builtin.TypeError(\"an integer is required\");\n    }\n    x = Sk.builtin.asnum$(x);\n\n    try {\n        return new Sk.builtin.str(String.fromCodePoint(x));\n    } catch (err) {\n        if (err instanceof RangeError) {\n            throw new Sk.builtin.ValueError(err.message);\n        }\n        throw err;\n    }\n};\n\nSk.builtin.int2str_ = function helper_ (x, radix, prefix) {\n    var suffix;\n    var str = \"\";\n    if (x instanceof Sk.builtin.lng) {\n        suffix = \"\";\n        if (radix !== 2) {\n            suffix = \"L\";\n        }\n\n        str = x.str$(radix, false);\n        if (x.nb$isnegative()) {\n            return new Sk.builtin.str(\"-\" + prefix + str + suffix);\n        }\n        return new Sk.builtin.str(prefix + str + suffix);\n    } else {\n        x = Sk.misceval.asIndex(x);\n        str = x.toString(radix);\n        if (x < 0) {\n            return new Sk.builtin.str(\"-\" + prefix + str.slice(1));\n        }\n        return new Sk.builtin.str(prefix + str);\n    }\n};\n\nSk.builtin.hex = function hex (x) {\n    Sk.builtin.pyCheckArgsLen(\"hex\", arguments.length, 1, 1);\n    if (!Sk.misceval.isIndex(x)) {\n        throw new Sk.builtin.TypeError(\"hex() argument can't be converted to hex\");\n    }\n    return Sk.builtin.int2str_(x, 16, \"0x\");\n};\n\nSk.builtin.oct = function oct (x) {\n    Sk.builtin.pyCheckArgsLen(\"oct\", arguments.length, 1, 1);\n    if (!Sk.misceval.isIndex(x)) {\n        throw new Sk.builtin.TypeError(\"oct() argument can't be converted to hex\");\n    }\n    if (Sk.__future__.octal_number_literal) {\n        return Sk.builtin.int2str_(x, 8, \"0o\");\n    } else {\n        return Sk.builtin.int2str_(x, 8, \"0\");\n    }\n};\n\nSk.builtin.bin = function bin (x) {\n    Sk.builtin.pyCheckArgsLen(\"bin\", arguments.length, 1, 1);\n    if (!Sk.misceval.isIndex(x)) {\n        throw new Sk.builtin.TypeError(\"'\" + Sk.abstr.typeName(x) + \"' object can't be interpreted as an index\");\n    }\n    return Sk.builtin.int2str_(x, 2, \"0b\");\n};\n\nSk.builtin.dir = function dir (x) {\n    var last;\n    var it;\n    var prop;\n    var base;\n    var mro;\n    var i;\n    var s;\n    var k;\n    var names;\n    var getName;\n    Sk.builtin.pyCheckArgsLen(\"dir\", arguments.length, 1, 1);\n\n    getName = function (k) {\n        var s = null;\n        var internal = [\n            \"__bases__\", \"__mro__\", \"__class__\", \"__name__\", \"GenericGetAttr\",\n            \"GenericSetAttr\", \"GenericPythonGetAttr\", \"GenericPythonSetAttr\",\n            \"pythonFunctions\", \"HashNotImplemented\", \"constructor\", \"__dict__\"\n        ];\n        if (internal.indexOf(k) !== -1) {\n            return null;\n        }\n        if (k.indexOf(\"$\") !== -1) {\n            s = Sk.builtin.dir.slotNameToRichName(k);\n        } else if (k.charAt(k.length - 1) !== \"_\") {\n            s = k;\n        } else if (k.charAt(0) === \"_\") {\n            s = k;\n        }\n        return s;\n    };\n\n    names = [];\n\n    var _seq;\n\n    // try calling magic method\n    var special = Sk.abstr.lookupSpecial(x, Sk.builtin.str.$dir);\n    if(special != null) {\n        // method on builtin, provide this arg\n        _seq = Sk.misceval.callsimArray(special, [x]);\n\n        if (!Sk.builtin.checkSequence(_seq)) {\n            throw new Sk.builtin.TypeError(\"__dir__ must return sequence.\");\n        }\n\n        // proper unwrapping\n        _seq = Sk.ffi.remapToJs(_seq);\n\n        for (i = 0; i < _seq.length; ++i) {\n            names.push(new Sk.builtin.str(_seq[i]));\n        }\n    } else {\n        // Add all object properties\n        for (k in x.constructor.prototype) {\n            s = getName(k);\n            if (s) {\n                names.push(new Sk.builtin.str(s));\n            }\n        }\n\n        // Add all attributes\n        if (x[\"$d\"]) {\n            if (x[\"$d\"].tp$iter) {\n                // Dictionary\n                it = x[\"$d\"].tp$iter();\n                for (i = it.tp$iternext(); i !== undefined; i = it.tp$iternext()) {\n                    s = new Sk.builtin.str(i);\n                    s = getName(s.v);\n                    if (s) {\n                        names.push(new Sk.builtin.str(s));\n                    }\n                }\n            } else {\n                // Object\n                for (s in x[\"$d\"]) {\n                    names.push(new Sk.builtin.str(s));\n                }\n            }\n        }\n\n        // Add all class attributes\n        mro = x.tp$mro;\n        if(!mro && x.ob$type) {\n            mro = x.ob$type.tp$mro;\n        }\n        if (mro) {\n            for (i = 0; i < mro.v.length; ++i) {\n                base = mro.v[i];\n                for (prop in base) {\n                    if (base.hasOwnProperty(prop)) {\n                        s = getName(prop);\n                        if (s) {\n                            names.push(new Sk.builtin.str(s));\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    // Sort results\n    names.sort(function (a, b) {\n        return (a.v > b.v) - (a.v < b.v);\n    });\n\n    // Get rid of duplicates before returning, as duplicates should\n    //  only occur when they are shadowed\n    last = function (value, index, self) {\n        // Returns true iff the value is not the same as the next value\n        return value !== self[index + 1];\n    };\n    return new Sk.builtin.list(names.filter(last));\n};\n\nSk.builtin.dir.slotNameToRichName = function (k) {\n    // todo; map tp$xyz to __xyz__ properly\n    return undefined;\n};\n\nSk.builtin.repr = function repr (x) {\n    Sk.builtin.pyCheckArgsLen(\"repr\", arguments.length, 1, 1);\n\n    return Sk.misceval.objectRepr(x);\n};\n\nSk.builtin.open = function open (filename, mode, bufsize) {\n    Sk.builtin.pyCheckArgsLen(\"open\", arguments.length, 1, 3);\n    if (mode === undefined) {\n        mode = new Sk.builtin.str(\"r\");\n    }\n\n    if (/\\+/.test(mode.v)) {\n        throw \"todo; haven't implemented read/write mode\";\n    } else if ((mode.v === \"w\" || mode.v === \"wb\" || mode.v === \"a\" || mode.v === \"ab\") && !Sk.nonreadopen) {\n        throw \"todo; haven't implemented non-read opens\";\n    }\n\n    return new Sk.builtin.file(filename, mode, bufsize);\n};\n\nSk.builtin.isinstance = function isinstance (obj, type) {\n    var issubclass;\n    var i;\n    Sk.builtin.pyCheckArgsLen(\"isinstance\", arguments.length, 2, 2);\n    if (!Sk.builtin.checkClass(type) && !(type instanceof Sk.builtin.tuple)) {\n        throw new Sk.builtin.TypeError(\"isinstance() arg 2 must be a class, type, or tuple of classes and types\");\n    }\n\n    if (type === Sk.builtin.none.prototype.ob$type) {\n        if (obj instanceof Sk.builtin.none) {\n            return Sk.builtin.bool.true$;\n        } else {\n            return Sk.builtin.bool.false$;\n        }\n    }\n\n    // Normal case\n    if (obj.ob$type === type) {\n        return Sk.builtin.bool.true$;\n    }\n\n    // Handle tuple type argument\n    if (type instanceof Sk.builtin.tuple) {\n        for (i = 0; i < type.v.length; ++i) {\n            if (Sk.misceval.isTrue(Sk.builtin.isinstance(obj, type.v[i]))) {\n                return Sk.builtin.bool.true$;\n            }\n        }\n        return Sk.builtin.bool.false$;\n    }\n\n    // Check for Javascript inheritance\n    if (obj instanceof type) {\n        return Sk.builtin.bool.true$;\n    }\n\n\n    issubclass = function (klass, base) {\n        var i;\n        var bases;\n        if (klass === base) {\n            return Sk.builtin.bool.true$;\n        }\n        if (klass[\"$d\"] === undefined) {\n            return Sk.builtin.bool.false$;\n        }\n        bases = klass[\"$d\"].mp$subscript(Sk.builtin.type.basesStr_);\n        for (i = 0; i < bases.v.length; ++i) {\n            if (Sk.misceval.isTrue(issubclass(bases.v[i], base))) {\n                return Sk.builtin.bool.true$;\n            }\n        }\n        return Sk.builtin.bool.false$;\n    };\n\n    return issubclass(obj.ob$type, type);\n};\n\nSk.builtin.hash = function hash (value) {\n    var junk;\n    Sk.builtin.pyCheckArgsLen(\"hash\", arguments.length, 1, 1);\n\n    // Useless object to get compiler to allow check for __hash__ property\n    junk = {__hash__: function () {\n        return 0;\n    }};\n\n    if (value instanceof Object) {\n        if (Sk.builtin.checkNone(value.tp$hash)) {\n            // python sets the hash function to None , so we have to catch this case here\n            throw new Sk.builtin.TypeError(new Sk.builtin.str(\"unhashable type: '\" + Sk.abstr.typeName(value) + \"'\"));\n        } else if (value.tp$hash !== undefined) {\n            if (value.$savedHash_) {\n                return value.$savedHash_;\n            }\n            value.$savedHash_ = value.tp$hash();\n            return value.$savedHash_;\n        } else {\n            if (value.__hash === undefined) {\n                Sk.builtin.hashCount += 1;\n                value.__hash = Sk.builtin.hashCount;\n            }\n            return new Sk.builtin.int_(value.__hash);\n        }\n    } else if (typeof value === \"number\" || value === null ||\n        value === true || value === false) {\n        throw new Sk.builtin.TypeError(\"unsupported Javascript type\");\n    }\n\n    return new Sk.builtin.str((typeof value) + \" \" + String(value));\n    // todo; throw properly for unhashable types\n};\n\nSk.builtin.getattr = function getattr (obj, pyName, default_) {\n    var ret, mangledName, jsName;\n    Sk.builtin.pyCheckArgsLen(\"getattr\", arguments.length, 2, 3);\n    if (!Sk.builtin.checkString(pyName)) {\n        throw new Sk.builtin.TypeError(\"attribute name must be string\");\n    }\n\n    jsName = pyName.$jsstr();\n    mangledName = new Sk.builtin.str(Sk.fixReservedWords(jsName));\n    ret = obj.tp$getattr(mangledName);\n    if (ret === undefined) {\n        if (default_ !== undefined) {\n            return default_;\n        } else {\n            throw new Sk.builtin.AttributeError(\"'\" + Sk.abstr.typeName(obj) + \"' object has no attribute '\" + jsName + \"'\");\n        }\n    }\n    return ret;\n};\n\nSk.builtin.setattr = function setattr (obj, pyName, value) {\n    var jsName;\n    Sk.builtin.pyCheckArgsLen(\"setattr\", arguments.length, 3, 3);\n    // cannot set or del attr from builtin type\n    if (obj === undefined || obj[\"$r\"] === undefined || obj[\"$r\"]().v.slice(1,5) !== \"type\") {\n        if (!Sk.builtin.checkString(pyName)) {\n            throw new Sk.builtin.TypeError(\"attribute name must be string\");\n        }\n        jsName = pyName.$jsstr();\n        if (obj.tp$setattr) {\n            obj.tp$setattr(new Sk.builtin.str(Sk.fixReservedWords(jsName)), value);\n        } else {\n            throw new Sk.builtin.AttributeError(\"object has no attribute \" + jsName);\n        }\n        return Sk.builtin.none.none$;\n    }\n\n    throw new Sk.builtin.TypeError(\"can't set attributes of built-in/extension type '\" + obj.tp$name + \"'\");\n};\n\nSk.builtin.raw_input = function (prompt) {\n    var lprompt = prompt ? prompt : \"\";\n\n    return Sk.misceval.chain(Sk.importModule(\"sys\", false, true), function (sys) {\n        if (Sk.inputfunTakesPrompt) {\n            return Sk.misceval.callsimOrSuspendArray(Sk.builtin.file.$readline, [sys[\"$d\"][\"stdin\"], null, lprompt]);\n        } else {\n            return Sk.misceval.chain(undefined, function() {\n                return Sk.misceval.callsimOrSuspendArray(sys[\"$d\"][\"stdout\"][\"write\"], [sys[\"$d\"][\"stdout\"], new Sk.builtin.str(lprompt)]);\n            }, function () {\n                return Sk.misceval.callsimOrSuspendArray(sys[\"$d\"][\"stdin\"][\"readline\"], [sys[\"$d\"][\"stdin\"]]);\n            });\n        }\n    });\n};\n\nSk.builtin.input = Sk.builtin.raw_input;\n\nSk.builtin.jseval = function jseval (evalcode) {\n    var result = Sk.global[\"eval\"](Sk.ffi.remapToJs(evalcode));\n    try {\n        return Sk.ffi.remapToPy(result);\n    } catch (err) {\n        if (err.constructor === Sk.asserts.AssertionError) {\n            return Sk.builtin.none.none$;\n        }\n\n        throw err;\n    }\n};\n\nSk.builtin.jsmillis = function jsmillis () {\n    var now = new Date();\n    return now.valueOf();\n};\n\nSk.builtin.eval_ = function eval_ () {\n    throw new Sk.builtin.NotImplementedError(\"eval is not yet implemented\");\n};\n\nSk.builtin.map = function map (fun, seq) {\n    var retval = [];\n    var next;\n    var nones;\n    var args;\n    var argnum;\n    var i;\n    var iterables;\n    var combined;\n    Sk.builtin.pyCheckArgsLen(\"map\", arguments.length, 2);\n\n    if (arguments.length > 2) {\n        // Pack sequences into one list of Javascript Arrays\n\n        combined = [];\n        iterables = Array.prototype.slice.apply(arguments).slice(1);\n        for (i = 0; i < iterables.length; i++) {\n            if (!Sk.builtin.checkIterable(iterables[i])) {\n                argnum = parseInt(i, 10) + 2;\n                throw new Sk.builtin.TypeError(\"argument \" + argnum + \" to map() must support iteration\");\n            }\n            iterables[i] = Sk.abstr.iter(iterables[i]);\n        }\n\n        while (true) {\n            args = [];\n            nones = 0;\n            for (i = 0; i < iterables.length; i++) {\n                next = iterables[i].tp$iternext();\n                if (next === undefined) {\n                    args.push(Sk.builtin.none.none$);\n                    nones++;\n                } else {\n                    args.push(next);\n                }\n            }\n            if (nones !== iterables.length) {\n                combined.push(args);\n            } else {\n                // All iterables are done\n                break;\n            }\n        }\n        seq = new Sk.builtin.list(combined);\n    }\n\n    if (!Sk.builtin.checkIterable(seq)) {\n        throw new Sk.builtin.TypeError(\"'\" + Sk.abstr.typeName(seq) + \"' object is not iterable\");\n    }\n\n    return Sk.misceval.chain(Sk.misceval.iterFor(Sk.abstr.iter(seq), function (item) {\n\n        if (fun === Sk.builtin.none.none$) {\n            if (item instanceof Array) {\n                // With None function and multiple sequences,\n                // map should return a list of tuples\n                item = new Sk.builtin.tuple(item);\n            }\n            retval.push(item);\n        } else {\n            if (!(item instanceof Array)) {\n                // If there was only one iterable, convert to Javascript\n                // Array for call to apply.\n                item = [item];\n            }\n\n            return Sk.misceval.chain(Sk.misceval.applyOrSuspend(fun, undefined, undefined, undefined, item), function (result) {\n                retval.push(result);\n            });\n        }\n    }), function () {\n        return new Sk.builtin.list(retval);\n    });\n};\n\nSk.builtin.reduce = function reduce (fun, seq, initializer) {\n    var item;\n    var accum_value;\n    var iter;\n    Sk.builtin.pyCheckArgsLen(\"reduce\", arguments.length, 2, 3);\n    if (!Sk.builtin.checkIterable(seq)) {\n        throw new Sk.builtin.TypeError(\"'\" + Sk.abstr.typeName(seq) + \"' object is not iterable\");\n    }\n\n    iter = Sk.abstr.iter(seq);\n    if (initializer === undefined) {\n        initializer = iter.tp$iternext();\n        if (initializer === undefined) {\n            throw new Sk.builtin.TypeError(\"reduce() of empty sequence with no initial value\");\n        }\n    }\n    accum_value = initializer;\n    for (item = iter.tp$iternext();\n        item !== undefined;\n        item = iter.tp$iternext()) {\n        accum_value = Sk.misceval.callsimArray(fun, [accum_value, item]);\n    }\n\n    return accum_value;\n};\n\nSk.builtin.filter = function filter (fun, iterable) {\n    var result;\n    var iter, item;\n    var retval;\n    var ret;\n    var add;\n    var ctor;\n    Sk.builtin.pyCheckArgsLen(\"filter\", arguments.length, 2, 2);\n\n    if (!Sk.builtin.checkIterable(iterable)) {\n        throw new Sk.builtin.TypeError(\"'\" + Sk.abstr.typeName(iterable) + \"' object is not iterable\");\n    }\n\n    ctor = function () {\n        return [];\n    };\n    add = function (iter, item) {\n        iter.push(item);\n        return iter;\n    };\n    ret = function (iter) {\n        return new Sk.builtin.list(iter);\n    };\n\n    if (iterable.__class__ === Sk.builtin.str) {\n        ctor = function () {\n            return new Sk.builtin.str(\"\");\n        };\n        add = function (iter, item) {\n            return iter.sq$concat(item);\n        };\n        ret = function (iter) {\n            return iter;\n        };\n    } else if (iterable.__class__ === Sk.builtin.tuple) {\n        ret = function (iter) {\n            return new Sk.builtin.tuple(iter);\n        };\n    }\n\n    retval = ctor();\n\n    for (iter = Sk.abstr.iter(iterable), item = iter.tp$iternext();\n        item !== undefined;\n        item = iter.tp$iternext()) {\n        if (fun === Sk.builtin.none.none$) {\n            result = new Sk.builtin.bool( item);\n        } else {\n            result = Sk.misceval.callsimArray(fun, [item]);\n        }\n\n        if (Sk.misceval.isTrue(result)) {\n            retval = add(retval, item);\n        }\n    }\n\n    return ret(retval);\n};\n\nSk.builtin.hasattr = function hasattr (obj, attr) {\n    Sk.builtin.pyCheckArgsLen(\"hasattr\", arguments.length, 2, 2);\n    var special, ret;\n    if (!Sk.builtin.checkString(attr)) {\n        throw new Sk.builtin.TypeError(\"hasattr(): attribute name must be string\");\n    }\n\n    if (obj.tp$getattr) {\n        if (obj.tp$getattr(attr)) {\n            return Sk.builtin.bool.true$;\n        } else {\n            return Sk.builtin.bool.false$;\n        }\n    } else {\n        throw new Sk.builtin.AttributeError(\"Object has no tp$getattr method\");\n    }\n};\n\n\nSk.builtin.pow = function pow (a, b, c) {\n    var ret;\n    var res;\n    var right;\n    var left;\n    var c_num;\n    var b_num;\n    var a_num;\n    Sk.builtin.pyCheckArgsLen(\"pow\", arguments.length, 2, 3);\n\n    if (c instanceof Sk.builtin.none) {\n        c = undefined;\n    }\n\n    // add complex type hook here, builtin is messed up anyways\n    if (Sk.builtin.checkComplex(a)) {\n        return a.nb$power(b, c); // call complex pow function\n    }\n\n    a_num = Sk.builtin.asnum$(a);\n    b_num = Sk.builtin.asnum$(b);\n    c_num = Sk.builtin.asnum$(c);\n\n    if (!Sk.builtin.checkNumber(a) || !Sk.builtin.checkNumber(b)) {\n        if (c === undefined) {\n            throw new Sk.builtin.TypeError(\"unsupported operand type(s) for pow(): '\" + Sk.abstr.typeName(a) + \"' and '\" + Sk.abstr.typeName(b) + \"'\");\n        }\n        throw new Sk.builtin.TypeError(\"unsupported operand type(s) for pow(): '\" + Sk.abstr.typeName(a) + \"', '\" + Sk.abstr.typeName(b) + \"', '\" + Sk.abstr.typeName(c) + \"'\");\n    }\n    if (a_num < 0 && b instanceof Sk.builtin.float_) {\n        throw new Sk.builtin.ValueError(\"negative number cannot be raised to a fractional power\");\n    }\n\n    if (c === undefined) {\n        if ((a instanceof Sk.builtin.float_ || b instanceof Sk.builtin.float_) || (b_num < 0)) {\n            return new Sk.builtin.float_(Math.pow(a_num, b_num));\n        }\n\n        left = new Sk.builtin.int_(a_num);\n        right = new Sk.builtin.int_(b_num);\n        res = left.nb$power(right);\n\n        if (a instanceof Sk.builtin.lng || b instanceof Sk.builtin.lng) {\n            return new Sk.builtin.lng(res);\n        }\n\n        return res;\n    } else {\n        if (!Sk.builtin.checkInt(a) || !Sk.builtin.checkInt(b) || !Sk.builtin.checkInt(c)) {\n            throw new Sk.builtin.TypeError(\"pow() 3rd argument not allowed unless all arguments are integers\");\n        }\n        if (b_num < 0) {\n            if (Sk.__future__.exceptions) {\n                throw new Sk.builtin.ValueError(\"pow() 2nd argument cannot be negative when 3rd argument specified\");\n            } else {\n                throw new Sk.builtin.TypeError(\"pow() 2nd argument cannot be negative when 3rd argument specified\");\n            }\n        }\n        if (c_num === 0) {\n            throw new Sk.builtin.ValueError(\"pow() 3rd argument cannot be 0\");\n        }\n        if ((a instanceof Sk.builtin.lng || b instanceof Sk.builtin.lng || c instanceof Sk.builtin.lng) ||\n            (Math.pow(a_num, b_num) === Infinity)) {\n            // convert a to a long so that we can use biginteger's modPowInt method\n            a = new Sk.builtin.lng(a);\n            return a.nb$power(b, c);\n        } else {\n            ret = new Sk.builtin.int_(Math.pow(a_num, b_num));\n            return ret.nb$remainder(c);\n        }\n    }\n};\n\nSk.builtin.quit = function quit (msg) {\n    var s = new Sk.builtin.str(msg).v;\n    throw new Sk.builtin.SystemExit(s);\n};\n\n\nSk.builtin.issubclass = function issubclass (c1, c2) {\n    var i;\n    var issubclass_internal;\n    Sk.builtin.pyCheckArgsLen(\"issubclass\", arguments.length, 2, 2);\n    if (!Sk.builtin.checkClass(c1)) {\n        throw new Sk.builtin.TypeError(\"issubclass() arg 1 must be a class\");\n    }\n\n    if (!Sk.builtin.checkClass(c2) && !(c2 instanceof Sk.builtin.tuple)) {\n        throw new Sk.builtin.TypeError(\"issubclass() arg 2 must be a class or tuple of classes\");\n    }\n\n    issubclass_internal = function (klass, base) {\n        var i;\n        var bases;\n        if (klass === base) {\n            return true;\n        }\n        if (klass[\"$d\"] === undefined) {\n            return false;\n        }\n        if (klass[\"$d\"].mp$subscript) {\n            // old style classes don't have bases\n            if (klass[\"$d\"].sq$contains(Sk.builtin.type.basesStr_)) {\n                bases = klass[\"$d\"].mp$subscript(Sk.builtin.type.basesStr_);\n            } else {\n                return false;\n            }\n        } else {\n            return false;\n        }\n        for (i = 0; i < bases.v.length; ++i) {\n            if (issubclass_internal(bases.v[i], base)) {\n                return true;\n            }\n        }\n        return false;\n    };\n\n    if (Sk.builtin.checkClass(c2)) {\n        /* Quick test for an exact match */\n        if (c1 === c2) {\n            return true;\n        }\n\n        return issubclass_internal(c1, c2);\n    }\n\n    // Handle tuple type argument\n    if (c2 instanceof Sk.builtin.tuple) {\n        for (i = 0; i < c2.v.length; ++i) {\n            if (Sk.builtin.issubclass(c1, c2.v[i])) {\n                return true;\n            }\n        }\n        return false;\n    }\n};\n\nSk.builtin.globals = function globals () {\n    var i;\n    var ret = new Sk.builtin.dict([]);\n    for (i in Sk[\"globals\"]) {\n        ret.mp$ass_subscript(new Sk.builtin.str(i), Sk[\"globals\"][i]);\n    }\n\n    return ret;\n\n};\n\nSk.builtin.divmod = function divmod (a, b) {\n    return Sk.abstr.numberBinOp(a, b, \"DivMod\");\n};\n\n/**\n * Convert a value to a formatted representation, as controlled by format_spec. The interpretation of format_spec\n * will depend on the type of the value argument, however there is a standard formatting syntax that is used by most\n * built-in types: Format Specification Mini-Language.\n */\nSk.builtin.format = function format (value, format_spec) {\n    Sk.builtin.pyCheckArgsLen(\"format\", arguments.length, 1, 2);\n\n    if (format_spec === undefined) {\n        format_spec = Sk.builtin.str.$emptystr;\n    }\n\n    return Sk.abstr.objectFormat(value, format_spec);\n};\n\nSk.builtin.reversed = function reversed (seq) {\n    Sk.builtin.pyCheckArgsLen(\"reversed\", arguments.length, 1, 1);\n\n    var special = Sk.abstr.lookupSpecial(seq, Sk.builtin.str.$reversed);\n    if (special != null) {\n        return Sk.misceval.callsimArray(special, [seq]);\n    } else {\n        if (!Sk.builtin.checkSequence(seq)) {\n            throw new Sk.builtin.TypeError(\"'\" + Sk.abstr.typeName(seq) + \"' object is not a sequence\");\n        }\n\n        /**\n         * Builds an iterator that outputs the items form last to first.\n         *\n         * @constructor\n         */\n        var reverseIter = function (obj) {\n            this.idx = obj.sq$length() - 1;\n            this.myobj = obj;\n            this.getitem = Sk.abstr.lookupSpecial(obj, Sk.builtin.str.$getitem);\n            this.tp$iter = function() {\n                return this;\n            },\n            this.tp$iternext = function () {\n                var ret;\n\n                if (this.idx < 0) {\n                    return undefined;\n                }\n\n                try {\n                    ret = Sk.misceval.callsimArray(this.getitem, [this.myobj, Sk.ffi.remapToPy(this.idx)]);\n                } catch (e) {\n                    if (e instanceof Sk.builtin.IndexError) {\n                        return undefined;\n                    } else {\n                        throw e;\n                    }\n                }\n                this.idx--;\n                return ret;\n            };\n        };\n\n        return new reverseIter(seq);\n    }\n};\n\nSk.builtin.id = function (obj) {\n    Sk.builtin.pyCheckArgsLen(\"id\", arguments.length, 1, 1);\n\n    if (obj.__id === undefined) {\n        Sk.builtin.idCount += 1;\n        obj.__id = Sk.builtin.idCount;\n    }\n\n    return new Sk.builtin.int_(obj.__id);\n};\n\nSk.builtin.bytearray = function bytearray () {\n    throw new Sk.builtin.NotImplementedError(\"bytearray is not yet implemented\");\n};\n\nSk.builtin.callable = function callable (obj) {\n    // check num of args\n    Sk.builtin.pyCheckArgsLen(\"callable\", arguments.length, 1, 1);\n\n    if (Sk.builtin.checkCallable(obj)) {\n        return Sk.builtin.bool.true$;\n    }\n    return Sk.builtin.bool.false$;\n};\n\nSk.builtin.delattr = function delattr (obj, attr) {\n    Sk.builtin.pyCheckArgsLen(\"delattr\", arguments.length, 2, 2);\n    if (obj[\"$d\"][attr.v] !== undefined) {\n        var ret = Sk.misceval.tryCatch(function() {\n            var try1 = Sk.builtin.setattr(obj, attr, undefined);\n            return try1;\n        }, function(e) {\n            Sk.misceval.tryCatch(function() {\n                var try2 = Sk.builtin.setattr(obj[\"$d\"], attr, undefined);\n\n                return try2;\n            }, function(e) {\n                if (e instanceof Sk.builtin.AttributeError) {\n                    throw new Sk.builtin.AttributeError(Sk.abstr.typeName(obj) + \" instance has no attribute '\"+ attr.v+ \"'\");\n                } else {\n                    throw e;\n                }\n            });\n        });\n        return ret;\n    } // cannot set or del attr from builtin type\n    if (obj[\"$r\"]().v.slice(1,5) !== \"type\") {\n        if (obj.ob$type === Sk.builtin.type && obj[attr.v] !== undefined) {\n            obj[attr.v] = undefined;\n            return Sk.builtin.none.none$;\n        }\n        throw new Sk.builtin.AttributeError(Sk.abstr.typeName(obj) + \" instance has no attribute '\"+ attr.v+ \"'\");\n    }\n    throw new Sk.builtin.TypeError(\"can't set attributes of built-in/extension type '\" + obj.tp$name + \"'\");\n};\n\nSk.builtin.execfile = function execfile () {\n    throw new Sk.builtin.NotImplementedError(\"execfile is not yet implemented\");\n};\n\nSk.builtin.frozenset = function frozenset () {\n    throw new Sk.builtin.NotImplementedError(\"frozenset is not yet implemented\");\n};\n\nSk.builtin.help = function help () {\n    throw new Sk.builtin.NotImplementedError(\"help is not yet implemented\");\n};\n\nSk.builtin.iter = function iter (obj, sentinel) {\n    Sk.builtin.pyCheckArgsLen(\"iter\", arguments.length, 1, 2);\n    if (arguments.length === 1) {\n        if (!Sk.builtin.checkIterable(obj)) {\n            throw new Sk.builtin.TypeError(\"'\" + Sk.abstr.typeName(obj) +\n                \"' object is not iterable\");\n        } else {\n            return new Sk.builtin.iterator(obj);\n        }\n    } else {\n        if (Sk.builtin.checkCallable(obj)) {\n            return new Sk.builtin.iterator(obj, sentinel);\n        } else {\n            throw new TypeError(\"iter(v, w): v must be callable\");\n        }\n    }\n};\n\nSk.builtin.locals = function locals () {\n    throw new Sk.builtin.NotImplementedError(\"locals is not yet implemented\");\n};\nSk.builtin.memoryview = function memoryview () {\n    throw new Sk.builtin.NotImplementedError(\"memoryview is not yet implemented\");\n};\n\nSk.builtin.next_ = function next_ (iter, default_) {\n    var nxt;\n    Sk.builtin.pyCheckArgsLen(\"next\", arguments.length, 1, 2);\n    if (!iter.tp$iternext) {\n        throw new Sk.builtin.TypeError(\"'\" + Sk.abstr.typeName(iter) +\n            \"' object is not an iterator\");\n    }\n    nxt = iter.tp$iternext();\n    if (nxt === undefined) {\n        if (default_) {\n            return default_;\n        }\n        throw new Sk.builtin.StopIteration();\n    }\n    return nxt;\n};\n\nSk.builtin.reload = function reload () {\n    throw new Sk.builtin.NotImplementedError(\"reload is not yet implemented\");\n};\nSk.builtin.vars = function vars () {\n    throw new Sk.builtin.NotImplementedError(\"vars is not yet implemented\");\n};\nSk.builtin.xrange = Sk.builtin.range;\nSk.builtin.apply_ = function apply_ () {\n    throw new Sk.builtin.NotImplementedError(\"apply is not yet implemented\");\n};\nSk.builtin.buffer = function buffer_ () {\n    throw new Sk.builtin.NotImplementedError(\"buffer is not yet implemented\");\n};\nSk.builtin.coerce = function coerce () {\n    throw new Sk.builtin.NotImplementedError(\"coerce is not yet implemented\");\n};\nSk.builtin.intern = function intern () {\n    throw new Sk.builtin.NotImplementedError(\"intern is not yet implemented\");\n};\n\n/*\n Sk.builtinFiles = {};\n Sk.builtin.read = function read(x) {\n if (Sk.builtinFiles === undefined || Sk.builtinFiles[\"files\"][x] === undefined)\n throw \"File not found: '\" + x + \"'\";\n return Sk.builtinFiles[\"files\"][x];\n };\n Sk.builtinFiles = undefined;\n */\n","/*! https://mths.be/fromcodepoint v0.2.1 by @mathias */\nif (!String.fromCodePoint) {\n    (function() {\n        var defineProperty = (function() {\n            // IE 8 only supports `Object.defineProperty` on DOM elements\n            var result;\n            try {\n                var object = {};\n                var $defineProperty = Object.defineProperty;\n                result = $defineProperty(object, \"foo\", object) && $defineProperty;\n            } catch(error) {}\n            return result;\n        }());\n        var stringFromCharCode = String.fromCharCode;\n        var floor = Math.floor;\n        var fromCodePoint = function(_) {\n            var MAX_SIZE = 0x4000;\n            var codeUnits = [];\n            var highSurrogate;\n            var lowSurrogate;\n            var index = -1;\n            var length = arguments.length;\n            if (!length) {\n                return \"\";\n            }\n            var result = \"\";\n            while (++index < length) {\n                var codePoint = Number(arguments[index]);\n                if (\n                    !isFinite(codePoint) || // `NaN`, `+Infinity`, or `-Infinity`\n                    codePoint < 0 || // not a valid Unicode code point\n                    codePoint > 0x10FFFF || // not a valid Unicode code point\n                    floor(codePoint) != codePoint // not an integer\n                ) {\n                    throw RangeError(\"Invalid code point: \" + codePoint);\n                }\n                if (codePoint <= 0xFFFF) { // BMP code point\n                    codeUnits.push(codePoint);\n                } else { // Astral code point; split in surrogate halves\n                    // https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae\n                    codePoint -= 0x10000;\n                    highSurrogate = (codePoint >> 10) + 0xD800;\n                    lowSurrogate = (codePoint % 0x400) + 0xDC00;\n                    codeUnits.push(highSurrogate, lowSurrogate);\n                }\n                if (index + 1 == length || codeUnits.length > MAX_SIZE) {\n                    result += stringFromCharCode.apply(null, codeUnits);\n                    codeUnits.length = 0;\n                }\n            }\n            return result;\n        };\n        if (defineProperty) {\n            defineProperty(String, \"fromCodePoint\", {\n                \"value\": fromCodePoint,\n                \"configurable\": true,\n                \"writable\": true\n            });\n        } else {\n            String.fromCodePoint = fromCodePoint;\n        }\n    }());\n}\n","/*\n * The filename, line number, and column number of exceptions are\n * stored within the exception object.  Note that not all exceptions\n * clearly report the column number.  To customize the exception\n * message to use any/all of these fields, you can either modify\n * tp$str below to print the desired message, or use them in the\n * skulpt wrapper (i.e., runit) to present the exception message.\n */\n\n\n/**\n * @constructor\n * @param {...Object|null} args\n */\nSk.builtin.BaseException = function (args) {\n    var i, o;\n\n    if (!(this instanceof Sk.builtin.BaseException)) {\n        o = Object.create(Sk.builtin.BaseException.prototype);\n        o.constructor.apply(o, arguments);\n        return o;\n    }\n\n    args = Array.prototype.slice.call(arguments);\n    // hackage to allow shorter throws\n    for (i = 0; i < args.length; ++i) {\n        if (typeof args[i] === \"string\") {\n            args[i] = new Sk.builtin.str(args[i]);\n        }\n    }\n    this.args = new Sk.builtin.tuple(args);\n    this.traceback = [];\n\n    // For errors occurring during normal execution, the line/col/etc\n    // of the error are populated by each stack frame of the runtime code,\n    // but we can seed it with the supplied parameters.\n    if (this.args.sq$length() >= 3) {\n\n        // if !this.args[1].v, this is an error, and the exception that causes it\n        // probably needs to be fixed, but we mark as \"<unknown>\" for now\n        this.traceback.push({\n            lineno: this.args.v[2],\n            filename: this.args.v[1].v || \"<unknown>\"\n        });\n    }\n};\nSk.abstr.setUpInheritance(\"BaseException\", Sk.builtin.BaseException, Sk.builtin.object);\n\nSk.builtin.BaseException.prototype.tp$str = function () {\n    var i;\n    var ret = \"\";\n\n    ret += this.tp$name;\n    if (this.args) {\n        ret += \": \" + (this.args.v.length > 0 ? this.args.v[0].v : \"\");\n    }\n    if (this.traceback.length !== 0) {\n        ret += \" on line \" + this.traceback[0].lineno;\n    } else {\n        ret += \" at <unknown>\";\n    }\n\n    if (this.args.v.length > 4) {\n        ret += \"\\n\" + this.args.v[4].v + \"\\n\";\n        for (i = 0; i < this.args.v[3]; ++i) {\n            ret += \" \";\n        }\n        ret += \"^\\n\";\n    }\n\n    /*for (i = 0; i < this.traceback.length; i++) {\n        ret += \"\\n  at \" + this.traceback[i].filename + \" line \" + this.traceback[i].lineno;\n        if (\"colno\" in this.traceback[i]) {\n            ret += \" column \" + this.traceback[i].colno;\n        }\n    }*/\n\n    return new Sk.builtin.str(ret);\n};\n\nSk.builtin.BaseException.prototype.toString = function () {\n    return this.tp$str().v;\n};\n\n// Create a descriptor to return the 'args' of an exception.\n// This is a hack to get around a weird mismatch between builtin\n// objects and proper types\nSk.builtin.BaseException.prototype.args = {\n    \"tp$descr_get\": function(self, clstype) {\n        return self.args;\n    }\n};\n\nSk.exportSymbol(\"Sk.builtin.BaseException\", Sk.builtin.BaseException);\n\n/**\n * @constructor\n * @extends Sk.builtin.BaseException\n * @param {...*} args\n */\nSk.builtin.Exception = function (args) {\n    var o;\n    if (!(this instanceof Sk.builtin.Exception)) {\n        o = Object.create(Sk.builtin.Exception.prototype);\n        o.constructor.apply(o, arguments);\n        return o;\n    }\n    Sk.builtin.BaseException.apply(this, arguments);\n};\nSk.abstr.setUpInheritance(\"Exception\", Sk.builtin.Exception, Sk.builtin.BaseException);\nSk.exportSymbol(\"Sk.builtin.Exception\", Sk.builtin.Exception);\n\n/**\n * @constructor\n * @extends Sk.builtin.Exception\n * @param {...*} args\n */\nSk.builtin.StandardError = function (args) {\n    var o;\n    if (!(this instanceof Sk.builtin.StandardError)) {\n        o = Object.create(Sk.builtin.StandardError.prototype);\n        o.constructor.apply(o, arguments);\n        return o;\n    }\n    Sk.builtin.Exception.apply(this, arguments);\n};\nSk.abstr.setUpInheritance(\"StandardError\", Sk.builtin.StandardError, Sk.builtin.Exception);\nSk.exportSymbol(\"Sk.builtin.StandardError\", Sk.builtin.StandardError);\n\n/**\n * @constructor\n * @extends Sk.builtin.StandardError\n * @param {...*} args\n */\nSk.builtin.AssertionError = function (args) {\n    var o;\n    if (!(this instanceof Sk.builtin.AssertionError)) {\n        o = Object.create(Sk.builtin.AssertionError.prototype);\n        o.constructor.apply(o, arguments);\n        return o;\n    }\n    Sk.builtin.StandardError.apply(this, arguments);\n};\nSk.abstr.setUpInheritance(\"AssertionError\", Sk.builtin.AssertionError, Sk.builtin.StandardError);\nSk.exportSymbol(\"Sk.builtin.AssertionError\", Sk.builtin.AssertionError);\n\n/**\n * @constructor\n * @extends Sk.builtin.StandardError\n * @param {...*} args\n */\nSk.builtin.AttributeError = function (args) {\n    var o;\n    if (!(this instanceof Sk.builtin.AttributeError)) {\n        o = Object.create(Sk.builtin.AttributeError.prototype);\n        o.constructor.apply(o, arguments);\n        return o;\n    }\n    Sk.builtin.StandardError.apply(this, arguments);\n};\nSk.abstr.setUpInheritance(\"AttributeError\", Sk.builtin.AttributeError, Sk.builtin.StandardError);\n\n/**\n * @constructor\n * @extends Sk.builtin.StandardError\n * @param {...*} args\n */\nSk.builtin.ImportError = function (args) {\n    var o;\n    if (!(this instanceof Sk.builtin.ImportError)) {\n        o = Object.create(Sk.builtin.ImportError.prototype);\n        o.constructor.apply(o, arguments);\n        return o;\n    }\n    Sk.builtin.StandardError.apply(this, arguments);\n};\nSk.abstr.setUpInheritance(\"ImportError\", Sk.builtin.ImportError, Sk.builtin.StandardError);\n\n/**\n * @constructor\n * @extends Sk.builtin.StandardError\n * @param {...*} args\n */\nSk.builtin.IndentationError = function (args) {\n    var o;\n    if (!(this instanceof Sk.builtin.IndentationError)) {\n        o = Object.create(Sk.builtin.IndentationError.prototype);\n        o.constructor.apply(o, arguments);\n        return o;\n    }\n    Sk.builtin.StandardError.apply(this, arguments);\n};\nSk.abstr.setUpInheritance(\"IndentationError\", Sk.builtin.IndentationError, Sk.builtin.StandardError);\n\n/**\n * @constructor\n * @extends Sk.builtin.StandardError\n * @param {...*} args\n */\nSk.builtin.IndexError = function (args) {\n    var o;\n    if (!(this instanceof Sk.builtin.IndexError)) {\n        o = Object.create(Sk.builtin.IndexError.prototype);\n        o.constructor.apply(o, arguments);\n        return o;\n    }\n    Sk.builtin.StandardError.apply(this, arguments);\n};\nSk.abstr.setUpInheritance(\"IndexError\", Sk.builtin.IndexError, Sk.builtin.StandardError);\n\n/**\n * @constructor\n * @extends Sk.builtin.StandardError\n * @param {...*} args\n */\nSk.builtin.KeyError = function (args) {\n    var o;\n    if (!(this instanceof Sk.builtin.KeyError)) {\n        o = Object.create(Sk.builtin.KeyError.prototype);\n        o.constructor.apply(o, arguments);\n        return o;\n    }\n    Sk.builtin.StandardError.apply(this, arguments);\n};\nSk.abstr.setUpInheritance(\"KeyError\", Sk.builtin.KeyError, Sk.builtin.StandardError);\n\n/**\n * @constructor\n * @extends Sk.builtin.StandardError\n * @param {...*} args\n */\nSk.builtin.NameError = function (args) {\n    var o;\n    if (!(this instanceof Sk.builtin.NameError)) {\n        o = Object.create(Sk.builtin.NameError.prototype);\n        o.constructor.apply(o, arguments);\n        return o;\n    }\n    Sk.builtin.StandardError.apply(this, arguments);\n};\nSk.abstr.setUpInheritance(\"NameError\", Sk.builtin.NameError, Sk.builtin.StandardError);\n\n/**\n * @constructor\n * @extends Sk.builtin.StandardError\n * @param {...*} args\n */\nSk.builtin.UnboundLocalError = function (args) {\n    var o;\n    if (!(this instanceof Sk.builtin.UnboundLocalError)) {\n        o = Object.create(Sk.builtin.UnboundLocalError.prototype);\n        o.constructor.apply(o, arguments);\n        return o;\n    }\n    Sk.builtin.StandardError.apply(this, arguments);\n};\nSk.abstr.setUpInheritance(\"UnboundLocalError\", Sk.builtin.UnboundLocalError, Sk.builtin.StandardError);\n\n/**\n * @constructor\n * @extends Sk.builtin.StandardError\n * @param {...*} args\n */\nSk.builtin.OverflowError = function (args) {\n    var o;\n    if (!(this instanceof Sk.builtin.OverflowError)) {\n        o = Object.create(Sk.builtin.OverflowError.prototype);\n        o.constructor.apply(o, arguments);\n        return o;\n    }\n    Sk.builtin.StandardError.apply(this, arguments);\n};\nSk.abstr.setUpInheritance(\"OverflowError\", Sk.builtin.OverflowError, Sk.builtin.StandardError);\n\n\n/**\n * @constructor\n * @extends Sk.builtin.StandardError\n * @param {...*} args\n */\nSk.builtin.SyntaxError = function (args) {\n    var o;\n    if (!(this instanceof Sk.builtin.SyntaxError)) {\n        o = Object.create(Sk.builtin.SyntaxError.prototype);\n        o.constructor.apply(o, arguments);\n        return o;\n    }\n    Sk.builtin.StandardError.apply(this, arguments);\n};\nSk.abstr.setUpInheritance(\"SyntaxError\", Sk.builtin.SyntaxError, Sk.builtin.StandardError);\n\n/**\n * @constructor\n * @extends Sk.builtin.StandardError\n * @param {...*} args\n */\nSk.builtin.RuntimeError = function (args) {\n    var o;\n    if (!(this instanceof Sk.builtin.RuntimeError)) {\n        o = Object.create(Sk.builtin.RuntimeError.prototype);\n        o.constructor.apply(o, arguments);\n        return o;\n    }\n    Sk.builtin.StandardError.apply(this, arguments);\n};\nSk.abstr.setUpInheritance(\"RuntimeError\", Sk.builtin.RuntimeError, Sk.builtin.StandardError);\nSk.exportSymbol(\"Sk.builtin.RuntimeError\", Sk.builtin.RuntimeError);\n\n\n/**\n * @constructor\n * @extends Sk.builtin.StandardError\n * @param {...*} args\n */\nSk.builtin.SuspensionError = function (args) {\n    var o;\n    if (!(this instanceof Sk.builtin.SuspensionError)) {\n        o = Object.create(Sk.builtin.SuspensionError.prototype);\n        o.constructor.apply(o, arguments);\n        return o;\n    }\n    Sk.builtin.StandardError.apply(this, arguments);\n};\nSk.abstr.setUpInheritance(\"SuspensionError\", Sk.builtin.SuspensionError, Sk.builtin.StandardError);\nSk.exportSymbol(\"Sk.builtin.SuspensionError\", Sk.builtin.SuspensionError);\n\n\n/**\n * @constructor\n * @extends Sk.builtin.BaseException\n * @param {...*} args\n */\nSk.builtin.SystemExit = function (args) {\n    var o;\n    if (!(this instanceof Sk.builtin.SystemExit)) {\n        o = Object.create(Sk.builtin.SystemExit.prototype);\n        o.constructor.apply(o, arguments);\n        return o;\n    }\n    Sk.builtin.BaseException.apply(this, arguments);\n};\nSk.abstr.setUpInheritance(\"SystemExit\", Sk.builtin.SystemExit, Sk.builtin.BaseException);\nSk.exportSymbol(\"Sk.builtin.SystemExit\", Sk.builtin.SystemExit);\n\n\n/**\n * @constructor\n * @extends Sk.builtin.StandardError\n * @param {...*} args\n */\nSk.builtin.TypeError = function (args) {\n    var o;\n    if (!(this instanceof Sk.builtin.TypeError)) {\n        o = Object.create(Sk.builtin.TypeError.prototype);\n        o.constructor.apply(o, arguments);\n        return o;\n    }\n    Sk.builtin.StandardError.apply(this, arguments);\n};\nSk.abstr.setUpInheritance(\"TypeError\", Sk.builtin.TypeError, Sk.builtin.StandardError);\nSk.exportSymbol(\"Sk.builtin.TypeError\", Sk.builtin.TypeError);\n/**\n * @constructor\n * @extends Sk.builtin.StandardError\n * @param {...*} args\n */\nSk.builtin.ValueError = function (args) {\n    var o;\n    if (!(this instanceof Sk.builtin.ValueError)) {\n        o = Object.create(Sk.builtin.ValueError.prototype);\n        o.constructor.apply(o, arguments);\n        return o;\n    }\n    Sk.builtin.StandardError.apply(this, arguments);\n};\nSk.abstr.setUpInheritance(\"ValueError\", Sk.builtin.ValueError, Sk.builtin.StandardError);\nSk.exportSymbol(\"Sk.builtin.ValueError\", Sk.builtin.ValueError);\n\n/**\n * @constructor\n * @extends Sk.builtin.StandardError\n * @param {...*} args\n */\nSk.builtin.ZeroDivisionError = function (args) {\n    var o;\n    if (!(this instanceof Sk.builtin.ZeroDivisionError)) {\n        o = Object.create(Sk.builtin.ZeroDivisionError.prototype);\n        o.constructor.apply(o, arguments);\n        return o;\n    }\n    Sk.builtin.StandardError.apply(this, arguments);\n};\nSk.abstr.setUpInheritance(\"ZeroDivisionError\", Sk.builtin.ZeroDivisionError, Sk.builtin.StandardError);\n\n/**\n * @constructor\n * @extends Sk.builtin.StandardError\n * @param {...*} args\n */\nSk.builtin.TimeLimitError = function (args) {\n    var o;\n    if (!(this instanceof Sk.builtin.TimeLimitError)) {\n        o = Object.create(Sk.builtin.TimeLimitError.prototype);\n        o.constructor.apply(o, arguments);\n        return o;\n    }\n    Sk.builtin.StandardError.apply(this, arguments);\n};\nSk.abstr.setUpInheritance(\"TimeLimitError\", Sk.builtin.TimeLimitError, Sk.builtin.StandardError);\nSk.exportSymbol(\"Sk.builtin.TimeLimitError\", Sk.builtin.TimeLimitError);\n\n/**\n * @constructor\n * @extends Sk.builtin.StandardError\n * @param {...*} args\n */\nSk.builtin.IOError = function (args) {\n    var o;\n    if (!(this instanceof Sk.builtin.IOError)) {\n        o = Object.create(Sk.builtin.IOError.prototype);\n        o.constructor.apply(o, arguments);\n        return o;\n    }\n    Sk.builtin.StandardError.apply(this, arguments);\n};\nSk.abstr.setUpInheritance(\"IOError\", Sk.builtin.IOError, Sk.builtin.StandardError);\nSk.exportSymbol(\"Sk.builtin.IOError\", Sk.builtin.IOError);\n\n\n/**\n * @constructor\n * @extends Sk.builtin.StandardError\n * @param {...*} args\n */\nSk.builtin.NotImplementedError = function (args) {\n    var o;\n    if (!(this instanceof Sk.builtin.NotImplementedError)) {\n        o = Object.create(Sk.builtin.NotImplementedError.prototype);\n        o.constructor.apply(o, arguments);\n        return o;\n    }\n    Sk.builtin.StandardError.apply(this, arguments);\n};\nSk.abstr.setUpInheritance(\"NotImplementedError\", Sk.builtin.NotImplementedError, Sk.builtin.StandardError);\nSk.exportSymbol(\"Sk.builtin.NotImplementedError\", Sk.builtin.NotImplementedError);\n\n/**\n * @constructor\n * @extends Sk.builtin.StandardError\n * @param {...*} args\n */\nSk.builtin.NegativePowerError = function (args) {\n    var o;\n    if (!(this instanceof Sk.builtin.NegativePowerError)) {\n        o = Object.create(Sk.builtin.NegativePowerError.prototype);\n        o.constructor.apply(o, arguments);\n        return o;\n    }\n    Sk.builtin.StandardError.apply(this, arguments);\n};\nSk.abstr.setUpInheritance(\"NegativePowerError\", Sk.builtin.NegativePowerError, Sk.builtin.StandardError);\nSk.exportSymbol(\"Sk.builtin.NegativePowerError\", Sk.builtin.NegativePowerError);\n\n/**\n * @constructor\n * @extends Sk.builtin.StandardError\n * @param {*} nativeError\n * @param {...*} args\n */\nSk.builtin.ExternalError = function (nativeError, args) {\n    var o;\n    if (!(this instanceof Sk.builtin.ExternalError)) {\n        o = Object.create(Sk.builtin.ExternalError.prototype);\n        o.constructor.apply(o, arguments);\n        return o;\n    }\n    // Make the first argument a string, so it can be printed in Python without errors,\n    // but save a reference to the real thing for Javascript consumption\n    args = Array.prototype.slice.call(arguments);\n    this.nativeError = args[0];\n    if (!(args[0] instanceof Sk.builtin.str)) {\n        args[0] = \"\"+args[0];\n    }\n    Sk.builtin.StandardError.apply(this, args);\n};\nSk.abstr.setUpInheritance(\"ExternalError\", Sk.builtin.ExternalError, Sk.builtin.StandardError);\nSk.exportSymbol(\"Sk.builtin.ExternalError\", Sk.builtin.ExternalError);\n\n/**\n * @constructor\n * @extends Sk.builtin.StandardError\n * @param {...*} args\n */\nSk.builtin.OperationError = function (args) {\n    var o;\n    if (!(this instanceof Sk.builtin.OperationError)) {\n        o = Object.create(Sk.builtin.OperationError.prototype);\n        o.constructor.apply(o, arguments);\n        return o;\n    }\n    Sk.builtin.StandardError.apply(this, arguments);\n};\nSk.abstr.setUpInheritance(\"OperationError\", Sk.builtin.OperationError, Sk.builtin.StandardError);\nSk.exportSymbol(\"Sk.builtin.OperationError\", Sk.builtin.OperationError);\n\n/**\n * @constructor\n * @extends Sk.builtin.StandardError\n * @param {...*} args\n */\nSk.builtin.SystemError = function (args) {\n    var o;\n    if (!(this instanceof Sk.builtin.SystemError)) {\n        o = Object.create(Sk.builtin.SystemError.prototype);\n        o.constructor.apply(o, arguments);\n        return o;\n    }\n    Sk.builtin.StandardError.apply(this, arguments);\n};\nSk.abstr.setUpInheritance(\"SystemError\", Sk.builtin.SystemError, Sk.builtin.StandardError);\nSk.exportSymbol(\"Sk.builtin.SystemError\", Sk.builtin.SystemError);\n\n/**\n * @constructor\n * @extends Sk.builtin.Exception\n * @param {...*} args\n */\nSk.builtin.StopIteration = function (args) {\n    var o;\n    if (!(this instanceof Sk.builtin.StopIteration)) {\n        o = Object.create(Sk.builtin.StopIteration.prototype);\n        o.constructor.apply(o, arguments);\n        return o;\n    }\n    Sk.builtin.Exception.apply(this, arguments);\n};\nSk.abstr.setUpInheritance(\"StopIteration\", Sk.builtin.StopIteration, Sk.builtin.Exception);\nSk.exportSymbol(\"Sk.builtin.StopIteration\", Sk.builtin.StopIteration);\n\n\n// TODO: Extract into sys.exc_info(). Work out how the heck\n// to find out what exceptions are being processed by parent stack frames...\nSk.builtin.getExcInfo = function(e) {\n    var v = [e.ob$type || Sk.builtin.none.none$, e, Sk.builtin.none.none$];\n\n    // TODO create a Traceback object for the third tuple element\n\n    return new Sk.builtin.tuple(v);\n};\n// NOT exported\n\n","/**\n * @constructor\n *\n * @param {Sk.builtin.func|Sk.builtin.method} func\n * @param {Object} self\n * @param {Sk.builtin.type|Sk.builtin.none} klass\n * @param {boolean=} builtin\n * \n * co_varnames and co_name come from generated code, must access as dict.\n */\nSk.builtin.method = function (func, self, klass, builtin) {\n    if (!(this instanceof Sk.builtin.method)) {\n        Sk.builtin.pyCheckArgsLen(\"method\", arguments.length, 3, 3);\n        if (!Sk.builtin.checkCallable(func)) {\n            throw new Sk.builtin.TypeError(\"First argument must be callable\");\n        }\n        if (self.ob$type === undefined) {\n            throw new Sk.builtin.TypeError(\"Second argument must be object of known type\");\n        }\n        return new Sk.builtin.method(func, self, klass);\n    }\n    this.tp$name = func.tp$name;\n    this.im_func = func;\n    this.im_self = self || Sk.builtin.none.none$;\n    this.im_class = klass || Sk.builtin.none.none$;\n    this.im_builtin = builtin;\n    this[\"$d\"] = {\n        im_func: func,\n        im_self: self,\n        im_class: klass\n    };\n};\n\nSk.exportSymbol(\"Sk.builtin.method\", Sk.builtin.method);\nSk.abstr.setUpInheritance(\"instancemethod\", Sk.builtin.method, Sk.builtin.object);\n\nSk.builtin.method.prototype.tp$name = \"method\";\n\nSk.builtin.method.prototype.ob$eq = function (other) {\n    if (((this.im_self == Sk.builtin.none.none$) && (other.im_self != Sk.builtin.none.none$)) ||  ((other.im_self == Sk.builtin.none.none$) && (this.im_self != Sk.builtin.none.none$))) {\n        return false;\n    }\n    try {\n        return Sk.misceval.richCompareBool(this.im_self, other.im_self, \"Eq\", false) && (this.im_func == other.im_func);\n    } catch (x) {\n        return false;\n    }\n};\n\nSk.builtin.method.prototype.ob$ne = function (other) {\n    return !(this.ob$eq(other));\n};\n\nSk.builtin.method.prototype.tp$hash = function () {\n    var selfhash, funchash;\n\n    if (this.im_self == Sk.builtin.none.none$) {\n        selfhash = 0;\n    } else {\n        selfhash = Sk.builtin.asnum$(Sk.builtin.hash(this.im_self));\n    }\n    funchash = Sk.builtin.asnum$(Sk.builtin.hash(this.im_func));\n\n    return new Sk.builtin.int_(selfhash + funchash);\n};\n\nSk.builtin.method.prototype.tp$call = function (args, kw) {\n    // Sk.asserts.assert(this.im_func instanceof Sk.builtin.func);\n\n    // 'args' and 'kw' get mucked around with heavily in applyOrSuspend();\n    // changing it here is OK.\n    if (this.im_self !== Sk.builtin.none.none$) {\n        args.unshift(this.im_self);\n    }\n\n    // if there is no first argument or\n    // if the first argument is not a subclass of the class this method belongs to we throw an error\n    // unless it's a builtin method, because they shouldn't have been __get__ and left in this unbound\n    // state.\n    if (this.im_self === Sk.builtin.none.none$) {\n        var getMessage = (function (reason) {\n            return \"unbound method \" + this.tp$name + \"() must be called with \" + Sk.abstr.typeName(this.im_class) + \" instance as first argument (got \" + reason + \" instead)\";\n        }).bind(this);\n\n        if (args.length > 0) {\n            if (this.im_class != Sk.builtin.none.none$ && !Sk.builtin.issubclass(args[0].ob$type, this.im_class) && !this.im_builtin) {\n                throw new Sk.builtin.TypeError(getMessage(Sk.abstr.typeName(args[0].ob$type) + \" instance\"));\n            }\n        } else {\n            throw new Sk.builtin.TypeError(getMessage(\"nothing\"));\n        }\n    }\n\n    // A method call is just a call to this.im_func with 'self' on the beginning of the args.\n    // Do the necessary.\n    return this.im_func.tp$call(args, kw);\n};\n\nSk.builtin.method.prototype.tp$descr_get = function (obj, objtype) {\n    Sk.asserts.assert(obj !== undefined && objtype !== undefined);\n    return new Sk.builtin.method(this, obj, objtype, this.im_builtin);\n};\n\nSk.builtin.method.pythonFunctions = [\"__get__\"];\n\nSk.builtin.method.prototype.__get__ = function __get__(self, instance, owner) {\n    Sk.builtin.pyCheckArgsLen(\"__get__\", arguments.length, 1, 2, false, true);\n    if (instance === Sk.builtin.none.none$ && owner === Sk.builtin.none.none$) {\n        throw new Sk.builtin.TypeError(\"__get__(None, None) is invalid\");\n    }\n\n    // if the owner is specified it needs to be a a subclass of im_self\n    if (owner && owner !== Sk.builtin.none.none$) {\n        if (Sk.builtin.issubclass(owner, self.im_class)) {\n            return self.tp$descr_get(instance, owner);\n        }\n\n        // if it's not we're not bound\n        return self;\n    }\n\n    // use the original type to get a bound object\n    return self.tp$descr_get(instance, Sk.builtin.none.none$);\n};\n\nSk.builtin.method.prototype[\"$r\"] = function () {\n    if (this.im_builtin) {\n        return new Sk.builtin.str(\"<built-in method \" + this.tp$name + \" of type object>\");\n    }\n\n    if (this.im_self === Sk.builtin.none.none$) {\n        return new Sk.builtin.str(\"<unbound method \" + Sk.abstr.typeName(this.im_class) + \".\" + this.tp$name + \">\");\n    }\n\n    var owner = this.im_class !== Sk.builtin.none.none$ ? Sk.abstr.typeName(this.im_class) : \"?\";\n    return new Sk.builtin.str(\"<bound method \" + owner  + \".\" + this.tp$name + \" of \" + Sk.ffi.remapToJs(Sk.misceval.objectRepr(this.im_self)) + \">\");\n};\n","/**\n * @namespace Sk.misceval\n *\n */\nSk.misceval = {};\n\n/*\n  Suspension object format:\n  {resume: function() {...}, // the continuation - returns either another suspension or the return value\n   data: <copied down from innermost level>,\n   optional: <if true, can be resumed immediately (eg debug stops)>,\n   child: <Suspension, or null if we are the innermost level>,\n   $blk: <>, $loc: <>, $gbl: <>, $exc: <>, $err: <>, [$cell: <>],\n  }\n*/\n\n/**\n *\n * Hi kids lets make a suspension...\n * @constructor\n * @param{function(?)=} resume A function to be called on resume. child is resumed first and its return value is passed to this function.\n * @param{Object=} child A child suspension. 'optional' will be copied from here if supplied.\n * @param{Object=} data Data attached to this suspension. Will be copied from child if not supplied.\n */\nSk.misceval.Suspension = function Suspension(resume, child, data) {\n    this.$isSuspension = true;\n    if (resume !== undefined && child !== undefined) {\n        this.resume = function() { return resume(child.resume()); };\n    }\n    this.child = child;\n    this.optional = child !== undefined && child.optional;\n    if (data === undefined && child !== undefined) {\n        this.data = child.data;\n    } else {\n        this.data = data;\n    }\n};\nSk.exportSymbol(\"Sk.misceval.Suspension\", Sk.misceval.Suspension);\n\n/**\n *\n * Well this seems pretty obvious by the name what it should do..\n *\n * @param{Sk.misceval.Suspension} susp\n * @param{string=} message\n */\nSk.misceval.retryOptionalSuspensionOrThrow = function (susp, message) {\n    while (susp instanceof Sk.misceval.Suspension) {\n        if (!susp.optional) {\n            throw new Sk.builtin.SuspensionError(message || \"Cannot call a function that blocks or suspends here\");\n        }\n        susp = susp.resume();\n    }\n    return susp;\n};\nSk.exportSymbol(\"Sk.misceval.retryOptionalSuspensionOrThrow\", Sk.misceval.retryOptionalSuspensionOrThrow);\n\n/**\n * Check if the given object is valid to use as an index. Only ints, or if the object has an `__index__` method.\n * @param o\n * @returns {boolean}\n */\nSk.misceval.isIndex = function (o) {\n    if (Sk.builtin.checkInt(o)) {\n        return true;\n    }\n    if (Sk.abstr.lookupSpecial(o, Sk.builtin.str.$index)) {\n        return true;\n    }\n    return false;\n};\nSk.exportSymbol(\"Sk.misceval.isIndex\", Sk.misceval.isIndex);\n\nSk.misceval.asIndex = function (o) {\n    var idxfn, ret;\n\n    if (!Sk.misceval.isIndex(o)) {\n        return undefined;\n    }\n    if (o === null) {\n        return undefined;\n    }\n    if (o === true) {\n        return 1;\n    }\n    if (o === false) {\n        return 0;\n    }\n    if (typeof o === \"number\") {\n        return o;\n    }\n    if (o.constructor === Sk.builtin.int_) {\n        return o.v;\n    }\n    if (o.constructor === Sk.builtin.lng) {\n        return o.tp$index();\n    }\n    if (o.constructor === Sk.builtin.bool) {\n        return Sk.builtin.asnum$(o);\n    }\n    idxfn = Sk.abstr.lookupSpecial(o, Sk.builtin.str.$index);\n    if (idxfn) {\n        ret = Sk.misceval.callsimArray(idxfn, [o]);\n        if (!Sk.builtin.checkInt(ret)) {\n            throw new Sk.builtin.TypeError(\"__index__ returned non-(int,long) (type \" +\n                                           Sk.abstr.typeName(ret) + \")\");\n        }\n        return Sk.builtin.asnum$(ret);\n    }\n    Sk.asserts.fail(\"todo asIndex;\");\n};\n\n/**\n * return u[v:w]\n */\nSk.misceval.applySlice = function (u, v, w, canSuspend) {\n    var ihigh;\n    var ilow;\n    if (u.sq$slice && Sk.misceval.isIndex(v) && Sk.misceval.isIndex(w)) {\n        ilow = Sk.misceval.asIndex(v);\n        if (ilow === undefined) {\n            ilow = 0;\n        }\n        ihigh = Sk.misceval.asIndex(w);\n        if (ihigh === undefined) {\n            ihigh = 1e100;\n        }\n        return Sk.abstr.sequenceGetSlice(u, ilow, ihigh);\n    }\n    return Sk.abstr.objectGetItem(u, new Sk.builtin.slice(v, w, null), canSuspend);\n};\nSk.exportSymbol(\"Sk.misceval.applySlice\", Sk.misceval.applySlice);\n\n/**\n * u[v:w] = x\n */\nSk.misceval.assignSlice = function (u, v, w, x, canSuspend) {\n    var slice;\n    var ihigh;\n    var ilow;\n    if (u.sq$ass_slice && Sk.misceval.isIndex(v) && Sk.misceval.isIndex(w)) {\n        ilow = Sk.misceval.asIndex(v) || 0;\n        ihigh = Sk.misceval.asIndex(w) || 1e100;\n        if (x === null) {\n            Sk.abstr.sequenceDelSlice(u, ilow, ihigh);\n        } else {\n            Sk.abstr.sequenceSetSlice(u, ilow, ihigh, x);\n        }\n    } else {\n        slice = new Sk.builtin.slice(v, w);\n        if (x === null) {\n            return Sk.abstr.objectDelItem(u, slice);\n        } else {\n            return Sk.abstr.objectSetItem(u, slice, x, canSuspend);\n        }\n    }\n};\nSk.exportSymbol(\"Sk.misceval.assignSlice\", Sk.misceval.assignSlice);\n\n/**\n * Used by min() and max() to get an array from arbitrary input.\n * Note that this does no validation, just coercion.\n */\nSk.misceval.arrayFromArguments = function (args) {\n    // If args is not a single thing return as is\n    var it, i;\n    var res;\n    var arg;\n    if (args.length != 1) {\n        return args;\n    }\n    arg = args[0];\n    if (arg instanceof Sk.builtin.set) {\n        // this is a Sk.builtin.set\n        arg = arg.tp$iter().$obj;\n    } else if (arg instanceof Sk.builtin.dict) {\n        // this is a Sk.builtin.list\n        arg = Sk.builtin.dict.prototype[\"keys\"].func_code(arg);\n    }\n\n    // shouldn't else if here as the above may output lists to arg.\n    if (arg instanceof Sk.builtin.list || arg instanceof Sk.builtin.tuple) {\n        return arg.v;\n    } else if (Sk.builtin.checkIterable(arg)) {\n        // handle arbitrary iterable (strings, generators, etc.)\n        res = [];\n        for (it = Sk.abstr.iter(arg), i = it.tp$iternext();\n            i !== undefined; i = it.tp$iternext()) {\n            res.push(i);\n        }\n        return res;\n    }\n\n    throw new Sk.builtin.TypeError(\"'\" + Sk.abstr.typeName(arg) + \"' object is not iterable\");\n};\nSk.exportSymbol(\"Sk.misceval.arrayFromArguments\", Sk.misceval.arrayFromArguments);\n\n/**\n * for reversed comparison: Gt -> Lt, etc.\n */\nSk.misceval.swappedOp_ = {\n    \"Eq\"   : \"Eq\",\n    \"NotEq\": \"NotEq\",\n    \"Lt\"   : \"GtE\",\n    \"LtE\"  : \"Gt\",\n    \"Gt\"   : \"LtE\",\n    \"GtE\"  : \"Lt\",\n    \"Is\"   : \"IsNot\",\n    \"IsNot\": \"Is\",\n    \"In_\"  : \"NotIn\",\n    \"NotIn\": \"In_\"\n};\n\n/**\n* @param{*} v\n* @param{*} w\n* @param{string} op\n* @param{boolean=} canSuspend\n */\nSk.misceval.richCompareBool = function (v, w, op, canSuspend) {\n    // v and w must be Python objects. will return Javascript true or false for internal use only\n    // if you want to return a value from richCompareBool to Python you must wrap as Sk.builtin.bool first\n    var wname,\n        vname,\n        ret,\n        swapped_method,\n        method,\n        swapped_shortcut,\n        shortcut,\n        v_has_shortcut,\n        w_has_shortcut,\n        op2shortcut,\n        vcmp,\n        wcmp,\n        w_seq_type,\n        w_num_type,\n        v_seq_type,\n        v_num_type,\n        sequence_types,\n        numeric_types,\n        w_type,\n        v_type;\n\n    Sk.asserts.assert((v !== null) && (v !== undefined), \"passed null or undefined parameter to Sk.misceval.richCompareBool\");\n    Sk.asserts.assert((w !== null) && (w !== undefined), \"passed null or undefined parameter to Sk.misceval.richCompareBool\");\n\n    v_type = new Sk.builtin.type(v);\n    w_type = new Sk.builtin.type(w);\n\n    // Python has specific rules when comparing two different builtin types\n    // currently, this code will execute even if the objects are not builtin types\n    // but will fall through and not return anything in this section\n    if ((v_type !== w_type) &&\n        (op === \"GtE\" || op === \"Gt\" || op === \"LtE\" || op === \"Lt\")) {\n        // note: sets are omitted here because they can only be compared to other sets\n        numeric_types = [Sk.builtin.float_.prototype.ob$type,\n                         Sk.builtin.int_.prototype.ob$type,\n                         Sk.builtin.lng.prototype.ob$type,\n                         Sk.builtin.bool.prototype.ob$type];\n        sequence_types = [Sk.builtin.dict.prototype.ob$type,\n                          Sk.builtin.enumerate.prototype.ob$type,\n                          Sk.builtin.list.prototype.ob$type,\n                          Sk.builtin.str.prototype.ob$type,\n                          Sk.builtin.tuple.prototype.ob$type];\n\n        v_num_type = numeric_types.indexOf(v_type);\n        v_seq_type = sequence_types.indexOf(v_type);\n        w_num_type = numeric_types.indexOf(w_type);\n        w_seq_type = sequence_types.indexOf(w_type);\n\n        // NoneTypes are considered less than any other type in Python\n        // note: this only handles comparing NoneType with any non-NoneType.\n        // Comparing NoneType with NoneType is handled further down.\n        if (v_type === Sk.builtin.none.prototype.ob$type) {\n            switch (op) {\n                case \"Lt\":\n                    return true;\n                case \"LtE\":\n                    return true;\n                case \"Gt\":\n                    return false;\n                case \"GtE\":\n                    return false;\n            }\n        }\n\n        if (w_type === Sk.builtin.none.prototype.ob$type) {\n            switch (op) {\n                case \"Lt\":\n                    return false;\n                case \"LtE\":\n                    return false;\n                case \"Gt\":\n                    return true;\n                case \"GtE\":\n                    return true;\n            }\n        }\n\n        // numeric types are always considered smaller than sequence types in Python\n        if (v_num_type !== -1 && w_seq_type !== -1) {\n            switch (op) {\n                case \"Lt\":\n                    return true;\n                case \"LtE\":\n                    return true;\n                case \"Gt\":\n                    return false;\n                case \"GtE\":\n                    return false;\n            }\n        }\n\n        if (v_seq_type !== -1 && w_num_type !== -1) {\n            switch (op) {\n                case \"Lt\":\n                    return false;\n                case \"LtE\":\n                    return false;\n                case \"Gt\":\n                    return true;\n                case \"GtE\":\n                    return true;\n            }\n        }\n\n        // in Python, different sequence types are ordered alphabetically\n        // by name so that dict < list < str < tuple\n        if (v_seq_type !== -1 && w_seq_type !== -1) {\n            switch (op) {\n                case \"Lt\":\n                    return v_seq_type < w_seq_type;\n                case \"LtE\":\n                    return v_seq_type <= w_seq_type;\n                case \"Gt\":\n                    return v_seq_type > w_seq_type;\n                case \"GtE\":\n                    return v_seq_type >= w_seq_type;\n            }\n        }\n    }\n\n\n    // handle identity and membership comparisons\n    if (op === \"Is\") {\n        if (v instanceof Sk.builtin.int_ && w instanceof Sk.builtin.int_) {\n            return v.numberCompare(w) === 0;\n        } else if (v instanceof Sk.builtin.float_ && w instanceof Sk.builtin.float_) {\n            return v.numberCompare(w) === 0;\n        } else if (v instanceof Sk.builtin.lng && w instanceof Sk.builtin.lng) {\n            return v.longCompare(w) === 0;\n        }\n\n        return v === w;\n    }\n\n    if (op === \"IsNot\") {\n        if (v instanceof Sk.builtin.int_ && w instanceof Sk.builtin.int_) {\n            return v.numberCompare(w) !== 0;\n        } else if (v instanceof Sk.builtin.float_ && w instanceof Sk.builtin.float_) {\n            return v.numberCompare(w) !== 0;\n        }else if (v instanceof Sk.builtin.lng && w instanceof Sk.builtin.lng) {\n            return v.longCompare(w) !== 0;\n        }\n\n        return v !== w;\n    }\n\n    if (op === \"In\") {\n        return Sk.misceval.chain(Sk.abstr.sequenceContains(w, v, canSuspend), Sk.misceval.isTrue);\n    }\n    if (op === \"NotIn\") {\n        return Sk.misceval.chain(\n            Sk.abstr.sequenceContains(w, v, canSuspend),\n            function(x) { return !Sk.misceval.isTrue(x); }\n        );\n    }\n\n    // Call Javascript shortcut method if exists for either object\n\n    op2shortcut = {\n        \"Eq\"   : \"ob$eq\",\n        \"NotEq\": \"ob$ne\",\n        \"Gt\"   : \"ob$gt\",\n        \"GtE\"  : \"ob$ge\",\n        \"Lt\"   : \"ob$lt\",\n        \"LtE\"  : \"ob$le\"\n    };\n\n    shortcut = op2shortcut[op];\n    v_has_shortcut = v.constructor.prototype.hasOwnProperty(shortcut);\n    if (v_has_shortcut) {\n        if ((ret = v[shortcut](w)) !== Sk.builtin.NotImplemented.NotImplemented$) {\n            return Sk.misceval.isTrue(ret);\n        }\n    }\n\n    swapped_shortcut = op2shortcut[Sk.misceval.swappedOp_[op]];\n    w_has_shortcut = w.constructor.prototype.hasOwnProperty(swapped_shortcut);\n    if (w_has_shortcut) {\n\n        if ((ret = w[swapped_shortcut](v)) !== Sk.builtin.NotImplemented.NotImplemented$) {\n            return Sk.misceval.isTrue(ret);\n        }\n    }\n\n    // use comparison methods if they are given for either object\n    if (v.tp$richcompare && (ret = v.tp$richcompare(w, op)) !== undefined) {\n        if (ret != Sk.builtin.NotImplemented.NotImplemented$) {\n            return Sk.misceval.isTrue(ret);\n        }\n    }\n\n    if (w.tp$richcompare && (ret = w.tp$richcompare(v, Sk.misceval.swappedOp_[op])) !== undefined) {\n        if (ret != Sk.builtin.NotImplemented.NotImplemented$) {\n            return Sk.misceval.isTrue(ret);\n        }\n    }\n\n\n    // depending on the op, try left:op:right, and if not, then\n    // right:reversed-top:left\n\n    method = Sk.abstr.lookupSpecial(v, Sk.misceval.op2method_[op]);\n    if (method && !v_has_shortcut) {\n        ret = Sk.misceval.callsimArray(method, [v, w]);\n        if (ret != Sk.builtin.NotImplemented.NotImplemented$) {\n            return Sk.misceval.isTrue(ret);\n        }\n    }\n\n    swapped_method = Sk.abstr.lookupSpecial(w, Sk.misceval.op2method_[Sk.misceval.swappedOp_[op]]);\n    if (swapped_method && !w_has_shortcut) {\n        ret = Sk.misceval.callsimArray(swapped_method, [w, v]);\n        if (ret != Sk.builtin.NotImplemented.NotImplemented$) {\n            return Sk.misceval.isTrue(ret);\n        }\n    }\n\n    vcmp = Sk.abstr.lookupSpecial(v, Sk.builtin.str.$cmp);\n    if (vcmp) {\n        try {\n            ret = Sk.misceval.callsimArray(vcmp, [v, w]);\n            if (Sk.builtin.checkNumber(ret)) {\n                ret = Sk.builtin.asnum$(ret);\n                if (op === \"Eq\") {\n                    return ret === 0;\n                } else if (op === \"NotEq\") {\n                    return ret !== 0;\n                } else if (op === \"Lt\") {\n                    return ret < 0;\n                } else if (op === \"Gt\") {\n                    return ret > 0;\n                } else if (op === \"LtE\") {\n                    return ret <= 0;\n                } else if (op === \"GtE\") {\n                    return ret >= 0;\n                }\n            }\n\n            if (ret !== Sk.builtin.NotImplemented.NotImplemented$) {\n                throw new Sk.builtin.TypeError(\"comparison did not return an int\");\n            }\n        } catch (e) {\n            throw new Sk.builtin.TypeError(\"comparison did not return an int\");\n        }\n    }\n\n    wcmp = Sk.abstr.lookupSpecial(w, Sk.builtin.str.$cmp);\n    if (wcmp) {\n        // note, flipped on return value and call\n        try {\n            ret = Sk.misceval.callsimArray(wcmp, [w, v]);\n            if (Sk.builtin.checkNumber(ret)) {\n                ret = Sk.builtin.asnum$(ret);\n                if (op === \"Eq\") {\n                    return ret === 0;\n                } else if (op === \"NotEq\") {\n                    return ret !== 0;\n                } else if (op === \"Lt\") {\n                    return ret > 0;\n                } else if (op === \"Gt\") {\n                    return ret < 0;\n                } else if (op === \"LtE\") {\n                    return ret >= 0;\n                } else if (op === \"GtE\") {\n                    return ret <= 0;\n                }\n            }\n\n            if (ret !== Sk.builtin.NotImplemented.NotImplemented$) {\n                throw new Sk.builtin.TypeError(\"comparison did not return an int\");\n            }\n        } catch (e) {\n            throw new Sk.builtin.TypeError(\"comparison did not return an int\");\n        }\n    }\n\n    // handle special cases for comparing None with None or Bool with Bool\n    if (((v instanceof Sk.builtin.none) && (w instanceof Sk.builtin.none)) ||\n        ((v instanceof Sk.builtin.bool) && (w instanceof Sk.builtin.bool))) {\n        // Javascript happens to return the same values when comparing null\n        // with null or true/false with true/false as Python does when\n        // comparing None with None or True/False with True/False\n\n        if (op === \"Eq\") {\n            return v.v === w.v;\n        }\n        if (op === \"NotEq\") {\n            return v.v !== w.v;\n        }\n        if (op === \"Gt\") {\n            return v.v > w.v;\n        }\n        if (op === \"GtE\") {\n            return v.v >= w.v;\n        }\n        if (op === \"Lt\") {\n            return v.v < w.v;\n        }\n        if (op === \"LtE\") {\n            return v.v <= w.v;\n        }\n    }\n\n\n    // handle equality comparisons for any remaining objects\n    if (op === \"Eq\") {\n        if ((v instanceof Sk.builtin.str) && (w instanceof Sk.builtin.str)) {\n            return v.v === w.v;\n        }\n        return v === w;\n    }\n    if (op === \"NotEq\") {\n        if ((v instanceof Sk.builtin.str) && (w instanceof Sk.builtin.str)) {\n            return v.v !== w.v;\n        }\n        return v !== w;\n    }\n\n    vname = Sk.abstr.typeName(v);\n    wname = Sk.abstr.typeName(w);\n    throw new Sk.builtin.ValueError(\"don't know how to compare '\" + vname + \"' and '\" + wname + \"'\");\n};\nSk.exportSymbol(\"Sk.misceval.richCompareBool\", Sk.misceval.richCompareBool);\n\nSk.misceval.objectRepr = function (v) {\n    Sk.asserts.assert(v !== undefined, \"trying to repr undefined\");\n    if ((v === null) || (v instanceof Sk.builtin.none)) {\n        return new Sk.builtin.str(\"None\");\n    } else if (v === true) {\n        // todo; these should be consts\n        return new Sk.builtin.str(\"True\");\n    } else if (v === false) {\n        return new Sk.builtin.str(\"False\");\n    } else if (typeof v === \"number\") {\n        return new Sk.builtin.str(\"\" + v);\n    } else if (typeof v === \"string\") {\n        return new Sk.builtin.str(v);\n    } else if (!v[\"$r\"]) {\n        if (v.tp$name) {\n            return new Sk.builtin.str(\"<\" + v.tp$name + \" object>\");\n        } else {\n            return new Sk.builtin.str(\"<unknown>\");\n        }\n    } else if (v.constructor === Sk.builtin.float_) {\n        if (v.v === Infinity) {\n            return new Sk.builtin.str(\"inf\");\n        } else if (v.v === -Infinity) {\n            return new Sk.builtin.str(\"-inf\");\n        } else {\n            return v[\"$r\"]();\n        }\n    } else if (v.constructor === Sk.builtin.int_) {\n        return v[\"$r\"]();\n    } else {\n        return v[\"$r\"]();\n    }\n};\nSk.exportSymbol(\"Sk.misceval.objectRepr\", Sk.misceval.objectRepr);\n\nSk.misceval.opAllowsEquality = function (op) {\n    switch (op) {\n        case \"LtE\":\n        case \"Eq\":\n        case \"GtE\":\n            return true;\n    }\n    return false;\n};\nSk.exportSymbol(\"Sk.misceval.opAllowsEquality\", Sk.misceval.opAllowsEquality);\n\nSk.misceval.isTrue = function (x) {\n    var ret;\n    if (x === true) {\n        return true;\n    }\n    if (x === false) {\n        return false;\n    }\n    if (x === null) {\n        return false;\n    }\n    if (x.constructor === Sk.builtin.none) {\n        return false;\n    }\n\n    if (x.constructor === Sk.builtin.NotImplemented) {\n        return false;\n    }\n\n    if (x.constructor === Sk.builtin.bool) {\n        return x.v;\n    }\n    if (typeof x === \"number\") {\n        return x !== 0;\n    }\n    if (x instanceof Sk.builtin.lng) {\n        return x.nb$nonzero();\n    }\n    if (x.constructor === Sk.builtin.int_) {\n        return x.v !== 0;\n    }\n    if (x.constructor === Sk.builtin.float_) {\n        return x.v !== 0;\n    }\n    if (x[\"__nonzero__\"]) {\n        ret = Sk.misceval.callsimArray(x[\"__nonzero__\"], [x]);\n        if (!Sk.builtin.checkInt(ret)) {\n            throw new Sk.builtin.TypeError(\"__nonzero__ should return an int\");\n        }\n        return Sk.builtin.asnum$(ret) !== 0;\n    }\n    if (x[\"__len__\"]) {\n        ret = Sk.misceval.callsimArray(x[\"__len__\"], [x]);\n        if (!Sk.builtin.checkInt(ret)) {\n            throw new Sk.builtin.TypeError(\"__len__ should return an int\");\n        }\n        return Sk.builtin.asnum$(ret) !== 0;\n    }\n    if (x.mp$length) {\n        return Sk.builtin.asnum$(x.mp$length()) !== 0;\n    }\n    if (x.sq$length) {\n        return Sk.builtin.asnum$(x.sq$length()) !== 0;\n    }\n    return true;\n};\nSk.exportSymbol(\"Sk.misceval.isTrue\", Sk.misceval.isTrue);\n\nSk.misceval.softspace_ = false;\nSk.misceval.print_ = function (x) {\n    var s;\n\n    function isspace(c) {\n        return c === \"\\n\" || c === \"\\t\" || c === \"\\r\";\n    }\n\n    if (Sk.misceval.softspace_) {\n        if (x !== \"\\n\") {\n            Sk.output(\" \");\n        }\n        Sk.misceval.softspace_ = false;\n    }\n\n    s = new Sk.builtin.str(x);\n\n    return Sk.misceval.chain(Sk.importModule(\"sys\", false, true), function(sys) {\n        return Sk.misceval.apply(sys[\"$d\"][\"stdout\"][\"write\"], undefined, undefined, undefined, [sys[\"$d\"][\"stdout\"], s]);\n    }, function () {\n        if (s.v.length === 0 || !isspace(s.v[s.v.length - 1]) || s.v[s.v.length - 1] === \" \") {\n            Sk.misceval.softspace_ = true;\n        }\n    });\n};\nSk.exportSymbol(\"Sk.misceval.print_\", Sk.misceval.print_);\n\n/**\n * @param {string} name\n * @param {Object=} other generally globals\n */\nSk.misceval.loadname = function (name, other) {\n    var bi;\n    var v = other[name];\n    if (v !== undefined) {\n        if (typeof v === \"function\" && v[\"$d\"] === undefined && v[\"tp$name\"] === undefined) {\n            return v();\n        }\n        return v;\n    }\n\n    bi = Sk.builtins[name];\n    if (bi !== undefined) {\n        return bi;\n    }\n\n    throw new Sk.builtin.NameError(\"name '\" + Sk.unfixReserved(name) + \"' is not defined\");\n};\nSk.exportSymbol(\"Sk.misceval.loadname\", Sk.misceval.loadname);\n\n/**\n *\n * Notes on necessity for 'call()':\n *\n * Classes are callable in python to create an instance of the class. If\n * we're calling \"C()\" we cannot tell at the call site whether we're\n * calling a standard function, or instantiating a class.\n *\n * JS does not support user-level callables. So, we can't use the normal\n * prototype hierarchy to make the class inherit from a 'class' type\n * where the various tp$getattr, etc. methods would live.\n *\n * Instead, we must copy all the methods from the prototype of our class\n * type onto every instance of the class constructor function object.\n * That way, both \"C()\" and \"C.tp$getattr(...)\" can still work. This is\n * of course quite expensive.\n *\n * The alternative would be to indirect all calls (whether classes or\n * regular functions) through something like C.$call(...). In the case\n * of class construction, $call could then call the constructor after\n * munging arguments to pass them on. This would impose a penalty on\n * regular function calls unfortunately, as they would have to do the\n * same thing.\n *\n * Note that the same problem exists for function objects too (a \"def\"\n * creates a function object that also has properties). It just happens\n * that attributes on classes in python are much more useful and common\n * that the attributes on functions.\n *\n * Also note, that for full python compatibility we have to do the $call\n * method because any python object could have a __call__ method which\n * makes the python object callable too. So, unless we were to make\n * *all* objects simply (function(){...}) and use the dict to create\n * hierarchy, there would be no way to call that python user function. I\n * think I'm prepared to sacrifice __call__ support, or only support it\n * post-ECMA5 or something.\n *\n * Is using (function(){...}) as the only object type too crazy?\n * Probably. Better or worse than having two levels of function\n * invocation for every function call?\n *\n * For a class `C' with instance `inst' we have the following cases:\n *\n * 1. C.attr\n *\n * 2. C.staticmeth()\n *\n * 3. x = C.staticmeth; x()\n *\n * 4. inst = C()\n *\n * 5. inst.attr\n *\n * 6. inst.meth()\n *\n * 7. x = inst.meth; x()\n *\n * 8. inst(), where C defines a __call__\n *\n * Because in general these are accomplished by a helper function\n * (tp$getattr/setattr/slice/ass_slice/etc.) it seems appropriate to add\n * a call that generally just calls through, but sometimes handles the\n * unusual cases. Once ECMA-5 is more broadly supported we can revisit\n * and hopefully optimize.\n *\n * @param {Object} func the thing to call\n * @param {Object=} kwdict **kwargs\n * @param {Object=} varargseq **args\n * @param {Object=} kws keyword args or undef\n * @param {...*} args stuff to pass it\n *\n *\n * TODO I think all the above is out of date.\n */\nSk.misceval.call = function (func, kwdict, varargseq, kws, args) {\n    args = Array.prototype.slice.call(arguments, 4);\n    // todo; possibly inline apply to avoid extra stack frame creation\n    return Sk.misceval.apply(func, kwdict, varargseq, kws, args);\n};\nSk.exportSymbol(\"Sk.misceval.call\", Sk.misceval.call);\n\n/**\n * @param {?Object} suspensionHandlers\n * @param {Object} func the thing to call\n * @param {Object=} kwdict **kwargs\n * @param {Object=} varargseq **args\n * @param {Object=} kws keyword args or undef\n * @param {...*} args stuff to pass it\n *\n *\n * TODO I think all the above is out of date.\n */\n\nSk.misceval.callAsync = function (suspensionHandlers, func, kwdict, varargseq, kws, args) {\n    args = Array.prototype.slice.call(arguments, 5);\n    // todo; possibly inline apply to avoid extra stack frame creation\n    return Sk.misceval.applyAsync(suspensionHandlers, func, kwdict, varargseq, kws, args);\n};\nSk.exportSymbol(\"Sk.misceval.callAsync\", Sk.misceval.callAsync);\n\n\nSk.misceval.callOrSuspend = function (func, kwdict, varargseq, kws, args) {\n    args = Array.prototype.slice.call(arguments, 4);\n    // todo; possibly inline apply to avoid extra stack frame creation\n    return Sk.misceval.applyOrSuspend(func, kwdict, varargseq, kws, args);\n};\nSk.exportSymbol(\"Sk.misceval.callOrSuspend\", Sk.misceval.callOrSuspend);\n\n/**\n * @param {Object} func the thing to call\n * @param {...*} args stuff to pass it\n */\nSk.misceval.callsim = function (func, args) {\n    args = Array.prototype.slice.call(arguments, 1);\n    return Sk.misceval.apply(func, undefined, undefined, undefined, args);\n};\nSk.exportSymbol(\"Sk.misceval.callsim\", Sk.misceval.callsim);\n\n/**\n * @param {Object} func the thing to call\n * @param {Array=} args an array of arguments to pass to the func\n *\n * Does the same thing as callsim without expensive call to Array.slice.\n * Requires args to be a Javascript array.\n */\nSk.misceval.callsimArray = function(func, args) {\n    var argarray = args ? args : [];\n    return Sk.misceval.apply(func, undefined, undefined, undefined, argarray);\n};\nSk.exportSymbol(\"Sk.misceval.callsimArray\", Sk.misceval.callsimArray);\n\n/**\n * @param {?Object} suspensionHandlers any custom suspension handlers\n * @param {Object} func the thing to call\n * @param {...*} args stuff to pass it\n */\nSk.misceval.callsimAsync = function (suspensionHandlers, func, args) {\n    args = Array.prototype.slice.call(arguments, 2);\n    return Sk.misceval.applyAsync(suspensionHandlers, func, undefined, undefined, undefined, args);\n};\nSk.exportSymbol(\"Sk.misceval.callsimAsync\", Sk.misceval.callsimAsync);\n\n\n/**\n * @param {Object} func the thing to call\n * @param {...*} args stuff to pass it\n */\nSk.misceval.callsimOrSuspend = function (func, args) {\n    args = Array.prototype.slice.call(arguments, 1);\n    return Sk.misceval.applyOrSuspend(func, undefined, undefined, undefined, args);\n};\nSk.exportSymbol(\"Sk.misceval.callsimOrSuspend\", Sk.misceval.callsimOrSuspend);\n\n/**\n * @param {Object} func the thing to call\n * @param {Array=} args an array of arguments to pass to the func\n *\n * Does the same thing as callsimOrSuspend without expensive call to\n * Array.slice.  Requires args to be a Javascript array.\n */\nSk.misceval.callsimOrSuspendArray = function (func, args) {\n    var argarray = args ? args : [];\n    return Sk.misceval.applyOrSuspend(func, undefined, undefined, undefined, argarray);\n};\nSk.exportSymbol(\"Sk.misceval.callsimOrSuspendArray\", Sk.misceval.callsimOrSuspendArray);\n\n/**\n * Wrap Sk.misceval.applyOrSuspend, but throw an error if we suspend\n */\nSk.misceval.apply = function (func, kwdict, varargseq, kws, args) {\n    var r = Sk.misceval.applyOrSuspend(func, kwdict, varargseq, kws, args);\n    if (r instanceof Sk.misceval.Suspension) {\n        return Sk.misceval.retryOptionalSuspensionOrThrow(r);\n    } else {\n        return r;\n    }\n};\nSk.exportSymbol(\"Sk.misceval.apply\", Sk.misceval.apply);\n\n/**\n * Wraps anything that can return an Sk.misceval.Suspension, and returns a\n * JS Promise with the result. Also takes an object map of suspension handlers:\n * pass in {\"suspType\": function (susp) {} }, and your function will be called\n * with the Suspension object if susp.type==\"suspType\". The type \"*\" will match\n * all otherwise unhandled suspensions.\n *\n * A suspension handler should return a Promise yielding the return value of\n * r.resume() - ie, either the final return value of this call or another\n * Suspension. That is, the null suspension handler is:\n *\n *     function handler(susp) {\n *       return new Promise(function(resolve, reject) {\n *         try {\n *           resolve(susp.resume());\n *         } catch(e) {\n *           reject(e);\n *         }\n *       });\n *     }\n *\n * Alternatively, a handler can return null to perform the default action for\n * that suspension type.\n *\n * (Note: do *not* call asyncToPromise() in a suspension handler; this will\n * create a new Promise object for each such suspension that occurs)\n *\n * asyncToPromise() returns a Promise that will be resolved with the final\n * return value, or rejected with an exception if one is thrown.\n *\n * @param{function()} suspendablefn returns either a result or a Suspension\n * @param{Object=} suspHandlers an object map of suspension handlers\n */\nSk.misceval.asyncToPromise = function(suspendablefn, suspHandlers) {\n    return new Promise(function(resolve, reject) {\n        try {\n            var r = suspendablefn();\n\n            (function handleResponse (r) {\n                try {\n                    // jsh*nt insists these be defined outside the loop\n                    var resume = function() {\n                        try {\n                            handleResponse(r.resume());\n                        } catch (e) {\n                            reject(e);\n                        }\n                    };\n                    var resumeWithData = function resolved(x) {\n                        try {\n                            r.data[\"result\"] = x;\n                            resume();\n                        } catch(e) {\n                            reject(e);\n                        }\n                    };\n                    var resumeWithError = function rejected(e) {\n                        try {\n                            r.data[\"error\"] = e;\n                            resume();\n                        } catch(ex) {\n                            reject(ex);\n                        }\n                    };\n\n\n                    while (r instanceof Sk.misceval.Suspension) {\n\n                        var handler = suspHandlers && (suspHandlers[r.data[\"type\"]] || suspHandlers[\"*\"]);\n\n                        if (handler) {\n                            var handlerPromise = handler(r);\n                            if (handlerPromise) {\n                                handlerPromise.then(handleResponse, reject);\n                                return;\n                            }\n                        }\n\n                        if (r.data[\"type\"] == \"Sk.promise\") {\n                            r.data[\"promise\"].then(resumeWithData, resumeWithError);\n                            return;\n\n                        } else if (r.data[\"type\"] == \"Sk.yield\") {\n                            // Assumes all yields are optional, as Sk.setTimeout might\n                            // not be able to yield.\n                            //Sk.setTimeout(resume, 0);\n                            Sk.global[\"setImmediate\"](resume);\n                            return;\n\n                        } else if (r.data[\"type\"] == \"Sk.delay\") {\n                            //Sk.setTimeout(resume, 1);\n                            Sk.global[\"setImmediate\"](resume);\n                            return;\n\n                        } else if (r.optional) {\n                            // Unhandled optional suspensions just get\n                            // resumed immediately, and we go around the loop again.\n                            r = r.resume();\n\n                        } else {\n                            // Unhandled, non-optional suspension.\n                            throw new Sk.builtin.SuspensionError(\"Unhandled non-optional suspension of type '\"+r.data[\"type\"]+\"'\");\n                        }\n                    }\n\n                    resolve(r);\n                } catch(e) {\n                    reject(e);\n                }\n            })(r);\n\n        } catch (e) {\n            reject(e);\n        }\n    });\n};\nSk.exportSymbol(\"Sk.misceval.asyncToPromise\", Sk.misceval.asyncToPromise);\n\nSk.misceval.applyAsync = function (suspHandlers, func, kwdict, varargseq, kws, args) {\n    return Sk.misceval.asyncToPromise(function() {\n        return Sk.misceval.applyOrSuspend(func, kwdict, varargseq, kws, args);\n    }, suspHandlers);\n};\nSk.exportSymbol(\"Sk.misceval.applyAsync\", Sk.misceval.applyAsync);\n\n/**\n * Chain together a set of functions, each of which might return a value or\n * an Sk.misceval.Suspension. Each function is called with the return value of\n * the preceding function, but does not see any suspensions. If a function suspends,\n * Sk.misceval.chain() returns a suspension that will resume the chain once an actual\n * return value is available.\n *\n * The idea is to allow a Promise-like chaining of possibly-suspending steps without\n * repeating boilerplate suspend-and-resume code.\n *\n * For example, imagine we call Sk.misceval.chain(x, f).\n *  - If x is a value, we return f(x).\n *  - If x is a suspension, we suspend. We will suspend and resume until we get a\n *    return value, and then we will return f(<resumed-value).\n * This can be expanded to an arbitrary number of functions\n * (eg Sk.misceval.chain(x, f, g), which is equivalent to chain(chain(x, f), g).)\n * @template T\n * @param {T}              initialValue\n * @param {...function(T)} chainedFns\n */\n\nSk.misceval.chain = function (initialValue, chainedFns) {\n    // We try to minimse overhead when nothing suspends (the common case)\n    var i = 1, value = initialValue, j, fs;\n\n    while (true) {\n        if (i == arguments.length) {\n            return value;\n        }\n        if (value && value.$isSuspension) { break; } // oops, slow case\n        value = arguments[i](value);\n        i++;\n    }\n\n    // Okay, we've suspended at least once, so we're taking the slow(er) path.\n\n    // Copy our remaining arguments into an array (inline, because passing\n    // \"arguments\" out of a function kills the V8 optimiser).\n    // (discussion: https://github.com/skulpt/skulpt/pull/552)\n    fs = new Array(arguments.length - i);\n\n    for (j = 0; j < arguments.length - i; j++) {\n        fs[j] = arguments[i+j];\n    }\n\n    j = 0;\n\n    return (function nextStep(r) {\n        while (j < fs.length) {\n            if (r instanceof Sk.misceval.Suspension) {\n                return new Sk.misceval.Suspension(nextStep, r);\n            }\n\n            r = fs[j](r);\n            j++;\n        }\n\n        return r;\n    })(value);\n};\nSk.exportSymbol(\"Sk.misceval.chain\", Sk.misceval.chain);\n\n\n/**\n * Catch any exceptions thrown by a function, or by resuming any suspension it\n * returns.\n *\n *     var result = Sk.misceval.tryCatch(asyncFunc, function(err) {\n *       console.log(err);\n *     });\n *\n * Because exceptions are returned asynchronously aswell you can't catch them\n * with a try/catch. That's what this function is for.\n */\nSk.misceval.tryCatch = function (tryFn, catchFn) {\n    var r;\n\n    try {\n        r = tryFn();\n    } catch(e) {\n        return catchFn(e);\n    }\n\n    if (r instanceof Sk.misceval.Suspension) {\n        var susp = new Sk.misceval.Suspension(undefined, r);\n        susp.resume = function() { return Sk.misceval.tryCatch(r.resume, catchFn); };\n        return susp;\n    } else {\n        return r;\n    }\n};\nSk.exportSymbol(\"Sk.misceval.tryCatch\", Sk.misceval.tryCatch);\n\n/**\n * Perform a suspension-aware for-each on an iterator, without\n * blowing up the stack.\n * forFn() is called for each element in the iterator, with two\n * arguments: the current element and the previous return value\n * of forFn() (or initialValue on the first call). In this way,\n * iterFor() can be used as a simple for loop, or alternatively\n * as a 'reduce' operation. The return value of the final call to\n * forFn() will be the return value of iterFor() (after all\n * suspensions are resumed, that is; if the iterator is empty then\n * initialValue will be returned.)\n *\n * The iteration can be terminated early, by returning\n * an instance of Sk.misceval.Break. If an argument is given to\n * the Sk.misceval.Break() constructor, that value will be\n * returned from iterFor(). It is therefore possible to use\n * iterFor() on infinite iterators.\n *\n * @param {*} iter\n * @param {function(*,*=)} forFn\n * @param {*=} initialValue\n */\nSk.misceval.iterFor = function (iter, forFn, initialValue) {\n    var prevValue = initialValue;\n\n    var breakOrIterNext = function(r) {\n        prevValue = r;\n        return (r instanceof Sk.misceval.Break) ? r : iter.tp$iternext(true);\n    };\n\n    return (function nextStep(i) {\n        while (i !== undefined) {\n            if (i instanceof Sk.misceval.Suspension) {\n                return new Sk.misceval.Suspension(nextStep, i);\n            }\n\n            if (i === Sk.misceval.Break || i instanceof Sk.misceval.Break) {\n                return i.brValue;\n            }\n\n            i = Sk.misceval.chain(\n                forFn(i, prevValue),\n                breakOrIterNext\n            );\n        }\n        return prevValue;\n    })(iter.tp$iternext(true));\n};\nSk.exportSymbol(\"Sk.misceval.iterFor\", Sk.misceval.iterFor);\n\n/**\n * A special value to return from an iterFor() function,\n * to abort the iteration. Optionally supply a value for iterFor() to return\n * (defaults to 'undefined')\n *\n * @constructor\n * @param {*=}  brValue\n */\nSk.misceval.Break = function(brValue) {\n    if (!(this instanceof Sk.misceval.Break)) {\n        return new Sk.misceval.Break(brValue);\n    }\n\n    this.brValue = brValue;\n};\nSk.exportSymbol(\"Sk.misceval.Break\", Sk.misceval.Break);\n\n/**\n * same as Sk.misceval.call except args is an actual array, rather than\n * varargs.\n */\nSk.misceval.applyOrSuspend = function (func, kwdict, varargseq, kws, args) {\n    var fcall;\n    var it, i;\n\n    if (func === null || func instanceof Sk.builtin.none) {\n        throw new Sk.builtin.TypeError(\"'\" + Sk.abstr.typeName(func) + \"' object is not callable\");\n    }\n\n    if (typeof func === \"function\" && func.tp$call === undefined) {\n        func = new Sk.builtin.func(func);\n    }\n\n    fcall = func.tp$call;\n    if (fcall !== undefined) {\n        if (varargseq) {\n            for (it = varargseq.tp$iter(), i = it.tp$iternext(); i !== undefined; i = it.tp$iternext()) {\n                args.push(i);\n            }\n        }\n\n        if (kwdict) {\n            for (it = Sk.abstr.iter(kwdict), i = it.tp$iternext(); i!== undefined; i = it.tp$iternext()) {\n                if (!Sk.builtin.checkString(i)) {\n                    throw new Sk.builtin.TypeError(\"Function keywords must be strings\");\n                }\n                kws.push(i.v);\n                kws.push(Sk.abstr.objectGetItem(kwdict, i, false));\n            }\n        }\n        return fcall.call(func, args, kws, kwdict);\n    }\n\n    // todo; can we push this into a tp$call somewhere so there's\n    // not redundant checks everywhere for all of these __x__ ones?\n    fcall = func.__call__;\n    if (fcall !== undefined) {\n        // func is actually the object here because we got __call__\n        // from it. todo; should probably use descr_get here\n        args.unshift(func);\n        return Sk.misceval.apply(fcall, kwdict, varargseq, kws, args);\n    }\n\n    throw new Sk.builtin.TypeError(\"'\" + Sk.abstr.typeName(func) + \"' object is not callable\");\n};\nSk.exportSymbol(\"Sk.misceval.applyOrSuspend\", Sk.misceval.applyOrSuspend);\n\n/**\n * Do the boilerplate suspension stuff.\n */\nSk.misceval.promiseToSuspension = function(promise) {\n    var suspension = new Sk.misceval.Suspension();\n\n    suspension.resume = function() {\n        if (suspension.data[\"error\"]) {\n            throw suspension.data[\"error\"];\n        }\n\n        return suspension.data[\"result\"];\n    };\n\n    suspension.data = {\n        type: \"Sk.promise\",\n        promise: promise\n    };\n\n    return suspension;\n};\nSk.exportSymbol(\"Sk.misceval.promiseToSuspension\", Sk.misceval.promiseToSuspension);\n\n/**\n * Constructs a class object given a code object representing the body\n * of the class, the name of the class, and the list of bases.\n *\n * There are no \"old-style\" classes in Skulpt, so use the user-specified\n * metaclass (todo;) if there is one, the type of the 0th base class if\n * there's bases, or otherwise the 'type' type.\n *\n * The func code object is passed a (js) dict for its locals which it\n * stores everything into.\n *\n * The metaclass is then called as metaclass(name, bases, locals) and\n * should return a newly constructed class object.\n *\n */\nSk.misceval.buildClass = function (globals, func, name, bases, cell) {\n    // todo; metaclass\n    var klass;\n    var meta = Sk.builtin.type;\n\n    var l_cell = cell === undefined ? {} : cell;\n    var locals = {};\n\n    // init the dict for the class\n    func(globals, locals, l_cell);\n    // ToDo: check if func contains the __meta__ attribute\n    // or if the bases contain __meta__\n    // new Syntax would be different\n\n    // file's __name__ is class's __module__\n    locals.__module__ = globals[\"__name__\"];\n    var _name = new Sk.builtin.str(name);\n    var _bases = new Sk.builtin.tuple(bases);\n    var _locals = [];\n    var key;\n\n    // build array for python dict\n    for (key in locals) {\n        if (!locals.hasOwnProperty(key)) {\n            //The current property key not a direct property of p\n            continue;\n        }\n        _locals.push(new Sk.builtin.str(key)); // push key\n        _locals.push(locals[key]); // push associated value\n    }\n    _locals = new Sk.builtin.dict(_locals);\n\n    klass = Sk.misceval.callsimArray(meta, [_name, _bases, _locals]);\n\n    return klass;\n};\nSk.exportSymbol(\"Sk.misceval.buildClass\", Sk.misceval.buildClass);\n","/**\n * @constructor\n * Sk.builtin.seqtype\n *\n * @description\n * Abstract class for Python sequence types.\n *\n * @extends {Sk.builtin.object}\n *\n * @return {undefined} Cannot instantiate a Sk.builtin.seqtype object\n */\nSk.builtin.seqtype = function () {\n\n    throw new Sk.builtin.ExternalError(\"Cannot instantiate abstract Sk.builtin.seqtype class\");\n\n};\n\nSk.abstr.setUpInheritance(\"SequenceType\", Sk.builtin.seqtype, Sk.builtin.object);\n\nSk.builtin.seqtype.sk$abstract = true;\n\n/**\n * Python wrapper of `__len__` method.\n *\n * @name  __len__\n * @instance\n * @memberOf Sk.builtin.seqtype.prototype\n */\nSk.builtin.seqtype.prototype[\"__len__\"] = new Sk.builtin.func(function (self) {\n\n    Sk.builtin.pyCheckArgsLen(\"__len__\", arguments.length, 0, 0, false, true);\n\n    return new Sk.builtin.int_(self.sq$length());    \n\n});\n\n/**\n * Python wrapper of `__iter__` method.\n *\n * @name  __iter__\n * @instance\n * @memberOf Sk.builtin.seqtype.prototype\n */\nSk.builtin.seqtype.prototype[\"__iter__\"] = new Sk.builtin.func(function (self) {\n\n    Sk.builtin.pyCheckArgsLen(\"__iter__\", arguments.length, 0, 0, false, true);\n\n    return self.tp$iter();\n\n});\n\n/**\n * Python wrapper of `__contains__` method.\n *\n * @name  __contains__\n * @instance\n * @memberOf Sk.builtin.seqtype.prototype\n */\nSk.builtin.seqtype.prototype[\"__contains__\"] = new Sk.builtin.func(function (self, item) {\n\n    Sk.builtin.pyCheckArgsLen(\"__contains__\", arguments.length, 1, 1, false, true);\n\n    if (self.sq$contains(item)) {\n        return Sk.builtin.bool.true$;\n    } else {\n        return Sk.builtin.bool.false$;\n    }\n\n});\n\n/**\n * Python wrapper of `__getitem__` method.\n *\n * @name  __getitem__\n * @instance\n * @memberOf Sk.builtin.seqtype.prototype\n */\nSk.builtin.seqtype.prototype[\"__getitem__\"] = new Sk.builtin.func(function (self, key) {\n\n    Sk.builtin.pyCheckArgsLen(\"__getitem__\", arguments.length, 1, 1, false, true);\n\n    return self.mp$subscript(key);\n\n});\n\n/**\n * Python wrapper of `__add__` method.\n *\n * @name  __add__\n * @instance\n * @memberOf Sk.builtin.seqtype.prototype\n */\nSk.builtin.seqtype.prototype[\"__add__\"] = new Sk.builtin.func(function (self, other) {\n\n    Sk.builtin.pyCheckArgsLen(\"__add__\", arguments.length, 1, 1, false, true);\n\n    return self.sq$concat(other);\n\n});\n\n/**\n * Python wrapper of `__mul__` method.\n *\n * @name  __mul__\n * @instance\n * @memberOf Sk.builtin.seqtype.prototype\n */\nSk.builtin.seqtype.prototype[\"__mul__\"] = new Sk.builtin.func(function (self, n) {\n\n    Sk.builtin.pyCheckArgsLen(\"__mul__\", arguments.length, 1, 1, false, true);\n\n    if (!Sk.misceval.isIndex(n)) {\n        throw new Sk.builtin.TypeError(\"can't multiply sequence by non-int of type '\" + Sk.abstr.typeName(n) + \"'\");\n    }\n\n    return self.sq$repeat(n);\n\n});\n\n/**\n * Python wrapper of `__rmul__` method.\n *\n * @name  __rmul__\n * @instance\n * @memberOf Sk.builtin.seqtype.prototype\n */\nSk.builtin.seqtype.prototype[\"__rmul__\"] = new Sk.builtin.func(function (self, n) {\n\n    Sk.builtin.pyCheckArgsLen(\"__rmul__\", arguments.length, 1, 1, false, true);\n\n    return self.sq$repeat(n);    \n\n});\n","/**\n * @constructor\n * @param {Array.<Object>=} L\n * @param {boolean=} canSuspend (defaults to true in this case, as list() is used directly from Python)\n * @extends Sk.builtin.object\n */\nSk.builtin.list = function (L, canSuspend) {\n    var v, it, thisList;\n\n    if (this instanceof Sk.builtin.list) {\n        canSuspend = canSuspend || false;\n    } else {\n        // Default to true in this case, because 'list' gets called directly from Python\n        return new Sk.builtin.list(L, canSuspend || true);\n    }\n\n    this.__class__ = Sk.builtin.list;\n\n    if (L === undefined) {\n        v = [];\n    } else if (Object.prototype.toString.apply(L) === \"[object Array]\") {\n        v = L;\n    } else if (Sk.builtin.checkIterable(L)) {\n        v = [];\n        it = Sk.abstr.iter(L);\n\n        thisList = this;\n\n        return (function next(i) {\n            while(true) {\n                if (i instanceof Sk.misceval.Suspension) {\n                    return new Sk.misceval.Suspension(next, i);\n                } else if (i === undefined) {\n                    // done!\n                    thisList.v = v;\n                    return thisList;\n                } else {\n                    v.push(i);\n                    i = it.tp$iternext(canSuspend);\n                }\n            }\n        })(it.tp$iternext(canSuspend));\n    } else {\n        throw new Sk.builtin.TypeError(\"'\" + Sk.abstr.typeName(L)+ \"' \" +\"object is not iterable\");\n    }\n\n    this[\"v\"] = this.v = v;\n    return this;\n};\n\nSk.abstr.setUpInheritance(\"list\", Sk.builtin.list, Sk.builtin.seqtype);\nSk.abstr.markUnhashable(Sk.builtin.list);\n\nSk.builtin.list.prototype.list_concat_ = function (other) {\n    // other not a list\n    var i;\n    var ret;\n    if (!other.__class__ || other.__class__ != Sk.builtin.list) {\n        throw new Sk.builtin.TypeError(\"can only concatenate list to list\");\n    }\n\n    ret = this.v.slice();\n    for (i = 0; i < other.v.length; ++i) {\n        ret.push(other.v[i]);\n    }\n    return new Sk.builtin.list(ret, false);\n};\n\nSk.builtin.list.prototype.list_extend_ = function (other) {\n    var it, i;\n    var newb;\n    if (!Sk.builtin.checkIterable(other)) {\n        throw new Sk.builtin.TypeError(\"'\" + Sk.abstr.typeName(other) +\n            \"' object is not iterable\");\n    }\n\n    if (this == other) {\n        // Handle extending list with itself\n        newb = [];\n        for (it = Sk.abstr.iter(other), i = it.tp$iternext(); i !== undefined; i = it.tp$iternext()) {\n            newb.push(i);\n        }\n\n        // Concatenate\n        this.v.push.apply(this.v, newb);\n    } else {\n        for (it = Sk.abstr.iter(other), i = it.tp$iternext(); i !== undefined; i = it.tp$iternext()) {\n            this.v.push(i);\n        }\n    }\n\n    return this;\n};\n\nSk.builtin.list.prototype.list_del_item_ = function (i) {\n    i = Sk.builtin.asnum$(i);\n    if (i < 0 || i >= this.v.length) {\n        throw new Sk.builtin.IndexError(\"list assignment index out of range\");\n    }\n    this.list_del_slice_(i, i + 1);\n};\n\nSk.builtin.list.prototype.list_del_slice_ = function (ilow, ihigh) {\n    var args;\n    ilow = Sk.builtin.asnum$(ilow);\n    ihigh = Sk.builtin.asnum$(ihigh);\n    args = [];\n    args.unshift(ihigh - ilow);\n    args.unshift(ilow);\n    this.v.splice.apply(this.v, args);\n};\n\nSk.builtin.list.prototype.list_ass_item_ = function (i, v) {\n    i = Sk.builtin.asnum$(i);\n    if (i < 0 || i >= this.v.length) {\n        throw new Sk.builtin.IndexError(\"list assignment index out of range\");\n    }\n    this.v[i] = v;\n};\n\nSk.builtin.list.prototype.list_ass_slice_ = function (ilow, ihigh, v) {\n    var args;\n    ilow = Sk.builtin.asnum$(ilow);\n    ihigh = Sk.builtin.asnum$(ihigh);\n\n    if (Sk.builtin.checkIterable(v)) {\n        args = new Sk.builtin.list(v, false).v.slice(0);\n    } else {\n        throw new Sk.builtin.TypeError(\"can only assign an iterable\");\n    }\n    args.unshift(ihigh - ilow);\n    args.unshift(ilow);\n    this.v.splice.apply(this.v, args);\n};\n\nSk.builtin.list.prototype[\"$r\"] = function () {\n    var it, i;\n    var ret = [];\n    for (it = Sk.abstr.iter(this), i = it.tp$iternext(); i !== undefined; i = it.tp$iternext()) {\n        if(i === this) {\n            ret.push(\"[...]\");\n        } else {\n            ret.push(Sk.misceval.objectRepr(i).v);\n        }\n    }\n    return new Sk.builtin.str(\"[\" + ret.join(\", \") + \"]\");\n};\n\nSk.builtin.list.prototype.tp$richcompare = function (w, op) {\n    // todo; can't figure out where cpy handles this silly case (test/run/t96.py)\n    // perhaps by trapping a stack overflow? otherwise i'm not sure for more\n    // complicated cases. bleh\n    //\n    // if the comparison allows for equality then short-circuit it here\n    var k;\n    var i;\n    var wl;\n    var vl;\n    var v;\n    if (this === w && Sk.misceval.opAllowsEquality(op)) {\n        return true;\n    }\n\n    // w not a list\n    if (!w.__class__ || w.__class__ != Sk.builtin.list) {\n        // shortcuts for eq/not\n        if (op === \"Eq\") {\n            return false;\n        }\n        if (op === \"NotEq\") {\n            return true;\n        }\n\n        // todo; other types should have an arbitrary order\n        return false;\n    }\n\n    v = this.v;\n    w = w.v;\n    vl = v.length;\n    wl = w.length;\n\n    for (i = 0; i < vl && i < wl; ++i) {\n        k = Sk.misceval.richCompareBool(v[i], w[i], \"Eq\");\n        if (!k) {\n            break;\n        }\n    }\n\n    if (i >= vl || i >= wl) {\n        // no more items to compare, compare sizes\n        switch (op) {\n            case \"Lt\":\n                return vl < wl;\n            case \"LtE\":\n                return vl <= wl;\n            case \"Eq\":\n                return vl === wl;\n            case \"NotEq\":\n                return vl !== wl;\n            case \"Gt\":\n                return vl > wl;\n            case \"GtE\":\n                return vl >= wl;\n            default:\n                Sk.asserts.fail();\n        }\n    }\n\n    // we have an item that's different\n\n    // shortcuts for eq/not\n    if (op === \"Eq\") {\n        return false;\n    }\n    if (op === \"NotEq\") {\n        return true;\n    }\n\n    // or, compare the differing element using the proper operator\n    return Sk.misceval.richCompareBool(v[i], w[i], op);\n};\n\nSk.builtin.list.prototype.__iter__ = new Sk.builtin.func(function (self) {\n    Sk.builtin.pyCheckArgsLen(\"__iter__\", arguments.length, 0, 0, true, false);\n    return new Sk.builtin.list_iter_(self);\n});\n\nSk.builtin.list.prototype.tp$iter = function () {\n    return new Sk.builtin.list_iter_(this);\n};\n\nSk.builtin.list.prototype.sq$length = function () {\n    return this.v.length;\n};\nSk.builtin.list.prototype.sq$concat = Sk.builtin.list.prototype.list_concat_;\nSk.builtin.list.prototype.nb$add = Sk.builtin.list.prototype.list_concat_;\nSk.builtin.list.prototype.nb$inplace_add = Sk.builtin.list.prototype.list_extend_;\nSk.builtin.list.prototype.sq$repeat = function (n) {\n    var j;\n    var i;\n    var ret;\n    if (!Sk.misceval.isIndex(n)) {\n        throw new Sk.builtin.TypeError(\"can't multiply sequence by non-int of type '\" + Sk.abstr.typeName(n) + \"'\");\n    }\n\n    n = Sk.misceval.asIndex(n);\n    ret = [];\n    for (i = 0; i < n; ++i) {\n        for (j = 0; j < this.v.length; ++j) {\n            ret.push(this.v[j]);\n        }\n    }\n    return new Sk.builtin.list(ret, false);\n};\nSk.builtin.list.prototype.nb$multiply = Sk.builtin.list.prototype.sq$repeat;\nSk.builtin.list.prototype.nb$inplace_multiply = function(n) {\n    var j;\n    var i;\n    var len;\n    if (!Sk.misceval.isIndex(n)) {\n        throw new Sk.builtin.TypeError(\"can't multiply sequence by non-int of type '\" + Sk.abstr.typeName(n) + \"'\");\n    }\n\n    // works on list itself --> inplace\n    n = Sk.misceval.asIndex(n);\n    len = this.v.length;\n    for (i = 1; i < n; ++i) {\n        for (j = 0; j < len; ++j) {\n            this.v.push(this.v[j]);\n        }\n    }\n\n    return this;\n};\n\n/*\n Sk.builtin.list.prototype.sq$item = list_item;\n Sk.builtin.list.prototype.sq$slice = list_slice;\n */\nSk.builtin.list.prototype.sq$ass_item = Sk.builtin.list.prototype.list_ass_item_;\nSk.builtin.list.prototype.sq$del_item = Sk.builtin.list.prototype.list_del_item_;\nSk.builtin.list.prototype.sq$ass_slice = Sk.builtin.list.prototype.list_ass_slice_;\nSk.builtin.list.prototype.sq$del_slice = Sk.builtin.list.prototype.list_del_slice_;\n\nSk.builtin.list.prototype.sq$contains = function (item) {\n    var it, i;\n\n    for (it = this.tp$iter(), i = it.tp$iternext(); i !== undefined; i = it.tp$iternext()) {\n        if (Sk.misceval.richCompareBool(i, item, \"Eq\")) {\n            return true;\n        }\n    }\n    return false;\n};\n\nSk.builtin.list.prototype.__contains__ = new Sk.builtin.func(function(self, item) {\n    Sk.builtin.pyCheckArgsLen(\"__contains__\", arguments.length, 2, 2);\n    return new Sk.builtin.bool(self.sq$contains(item));\n});\n\n/*\n Sk.builtin.list.prototype.sq$inplace_concat = list_inplace_concat;\n Sk.builtin.list.prototype.sq$inplace_repeat = list_inplace_repeat;\n */\n\nSk.builtin.list.prototype.list_subscript_ = function (index) {\n    var ret;\n    var i;\n    if (Sk.misceval.isIndex(index)) {\n        i = Sk.misceval.asIndex(index);\n        if (i !== undefined) {\n            if (i < 0) {\n                i = this.v.length + i;\n            }\n            if (i < 0 || i >= this.v.length) {\n                throw new Sk.builtin.IndexError(\"list index out of range\");\n            }\n            return this.v[i];\n        }\n    } else if (index instanceof Sk.builtin.slice) {\n        ret = [];\n        index.sssiter$(this, function (i, wrt) {\n            ret.push(wrt.v[i]);\n        });\n        return new Sk.builtin.list(ret, false);\n    }\n\n    throw new Sk.builtin.TypeError(\"list indices must be integers, not \" + Sk.abstr.typeName(index));\n};\n\nSk.builtin.list.prototype.list_ass_subscript_ = function (index, value) {\n    var i;\n    var j;\n    var tosub;\n    var indices;\n    if (Sk.misceval.isIndex(index)) {\n        i = Sk.misceval.asIndex(index);\n        if (i !== undefined) {\n            if (i < 0) {\n                i = this.v.length + i;\n            }\n            this.list_ass_item_(i, value);\n            return;\n        }\n    } else if (index instanceof Sk.builtin.slice) {\n        indices = index.slice_indices_(this.v.length);\n        if (indices[2] === 1) {\n            this.list_ass_slice_(indices[0], indices[1], value);\n        } else {\n            tosub = [];\n            index.sssiter$(this, function (i, wrt) {\n                tosub.push(i);\n            });\n            j = 0;\n            if (tosub.length !== value.v.length) {\n                throw new Sk.builtin.ValueError(\"attempt to assign sequence of size \" + value.v.length + \" to extended slice of size \" + tosub.length);\n            }\n            for (i = 0; i < tosub.length; ++i) {\n                this.v.splice(tosub[i], 1, value.v[j]);\n                j += 1;\n            }\n        }\n        return;\n    }\n\n    throw new Sk.builtin.TypeError(\"list indices must be integers, not \" + Sk.abstr.typeName(index));\n};\n\nSk.builtin.list.prototype.list_del_subscript_ = function (index) {\n    var offdir;\n    var dec;\n    var self;\n    var indices;\n    var i;\n    if (Sk.misceval.isIndex(index)) {\n        i = Sk.misceval.asIndex(index);\n        if (i !== undefined) {\n            if (i < 0) {\n                i = this.v.length + i;\n            }\n            this.list_del_item_(i);\n            return;\n        }\n    } else if (index instanceof Sk.builtin.slice) {\n        indices = index.slice_indices_(this.v.length);\n        if (indices[2] === 1) {\n            this.list_del_slice_(indices[0], indices[1]);\n        } else {\n            self = this;\n            dec = 0; // offset of removal for next index (because we'll have removed, but the iterator is giving orig indices)\n            offdir = indices[2] > 0 ? 1 : 0;\n            index.sssiter$(this, function (i, wrt) {\n                self.v.splice(i - dec, 1);\n                dec += offdir;\n            });\n        }\n        return;\n    }\n\n    throw new Sk.builtin.TypeError(\"list indices must be integers, not \" + typeof index);\n};\n\nSk.builtin.list.prototype.mp$subscript = Sk.builtin.list.prototype.list_subscript_;\nSk.builtin.list.prototype.mp$ass_subscript = Sk.builtin.list.prototype.list_ass_subscript_;\nSk.builtin.list.prototype.mp$del_subscript = Sk.builtin.list.prototype.list_del_subscript_;\n\nSk.builtin.list.prototype.__getitem__ = new Sk.builtin.func(function (self, index) {\n    return Sk.builtin.list.prototype.list_subscript_.call(self, index);\n});\n\nSk.builtin.list.prototype.__setitem__ = new Sk.builtin.func(function (self, index, val) {\n    return Sk.builtin.list.prototype.list_ass_subscript_.call(self, index, val);\n});\n\nSk.builtin.list.prototype.__delitem__ = new Sk.builtin.func(function (self, index) {\n    return Sk.builtin.list.prototype.list_del_subscript_.call(self, index);\n});\n\n/**\n * @param {?=} self\n * @param {?=} cmp optional\n * @param {?=} key optional\n * @param {?=} reverse optional\n */\nSk.builtin.list.prototype.list_sort_ = function sort(self, cmp, key, reverse) {\n    var mucked;\n    var j;\n    var keyvalue;\n    var item;\n    var i;\n    var zero;\n    var timsort;\n    var has_key = key !== undefined && key !== null && key !== Sk.builtin.none.none$;\n    var has_cmp = cmp !== undefined && cmp !== null && cmp !== Sk.builtin.none.none$;\n    var rev;\n\n    if (reverse === undefined) {\n        rev = false;\n    } else if (reverse === Sk.builtin.none.none$) {\n        throw new Sk.builtin.TypeError(\"an integer is required\");\n    } else {\n        rev = Sk.misceval.isTrue(reverse);\n    }\n\n    timsort = new Sk.builtin.timSort(self);\n\n    self.v = [];\n    zero = new Sk.builtin.int_(0);\n\n    if (has_key) {\n        if (has_cmp) {\n            timsort.lt = function (a, b) {\n                var res = Sk.misceval.callsimArray(cmp, [a[0], b[0]]);\n                return Sk.misceval.richCompareBool(res, zero, \"Lt\");\n            };\n        } else {\n            timsort.lt = function (a, b) {\n                return Sk.misceval.richCompareBool(a[0], b[0], \"Lt\");\n            };\n        }\n        for (i = 0; i < timsort.listlength; i++) {\n            item = timsort.list.v[i];\n            keyvalue = Sk.misceval.callsimArray(key, [item]);\n            timsort.list.v[i] = [keyvalue, item];\n        }\n    } else if (has_cmp) {\n        timsort.lt = function (a, b) {\n            var res = Sk.misceval.callsimArray(cmp, [a, b]);\n            return Sk.misceval.richCompareBool(res, zero, \"Lt\");\n        };\n    }\n\n    if (rev) {\n        timsort.list.list_reverse_(timsort.list);\n    }\n\n    timsort.sort();\n\n    if (rev) {\n        timsort.list.list_reverse_(timsort.list);\n    }\n\n    if (has_key) {\n        for (j = 0; j < timsort.listlength; j++) {\n            item = timsort.list.v[j][1];\n            timsort.list.v[j] = item;\n        }\n    }\n\n    mucked = self.sq$length() > 0;\n\n    self.v = timsort.list.v;\n\n    if (mucked) {\n        throw new Sk.builtin.OperationError(\"list modified during sort\");\n    }\n\n    return Sk.builtin.none.none$;\n};\nSk.builtin.list.prototype.list_sort_.co_varnames = [\"__self__\", \"cmp\", \"key\", \"reverse\"];\nSk.builtin.list.prototype.list_sort_.$defaults = [Sk.builtin.none.none$, Sk.builtin.none.none$, false];\n\n/**\n * @param {Sk.builtin.list=} self optional\n **/\nSk.builtin.list.prototype.list_reverse_ = function (self) {\n    var i;\n    var newarr;\n    var old;\n    var len;\n    Sk.builtin.pyCheckArgsLen(\"reverse\", arguments.length, 1, 1);\n\n    len = self.v.length;\n    old = self.v;\n    newarr = [];\n    for (i = len - 1; i > -1; --i) {\n        newarr.push(old[i]);\n    }\n    self[\"v\"] = newarr;\n    return Sk.builtin.none.none$;\n};\n\n//Sk.builtin.list.prototype.__reversed__ = todo;\n\nSk.builtin.list.prototype[\"append\"] = new Sk.builtin.func(function (self, item) {\n    Sk.builtin.pyCheckArgsLen(\"append\", arguments.length, 2, 2);\n\n    self.v.push(item);\n    return Sk.builtin.none.none$;\n});\n\nSk.builtin.list.prototype[\"insert\"] = new Sk.builtin.func(function (self, i, x) {\n    Sk.builtin.pyCheckArgsLen(\"insert\", arguments.length, 3, 3);\n    if (!Sk.builtin.checkNumber(i)) {\n        throw new Sk.builtin.TypeError(\"an integer is required\");\n    }\n\n    i = Sk.builtin.asnum$(i);\n    if (i < 0) {\n        i = i + self.v.length;\n    }\n    if (i < 0) {\n        i = 0;\n    } else if (i > self.v.length) {\n        i = self.v.length;\n    }\n    self.v.splice(i, 0, x);\n    return Sk.builtin.none.none$;\n});\n\nSk.builtin.list.prototype[\"extend\"] = new Sk.builtin.func(function (self, b) {\n    Sk.builtin.pyCheckArgsLen(\"extend\", arguments.length, 2, 2);\n    self.list_extend_(b);\n    return Sk.builtin.none.none$;\n});\n\nSk.builtin.list.prototype[\"pop\"] = new Sk.builtin.func(function (self, i) {\n    var ret;\n    Sk.builtin.pyCheckArgsLen(\"pop\", arguments.length, 1, 2);\n    if (i === undefined) {\n        i = self.v.length - 1;\n    }\n\n    if (!Sk.builtin.checkNumber(i)) {\n        throw new Sk.builtin.TypeError(\"an integer is required\");\n    }\n\n    i = Sk.builtin.asnum$(i);\n    if (i < 0) {\n        i = i + self.v.length;\n    }\n    if ((i < 0) || (i >= self.v.length)) {\n        throw new Sk.builtin.IndexError(\"pop index out of range\");\n    }\n    ret = self.v[i];\n    self.v.splice(i, 1);\n    return ret;\n});\n\nSk.builtin.list.prototype[\"remove\"] = new Sk.builtin.func(function (self, item) {\n    var idx;\n    Sk.builtin.pyCheckArgsLen(\"remove\", arguments.length, 2, 2);\n\n    idx = Sk.builtin.list.prototype[\"index\"].func_code(self, item);\n    self.v.splice(Sk.builtin.asnum$(idx), 1);\n    return Sk.builtin.none.none$;\n});\n\nSk.builtin.list.prototype.clear$ = function (self) {\n    Sk.builtin.pyCheckArgsLen(\"clear\", arguments.length, 1, 1);\n    self.v = [];\n    return Sk.builtin.none.none$;\n};\n\nSk.builtin.list.prototype[\"index\"] = new Sk.builtin.func(function (self, item, start, stop) {\n    var i;\n    var obj;\n    var len;\n    Sk.builtin.pyCheckArgsLen(\"index\", arguments.length, 2, 4);\n    if (start !== undefined && !Sk.builtin.checkInt(start)) {\n        throw new Sk.builtin.TypeError(\"slice indices must be integers\");\n    }\n    if (stop !== undefined && !Sk.builtin.checkInt(stop)) {\n        throw new Sk.builtin.TypeError(\"slice indices must be integers\");\n    }\n\n    len = self.v.length;\n    obj = self.v;\n\n    start = (start === undefined) ? 0 : start.v;\n    if (start < 0) {\n        start = ((start + len) >= 0) ? start + len : 0;\n    }\n\n    stop = (stop === undefined) ? len : stop.v;\n    if (stop < 0) {\n        stop = ((stop + len) >= 0) ? stop + len : 0;\n    }\n\n    for (i = start; i < stop; ++i) {\n        if (Sk.misceval.richCompareBool(obj[i], item, \"Eq\")) {\n            return new Sk.builtin.int_(i);\n        }\n    }\n    throw new Sk.builtin.ValueError(\"list.index(x): x not in list\");\n});\n\nSk.builtin.list.prototype[\"count\"] = new Sk.builtin.func(function (self, item) {\n    var i;\n    var count;\n    var obj;\n    var len;\n    Sk.builtin.pyCheckArgsLen(\"count\", arguments.length, 2, 2);\n\n    len = self.v.length;\n    obj = self.v;\n    count = 0;\n    for (i = 0; i < len; ++i) {\n        if (Sk.misceval.richCompareBool(obj[i], item, \"Eq\")) {\n            count += 1;\n        }\n    }\n    return new Sk.builtin.int_(count);\n});\n\nSk.builtin.list.prototype[\"reverse\"] = new Sk.builtin.func(Sk.builtin.list.prototype.list_reverse_);\nSk.builtin.list.prototype[\"sort\"] = new Sk.builtin.func(Sk.builtin.list.prototype.list_sort_);\n\nSk.exportSymbol(\"Sk.builtin.list\", Sk.builtin.list);\n\n/**\n * @constructor\n * @param {Object} lst\n */\nSk.builtin.list_iter_ = function (lst) {\n    if (!(this instanceof Sk.builtin.list_iter_)) {\n        return new Sk.builtin.list_iter_(lst);\n    }\n    this.$index = 0;\n    this.lst = lst.v.slice();\n    this.sq$length = this.lst.length;\n    this.tp$iter = this;\n    this.tp$iternext = function () {\n        if (this.$index >= this.sq$length) {\n            return undefined;\n        }\n        return this.lst[this.$index++];\n    };\n    this.$r = function () {\n        return new Sk.builtin.str(\"listiterator\");\n    };\n    return this;\n};\n\nSk.abstr.setUpInheritance(\"listiterator\", Sk.builtin.list_iter_, Sk.builtin.object);\n\nSk.builtin.list_iter_.prototype.__class__ = Sk.builtin.list_iter_;\n\nSk.builtin.list_iter_.prototype.__iter__ = new Sk.builtin.func(function (self) {\n    return self;\n});\n\nSk.builtin.list_iter_.prototype.next$ = function (self) {\n    var ret = self.tp$iternext();\n    if (ret === undefined) {\n        throw new Sk.builtin.StopIteration();\n    }\n    return ret;\n};\n","Sk.builtin.interned = {};\n\n/**\n * @constructor\n * @param {*} x\n * @extends Sk.builtin.object\n */\nSk.builtin.str = function (x) {\n    var ret;\n\n    Sk.builtin.pyCheckArgsLen(\"str\", arguments.length, 0, 1);\n\n    if (x === undefined) {\n        x = \"\";\n    }\n    if (x instanceof Sk.builtin.str) {\n        return x;\n    }\n    if (!(this instanceof Sk.builtin.str)) {\n        return new Sk.builtin.str(x);\n    }\n\n\n    // convert to js string\n    if (x === true) {\n        ret = \"True\";\n    } else if (x === false) {\n        ret = \"False\";\n    } else if ((x === null) || (x instanceof Sk.builtin.none)) {\n        ret = \"None\";\n    } else if (x instanceof Sk.builtin.bool) {\n        if (x.v) {\n            ret = \"True\";\n        } else {\n            ret = \"False\";\n        }\n    } else if (typeof x === \"number\") {\n        ret = x.toString();\n        if (ret === \"Infinity\") {\n            ret = \"inf\";\n        } else if (ret === \"-Infinity\") {\n            ret = \"-inf\";\n        }\n    } else if (typeof x === \"string\") {\n        ret = x;\n    } else if (x.tp$str !== undefined) {\n        ret = x.tp$str();\n        if (!(ret instanceof Sk.builtin.str)) {\n            throw new Sk.builtin.ValueError(\"__str__ didn't return a str\");\n        }\n        return ret;\n    } else {\n        return Sk.misceval.objectRepr(x);\n    }\n\n    // interning required for strings in py\n    if (Sk.builtin.interned[\"1\" + ret]) {\n        return Sk.builtin.interned[\"1\" + ret];\n    }\n\n    this.__class__ = Sk.builtin.str;\n    this.v = ret;\n    this[\"v\"] = this.v;\n    Sk.builtin.interned[\"1\" + ret] = this;\n    return this;\n\n};\nSk.exportSymbol(\"Sk.builtin.str\", Sk.builtin.str);\n\nSk.abstr.setUpInheritance(\"str\", Sk.builtin.str, Sk.builtin.seqtype);\n\nSk.builtin.str.prototype.$jsstr = function () {\n    return this.v;\n};\n\nSk.builtin.str.prototype.mp$subscript = function (index) {\n    var ret;\n    if (Sk.misceval.isIndex(index)) {\n        index = Sk.misceval.asIndex(index);\n        if (index < 0) {\n            index = this.v.length + index;\n        }\n        if (index < 0 || index >= this.v.length) {\n            throw new Sk.builtin.IndexError(\"string index out of range\");\n        }\n        return new Sk.builtin.str(this.v.charAt(index));\n    } else if (index instanceof Sk.builtin.slice) {\n        ret = \"\";\n        index.sssiter$(this, function (i, wrt) {\n            if (i >= 0 && i < wrt.v.length) {\n                ret += wrt.v.charAt(i);\n            }\n        });\n        return new Sk.builtin.str(ret);\n    } else {\n        throw new Sk.builtin.TypeError(\"string indices must be integers, not \" + Sk.abstr.typeName(index));\n    }\n};\n\nSk.builtin.str.prototype.sq$length = function () {\n    return this.v.length;\n};\nSk.builtin.str.prototype.sq$concat = function (other) {\n    var otypename;\n    if (!other || !Sk.builtin.checkString(other)) {\n        otypename = Sk.abstr.typeName(other);\n        throw new Sk.builtin.TypeError(\"cannot concatenate 'str' and '\" + otypename + \"' objects\");\n    }\n    return new Sk.builtin.str(this.v + other.v);\n};\nSk.builtin.str.prototype.nb$add = Sk.builtin.str.prototype.sq$concat;\nSk.builtin.str.prototype.nb$inplace_add = Sk.builtin.str.prototype.sq$concat;\nSk.builtin.str.prototype.sq$repeat = function (n) {\n    var i;\n    var ret;\n\n    if (!Sk.misceval.isIndex(n)) {\n        throw new Sk.builtin.TypeError(\"can't multiply sequence by non-int of type '\" + Sk.abstr.typeName(n) + \"'\");\n    }\n\n    n = Sk.misceval.asIndex(n);\n    ret = \"\";\n    for (i = 0; i < n; ++i) {\n        ret += this.v;\n    }\n    return new Sk.builtin.str(ret);\n};\nSk.builtin.str.prototype.nb$multiply = Sk.builtin.str.prototype.sq$repeat;\nSk.builtin.str.prototype.nb$inplace_multiply = Sk.builtin.str.prototype.sq$repeat;\nSk.builtin.str.prototype.sq$item = function () {\n    Sk.asserts.fail();\n};\nSk.builtin.str.prototype.sq$slice = function (i1, i2) {\n    i1 = Sk.builtin.asnum$(i1);\n    i2 = Sk.builtin.asnum$(i2);\n    if (i1 < 0) {\n        i1 = 0;\n    }\n    return new Sk.builtin.str(this.v.substr(i1, i2 - i1));\n};\n\nSk.builtin.str.prototype.sq$contains = function (ob) {\n    if (!(ob instanceof Sk.builtin.str)) {\n        throw new Sk.builtin.TypeError(\"TypeError: 'In <string> requires string as left operand\");\n    }\n    return this.v.indexOf(ob.v) != -1;\n};\n\nSk.builtin.str.prototype.__iter__ = new Sk.builtin.func(function (self) {\n    return new Sk.builtin.str_iter_(self);\n});\n\nSk.builtin.str.prototype.tp$iter = function () {\n    return new Sk.builtin.str_iter_(this);\n};\n\nSk.builtin.str.prototype.tp$richcompare = function (other, op) {\n    if (!(other instanceof Sk.builtin.str)) {\n        return undefined;\n    }\n\n    switch (op) {\n        case \"Lt\":\n            return this.v < other.v;\n        case \"LtE\":\n            return this.v <= other.v;\n        case \"Eq\":\n            return this.v === other.v;\n        case \"NotEq\":\n            return this.v !== other.v;\n        case \"Gt\":\n            return this.v > other.v;\n        case \"GtE\":\n            return this.v >= other.v;\n        default:\n            Sk.asserts.fail();\n    }\n};\n\nSk.builtin.str.prototype[\"$r\"] = function () {\n    // single is preferred\n    var ashex;\n    var c;\n    var i;\n    var ret;\n    var len;\n    var quote = \"'\";\n    //jshint ignore:start\n    if (this.v.indexOf(\"'\") !== -1 && this.v.indexOf('\"') === -1) {\n        quote = '\"';\n    }\n    //jshint ignore:end\n    len = this.v.length;\n    ret = quote;\n    for (i = 0; i < len; ++i) {\n        c = this.v.charAt(i);\n        if (c === quote || c === \"\\\\\") {\n            ret += \"\\\\\" + c;\n        } else if (c === \"\\t\") {\n            ret += \"\\\\t\";\n        } else if (c === \"\\n\") {\n            ret += \"\\\\n\";\n        } else if (c === \"\\r\") {\n            ret += \"\\\\r\";\n        } else if (c < \" \" || c >= 0x7f) {\n            ashex = c.charCodeAt(0).toString(16);\n            if (ashex.length < 2) {\n                ashex = \"0\" + ashex;\n            }\n            ret += \"\\\\x\" + ashex;\n        } else {\n            ret += c;\n        }\n    }\n    ret += quote;\n    return new Sk.builtin.str(ret);\n};\n\n\nSk.builtin.str.re_escape_ = function (s) {\n    var c;\n    var i;\n    var ret = [];\n    var re = /^[A-Za-z0-9]+$/;\n    for (i = 0; i < s.length; ++i) {\n        c = s.charAt(i);\n\n        if (re.test(c)) {\n            ret.push(c);\n        } else {\n            if (c === \"\\\\000\") {\n                ret.push(\"\\\\000\");\n            } else {\n                ret.push(\"\\\\\" + c);\n            }\n        }\n    }\n    return ret.join(\"\");\n};\n\nSk.builtin.str.prototype[\"lower\"] = new Sk.builtin.func(function (self) {\n    Sk.builtin.pyCheckArgsLen(\"lower\", arguments.length, 1, 1);\n    return new Sk.builtin.str(self.v.toLowerCase());\n});\n\nSk.builtin.str.prototype[\"upper\"] = new Sk.builtin.func(function (self) {\n    Sk.builtin.pyCheckArgsLen(\"upper\", arguments.length, 1, 1);\n    return new Sk.builtin.str(self.v.toUpperCase());\n});\n\nSk.builtin.str.prototype[\"capitalize\"] = new Sk.builtin.func(function (self) {\n    var i;\n    var cap;\n    var orig;\n    Sk.builtin.pyCheckArgsLen(\"capitalize\", arguments.length, 1, 1);\n    orig = self.v;\n\n    if (orig.length === 0) {\n        return new Sk.builtin.str(\"\");\n    }\n    cap = orig.charAt(0).toUpperCase();\n\n    for (i = 1; i < orig.length; i++) {\n        cap += orig.charAt(i).toLowerCase();\n    }\n    return new Sk.builtin.str(cap);\n});\n\nSk.builtin.str.prototype[\"join\"] = new Sk.builtin.func(function (self, seq) {\n    var it, i;\n    var arrOfStrs;\n    Sk.builtin.pyCheckArgsLen(\"join\", arguments.length, 2, 2);\n    Sk.builtin.pyCheckType(\"seq\", \"iterable\", Sk.builtin.checkIterable(seq));\n    arrOfStrs = [];\n    for (it = seq.tp$iter(), i = it.tp$iternext(); i !== undefined; i = it.tp$iternext()) {\n        if (i.constructor !== Sk.builtin.str) {\n            throw new Sk.builtin.TypeError(\"TypeError: sequence item \" + arrOfStrs.length + \": expected string, \" + typeof i + \" found\");\n        }\n        arrOfStrs.push(i.v);\n    }\n    return new Sk.builtin.str(arrOfStrs.join(self.v));\n});\n\nSk.builtin.str.prototype[\"split\"] = new Sk.builtin.func(function (self, on, howmany) {\n    var splits;\n    var index;\n    var match;\n    var result;\n    var s;\n    var str;\n    var regex;\n    Sk.builtin.pyCheckArgsLen(\"split\", arguments.length, 1, 3);\n    if ((on === undefined) || (on instanceof Sk.builtin.none)) {\n        on = null;\n    }\n    if ((on !== null) && !Sk.builtin.checkString(on)) {\n        throw new Sk.builtin.TypeError(\"expected a string\");\n    }\n    if ((on !== null) && on.v === \"\") {\n        throw new Sk.builtin.ValueError(\"empty separator\");\n    }\n    if ((howmany !== undefined) && !Sk.builtin.checkInt(howmany)) {\n        throw new Sk.builtin.TypeError(\"an integer is required\");\n    }\n\n    howmany = Sk.builtin.asnum$(howmany);\n    regex = /[\\s\\xa0]+/g;\n    str = self.v;\n    if (on === null) {\n        // Remove leading whitespace\n        str = str.replace(/^[\\s\\xa0]+/, \"\");\n    } else {\n        // Escape special characters in \"on\" so we can use a regexp\n        s = on.v.replace(/([.*+?=|\\\\\\/()\\[\\]\\{\\}^$])/g, \"\\\\$1\");\n        regex = new RegExp(s, \"g\");\n    }\n\n    // This is almost identical to re.split,\n    // except how the regexp is constructed\n\n    result = [];\n    index = 0;\n    splits = 0;\n    while ((match = regex.exec(str)) != null) {\n        if (match.index === regex.lastIndex) {\n            // empty match\n            break;\n        }\n        result.push(new Sk.builtin.str(str.substring(index, match.index)));\n        index = regex.lastIndex;\n        splits += 1;\n        if (howmany && (splits >= howmany)) {\n            break;\n        }\n    }\n    str = str.substring(index);\n    if (on !== null || (str.length > 0)) {\n        result.push(new Sk.builtin.str(str));\n    }\n\n    return new Sk.builtin.list(result);\n});\n\nSk.builtin.str.prototype[\"strip\"] = new Sk.builtin.func(function (self, chars) {\n    var regex;\n    var pattern;\n    Sk.builtin.pyCheckArgsLen(\"strip\", arguments.length, 1, 2);\n    if ((chars !== undefined) && !Sk.builtin.checkString(chars)) {\n        throw new Sk.builtin.TypeError(\"strip arg must be None or str\");\n    }\n    if (chars === undefined) {\n        pattern = /^\\s+|\\s+$/g;\n    } else {\n        regex = Sk.builtin.str.re_escape_(chars.v);\n        pattern = new RegExp(\"^[\" + regex + \"]+|[\" + regex + \"]+$\", \"g\");\n    }\n    return new Sk.builtin.str(self.v.replace(pattern, \"\"));\n});\n\nSk.builtin.str.prototype[\"lstrip\"] = new Sk.builtin.func(function (self, chars) {\n    var regex;\n    var pattern;\n    Sk.builtin.pyCheckArgsLen(\"lstrip\", arguments.length, 1, 2);\n    if ((chars !== undefined) && !Sk.builtin.checkString(chars)) {\n        throw new Sk.builtin.TypeError(\"lstrip arg must be None or str\");\n    }\n    if (chars === undefined) {\n        pattern = /^\\s+/g;\n    } else {\n        regex = Sk.builtin.str.re_escape_(chars.v);\n        pattern = new RegExp(\"^[\" + regex + \"]+\", \"g\");\n    }\n    return new Sk.builtin.str(self.v.replace(pattern, \"\"));\n});\n\nSk.builtin.str.prototype[\"rstrip\"] = new Sk.builtin.func(function (self, chars) {\n    var regex;\n    var pattern;\n    Sk.builtin.pyCheckArgsLen(\"rstrip\", arguments.length, 1, 2);\n    if ((chars !== undefined) && !Sk.builtin.checkString(chars)) {\n        throw new Sk.builtin.TypeError(\"rstrip arg must be None or str\");\n    }\n    if (chars === undefined) {\n        pattern = /\\s+$/g;\n    } else {\n        regex = Sk.builtin.str.re_escape_(chars.v);\n        pattern = new RegExp(\"[\" + regex + \"]+$\", \"g\");\n    }\n    return new Sk.builtin.str(self.v.replace(pattern, \"\"));\n});\n\nSk.builtin.str.prototype[\"__format__\"] = new Sk.builtin.func(function (self, format_spec) {\n    var formatstr;\n    Sk.builtin.pyCheckArgsLen(\"__format__\", arguments.length, 2, 2);\n\n    if (!Sk.builtin.checkString(format_spec)) {\n        if (Sk.__future__.exceptions) {\n            throw new Sk.builtin.TypeError(\"format() argument 2 must be str, not \" + Sk.abstr.typeName(format_spec));\n        } else {\n            throw new Sk.builtin.TypeError(\"format expects arg 2 to be string or unicode, not \" + Sk.abstr.typeName(format_spec));\n        }\n    } else {\n        formatstr = Sk.ffi.remapToJs(format_spec);\n        if (formatstr !== \"\" && formatstr !== \"s\") {\n            throw new Sk.builtin.NotImplementedError(\"format spec is not yet implemented\");\n        }\n    }\n\n    return new Sk.builtin.str(self);\n});\n\nSk.builtin.str.prototype[\"partition\"] = new Sk.builtin.func(function (self, sep) {\n    var pos;\n    var sepStr;\n    Sk.builtin.pyCheckArgsLen(\"partition\", arguments.length, 2, 2);\n    Sk.builtin.pyCheckType(\"sep\", \"string\", Sk.builtin.checkString(sep));\n    sepStr = new Sk.builtin.str(sep);\n    pos = self.v.indexOf(sepStr.v);\n    if (pos < 0) {\n        return new Sk.builtin.tuple([self, Sk.builtin.str.$emptystr, Sk.builtin.str.$emptystr]);\n    }\n\n    return new Sk.builtin.tuple([\n        new Sk.builtin.str(self.v.substring(0, pos)),\n        sepStr,\n        new Sk.builtin.str(self.v.substring(pos + sepStr.v.length))]);\n});\n\nSk.builtin.str.prototype[\"rpartition\"] = new Sk.builtin.func(function (self, sep) {\n    var pos;\n    var sepStr;\n    Sk.builtin.pyCheckArgsLen(\"rpartition\", arguments.length, 2, 2);\n    Sk.builtin.pyCheckType(\"sep\", \"string\", Sk.builtin.checkString(sep));\n    sepStr = new Sk.builtin.str(sep);\n    pos = self.v.lastIndexOf(sepStr.v);\n    if (pos < 0) {\n        return new Sk.builtin.tuple([Sk.builtin.str.$emptystr, Sk.builtin.str.$emptystr, self]);\n    }\n\n    return new Sk.builtin.tuple([\n        new Sk.builtin.str(self.v.substring(0, pos)),\n        sepStr,\n        new Sk.builtin.str(self.v.substring(pos + sepStr.v.length))]);\n});\n\nSk.builtin.str.prototype[\"count\"] = new Sk.builtin.func(function (self, pat, start, end) {\n    var normaltext;\n    var ctl;\n    var slice;\n    var m;\n    Sk.builtin.pyCheckArgsLen(\"count\", arguments.length, 2, 4);\n    if (!Sk.builtin.checkString(pat)) {\n        throw new Sk.builtin.TypeError(\"expected a character buffer object\");\n    }\n    if ((start !== undefined) && !Sk.builtin.checkInt(start)) {\n        throw new Sk.builtin.TypeError(\"slice indices must be integers or None or have an __index__ method\");\n    }\n    if ((end !== undefined) && !Sk.builtin.checkInt(end)) {\n        throw new Sk.builtin.TypeError(\"slice indices must be integers or None or have an __index__ method\");\n    }\n\n    if (start === undefined) {\n        start = 0;\n    } else {\n        start = Sk.builtin.asnum$(start);\n        start = start >= 0 ? start : self.v.length + start;\n    }\n\n    if (end === undefined) {\n        end = self.v.length;\n    } else {\n        end = Sk.builtin.asnum$(end);\n        end = end >= 0 ? end : self.v.length + end;\n    }\n\n    normaltext = pat.v.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, \"\\\\$&\");\n    m = new RegExp(normaltext, \"g\");\n    slice = self.v.slice(start, end);\n    ctl = slice.match(m);\n    if (!ctl) {\n        return  new Sk.builtin.int_(0);\n    } else {\n        return new Sk.builtin.int_(ctl.length);\n    }\n\n});\n\nSk.builtin.str.prototype[\"ljust\"] = new Sk.builtin.func(function (self, len, fillchar) {\n    var newstr;\n    Sk.builtin.pyCheckArgsLen(\"ljust\", arguments.length, 2, 3);\n    if (!Sk.builtin.checkInt(len)) {\n        throw new Sk.builtin.TypeError(\"integer argument exepcted, got \" + Sk.abstr.typeName(len));\n    }\n    if ((fillchar !== undefined) && (!Sk.builtin.checkString(fillchar) || fillchar.v.length !== 1)) {\n        throw new Sk.builtin.TypeError(\"must be char, not \" + Sk.abstr.typeName(fillchar));\n    }\n    if (fillchar === undefined) {\n        fillchar = \" \";\n    } else {\n        fillchar = fillchar.v;\n    }\n    len = Sk.builtin.asnum$(len);\n    if (self.v.length >= len) {\n        return self;\n    } else {\n        newstr = Array.prototype.join.call({length: Math.floor(len - self.v.length) + 1}, fillchar);\n        return new Sk.builtin.str(self.v + newstr);\n    }\n});\n\nSk.builtin.str.prototype[\"rjust\"] = new Sk.builtin.func(function (self, len, fillchar) {\n    var newstr;\n    Sk.builtin.pyCheckArgsLen(\"rjust\", arguments.length, 2, 3);\n    if (!Sk.builtin.checkInt(len)) {\n        throw new Sk.builtin.TypeError(\"integer argument exepcted, got \" + Sk.abstr.typeName(len));\n    }\n    if ((fillchar !== undefined) && (!Sk.builtin.checkString(fillchar) || fillchar.v.length !== 1)) {\n        throw new Sk.builtin.TypeError(\"must be char, not \" + Sk.abstr.typeName(fillchar));\n    }\n    if (fillchar === undefined) {\n        fillchar = \" \";\n    } else {\n        fillchar = fillchar.v;\n    }\n    len = Sk.builtin.asnum$(len);\n    if (self.v.length >= len) {\n        return self;\n    } else {\n        newstr = Array.prototype.join.call({length: Math.floor(len - self.v.length) + 1}, fillchar);\n        return new Sk.builtin.str(newstr + self.v);\n    }\n\n});\n\nSk.builtin.str.prototype[\"center\"] = new Sk.builtin.func(function (self, len, fillchar) {\n    var newstr;\n    var newstr1;\n    Sk.builtin.pyCheckArgsLen(\"center\", arguments.length, 2, 3);\n    if (!Sk.builtin.checkInt(len)) {\n        throw new Sk.builtin.TypeError(\"integer argument exepcted, got \" + Sk.abstr.typeName(len));\n    }\n    if ((fillchar !== undefined) && (!Sk.builtin.checkString(fillchar) || fillchar.v.length !== 1)) {\n        throw new Sk.builtin.TypeError(\"must be char, not \" + Sk.abstr.typeName(fillchar));\n    }\n    if (fillchar === undefined) {\n        fillchar = \" \";\n    } else {\n        fillchar = fillchar.v;\n    }\n    len = Sk.builtin.asnum$(len);\n    if (self.v.length >= len) {\n        return self;\n    } else {\n        newstr1 = Array.prototype.join.call({length: Math.floor((len - self.v.length) / 2) + 1}, fillchar);\n        newstr = newstr1 + self.v + newstr1;\n        if (newstr.length < len) {\n            newstr = newstr + fillchar;\n        }\n        return new Sk.builtin.str(newstr);\n    }\n\n});\n\nSk.builtin.str.prototype[\"find\"] = new Sk.builtin.func(function (self, tgt, start, end) {\n    var idx;\n    Sk.builtin.pyCheckArgsLen(\"find\", arguments.length, 2, 4);\n    if (!Sk.builtin.checkString(tgt)) {\n        throw new Sk.builtin.TypeError(\"expected a character buffer object\");\n    }\n    if ((start !== undefined) && !Sk.builtin.checkInt(start)) {\n        throw new Sk.builtin.TypeError(\"slice indices must be integers or None or have an __index__ method\");\n    }\n    if ((end !== undefined) && !Sk.builtin.checkInt(end)) {\n        throw new Sk.builtin.TypeError(\"slice indices must be integers or None or have an __index__ method\");\n    }\n\n    if (start === undefined) {\n        start = 0;\n    } else {\n        start = Sk.builtin.asnum$(start);\n        start = start >= 0 ? start : self.v.length + start;\n    }\n\n    if (end === undefined) {\n        end = self.v.length;\n    } else {\n        end = Sk.builtin.asnum$(end);\n        end = end >= 0 ? end : self.v.length + end;\n    }\n\n    idx = self.v.indexOf(tgt.v, start);\n    idx = ((idx >= start) && (idx < end)) ? idx : -1;\n\n    return new Sk.builtin.int_(idx);\n});\n\nSk.builtin.str.prototype[\"index\"] = new Sk.builtin.func(function (self, tgt, start, end) {\n    var idx;\n    Sk.builtin.pyCheckArgsLen(\"index\", arguments.length, 2, 4);\n    idx = Sk.misceval.callsimArray(self[\"find\"], [self, tgt, start, end]);\n    if (Sk.builtin.asnum$(idx) === -1) {\n        throw new Sk.builtin.ValueError(\"substring not found\");\n    }\n    return idx;\n});\n\nSk.builtin.str.prototype[\"rfind\"] = new Sk.builtin.func(function (self, tgt, start, end) {\n    var idx;\n    Sk.builtin.pyCheckArgsLen(\"rfind\", arguments.length, 2, 4);\n    if (!Sk.builtin.checkString(tgt)) {\n        throw new Sk.builtin.TypeError(\"expected a character buffer object\");\n    }\n    if ((start !== undefined) && !Sk.builtin.checkInt(start)) {\n        throw new Sk.builtin.TypeError(\"slice indices must be integers or None or have an __index__ method\");\n    }\n    if ((end !== undefined) && !Sk.builtin.checkInt(end)) {\n        throw new Sk.builtin.TypeError(\"slice indices must be integers or None or have an __index__ method\");\n    }\n\n    if (start === undefined) {\n        start = 0;\n    } else {\n        start = Sk.builtin.asnum$(start);\n        start = start >= 0 ? start : self.v.length + start;\n    }\n\n    if (end === undefined) {\n        end = self.v.length;\n    } else {\n        end = Sk.builtin.asnum$(end);\n        end = end >= 0 ? end : self.v.length + end;\n    }\n\n    idx = self.v.lastIndexOf(tgt.v, end);\n    idx = (idx !== end) ? idx : self.v.lastIndexOf(tgt.v, end - 1);\n    idx = ((idx >= start) && (idx < end)) ? idx : -1;\n\n    return new Sk.builtin.int_(idx);\n});\n\nSk.builtin.str.prototype[\"rindex\"] = new Sk.builtin.func(function (self, tgt, start, end) {\n    var idx;\n    Sk.builtin.pyCheckArgsLen(\"rindex\", arguments.length, 2, 4);\n    idx = Sk.misceval.callsimArray(self[\"rfind\"], [self, tgt, start, end]);\n    if (Sk.builtin.asnum$(idx) === -1) {\n        throw new Sk.builtin.ValueError(\"substring not found\");\n    }\n    return idx;\n});\n\nSk.builtin.str.prototype[\"startswith\"] = new Sk.builtin.func(function (self, tgt) {\n    Sk.builtin.pyCheckArgsLen(\"startswith\", arguments.length, 2, 2);\n    Sk.builtin.pyCheckType(\"tgt\", \"string\", Sk.builtin.checkString(tgt));\n    return new Sk.builtin.bool( self.v.indexOf(tgt.v) === 0);\n});\n\n// http://stackoverflow.com/questions/280634/endswith-in-javascript\nSk.builtin.str.prototype[\"endswith\"] = new Sk.builtin.func(function (self, tgt) {\n    Sk.builtin.pyCheckArgsLen(\"endswith\", arguments.length, 2, 2);\n    Sk.builtin.pyCheckType(\"tgt\", \"string\", Sk.builtin.checkString(tgt));\n    return new Sk.builtin.bool( self.v.indexOf(tgt.v, self.v.length - tgt.v.length) !== -1);\n});\n\nSk.builtin.str.prototype[\"replace\"] = new Sk.builtin.func(function (self, oldS, newS, count) {\n    var c;\n    var patt;\n    Sk.builtin.pyCheckArgsLen(\"replace\", arguments.length, 3, 4);\n    Sk.builtin.pyCheckType(\"oldS\", \"string\", Sk.builtin.checkString(oldS));\n    Sk.builtin.pyCheckType(\"newS\", \"string\", Sk.builtin.checkString(newS));\n    if ((count !== undefined) && !Sk.builtin.checkInt(count)) {\n        throw new Sk.builtin.TypeError(\"integer argument expected, got \" +\n            Sk.abstr.typeName(count));\n    }\n    count = Sk.builtin.asnum$(count);\n    patt = new RegExp(Sk.builtin.str.re_escape_(oldS.v), \"g\");\n\n    if ((count === undefined) || (count < 0)) {\n        return new Sk.builtin.str(self.v.replace(patt, newS.v));\n    }\n\n    c = 0;\n\n    function replacer (match) {\n        c++;\n        if (c <= count) {\n            return newS.v;\n        }\n        return match;\n    }\n\n    return new Sk.builtin.str(self.v.replace(patt, replacer));\n});\n\nSk.builtin.str.prototype[\"zfill\"] = new Sk.builtin.func(function (self, len) {\n    var str = self.v;\n    var ret;\n    var zeroes;\n    var offset;\n    var pad = \"\";\n\n    Sk.builtin.pyCheckArgsLen(\"zfill\", arguments.length, 2, 2);\n    if (! Sk.builtin.checkInt(len)) {\n        throw new Sk.builtin.TypeError(\"integer argument exepected, got \" + Sk.abstr.typeName(len));\n    }\n\n    // figure out how many zeroes are needed to make the proper length\n    zeroes = len.v - str.length;\n    // offset by 1 if there is a +/- at the beginning of the string\n    offset = (str[0] === \"+\" || str[0] === \"-\") ? 1 : 0;\n    for(var i = 0; i < zeroes; i++){\n        pad += \"0\";\n    }\n    // combine the string and the zeroes\n    ret = str.substr(0, offset) + pad + str.substr(offset);\n    return new Sk.builtin.str(ret);\n\n\n});\n\nSk.builtin.str.prototype[\"isdigit\"] = new Sk.builtin.func(function (self) {\n    Sk.builtin.pyCheckArgsLen(\"isdigit\", arguments.length, 1, 1);\n    return new Sk.builtin.bool( /^\\d+$/.test(self.v));\n});\n\nSk.builtin.str.prototype[\"isspace\"] = new Sk.builtin.func(function (self) {\n    Sk.builtin.pyCheckArgsLen(\"isspace\", arguments.length, 1, 1);\n    return new Sk.builtin.bool( /^\\s+$/.test(self.v));\n});\n\n\nSk.builtin.str.prototype[\"expandtabs\"] = new Sk.builtin.func(function (self, tabsize) {\n    // var input = self.v;\n    // var expanded = \"\";\n    // var split;\n    // var spacestr = \"\";\n    // var spacerem;\n\n\n    var spaces;\n    var expanded;\n\n    Sk.builtin.pyCheckArgsLen(\"expandtabs\", arguments.length, 1, 2);\n\n\n    if ((tabsize !== undefined) && ! Sk.builtin.checkInt(tabsize)) {\n        throw new Sk.builtin.TypeError(\"integer argument exepected, got \" + Sk.abstr.typeName(tabsize));\n    }\n    if (tabsize === undefined) {\n        tabsize = 8;\n    } else {\n        tabsize = Sk.builtin.asnum$(tabsize);\n    }\n\n    spaces = (new Array(tabsize + 1)).join(\" \");\n    expanded = self.v.replace(/([^\\r\\n\\t]*)\\t/g, function(a, b) {\n        return b + spaces.slice(b.length % tabsize);\n    });\n    return new Sk.builtin.str(expanded);\n});\n\nSk.builtin.str.prototype[\"swapcase\"] = new Sk.builtin.func(function (self) {\n    var ret;\n    Sk.builtin.pyCheckArgsLen(\"swapcase\", arguments.length, 1, 1);\n\n\n    ret = self.v.replace(/[a-z]/gi, function(c) {\n        var lc = c.toLowerCase();\n        return lc === c ? c.toUpperCase() : lc;\n    });\n\n    return new Sk.builtin.str(ret);\n});\n\nSk.builtin.str.prototype[\"splitlines\"] = new Sk.builtin.func(function (self, keepends) {\n    var data = self.v;\n    var i = 0;\n    var j = i;\n    var selflen = self.v.length;\n    var strs_w = [];\n    var ch;\n    var eol;\n    var sol = 0;\n    var slice;\n    Sk.builtin.pyCheckArgsLen(\"splitlines\", arguments.length, 1, 2);\n    if ((keepends !== undefined) && ! Sk.builtin.checkBool(keepends)) {\n        throw new Sk.builtin.TypeError(\"boolean argument expected, got \" + Sk.abstr.typeName(keepends));\n    }\n    if (keepends === undefined) {\n        keepends = false;\n    } else {\n        keepends = keepends.v;\n    }\n\n\n    for (i = 0; i < selflen; i ++) {\n        ch = data.charAt(i);\n        if (data.charAt(i + 1) === \"\\n\" && ch === \"\\r\") {\n            eol = i + 2;\n            slice = data.slice(sol, eol);\n            if (! keepends) {\n                slice = slice.replace(/(\\r|\\n)/g, \"\");\n            }\n            strs_w.push(new Sk.builtin.str(slice));\n            sol = eol;\n        } else if ((ch === \"\\n\" && data.charAt(i - 1) !== \"\\r\") || ch === \"\\r\") {\n            eol = i + 1;\n            slice = data.slice(sol, eol);\n            if (! keepends) {\n                slice = slice.replace(/(\\r|\\n)/g, \"\");\n            }\n            strs_w.push(new Sk.builtin.str(slice));\n            sol = eol;\n        }\n\n    }\n    if (sol < selflen) {\n        eol = selflen;\n        slice = data.slice(sol, eol);\n        if (! keepends) {\n            slice = slice.replace(/(\\r|\\n)/g, \"\");\n        }\n        strs_w.push(new Sk.builtin.str(slice));\n    }\n    return new Sk.builtin.list(strs_w);\n});\n\nSk.builtin.str.prototype[\"title\"] = new Sk.builtin.func(function (self) {\n    var ret;\n\n    Sk.builtin.pyCheckArgsLen(\"title\", arguments.length, 1, 1);\n\n    ret = self.v.replace(/[a-z][a-z]*/gi, function(str) {\n        return str[0].toUpperCase() + str.substr(1).toLowerCase();\n    });\n\n    return new Sk.builtin.str(ret);\n});\n\nSk.builtin.str.prototype[\"isalpha\"] = new Sk.builtin.func(function (self) {\n    Sk.builtin.pyCheckArgsLen(\"isalpha\", arguments.length, 1, 1);\n    return new Sk.builtin.bool( self.v.length && !/[^a-zA-Z]/.test(self.v));\n});\n\nSk.builtin.str.prototype[\"isalnum\"] = new Sk.builtin.func(function (self) {\n    Sk.builtin.pyCheckArgsLen(\"isalnum\", arguments.length, 1, 1);\n    return new Sk.builtin.bool( self.v.length && !/[^a-zA-Z0-9]/.test(self.v));\n});\n\n// does not account for unicode numeric values\nSk.builtin.str.prototype[\"isnumeric\"] = new Sk.builtin.func(function (self) {\n    Sk.builtin.pyCheckArgsLen(\"isnumeric\", arguments.length, 1, 1);\n    return new Sk.builtin.bool( self.v.length && !/[^0-9]/.test(self.v));\n});\n\nSk.builtin.str.prototype[\"islower\"] = new Sk.builtin.func(function (self) {\n    Sk.builtin.pyCheckArgsLen(\"islower\", arguments.length, 1, 1);\n    return new Sk.builtin.bool( self.v.length && /[a-z]/.test(self.v) && !/[A-Z]/.test(self.v));\n});\n\nSk.builtin.str.prototype[\"isupper\"] = new Sk.builtin.func(function (self) {\n    Sk.builtin.pyCheckArgsLen(\"isupper\", arguments.length, 1, 1);\n    return new Sk.builtin.bool( self.v.length && !/[a-z]/.test(self.v) && /[A-Z]/.test(self.v));\n});\n\nSk.builtin.str.prototype[\"istitle\"] = new Sk.builtin.func(function (self) {\n    // Comparing to str.title() seems the most intuitive thing, but it fails on \"\",\n    // Other empty-ish strings with no change.\n    var input = self.v;\n    var cased = false;\n    var previous_is_cased = false;\n    var pos;\n    var ch;\n    Sk.builtin.pyCheckArgsLen(\"istitle\", arguments.length, 1, 1);\n    for (pos = 0; pos < input.length; pos ++) {\n        ch = input.charAt(pos);\n        if (! /[a-z]/.test(ch) && /[A-Z]/.test(ch)) {\n            if (previous_is_cased) {\n                return new Sk.builtin.bool( false);\n            }\n            previous_is_cased = true;\n            cased = true;\n        } else if (/[a-z]/.test(ch) && ! /[A-Z]/.test(ch)) {\n            if (! previous_is_cased) {\n                return new Sk.builtin.bool( false);\n            }\n            cased = true;\n        } else {\n            previous_is_cased = false;\n        }\n    }\n    return new Sk.builtin.bool( cased);\n});\n\nSk.builtin.str.prototype.nb$remainder = function (rhs) {\n    // % format op. rhs can be a value, a tuple, or something with __getitem__ (dict)\n\n    // From http://docs.python.org/library/stdtypes.html#string-formatting the\n    // format looks like:\n    // 1. The '%' character, which marks the start of the specifier.\n    // 2. Mapping key (optional), consisting of a parenthesised sequence of characters (for example, (somename)).\n    // 3. Conversion flags (optional), which affect the result of some conversion types.\n    // 4. Minimum field width (optional). If specified as an '*' (asterisk), the actual width is read from the next\n    // element of the tuple in values, and the object to convert comes after the minimum field width and optional\n    // precision. 5. Precision (optional), given as a '.' (dot) followed by the precision. If specified as '*' (an\n    // asterisk), the actual width is read from the next element of the tuple in values, and the value to convert comes\n    // after the precision. 6. Length modifier (optional). 7. Conversion type.  length modifier is ignored\n\n    var ret;\n    var replFunc;\n    var index;\n    var regex;\n    if (rhs.constructor !== Sk.builtin.tuple && (rhs.mp$subscript === undefined || rhs.constructor === Sk.builtin.str)) {\n        rhs = new Sk.builtin.tuple([rhs]);\n    }\n\n    // general approach is to use a regex that matches the format above, and\n    // do an re.sub with a function as replacement to make the subs.\n\n    //           1 2222222222222222   33333333   444444444   5555555555555  66666  777777777777777777\n    regex = /%(\\([a-zA-Z0-9]+\\))?([#0 +\\-]+)?(\\*|[0-9]+)?(\\.(\\*|[0-9]+))?[hlL]?([diouxXeEfFgGcrs%])/g;\n    index = 0;\n    replFunc = function (substring, mappingKey, conversionFlags, fieldWidth, precision, precbody, conversionType) {\n        var result;\n        var convName;\n        var convValue;\n        var base;\n        var r;\n        var mk;\n        var value;\n        var handleWidth;\n        var formatNumber;\n        var alternateForm;\n        var precedeWithSign;\n        var blankBeforePositive;\n        var leftAdjust;\n        var zeroPad;\n        var i;\n        fieldWidth = Sk.builtin.asnum$(fieldWidth);\n        precision = Sk.builtin.asnum$(precision);\n\n        if (mappingKey === undefined || mappingKey === \"\") {\n            i = index++;\n        } // ff passes '' not undef for some reason\n\n        if (precision === \"\") { // ff passes '' here aswell causing problems with G,g, etc.\n            precision = undefined;\n        }\n\n        zeroPad = false;\n        leftAdjust = false;\n        blankBeforePositive = false;\n        precedeWithSign = false;\n        alternateForm = false;\n        if (conversionFlags) {\n            if (conversionFlags.indexOf(\"-\") !== -1) {\n                leftAdjust = true;\n            } else if (conversionFlags.indexOf(\"0\") !== -1) {\n                zeroPad = true;\n            }\n\n            if (conversionFlags.indexOf(\"+\") !== -1) {\n                precedeWithSign = true;\n            } else if (conversionFlags.indexOf(\" \") !== -1) {\n                blankBeforePositive = true;\n            }\n\n            alternateForm = conversionFlags.indexOf(\"#\") !== -1;\n        }\n\n        if (precision) {\n            precision = parseInt(precision.substr(1), 10);\n        }\n\n        formatNumber = function (n, base) {\n            var precZeroPadded;\n            var prefix;\n            var didSign;\n            var neg;\n            var r;\n            var j;\n            base = Sk.builtin.asnum$(base);\n            neg = false;\n            didSign = false;\n            if (typeof n === \"number\") {\n                if (n < 0) {\n                    n = -n;\n                    neg = true;\n                }\n                r = n.toString(base);\n            } else if (n instanceof Sk.builtin.float_) {\n                r = n.str$(base, false);\n                if (r.length > 2 && r.substr(-2) === \".0\") {\n                    r = r.substr(0, r.length - 2);\n                }\n                neg = n.nb$isnegative();\n            } else if (n instanceof Sk.builtin.int_) {\n                r = n.str$(base, false);\n                neg = n.nb$isnegative();\n            } else if (n instanceof Sk.builtin.lng) {\n                r = n.str$(base, false);\n                neg = n.nb$isnegative();\n            }\n\n            Sk.asserts.assert(r !== undefined, \"unhandled number format\");\n\n            precZeroPadded = false;\n\n            if (precision) {\n                //print(\"r.length\",r.length,\"precision\",precision);\n                for (j = r.length; j < precision; ++j) {\n                    r = \"0\" + r;\n                    precZeroPadded = true;\n                }\n            }\n\n            prefix = \"\";\n\n            if (neg) {\n                prefix = \"-\";\n            } else if (precedeWithSign) {\n                prefix = \"+\" + prefix;\n            } else if (blankBeforePositive) {\n                prefix = \" \" + prefix;\n            }\n\n            if (alternateForm) {\n                if (base === 16) {\n                    prefix += \"0x\";\n                } else if (base === 8 && !precZeroPadded && r !== \"0\") {\n                    prefix += \"0\";\n                }\n            }\n\n            return [prefix, r];\n        };\n\n        handleWidth = function (args) {\n            var totLen;\n            var prefix = args[0];\n            var r = args[1];\n            var j;\n            if (fieldWidth) {\n                fieldWidth = parseInt(fieldWidth, 10);\n                totLen = r.length + prefix.length;\n                if (zeroPad) {\n                    for (j = totLen; j < fieldWidth; ++j) {\n                        r = \"0\" + r;\n                    }\n                } else if (leftAdjust) {\n                    for (j = totLen; j < fieldWidth; ++j) {\n                        r = r + \" \";\n                    }\n                } else {\n                    for (j = totLen; j < fieldWidth; ++j) {\n                        prefix = \" \" + prefix;\n                    }\n                }\n            }\n            return prefix + r;\n        };\n\n        //print(\"Rhs:\",rhs, \"ctor\", rhs.constructor);\n        if (rhs.constructor === Sk.builtin.tuple) {\n            value = rhs.v[i];\n        } else if (rhs.mp$subscript !== undefined && mappingKey !== undefined) {\n            mk = mappingKey.substring(1, mappingKey.length - 1);\n            //print(\"mk\",mk);\n            value = rhs.mp$subscript(new Sk.builtin.str(mk));\n        } else if (rhs.constructor === Sk.builtin.dict || rhs.constructor === Sk.builtin.list) {\n            // new case where only one argument is provided\n            value = rhs;\n        } else {\n            throw new Sk.builtin.AttributeError(rhs.tp$name + \" instance has no attribute 'mp$subscript'\");\n        }\n        base = 10;\n        if (conversionType === \"d\" || conversionType === \"i\") {\n            return handleWidth(formatNumber(value, 10));\n        } else if (conversionType === \"o\") {\n            return handleWidth(formatNumber(value, 8));\n        } else if (conversionType === \"x\") {\n            return handleWidth(formatNumber(value, 16));\n        } else if (conversionType === \"X\") {\n            return handleWidth(formatNumber(value, 16)).toUpperCase();\n        } else if (conversionType === \"f\" || conversionType === \"F\" || conversionType === \"e\" || conversionType === \"E\" || conversionType === \"g\" || conversionType === \"G\") {\n            convValue = Sk.builtin.asnum$(value);\n            if (typeof convValue === \"string\") {\n                convValue = Number(convValue);\n            }\n            if (convValue === Infinity) {\n                return \"inf\";\n            }\n            if (convValue === -Infinity) {\n                return \"-inf\";\n            }\n            if (isNaN(convValue)) {\n                return \"nan\";\n            }\n            convName = [\"toExponential\", \"toFixed\", \"toPrecision\"][\"efg\".indexOf(conversionType.toLowerCase())];\n            if (precision === undefined || precision === \"\") {\n                if (conversionType === \"e\" || conversionType === \"E\") {\n                    precision = 6;\n                } else if (conversionType === \"f\" || conversionType === \"F\") {\n                    precision = 7;\n                }\n            }\n            result = (convValue)[convName](precision); // possible loose of negative zero sign\n\n            // apply sign to negative zeros, floats only!\n            if(Sk.builtin.checkFloat(value)) {\n                if(convValue === 0 && 1/convValue === -Infinity) {\n                    result = \"-\" + result; // add sign for zero\n                }\n            }\n\n            if (\"EFG\".indexOf(conversionType) !== -1) {\n                result = result.toUpperCase();\n            }\n            return handleWidth([\"\", result]);\n        } else if (conversionType === \"c\") {\n            if (typeof value === \"number\") {\n                return String.fromCharCode(value);\n            } else if (value instanceof Sk.builtin.int_) {\n                return String.fromCharCode(value.v);\n            } else if (value instanceof Sk.builtin.float_) {\n                return String.fromCharCode(value.v);\n            } else if (value instanceof Sk.builtin.lng) {\n                return String.fromCharCode(value.str$(10, false)[0]);\n            } else if (value.constructor === Sk.builtin.str) {\n                return value.v.substr(0, 1);\n            } else {\n                throw new Sk.builtin.TypeError(\"an integer is required\");\n            }\n        } else if (conversionType === \"r\") {\n            r = Sk.builtin.repr(value);\n            if (precision) {\n                return r.v.substr(0, precision);\n            }\n            return r.v;\n        } else if (conversionType === \"s\") {\n            r = new Sk.builtin.str(value);\n            r = r.$jsstr();\n            if (precision) {\n                return r.substr(0, precision);\n            }\n            if(fieldWidth) {\n                r = handleWidth([\" \", r]);\n            }\n            return r;\n        } else if (conversionType === \"%\") {\n            return \"%\";\n        }\n    };\n\n    ret = this.v.replace(regex, replFunc);\n    return new Sk.builtin.str(ret);\n};\n\n/**\n * @constructor\n * @param {Object} obj\n */\nSk.builtin.str_iter_ = function (obj) {\n    if (!(this instanceof Sk.builtin.str_iter_)) {\n        return new Sk.builtin.str_iter_(obj);\n    }\n    this.$index = 0;\n    this.$obj = obj.v.slice();\n    this.sq$length = this.$obj.length;\n    this.tp$iter = this;\n    this.tp$iternext = function () {\n        if (this.$index >= this.sq$length) {\n            return undefined;\n        }\n        return new Sk.builtin.str(this.$obj.substr(this.$index++, 1));\n    };\n    this.$r = function () {\n        return new Sk.builtin.str(\"iterator\");\n    };\n    return this;\n};\n\nSk.abstr.setUpInheritance(\"iterator\", Sk.builtin.str_iter_, Sk.builtin.object);\n\nSk.builtin.str_iter_.prototype.__class__ = Sk.builtin.str_iter_;\n\nSk.builtin.str_iter_.prototype.__iter__ = new Sk.builtin.func(function (self) {\n    Sk.builtin.pyCheckArgsLen(\"__iter__\", arguments.length, 0, 0, true, false);\n    return self;\n});\n\nSk.builtin.str_iter_.prototype.next$ = function (self) {\n    var ret = self.tp$iternext();\n    if (ret === undefined) {\n        throw new Sk.builtin.StopIteration();\n    }\n    return ret;\n};\n","var format = function (kwa) {\n    // following PEP 3101\n\n    var a, args, key, kwargs;\n    var ret;\n    var regex;\n    var index;\n    var replFunc;\n    var arg_dict = {};\n\n    Sk.builtin.pyCheckArgsLen(\"format\", arguments.length, 0, Infinity, true, true);\n\n    args = new Sk.builtins[\"tuple\"](Array.prototype.slice.call(arguments, 1)); /*vararg*/\n    kwargs = new Sk.builtins[\"dict\"](kwa);\n\n    if (arguments[1] === undefined) {\n        return args.v;\n    }\n    index = 0;\n    regex = /{(((?:\\d+)|(?:\\w+))?((?:\\.(\\w+))|(?:\\[((?:\\d+)|(?:\\w+))\\])?))?(?:\\!([rs]))?(?:\\:((?:(.)?([<\\>\\=\\^]))?([\\+\\-\\s])?(#)?(0)?(\\d+)?(,)?(?:\\.(\\d+))?([bcdeEfFgGnosxX%])?))?}/g;\n    // ex: {o.name!r:*^+#030,.9b}\n    // Field 1, Field_name, o.name\n    // Field 2, arg_name, o\n    // Field 3, attribute_name/Element_index , .name\n    // Field 4, Attribute name, name\n    // Field 5, element_index, [0]\n    // Field 6, conversion, r\n    // Field 7, format_spec,*^+#030,.9b\n    // Field 9, fill_character,*\n    // Field 10, fill_align, ^\n    // Field 11, sign, +\n    // Field 12, 0x, #\n    // Filed 13, sign-aware 0 padding, 0\n    // Field 14, width, 30\n    // Field 15, comma, ,\n    // Field 16, precision, .9\n    // Field 17, conversionType, b\n\n    // Detect empty/int/complex name\n    // retrive field value\n    // hand off format spec\n    // return resulting spec to function\n\n\n    if(kwargs.size !== 0){\n\n        var kwItems = Sk.misceval.callsimArray(Sk.builtin.dict.prototype[\"items\"], [kwargs]);\n\n        for (var n in kwItems.v){\n            arg_dict[kwItems.v[n].v[0].v] = kwItems.v[n].v[1];\n        }\n    }\n    for(var i in args.v){\n        if(i !== \"0\") {\n            arg_dict[i-1] = args.v[i];\n        }\n    }\n\n    replFunc = function (substring, field_name, arg_name, attr_name, attribute_name, element_index, conversion, format_spec, fill_char, fill_align, sign, zero_pad, sign_aware, fieldWidth, comma, precision, conversionType, offset, str_whole) {\n        var return_str;\n        var formatNumber;\n        var formatFormat;\n        var result;\n        var base;\n        var value;\n        var handleWidth;\n        var alternateForm;\n        var precedeWithSign;\n        var blankBeforePositive;\n        var leftAdjust;\n        var centerAdjust;\n        var zeroPad;\n        var convName;\n        var convValue;\n        var percent;\n        var container;\n        fieldWidth = Sk.builtin.asnum$(fieldWidth);\n        precision = Sk.builtin.asnum$(precision);\n\n        if(element_index !== undefined && element_index !== \"\"){\n            container = arg_dict[arg_name];\n            if (container.constructor === Array) {\n                value = container[element_index];\n            } else {\n                if (container instanceof Sk.builtin.dict) {\n                    value = Sk.abstr.objectGetItem(container, new Sk.builtin.str(element_index), false);\n                } else {\n                    value = Sk.abstr.objectGetItem(container, new Sk.builtin.int_(parseInt(element_index, 10)), false);\n                }\n            }\n            index++;\n        } else if(attribute_name !== undefined && attribute_name !== \"\"){\n            value = arg_dict[arg_name][attribute_name];\n            index++;\n        } else if(arg_name !== undefined && arg_name !== \"\"){\n            value = arg_dict[arg_name];\n            index++;\n        } else if(field_name === undefined || field_name === \"\"){\n            return_str = arg_dict[index];\n            index++;\n            value = return_str;\n        } else if(field_name instanceof Sk.builtin.int_ ||\n                  field_name instanceof Sk.builtin.float_ ||\n                  field_name instanceof Sk.builtin.lng || !isNaN(parseInt(field_name, 10))){\n            return_str = arg_dict[field_name];\n            index++;\n            value = return_str;\n        }\n\n        if (precision === \"\") { // ff passes '' here aswell causing problems with G,g, etc.\n            precision = undefined;\n        }\n        if(fill_char === undefined || fill_char === \"\"){\n            fill_char = \" \";\n        }\n\n        zeroPad = false;\n        leftAdjust = false;\n        centerAdjust = false;\n        blankBeforePositive = false;\n        precedeWithSign = false;\n        alternateForm = false;\n        if (format_spec) {\n            if(sign !== undefined && sign !== \"\"){\n                if (\"-\".indexOf(sign) !== -1) {\n                    leftAdjust = true;\n                } else if (\"+\".indexOf(sign) !== -1) {\n                    precedeWithSign = true;\n                } else if (\" \".indexOf(sign) !== -1) {\n                    blankBeforePositive = true;\n                }\n            }\n            if(zero_pad){\n                alternateForm = \"#\".indexOf(zero_pad) !== -1;\n            }\n            if(fieldWidth !== undefined && fieldWidth !== \"\"){\n                if(fill_char === undefined || fill_char === \"\"){\n                    fill_char = \" \";\n                }\n            }\n            if(\"%\".indexOf(conversionType) !== -1){\n                percent = true;\n            }\n        }\n        if (precision) {\n            precision = parseInt(precision, 10);\n        }\n\n        formatFormat = function(value){\n            var r;\n            var s;\n            if(conversion === undefined || conversion === \"\" || conversion == \"s\"){\n                s = new Sk.builtin.str(value);\n                return s.v;\n            } else if(conversion == \"r\"){\n                r = Sk.builtin.repr(value);\n                return r.v;\n            }\n\n        };\n\n        handleWidth = function (prefix, r) {\n            // print(prefix);\n            var totLen;\n            r = Sk.ffi.remapToJs(r);\n\n            var j;\n            if(percent){\n                r = r +\"%\";\n            }\n            if (fieldWidth !== undefined && fieldWidth !== \"\") {\n                fieldWidth = parseInt(fieldWidth, 10);\n                totLen = r.length + prefix.length;\n                if (zeroPad) {\n                    for (j = totLen; j < fieldWidth; ++j) {\n                        r = \"0\" + r;\n                    }\n                } else if (leftAdjust) {\n                    for (j = totLen; j < fieldWidth; ++j) {\n                        r = r + fill_char;\n                    }\n                } else if(\">\".indexOf(fill_align) !== -1){\n                    for (j = totLen; j < fieldWidth; ++j) {\n                        prefix = fill_char + prefix;\n                    }\n                } else if(\"^\".indexOf(fill_align) !== -1){\n                    for (j = totLen; j < fieldWidth; ++j) {\n                        if(j % 2 === 0){\n                            prefix = fill_char + prefix;\n                        } else if ( j % 2 === 1){\n                            r = r + fill_char;\n                        }\n                    }\n                } else if(\"=\".indexOf(fill_align) !== -1){\n                    for (j = totLen; j < fieldWidth; ++j) {\n                        r =  fill_char + r;\n                    }\n                } else{\n                    for (j = totLen; j < fieldWidth; ++j) {\n                        r = r + fill_char;\n                    }\n                }\n            }\n            return formatFormat(prefix + r);\n        };\n\n        formatNumber = function(n, base){\n            var precZeroPadded;\n            var prefix;\n            var neg;\n            var r;\n\n            base = Sk.builtin.asnum$(base);\n            neg = false;\n\n            if(format_spec === undefined){\n                return formatFormat(value);\n            }\n\n            if (typeof n === \"number\") {\n                if (n < 0) {\n                    n = -n;\n                    neg = true;\n                }\n                r = n.toString(base);\n            } else if (n instanceof Sk.builtin.float_) {\n                r = n.str$(base, false);\n                if (r.length > 2 && r.substr(-2) === \".0\") {\n                    r = r.substr(0, r.length - 2);\n                }\n                neg = n.nb$isnegative();\n            } else if (n instanceof Sk.builtin.int_) {\n                r = n.str$(base, false);\n                neg = n.nb$isnegative();\n            } else if (n instanceof Sk.builtin.lng) {\n                r = n.str$(base, false);\n                neg = n.nb$isnegative();    //  neg = n.size$ < 0;  RNL long.js change\n            } else{\n                r = n;\n            }\n\n            if (precision) {\n                n = Number(r);\n                if (n < 0) {\n                    n = -n;\n                    neg = true;\n                }\n                r = n.toFixed(precision);\n            }\n\n            precZeroPadded = false;\n            prefix = \"\";\n\n            if (neg) {\n                prefix = \"-\";\n            } else if (precedeWithSign) {\n                prefix = \"+\" ;\n            } else if (blankBeforePositive) {\n                prefix = \" \" ;\n            }\n\n            if (alternateForm) {\n                if (base === 16) {\n                    prefix += \"0x\";\n                } else if (base === 8 && !precZeroPadded && r !== \"0\") {\n                    prefix += \"0o\";\n                } else if (base === 2 && !precZeroPadded && r !== \"0\"){\n                    prefix += \"0b\";\n                }\n            }\n\n            if(conversionType === \"n\"){\n                r=r.toLocaleString();\n            } else if(\",\".indexOf(comma) !== -1){\n                var parts = r.toString().split(\".\");\n                parts[0] = parts[0].replace(/\\B(?=(\\d{3})+(?!\\d))/g, \",\");\n                r = parts.join(\".\");\n            }\n            return handleWidth(prefix, r);\n        };\n\n        base = 10;\n        if(conversionType === \"d\" || conversionType === \"n\" || conversionType === \"\" || conversionType === undefined){\n            return formatNumber(value, 10);\n        }else if (conversionType === \"b\") {\n            return formatNumber(value, 2);\n        }else if (conversionType === \"o\") {\n            return formatNumber(value, 8);\n        } else if (conversionType === \"x\") {\n            return formatNumber(value, 16);\n        } else if (conversionType === \"X\") {\n            return formatNumber(value, 16).toUpperCase();\n        } else if (conversionType === \"f\" || conversionType === \"F\" || conversionType === \"e\" || conversionType === \"E\" || conversionType === \"g\" || conversionType === \"G\") {\n            if(alternateForm){\n                throw new Sk.builtin.ValueError(\"Alternate form (#) not allowed in float format specifier\");\n            }\n            convValue = Sk.builtin.asnum$(value);\n            if (typeof convValue === \"string\") {\n                convValue = Number(convValue);\n            }\n            if (convValue === Infinity) {\n                return handleWidth(\"\",\"inf\");\n            }\n            if (convValue === -Infinity) {\n                return handleWidth(\"-\",\"inf\");\n            }\n            if (isNaN(convValue)) {\n                return handleWidth(\"\",\"nan\");\n            }\n            convName = [\"toExponential\", \"toFixed\", \"toPrecision\"][\"efg\".indexOf(conversionType.toLowerCase())];\n            if (precision === undefined || precision === \"\") {\n                if (conversionType === \"e\" || conversionType === \"E\" || conversionType === \"%\") {\n                    precision = parseInt(6, 10);\n                } else if (conversionType === \"f\" || conversionType === \"F\") {\n                    precision = parseInt(6, 10);\n                }\n            }\n            result = (convValue)[convName](precision);\n            if (\"EFG\".indexOf(conversionType) !== -1) {\n                result = result.toUpperCase();\n            }\n            return formatNumber(result, 10);\n        } else if (conversionType === \"c\") {\n            if (typeof value === \"number\") {\n                return handleWidth(\"\", String.fromCharCode(value));\n            } else if (value instanceof Sk.builtin.int_) {\n                return handleWidth(\"\", String.fromCharCode(value.v));\n            } else if (value instanceof Sk.builtin.float_) {\n                return handleWidth(\"\", String.fromCharCode(value.v));\n            } else if (value instanceof Sk.builtin.lng) {\n                return handleWidth(\"\", String.fromCharCode(value.str$(10, false)[0]));\n            } else if (value.constructor === Sk.builtin.str) {\n                return handleWidth(\"\", value.v.substr(0, 1));\n            } else {\n                throw new Sk.builtin.TypeError(\"an integer is required\");\n            }\n        } else if (percent) {\n            if(precision === undefined){precision = parseInt(7,10);}\n            return formatNumber(value.nb$multiply(new Sk.builtin.int_(100)), 10);\n        }\n\n    };\n\n    ret = args.v[0].v.replace(regex, replFunc);\n    return new Sk.builtin.str(ret);\n};\n\nformat[\"co_kwargs\"] = true;\nSk.builtin.str.prototype[\"format\"] = new Sk.builtin.func(format);\n","/**\n * @constructor\n * @param {Array.<Object>|Object} L\n */\nSk.builtin.tuple = function (L) {\n    var it, i;\n    if (!(this instanceof Sk.builtin.tuple)) {\n        Sk.builtin.pyCheckArgsLen(\"tuple\", arguments.length, 0, 1);\n        return new Sk.builtin.tuple(L);\n    }\n\n\n    if (L === undefined) {\n        L = [];\n    }\n\n    if (Object.prototype.toString.apply(L) === \"[object Array]\") {\n        this.v = L;\n    } else {\n        if (Sk.builtin.checkIterable(L)) {\n            this.v = [];\n            for (it = Sk.abstr.iter(L), i = it.tp$iternext(); i !== undefined; i = it.tp$iternext()) {\n                this.v.push(i);\n            }\n        } else {\n            throw new Sk.builtin.TypeError(\"expecting Array or iterable\");\n        }\n    }\n\n    this.__class__ = Sk.builtin.tuple;\n\n    this[\"v\"] = this.v;\n    return this;\n};\n\nSk.abstr.setUpInheritance(\"tuple\", Sk.builtin.tuple, Sk.builtin.seqtype);\n\nSk.builtin.tuple.prototype[\"$r\"] = function () {\n    var ret;\n    var i;\n    var bits;\n    if (this.v.length === 0) {\n        return new Sk.builtin.str(\"()\");\n    }\n    bits = [];\n    for (i = 0; i < this.v.length; ++i) {\n        bits[i] = Sk.misceval.objectRepr(this.v[i]).v;\n    }\n    ret = bits.join(\", \");\n    if (this.v.length === 1) {\n        ret += \",\";\n    }\n    return new Sk.builtin.str(\"(\" + ret + \")\");\n};\n\nSk.builtin.tuple.prototype.mp$subscript = function (index) {\n    var ret;\n    var i;\n    if (Sk.misceval.isIndex(index)) {\n        i = Sk.misceval.asIndex(index);\n        if (i !== undefined) {\n            if (i < 0) {\n                i = this.v.length + i;\n            }\n            if (i < 0 || i >= this.v.length) {\n                throw new Sk.builtin.IndexError(\"tuple index out of range\");\n            }\n            return this.v[i];\n        }\n    } else if (index instanceof Sk.builtin.slice) {\n        ret = [];\n        index.sssiter$(this, function (i, wrt) {\n            ret.push(wrt.v[i]);\n        });\n        return new Sk.builtin.tuple(ret);\n    }\n\n    throw new Sk.builtin.TypeError(\"tuple indices must be integers, not \" + Sk.abstr.typeName(index));\n};\n\n// todo; the numbers and order are taken from python, but the answer's\n// obviously not the same because there's no int wrapping. shouldn't matter,\n// but would be nice to make the hash() values the same if it's not too\n// expensive to simplify tests.\nSk.builtin.tuple.prototype.tp$hash = function () {\n    var y;\n    var i;\n    var mult = 1000003;\n    var x = 0x345678;\n    var len = this.v.length;\n    for (i = 0; i < len; ++i) {\n        y = Sk.builtin.hash(this.v[i]).v;\n        if (y === -1) {\n            return new Sk.builtin.int_(-1);\n        }\n        x = (x ^ y) * mult;\n        mult += 82520 + len + len;\n    }\n    x += 97531;\n    if (x === -1) {\n        x = -2;\n    }\n    return new Sk.builtin.int_(x | 0);\n};\n\nSk.builtin.tuple.prototype.sq$repeat = function (n) {\n    var j;\n    var i;\n    var ret;\n\n    n = Sk.misceval.asIndex(n);\n    ret = [];\n    for (i = 0; i < n; ++i) {\n        for (j = 0; j < this.v.length; ++j) {\n            ret.push(this.v[j]);\n        }\n    }\n    return new Sk.builtin.tuple(ret);\n};\nSk.builtin.tuple.prototype.nb$multiply = Sk.builtin.tuple.prototype.sq$repeat;\nSk.builtin.tuple.prototype.nb$inplace_multiply = Sk.builtin.tuple.prototype.sq$repeat;\n\nSk.builtin.tuple.prototype.__iter__ = new Sk.builtin.func(function (self) {\n    Sk.builtin.pyCheckArgsLen(\"__iter__\", arguments.length, 1, 1);\n    return new Sk.builtin.tuple_iter_(self);\n});\n\nSk.builtin.tuple.prototype.tp$iter = function () {\n    return new Sk.builtin.tuple_iter_(this);\n};\n\nSk.builtin.tuple.prototype.tp$richcompare = function (w, op) {\n    //print(\"  tup rc\", JSON.stringify(this.v), JSON.stringify(w), op);\n\n    // w not a tuple\n    var k;\n    var i;\n    var wl;\n    var vl;\n    var v;\n    if (!w.__class__ ||\n        !Sk.misceval.isTrue(Sk.builtin.isinstance(w, Sk.builtin.tuple))) {\n        // shortcuts for eq/not\n        if (op === \"Eq\") {\n            return false;\n        }\n        if (op === \"NotEq\") {\n            return true;\n        }\n\n        // todo; other types should have an arbitrary order\n        return false;\n    }\n\n    v = this.v;\n    w = w.v;\n    vl = v.length;\n    wl = w.length;\n\n    for (i = 0; i < vl && i < wl; ++i) {\n        k = Sk.misceval.richCompareBool(v[i], w[i], \"Eq\");\n        if (!k) {\n            break;\n        }\n    }\n\n    if (i >= vl || i >= wl) {\n        // no more items to compare, compare sizes\n        switch (op) {\n            case \"Lt\":\n                return vl < wl;\n            case \"LtE\":\n                return vl <= wl;\n            case \"Eq\":\n                return vl === wl;\n            case \"NotEq\":\n                return vl !== wl;\n            case \"Gt\":\n                return vl > wl;\n            case \"GtE\":\n                return vl >= wl;\n            default:\n                Sk.asserts.fail();\n        }\n    }\n\n    // we have an item that's different\n\n    // shortcuts for eq/not\n    if (op === \"Eq\") {\n        return false;\n    }\n    if (op === \"NotEq\") {\n        return true;\n    }\n\n    // or, compare the differing element using the proper operator\n    //print(\"  tup rcb end\", i, v[i] instanceof Sk.builtin.str, JSON.stringify(v[i]), w[i] instanceof Sk.builtin.str, JSON.stringify(w[i]), op);\n    return Sk.misceval.richCompareBool(v[i], w[i], op);\n};\n\nSk.builtin.tuple.prototype.sq$concat = function (other) {\n    var msg;\n    if (other.__class__ != Sk.builtin.tuple) {\n        msg = \"can only concatenate tuple (not \\\"\";\n        msg += Sk.abstr.typeName(other) + \"\\\") to tuple\";\n        throw new Sk.builtin.TypeError(msg);\n    }\n\n    return new Sk.builtin.tuple(this.v.concat(other.v));\n};\n\nSk.builtin.tuple.prototype.sq$contains = function (ob) {\n    var it, i;\n\n    for (it = this.tp$iter(), i = it.tp$iternext(); i !== undefined; i = it.tp$iternext()) {\n        if (Sk.misceval.richCompareBool(i, ob, \"Eq\")) {\n            return true;\n        }\n    }\n\n    return false;\n};\n\nSk.builtin.tuple.prototype.nb$add = Sk.builtin.tuple.prototype.sq$concat;\nSk.builtin.tuple.prototype.nb$inplace_add = Sk.builtin.tuple.prototype.sq$concat;\n\nSk.builtin.tuple.prototype.sq$length = function () {\n    return this.v.length;\n};\n\n\nSk.builtin.tuple.prototype[\"index\"] = new Sk.builtin.func(function (self, item) {\n    var i;\n    var len = self.v.length;\n    var obj = self.v;\n    for (i = 0; i < len; ++i) {\n        if (Sk.misceval.richCompareBool(obj[i], item, \"Eq\")) {\n            return new Sk.builtin.int_(i);\n        }\n    }\n    throw new Sk.builtin.ValueError(\"tuple.index(x): x not in tuple\");\n});\n\nSk.builtin.tuple.prototype[\"count\"] = new Sk.builtin.func(function (self, item) {\n    var i;\n    var len = self.v.length;\n    var obj = self.v;\n    var count = 0;\n    for (i = 0; i < len; ++i) {\n        if (Sk.misceval.richCompareBool(obj[i], item, \"Eq\")) {\n            count += 1;\n        }\n    }\n    return  new Sk.builtin.int_(count);\n});\n\nSk.exportSymbol(\"Sk.builtin.tuple\", Sk.builtin.tuple);\n\n/**\n * @constructor\n * @param {Object} obj\n */\nSk.builtin.tuple_iter_ = function (obj) {\n    if (!(this instanceof Sk.builtin.tuple_iter_)) {\n        return new Sk.builtin.tuple_iter_(obj);\n    }\n    this.$index = 0;\n    this.$obj = obj.v.slice();\n    this.sq$length = this.$obj.length;\n    this.tp$iter = this;\n    this.tp$iternext = function () {\n        if (this.$index >= this.sq$length) {\n            return undefined;\n        }\n        return this.$obj[this.$index++];\n    };\n    this.$r = function () {\n        return new Sk.builtin.str(\"tupleiterator\");\n    };\n    return this;\n};\n\nSk.abstr.setUpInheritance(\"tupleiterator\", Sk.builtin.tuple_iter_, Sk.builtin.object);\n\nSk.builtin.tuple_iter_.prototype.__class__ = Sk.builtin.tuple_iter_;\n\nSk.builtin.tuple_iter_.prototype.__iter__ = new Sk.builtin.func(function (self) {\n    return self;\n});\n\nSk.builtin.tuple_iter_.prototype.next$ = function (self) {\n    var ret = self.tp$iternext();\n    if (ret === undefined) {\n        throw new Sk.builtin.StopIteration();\n    }\n    return ret;\n};\n","/**\n * @constructor\n * @param {Array.<Object>} L\n */\nSk.builtin.dict = function dict (L) {\n    var v;\n    var it, k;\n    var i;\n    if (!(this instanceof Sk.builtin.dict)) {\n        return new Sk.builtin.dict(L);\n    }\n\n\n    if (L === undefined) {\n        L = [];\n    }\n\n    this.size = 0;\n    this.buckets = {};\n\n    if (Object.prototype.toString.apply(L) === \"[object Array]\") {\n        // Handle dictionary literals\n        for (i = 0; i < L.length; i += 2) {\n            this.mp$ass_subscript(L[i], L[i + 1]);\n        }\n    } else if (L instanceof Sk.builtin.dict) {\n        // Handle calls of type \"dict(mapping)\" from Python code\n        for (it = Sk.abstr.iter(L), k = it.tp$iternext();\n            k !== undefined;\n            k = it.tp$iternext()) {\n            v = L.mp$subscript(k);\n            if (v === undefined) {\n                //print(k, \"had undefined v\");\n                v = null;\n            }\n            this.mp$ass_subscript(k, v);\n        }\n    } else if (Sk.builtin.checkIterable(L)) {\n        // Handle calls of type \"dict(iterable)\" from Python code\n        for (it = Sk.abstr.iter(L), i = it.tp$iternext(); i !== undefined; i = it.tp$iternext()) {\n            if (i.mp$subscript) {\n                this.mp$ass_subscript(i.mp$subscript(0), i.mp$subscript(1));\n            } else {\n                throw new Sk.builtin.TypeError(\"element \" + this.size + \" is not a sequence\");\n            }\n        }\n    } else {\n        throw new Sk.builtin.TypeError(\"object is not iterable\");\n    }\n\n    this.__class__ = Sk.builtin.dict;\n    this.tp$call = undefined; // Not callable, even though constructor is\n\n    return this;\n};\n\nSk.builtin.dict.tp$call = function(args, kw) {\n    var d, i;\n    Sk.builtin.pyCheckArgsLen(\"dict\", args, 0, 1);\n    d = new Sk.builtin.dict(args[0]);\n    if (kw) {\n        for (i = 0; i < kw.length; i += 2) {\n            d.mp$ass_subscript(new Sk.builtin.str(kw[i]), kw[i+1]);\n        }\n    }\n    return d;\n};\n\nSk.abstr.setUpInheritance(\"dict\", Sk.builtin.dict, Sk.builtin.object);\nSk.abstr.markUnhashable(Sk.builtin.dict);\n\nvar kf = Sk.builtin.hash;\n\nSk.builtin.dict.prototype.key$lookup = function (bucket, key) {\n    var item;\n    var eq;\n    var i;\n\n    for (i = 0; i < bucket.items.length; i++) {\n        item = bucket.items[i];\n        eq = Sk.misceval.richCompareBool(item.lhs, key, \"Eq\");\n        if (eq) {\n            return item;\n        }\n    }\n\n    return null;\n};\n\nSk.builtin.dict.prototype.key$pop = function (bucket, key) {\n    var item;\n    var eq;\n    var i;\n\n    for (i = 0; i < bucket.items.length; i++) {\n        item = bucket.items[i];\n        eq = Sk.misceval.richCompareBool(item.lhs, key, \"Eq\");\n        if (eq) {\n            bucket.items.splice(i, 1);\n            this.size -= 1;\n            return item;\n        }\n    }\n    return undefined;\n};\n\n// Perform dictionary lookup, either return value or undefined if key not in dictionary\nSk.builtin.dict.prototype.mp$lookup = function (key) {\n    var k = kf(key);\n    var bucket = this.buckets[k.v];\n    var item;\n\n    // todo; does this need to go through mp$ma_lookup\n\n    if (bucket !== undefined) {\n        item = this.key$lookup(bucket, key);\n        if (item) {\n            return item.rhs;\n        }\n    }\n\n    // Not found in dictionary\n    return undefined;\n};\n\nSk.builtin.dict.prototype.mp$subscript = function (key) {\n    Sk.builtin.pyCheckArgsLen(\"[]\", arguments.length, 1, 2, false, false);\n    var s;\n    var res = this.mp$lookup(key);\n\n    if (res !== undefined) {\n        // Found in dictionary\n        return res;\n    } else {\n        // Not found in dictionary\n        s = new Sk.builtin.str(key);\n        throw new Sk.builtin.KeyError(s.v);\n    }\n};\n\nSk.builtin.dict.prototype.sq$contains = function (ob) {\n    var res = this.mp$lookup(ob);\n\n    return (res !== undefined);\n};\n\nSk.builtin.dict.prototype.mp$ass_subscript = function (key, w) {\n    var k = kf(key);\n    var bucket = this.buckets[k.v];\n    var item;\n\n    if (bucket === undefined) {\n        // New bucket\n        bucket = {$hash: k, items: [\n            {lhs: key, rhs: w}\n        ]};\n        this.buckets[k.v] = bucket;\n        this.size += 1;\n        return;\n    }\n\n    item = this.key$lookup(bucket, key);\n    if (item) {\n        item.rhs = w;\n        return;\n    }\n\n    // Not found in dictionary\n    bucket.items.push({lhs: key, rhs: w});\n    this.size += 1;\n};\n\nSk.builtin.dict.prototype.mp$del_subscript = function (key) {\n    Sk.builtin.pyCheckArgsLen(\"del\", arguments.length, 1, 1, false, false);\n    var k = kf(key);\n    var bucket = this.buckets[k.v];\n    var item;\n    var s;\n\n    // todo; does this need to go through mp$ma_lookup\n\n    if (bucket !== undefined) {\n        item = this.key$pop(bucket, key);\n        if (item !== undefined) {\n            return;\n        }\n    }\n\n    // Not found in dictionary\n    s = new Sk.builtin.str(key);\n    throw new Sk.builtin.KeyError(s.v);\n};\n\nSk.builtin.dict.prototype[\"$r\"] = function () {\n    var v;\n    var iter, k;\n    var ret = [];\n    for (iter = Sk.abstr.iter(this), k = iter.tp$iternext();\n        k !== undefined;\n        k = iter.tp$iternext()) {\n        v = this.mp$subscript(k);\n        if (v === undefined) {\n            //print(k, \"had undefined v\");\n            v = null;\n        }\n\n        // we need to check if value is same as object\n        // otherwise it would cause an stack overflow\n        if(v === this) {\n            ret.push(Sk.misceval.objectRepr(k).v + \": {...}\");\n        } else {\n            ret.push(Sk.misceval.objectRepr(k).v + \": \" + Sk.misceval.objectRepr(v).v);\n        }\n    }\n    return new Sk.builtin.str(\"{\" + ret.join(\", \") + \"}\");\n};\n\nSk.builtin.dict.prototype.mp$length = function () {\n    return this.size;\n};\n\nSk.builtin.dict.prototype[\"get\"] = new Sk.builtin.func(function (self, k, d) {\n    Sk.builtin.pyCheckArgsLen(\"get()\", arguments.length, 1, 2, false, true);\n    var ret;\n\n    if (d === undefined) {\n        d = Sk.builtin.none.none$;\n    }\n\n    ret = self.mp$lookup(k);\n    if (ret === undefined) {\n        ret = d;\n    }\n\n    return ret;\n});\n\nSk.builtin.dict.prototype[\"pop\"] = new Sk.builtin.func(function (self, key, d) {\n    Sk.builtin.pyCheckArgsLen(\"pop()\", arguments.length, 1, 2, false, true);\n    var k = kf(key);\n    var bucket = self.buckets[k.v];\n    var item;\n    var s;\n\n    // todo; does this need to go through mp$ma_lookup\n    if (bucket !== undefined) {\n        item = self.key$pop(bucket, key);\n        if (item !== undefined) {\n            return item.rhs;\n        }\n    }\n\n    // Not found in dictionary\n    if (d !== undefined) {\n        return d;\n    }\n\n    s = new Sk.builtin.str(key);\n    throw new Sk.builtin.KeyError(s.v);\n});\n\nSk.builtin.dict.prototype[\"has_key\"] = new Sk.builtin.func(function (self, k) {\n    Sk.builtin.pyCheckArgsLen(\"has_key()\", arguments.length, 1, 1, false, true);\n    return new Sk.builtin.bool( self.sq$contains(k));\n});\n\nSk.builtin.dict.prototype[\"items\"] = new Sk.builtin.func(function (self) {\n    Sk.builtin.pyCheckArgsLen(\"items()\", arguments.length, 0, 0, false, true);\n    var v;\n    var iter, k;\n    var ret = [];\n\n    for (iter = Sk.abstr.iter(self), k = iter.tp$iternext();\n        k !== undefined;\n        k = iter.tp$iternext()) {\n        v = self.mp$subscript(k);\n        if (v === undefined) {\n            //print(k, \"had undefined v\");\n            v = null;\n        }\n        ret.push(new Sk.builtin.tuple([k, v]));\n    }\n    return new Sk.builtin.list(ret);\n});\n\nSk.builtin.dict.prototype[\"keys\"] = new Sk.builtin.func(function (self) {\n    Sk.builtin.pyCheckArgsLen(\"keys()\", arguments.length, 0, 0, false, true);\n    var iter, k;\n    var ret = [];\n\n    for (iter = Sk.abstr.iter(self), k = iter.tp$iternext();\n        k !== undefined;\n        k = iter.tp$iternext()) {\n        ret.push(k);\n    }\n    return new Sk.builtin.list(ret);\n});\n\nSk.builtin.dict.prototype[\"values\"] = new Sk.builtin.func(function (self) {\n    Sk.builtin.pyCheckArgsLen(\"values()\", arguments.length, 0, 0, false, true);\n    var v;\n    var iter, k;\n    var ret = [];\n\n    for (iter = Sk.abstr.iter(self), k = iter.tp$iternext();\n        k !== undefined;\n        k = iter.tp$iternext()) {\n        v = self.mp$subscript(k);\n        if (v === undefined) {\n            v = null;\n        }\n        ret.push(v);\n    }\n    return new Sk.builtin.list(ret);\n});\n\nSk.builtin.dict.prototype[\"clear\"] = new Sk.builtin.func(function (self) {\n    Sk.builtin.pyCheckArgsLen(\"clear()\", arguments.length, 0, 0, false, true);\n    var k;\n    var iter;\n\n    for (iter = Sk.abstr.iter(self), k = iter.tp$iternext();\n        k !== undefined;\n        k = iter.tp$iternext()) {\n        self.mp$del_subscript(k);\n    }\n});\n\nSk.builtin.dict.prototype[\"setdefault\"] = new Sk.builtin.func(function (self, key, default_) {\n    try {\n        return self.mp$subscript(key);\n    } catch (e) {\n        if (default_ === undefined) {\n            default_ = Sk.builtin.none.none$;\n        }\n        self.mp$ass_subscript(key, default_);\n        return default_;\n    }\n});\n\n/*\n    this function mimics the cpython implementation, which is also the reason for the\n    almost similar code, this may be changed in future\n*/\nSk.builtin.dict.prototype.dict_merge = function(b) {\n    var iter;\n    var k, v;\n    if(b instanceof Sk.builtin.dict) {\n        // fast way\n        for (iter = b.tp$iter(), k = iter.tp$iternext(); k !== undefined; k = iter.tp$iternext()) {\n            v = b.mp$subscript(k);\n            if (v === undefined) {\n                throw new Sk.builtin.AttributeError(\"cannot get item for key: \" + k.v);\n            }\n            this.mp$ass_subscript(k, v);\n        }\n    } else {\n        // generic slower way\n        var keys = Sk.misceval.callsimArray(b[\"keys\"], [b]);\n        for (iter = Sk.abstr.iter(keys), k = iter.tp$iternext(); k !== undefined; k = iter.tp$iternext()) {\n            v = b.tp$getitem(k); // get value\n            if (v === undefined) {\n                throw new Sk.builtin.AttributeError(\"cannot get item for key: \" + k.v);\n            }\n            this.mp$ass_subscript(k, v);\n        }\n    }\n};\n\n/**\n *   update() accepts either another dictionary object or an iterable of key/value pairs (as tuples or other iterables of length two).\n *   If keyword arguments are specified, the dictionary is then updated with those key/value pairs: d.update(red=1, blue=2).\n *   https://hg.python.org/cpython/file/4ff865976bb9/Objects/dictobject.c\n */\nvar update_f = function (kwargs, self, other) {\n    // case another dict or obj with keys and getitem has been provided\n    if(other !== undefined && (other.tp$name === \"dict\" || other[\"keys\"])) {\n        self.dict_merge(other); // we merge with override\n    } else if(other !== undefined && Sk.builtin.checkIterable(other)) {\n        // 2nd case, we expect an iterable that contains another iterable of length 2\n        var iter;\n        var k, v;\n        var seq_i = 0; // index of current sequence item\n        for (iter = Sk.abstr.iter(other), k = iter.tp$iternext(); k !== undefined; k = iter.tp$iternext(), seq_i++) {\n            // check if value is iter\n            if (!Sk.builtin.checkIterable(k)) {\n                throw new Sk.builtin.TypeError(\"cannot convert dictionary update sequence element #\" + seq_i + \" to a sequence\");\n            }\n\n            // cpython impl. would transform iterable into sequence\n            // we just call iternext twice if k has length of 2\n            if(k.sq$length() === 2) {\n                var k_iter = Sk.abstr.iter(k);\n                var k_key = k_iter.tp$iternext();\n                var k_value = k_iter.tp$iternext();\n                self.mp$ass_subscript(k_key, k_value);\n            } else {\n                // throw exception\n                throw new Sk.builtin.ValueError(\"dictionary update sequence element #\" + seq_i + \" has length \" + k.sq$length() + \"; 2 is required\");\n            }\n        }\n    } else if(other !== undefined) {\n        // other is not a dict or iterable\n        throw new Sk.builtin.TypeError(\"'\" +Sk.abstr.typeName(other) + \"' object is not iterable\");\n    }\n\n    // apply all key/value pairs of kwargs\n    // create here kwargs_dict, there could be exceptions in other cases before\n    var kwargs_dict = new Sk.builtins.dict(kwargs);\n    self.dict_merge(kwargs_dict);\n\n    // returns none, when successful or throws exception\n    return  Sk.builtin.none.none$;\n};\n\nupdate_f.co_kwargs = true;\nSk.builtin.dict.prototype.update = new Sk.builtin.func(update_f);\n\nSk.builtin.dict.prototype.__contains__ = new Sk.builtin.func(function (self, item) {\n    Sk.builtin.pyCheckArgsLen(\"__contains__\", arguments.length, 2, 2);\n    return new Sk.builtin.bool(self.sq$contains(item));\n});\n\nSk.builtin.dict.prototype.__cmp__ = new Sk.builtin.func(function (self, other, op) {\n    // __cmp__ cannot be supported until dict lt/le/gt/ge operations are supported\n    return Sk.builtin.NotImplemented.NotImplemented$;\n});\n\nSk.builtin.dict.prototype.__delitem__ = new Sk.builtin.func(function (self, item) {\n    Sk.builtin.pyCheckArgsLen(\"__delitem__\", arguments.length, 1, 1, false, true);\n    return Sk.builtin.dict.prototype.mp$del_subscript.call(self, item);\n});\n\nSk.builtin.dict.prototype.__getitem__ = new Sk.builtin.func(function (self, item) {\n    Sk.builtin.pyCheckArgsLen(\"__getitem__\", arguments.length, 1, 1, false, true);\n    return Sk.builtin.dict.prototype.mp$subscript.call(self, item);\n});\n\nSk.builtin.dict.prototype.__setitem__ = new Sk.builtin.func(function (self, item, value) {\n    Sk.builtin.pyCheckArgsLen(\"__setitem__\", arguments.length, 2, 2, false, true);\n    return Sk.builtin.dict.prototype.mp$ass_subscript.call(self, item, value);\n});\n\nSk.builtin.dict.prototype.__hash__ = new Sk.builtin.func(function (self) {\n    Sk.builtin.pyCheckArgsLen(\"__hash__\", arguments.length, 0, 0, false, true);\n    return Sk.builtin.dict.prototype.tp$hash.call(self);\n});\n\nSk.builtin.dict.prototype.__len__ = new Sk.builtin.func(function (self) {\n    Sk.builtin.pyCheckArgsLen(\"__len__\", arguments.length, 0, 0, false, true);\n    return Sk.builtin.dict.prototype.mp$length.call(self);\n});\n\nSk.builtin.dict.prototype.__getattribute__ = new Sk.builtin.func(function (self, attr) {\n    Sk.builtin.pyCheckArgsLen(\"__getattribute__\", arguments.length, 1, 1, false, true);\n    if (!Sk.builtin.checkString(attr)) { throw new Sk.builtin.TypeError(\"__getattribute__ requires a string\"); }\n    return Sk.builtin.dict.prototype.tp$getattr.call(self, attr);\n});\n\nSk.builtin.dict.prototype.__iter__ = new Sk.builtin.func(function (self) {\n    Sk.builtin.pyCheckArgsLen(\"__iter__\", arguments.length, 0, 0, false, true);\n\n    return new Sk.builtin.dict_iter_(self);\n});\n\nSk.builtin.dict.prototype.tp$iter = function () {\n    return new Sk.builtin.dict_iter_(this);\n};\n\nSk.builtin.dict.prototype.__repr__ = new Sk.builtin.func(function (self) {\n    Sk.builtin.pyCheckArgsLen(\"__repr__\", arguments.length, 0, 0, false, true);\n    return Sk.builtin.dict.prototype[\"$r\"].call(self);\n});\n\n/* python3 recommends implementing simple ops */\nSk.builtin.dict.prototype.ob$eq = function (other) {\n\n    var iter, k, v, otherv;\n\n    if (this === other) {\n        return Sk.builtin.bool.true$;\n    }\n\n    if (!(other instanceof Sk.builtin.dict)) {\n        return Sk.builtin.NotImplemented.NotImplemented$;\n    }\n\n    if (this.size !== other.size) {\n        return Sk.builtin.bool.false$;\n    }\n\n    for (iter = this.tp$iter(), k = iter.tp$iternext();\n        k !== undefined;\n        k = iter.tp$iternext()) {\n        v = this.mp$subscript(k);\n        otherv = other.mp$subscript(k);\n\n        if (!Sk.misceval.richCompareBool(v, otherv, \"Eq\")) {\n            return Sk.builtin.bool.false$;\n        }\n    }\n\n    return Sk.builtin.bool.true$;\n};\n\nSk.builtin.dict.prototype.ob$ne = function (other) {\n\n    var isEqual = this.ob$eq(other);\n\n    if (isEqual instanceof Sk.builtin.NotImplemented) {\n        return isEqual;\n    } else if (isEqual.v) {\n        return Sk.builtin.bool.false$;\n    } else {\n        return Sk.builtin.bool.true$;\n    }\n\n};\n\nSk.builtin.dict.prototype[\"copy\"] = new Sk.builtin.func(function (self) {\n    Sk.builtin.pyCheckArgsLen(\"copy\", arguments.length, 0, 0, false, true);\n\n    var it; // Iterator\n    var k; // Key of dict item\n    var v; // Value of dict item\n    var newCopy = new Sk.builtin.dict([]);\n\n    for (it = Sk.abstr.iter(self), k = it.tp$iternext();\n        k !== undefined;\n        k = it.tp$iternext()) {\n        v = self.mp$subscript(k);\n        if (v === undefined) {\n            v = null;\n        }\n        newCopy.mp$ass_subscript(k, v);\n    }\n\n    return newCopy;\n});\n\nSk.builtin.dict.$fromkeys = function fromkeys(self, seq, value) {\n    var k, iter, val, res, iterable;\n\n    if (self instanceof Sk.builtin.dict) {\n        // instance call\n        Sk.builtin.pyCheckArgsLen(\"fromkeys\", arguments.length, 1, 2, false, true);\n\n        res = self;\n        iterable = seq;\n        val = value === undefined ? Sk.builtin.none.none$ : value;\n    } else {\n        // static call\n        Sk.builtin.pyCheckArgsLen(\"fromkeys\", arguments.length, 1, 2, false, false);\n\n        res = new Sk.builtin.dict([]);\n        iterable = self;\n        val = seq === undefined ? Sk.builtin.none.none$ : seq;\n    }\n\n    if (!Sk.builtin.checkIterable(iterable)) {\n        throw new Sk.builtin.TypeError(\"'\" + Sk.abstr.typeName(iterable) + \"' object is not iterable\");\n    }\n\n    for (iter = Sk.abstr.iter(iterable), k = iter.tp$iternext();\n        k !== undefined;\n        k = iter.tp$iternext()) {\n        res.mp$ass_subscript(k, val);\n    }\n\n    return res;\n};\n\n\nSk.builtin.dict.prototype[\"iteritems\"] = new Sk.builtin.func(function (self) {\n    throw new Sk.builtin.NotImplementedError(\"dict.iteritems is not yet implemented in Skulpt\");\n});\n\nSk.builtin.dict.prototype[\"iterkeys\"] = new Sk.builtin.func(function (self) {\n    throw new Sk.builtin.NotImplementedError(\"dict.iterkeys is not yet implemented in Skulpt\");\n});\n\nSk.builtin.dict.prototype[\"itervalues\"] = new Sk.builtin.func(function (self) {\n    throw new Sk.builtin.NotImplementedError(\"dict.itervalues is not yet implemented in Skulpt\");\n});\n\nSk.builtin.dict.prototype[\"popitem\"] = new Sk.builtin.func(function (self) {\n    throw new Sk.builtin.NotImplementedError(\"dict.popitem is not yet implemented in Skulpt\");\n});\n\nSk.builtin.dict.prototype[\"viewitems\"] = new Sk.builtin.func(function (self) {\n    throw new Sk.builtin.NotImplementedError(\"dict.viewitems is not yet implemented in Skulpt\");\n});\n\nSk.builtin.dict.prototype[\"viewkeys\"] = new Sk.builtin.func(function (self) {\n    throw new Sk.builtin.NotImplementedError(\"dict.viewkeys is not yet implemented in Skulpt\");\n});\n\nSk.builtin.dict.prototype[\"viewvalues\"] = new Sk.builtin.func(function (self) {\n    throw new Sk.builtin.NotImplementedError(\"dict.viewvalues is not yet implemented in Skulpt\");\n});\n\nSk.exportSymbol(\"Sk.builtin.dict\", Sk.builtin.dict);\n\n/**\n * @constructor\n * @param {Object} obj\n */\nSk.builtin.dict_iter_ = function (obj) {\n    var k, i, bucket, allkeys, buckets;\n    if (!(this instanceof Sk.builtin.dict_iter_)) {\n        return new Sk.builtin.dict_iter_(obj);\n    }\n    this.$index = 0;\n    this.$obj = obj;\n    allkeys = [];\n    buckets = obj.buckets;\n    for (k in buckets) {\n        if (buckets.hasOwnProperty(k)) {\n            bucket = buckets[k];\n            if (bucket && bucket.$hash !== undefined && bucket.items !== undefined) {\n                // skip internal stuff. todo; merge pyobj and this\n                for (i = 0; i < bucket.items.length; i++) {\n                    allkeys.push(bucket.items[i].lhs);\n                }\n            }\n        }\n    }\n    this.$keys = allkeys;\n    this.tp$iter = this;\n    this.tp$iternext = function () {\n        // todo; StopIteration\n        if (this.$index >= this.$keys.length) {\n            return undefined;\n        }\n        return this.$keys[this.$index++];\n        // return this.$obj[this.$keys[this.$index++]].lhs;\n    };\n    this.$r = function () {\n        return new Sk.builtin.str(\"dictionary-keyiterator\");\n    };\n    return this;\n};\n\nSk.abstr.setUpInheritance(\"dictionary-keyiterator\", Sk.builtin.dict_iter_, Sk.builtin.object);\n\nSk.builtin.dict_iter_.prototype.__class__ = Sk.builtin.dict_iter_;\n\nSk.builtin.dict_iter_.prototype.__iter__ = new Sk.builtin.func(function (self) {\n    return self;\n});\n\nSk.builtin.dict_iter_.prototype.next$ = function (self) {\n    var ret = self.tp$iternext();\n    if (ret === undefined) {\n        throw new Sk.builtin.StopIteration();\n    }\n    return ret;\n};\n","/**\n * @constructor\n * Sk.builtin.numtype\n *\n * @description\n * Abstract class for Python numeric types.\n *\n * @extends {Sk.builtin.object}\n *\n * @return {undefined} Cannot instantiate a Sk.builtin.numtype object\n */\nSk.builtin.numtype = function () {\n\n    throw new Sk.builtin.ExternalError(\"Cannot instantiate abstract Sk.builtin.numtype class\");\n\n};\n\nSk.abstr.setUpInheritance(\"NumericType\", Sk.builtin.numtype, Sk.builtin.object);\n\nSk.builtin.numtype.sk$abstract = true;\n\n/**\n * Python wrapper of `__abs__` method.\n *\n * @name  __abs__\n * @instance\n * @memberOf Sk.builtin.numtype.prototype\n */\nSk.builtin.numtype.prototype[\"__abs__\"] = new Sk.builtin.func(function (self) {\n\n    if (self.nb$abs === undefined) {\n        throw new Sk.builtin.NotImplementedError(\"__abs__ is not yet implemented\");\n    }\n\n    Sk.builtin.pyCheckArgsLen(\"__abs__\", arguments.length, 0, 0, false, true);\n    return self.nb$abs();\n\n});\n\n/**\n * Python wrapper of `__neg__` method.\n *\n * @name  __neg__\n * @instance\n * @memberOf Sk.builtin.numtype.prototype\n */\nSk.builtin.numtype.prototype[\"__neg__\"] = new Sk.builtin.func(function (self) {\n\n    if (self.nb$negative === undefined) {\n        throw new Sk.builtin.NotImplementedError(\"__neg__ is not yet implemented\");\n    }\n\n    Sk.builtin.pyCheckArgsLen(\"__neg__\", arguments.length, 0, 0, false, true);\n    return self.nb$negative();\n\n});\n\n/**\n * Python wrapper of `__pos__` method.\n *\n * @name  __pos__\n * @instance\n * @memberOf Sk.builtin.numtype.prototype\n */\nSk.builtin.numtype.prototype[\"__pos__\"] = new Sk.builtin.func(function (self) {\n\n    if (self.nb$positive === undefined) {\n        throw new Sk.builtin.NotImplementedError(\"__pos__ is not yet implemented\");\n    }\n\n    Sk.builtin.pyCheckArgsLen(\"__pos__\", arguments.length, 0, 0, false, true);\n    return self.nb$positive();\n\n});\n\n/**\n * Python wrapper of `__int__` method.\n *\n * @name  __int__\n * @instance\n * @memberOf Sk.builtin.numtype.prototype\n */\nSk.builtin.numtype.prototype[\"__int__\"] = new Sk.builtin.func(function (self) {\n\n    if (self.nb$int_ === undefined) {\n        throw new Sk.builtin.NotImplementedError(\"__int__ is not yet implemented\");\n    }\n\n    Sk.builtin.pyCheckArgsLen(\"__int__\", arguments.length, 0, 0, false, true);\n    return self.nb$int_();\n\n});\n\n/**\n * Python wrapper of `__long__` method.\n *\n * @name  __long__\n * @instance\n * @memberOf Sk.builtin.numtype.prototype\n */\nSk.builtin.numtype.prototype[\"__long__\"] = new Sk.builtin.func(function (self) {\n\n    if (self.nb$lng === undefined) {\n        throw new Sk.builtin.NotImplementedError(\"__long__ is not yet implemented\");\n    }\n\n    Sk.builtin.pyCheckArgsLen(\"__long__\", arguments.length, 0, 0, false, true);\n    return self.nb$lng();\n\n});\n\n/**\n * Python wrapper of `__float__` method.\n *\n * @name  __float__\n * @instance\n * @memberOf Sk.builtin.numtype.prototype\n */\nSk.builtin.numtype.prototype[\"__float__\"] = new Sk.builtin.func(function (self) {\n\n    if (self.nb$float_ === undefined) {\n        throw new Sk.builtin.NotImplementedError(\"__float__ is not yet implemented\");\n    }\n\n    Sk.builtin.pyCheckArgsLen(\"__float__\", arguments.length, 0, 0, false, true);\n    return self.nb$float_();\n\n});\n\n/**\n * Python wrapper of `__add__` method.\n *\n * @name  __add__\n * @instance\n * @memberOf Sk.builtin.numtype.prototype\n */\nSk.builtin.numtype.prototype[\"__add__\"] = new Sk.builtin.func(function (self, other) {\n\n    if (self.nb$add === undefined) {\n        throw new Sk.builtin.NotImplementedError(\"__add__ is not yet implemented\");\n    }\n\n    Sk.builtin.pyCheckArgsLen(\"__add__\", arguments.length, 1, 1, false, true);\n    return self.nb$add(other);\n\n});\n\n/**\n * Python wrapper of `__radd__` method.\n *\n * @name  __radd__\n * @instance\n * @memberOf Sk.builtin.numtype.prototype\n */\nSk.builtin.numtype.prototype[\"__radd__\"] = new Sk.builtin.func(function (self, other) {\n\n    if (self.nb$reflected_add === undefined) {\n        throw new Sk.builtin.NotImplementedError(\"__radd__ is not yet implemented\");\n    }\n\n    Sk.builtin.pyCheckArgsLen(\"__radd__\", arguments.length, 1, 1, false, true);\n    return self.nb$reflected_add(other);\n\n});\n\n/**\n * Python wrapper of `__sub__` method.\n *\n * @name  __sub__\n * @instance\n * @memberOf Sk.builtin.numtype.prototype\n */\nSk.builtin.numtype.prototype[\"__sub__\"] = new Sk.builtin.func(function (self, other) {\n\n    if (self.nb$subtract === undefined) {\n        throw new Sk.builtin.NotImplementedError(\"__sub__ is not yet implemented\");\n    }\n\n    Sk.builtin.pyCheckArgsLen(\"__sub__\", arguments.length, 1, 1, false, true);\n    return self.nb$subtract(other);\n\n});\n\n/**\n * Python wrapper of `__rsub__` method.\n *\n * @name  __rsub__\n * @instance\n * @memberOf Sk.builtin.numtype.prototype\n */\nSk.builtin.numtype.prototype[\"__rsub__\"] = new Sk.builtin.func(function (self, other) {\n\n    if (self.nb$reflected_subtract === undefined) {\n        throw new Sk.builtin.NotImplementedError(\"__rsub__ is not yet implemented\");\n    }\n\n    Sk.builtin.pyCheckArgsLen(\"__rsub__\", arguments.length, 1, 1, false, true);\n    return self.nb$reflected_subtract(other);\n\n});\n\n/**\n * Python wrapper of `__mul__` method.\n *\n * @name  __mul__\n * @instance\n * @memberOf Sk.builtin.numtype.prototype\n */\nSk.builtin.numtype.prototype[\"__mul__\"] = new Sk.builtin.func(function (self, other) {\n\n    if (self.nb$multiply === undefined) {\n        throw new Sk.builtin.NotImplementedError(\"__mul__ is not yet implemented\");\n    }\n\n    Sk.builtin.pyCheckArgsLen(\"__mul__\", arguments.length, 1, 1, false, true);\n    return self.nb$multiply(other);\n\n});\n\n/**\n * Python wrapper of `__rmul__` method.\n *\n * @name  __rmul__\n * @instance\n * @memberOf Sk.builtin.numtype.prototype\n */\nSk.builtin.numtype.prototype[\"__rmul__\"] = new Sk.builtin.func(function (self, other) {\n\n    if (self.nb$reflected_multiply === undefined) {\n        throw new Sk.builtin.NotImplementedError(\"__rmul__ is not yet implemented\");\n    }\n\n    Sk.builtin.pyCheckArgsLen(\"__rmul__\", arguments.length, 1, 1, false, true);\n    return self.nb$reflected_multiply(other);\n\n});\n\n/**\n * Python wrapper of `__div__` method.\n *\n * @name  __div__\n * @instance\n * @memberOf Sk.builtin.numtype.prototype\n */\nSk.builtin.numtype.prototype[\"__div__\"] = new Sk.builtin.func(function (self, other) {\n\n    if (self.nb$divide === undefined) {\n        throw new Sk.builtin.NotImplementedError(\"__div__ is not yet implemented\");\n    }\n\n    Sk.builtin.pyCheckArgsLen(\"__div__\", arguments.length, 1, 1, false, true);\n    return self.nb$divide(other);\n\n});\n\n/**\n * Python wrapper of `__rdiv__` method.\n *\n * @name  __rdiv__\n * @instance\n * @memberOf Sk.builtin.numtype.prototype\n */\nSk.builtin.numtype.prototype[\"__rdiv__\"] = new Sk.builtin.func(function (self, other) {\n\n    if (self.nb$reflected_divide === undefined) {\n        throw new Sk.builtin.NotImplementedError(\"__rdiv__ is not yet implemented\");\n    }\n\n    Sk.builtin.pyCheckArgsLen(\"__rdiv__\", arguments.length, 1, 1, false, true);\n    return self.nb$reflected_divide(other);\n\n});\n\n/**\n * Python wrapper of `__floordiv__` method.\n *\n * @name  __floordiv__\n * @instance\n * @memberOf Sk.builtin.numtype.prototype\n */\nSk.builtin.numtype.prototype[\"__floordiv__\"] = new Sk.builtin.func(function (self, other) {\n\n    if (self.nb$floor_divide === undefined) {\n        throw new Sk.builtin.NotImplementedError(\"__floordiv__ is not yet implemented\");\n    }\n\n    Sk.builtin.pyCheckArgsLen(\"__floordiv__\", arguments.length, 1, 1, false, true);\n    return self.nb$floor_divide(other);\n\n});\n\n/**\n * Python wrapper of `__rfloordiv__` method.\n *\n * @name  __rfloordiv__\n * @instance\n * @memberOf Sk.builtin.numtype.prototype\n */\nSk.builtin.numtype.prototype[\"__rfloordiv__\"] = new Sk.builtin.func(function (self, other) {\n\n    if (self.nb$reflected_floor_divide === undefined) {\n        throw new Sk.builtin.NotImplementedError(\"__rfloordiv__ is not yet implemented\");\n    }\n\n    Sk.builtin.pyCheckArgsLen(\"__rfloordiv__\", arguments.length, 1, 1, false, true);\n    return self.nb$reflected_floor_divide(other);\n\n});\n\n/**\n * Python wrapper of `__mod__` method.\n *\n * @name  __mod__\n * @instance\n * @memberOf Sk.builtin.numtype.prototype\n */\nSk.builtin.numtype.prototype[\"__mod__\"] = new Sk.builtin.func(function (self, other) {\n\n    if (self.nb$remainder === undefined) {\n        throw new Sk.builtin.NotImplementedError(\"__mod__ is not yet implemented\");\n    }\n\n    Sk.builtin.pyCheckArgsLen(\"__mod__\", arguments.length, 1, 1, false, true);\n    return self.nb$remainder(other);\n\n});\n\n/**\n * Python wrapper of `__rmod__` method.\n *\n * @name  __rmod__\n * @instance\n * @memberOf Sk.builtin.numtype.prototype\n */\nSk.builtin.numtype.prototype[\"__rmod__\"] = new Sk.builtin.func(function (self, other) {\n\n    if (self.nb$reflected_remainder === undefined) {\n        throw new Sk.builtin.NotImplementedError(\"__rmod__ is not yet implemented\");\n    }\n\n    Sk.builtin.pyCheckArgsLen(\"__rmod__\", arguments.length, 1, 1, false, true);\n    return self.nb$reflected_remainder(other);\n\n});\n\n/**\n * Python wrapper of `__divmod__` method.\n *\n * @name  __divmod__\n * @instance\n * @memberOf Sk.builtin.numtype.prototype\n */\nSk.builtin.numtype.prototype[\"__divmod__\"] = new Sk.builtin.func(function (self, other) {\n\n    if (self.nb$divmod === undefined) {\n        throw new Sk.builtin.NotImplementedError(\"__divmod__ is not yet implemented\");\n    }\n\n    Sk.builtin.pyCheckArgsLen(\"__divmod__\", arguments.length, 1, 1, false, true);\n    return self.nb$divmod(other);\n\n});\n\n/**\n * Python wrapper of `__rdivmod__` method.\n *\n * @name  __rdivmod__\n * @instance\n * @memberOf Sk.builtin.numtype.prototype\n */\nSk.builtin.numtype.prototype[\"__rdivmod__\"] = new Sk.builtin.func(function (self, other) {\n\n    if (self.nb$reflected_divmod === undefined) {\n        throw new Sk.builtin.NotImplementedError(\"__rdivmod__ is not yet implemented\");\n    }\n\n    Sk.builtin.pyCheckArgsLen(\"__rdivmod__\", arguments.length, 1, 1, false, true);\n    return self.nb$reflected_divmod(other);\n\n});\n\n/**\n * Python wrapper of `__pow__` method.\n *\n * @name  __pow__\n * @instance\n * @memberOf Sk.builtin.numtype.prototype\n */\nSk.builtin.numtype.prototype[\"__pow__\"] = new Sk.builtin.func(function (self, other) {\n\n    if (self.nb$power === undefined) {\n        throw new Sk.builtin.NotImplementedError(\"__pow__ is not yet implemented\");\n    }\n\n    Sk.builtin.pyCheckArgsLen(\"__pow__\", arguments.length, 1, 1, false, true);\n    return self.nb$power(other);\n\n});\n\n/**\n * Python wrapper of `__rpow__` method.\n *\n * @name  __rpow__\n * @instance\n * @memberOf Sk.builtin.numtype.prototype\n */\nSk.builtin.numtype.prototype[\"__rpow__\"] = new Sk.builtin.func(function (self, other) {\n\n    if (self.nb$reflected_power === undefined) {\n        throw new Sk.builtin.NotImplementedError(\"__rpow__ is not yet implemented\");\n    }\n\n    Sk.builtin.pyCheckArgsLen(\"__rpow__\", arguments.length, 1, 1, false, true);\n    return self.nb$reflected_power(other);\n\n});\n\n/**\n * Python wrapper of `__coerce__` method.\n *\n * @name  __coerce__\n * @instance\n * @memberOf Sk.builtin.numtype.prototype\n */\nSk.builtin.numtype.prototype[\"__coerce__\"] = new Sk.builtin.func(function (self, other) {\n\n    throw new Sk.builtin.NotImplementedError(\"__coerce__ is not yet implemented\");\n\n});\n\n/**\n * Add a Python object to this instance and return the result (i.e. this + other).\n *\n * Returns NotImplemented if addition between this type and other type is unsupported.\n *\n * Javscript function, returns Python object.\n *\n * @param  {!Sk.builtin.object} other The Python object to add.\n * @return {(Sk.builtin.numtype|Sk.builtin.NotImplemented)} The result of the addition.\n */\nSk.builtin.numtype.prototype.nb$add = function (other) {\n    return Sk.builtin.NotImplemented.NotImplemented$;\n};\n\nSk.builtin.numtype.prototype.nb$reflected_add = function (other) {\n    return Sk.builtin.NotImplemented.NotImplemented$;\n};\n\nSk.builtin.numtype.prototype.nb$inplace_add = function (other) {\n    return Sk.builtin.NotImplemented.NotImplemented$;\n};\n\n/**\n * Subtract a Python object from this instance and return the result (i.e. this - other).\n *\n * Returns NotImplemented if subtraction between this type and other type is unsupported.\n *\n * Javscript function, returns Python object.\n *\n * @param  {!Sk.builtin.object} other The Python object to subtract.\n * @return {(Sk.builtin.numtype|Sk.builtin.NotImplemented)} The result of the subtraction.\n */\nSk.builtin.numtype.prototype.nb$subtract = function (other) {\n    return Sk.builtin.NotImplemented.NotImplemented$;\n};\n\nSk.builtin.numtype.prototype.nb$reflected_subtract = function (other) {\n    return Sk.builtin.NotImplemented.NotImplemented$;\n};\n\nSk.builtin.numtype.prototype.nb$inplace_subtract = function (other) {\n    return Sk.builtin.NotImplemented.NotImplemented$;\n};\n\n/**\n * Multiply this instance by a Python object and return the result (i.e. this * other).\n *\n * Returns NotImplemented if multiplication between this type and other type is unsupported.\n *\n * Javscript function, returns Python object.\n *\n * @param  {!Sk.builtin.object} other The multiplier, which must be a Python object.\n * @return {(Sk.builtin.numtype|Sk.builtin.NotImplemented)} The result of the multiplication\n */\nSk.builtin.numtype.prototype.nb$multiply = function (other) {\n    return Sk.builtin.NotImplemented.NotImplemented$;\n};\n\n\nSk.builtin.numtype.prototype.nb$reflected_multiply = function (other) {\n    return Sk.builtin.NotImplemented.NotImplemented$;\n};\n\nSk.builtin.numtype.prototype.nb$inplace_multiply = function (other) {\n    return Sk.builtin.NotImplemented.NotImplemented$;\n};\n\n/**\n * Divide this instance by a Python object and return the result (i.e this / other).\n *\n * Returns NotImplemented if division between this type and other type is unsupported.\n *\n * Javscript function, returns Python object.\n *\n * @param  {!Sk.builtin.object} other The divisor, which must be a Python object.\n * @return {(Sk.builtin.numtype|Sk.builtin.NotImplemented)} The result of the division\n */\nSk.builtin.numtype.prototype.nb$divide = function (other) {\n    return Sk.builtin.NotImplemented.NotImplemented$;\n};\n\nSk.builtin.numtype.prototype.nb$reflected_divide = function (other) {\n    return Sk.builtin.NotImplemented.NotImplemented$;\n};\n\nSk.builtin.numtype.prototype.nb$inplace_divide = function (other) {\n    return Sk.builtin.NotImplemented.NotImplemented$;\n};\n\n/**\n * Floor divide this instance by a Python object and return the result (i.e. this // other).\n *\n * Returns NotImplemented if floor division between this type and other type is unsupported.\n *\n * Javscript function, returns Python object.\n *\n * @param  {!Sk.builtin.object} other The divisor, which must be a Python object.\n * @return {(Sk.builtin.numtype|Sk.builtin.NotImplemented)} The result of the floor division\n */\nSk.builtin.numtype.prototype.nb$floor_divide = function (other) {\n    return Sk.builtin.NotImplemented.NotImplemented$;\n};\n\nSk.builtin.numtype.prototype.nb$reflected_floor_divide = function (other) {\n    return Sk.builtin.NotImplemented.NotImplemented$;\n};\n\nSk.builtin.numtype.prototype.nb$inplace_floor_divide = function (other) {\n    return Sk.builtin.NotImplemented.NotImplemented$;\n};\n\n/**\n * Modulo this instance by a Python object and return the result (i.e. this % other).\n *\n * Returns NotImplemented if modulation between this type and other type is unsupported.\n *\n * Javscript function, returns Python object.\n *\n * @param  {!Sk.builtin.object} other The divisor, which must be a Python object.\n * @return {(Sk.builtin.numtype|Sk.builtin.NotImplemented)} The result of the modulation\n */\nSk.builtin.numtype.prototype.nb$remainder = function (other) {\n    return Sk.builtin.NotImplemented.NotImplemented$;\n};\n\nSk.builtin.numtype.prototype.nb$reflected_remainder = function (other) {\n    return Sk.builtin.NotImplemented.NotImplemented$;\n};\n\nSk.builtin.numtype.prototype.nb$inplace_remainder = function (other) {\n    return Sk.builtin.NotImplemented.NotImplemented$;\n};\n\n/**\n * Compute the quotient and the remainder of this instance and a given Python object and return the result.\n *\n * Returns NotImplemented if division or modulo operations between this type and other type are unsupported.\n *\n * Javscript function, returns Python object.\n *\n * @param  {!Sk.builtin.object} other The divisor, which must be a Python object.\n * @return {(Sk.builtin.tuple|Sk.builtin.NotImplemented)} The result of the operation.\n * If both operations are supported, a Python tuple containing (quotient, remainder) in that order.\n */\nSk.builtin.numtype.prototype.nb$divmod = function (other) {\n    return Sk.builtin.NotImplemented.NotImplemented$;\n};\n\nSk.builtin.numtype.prototype.nb$reflected_divmod = function (other) {\n    return Sk.builtin.NotImplemented.NotImplemented$;\n};\n\n/**\n * Raise this instance by a Python object, optionally modulo the exponent, and return the final result.\n *\n * If mod is undefined, return this \\*\\* other. Else, return (this \\*\\* other) % mod.\n *\n * Returns NotImplemented if exponentiation or modulation between this type and other type is unsupported.\n *\n * Javscript function, returns Python object.\n *\n * @param  {!Sk.builtin.object} other The exponent, which must be a Python object.\n * @param  {!Sk.builtin.object=} mod The optional divisor, which must be a Python object if defined.\n * @return {(Sk.builtin.numtype|Sk.builtin.NotImplemented)} The result of the exponentiation.\n */\nSk.builtin.numtype.prototype.nb$power = function (other, mod) {\n    return Sk.builtin.NotImplemented.NotImplemented$;\n};\n\nSk.builtin.numtype.prototype.nb$reflected_power = function (other, mod) {\n    return Sk.builtin.NotImplemented.NotImplemented$;\n};\n\nSk.builtin.numtype.prototype.nb$inplace_power = function (other) {\n    return Sk.builtin.NotImplemented.NotImplemented$;\n};\n\n/**\n * Compute the absolute value of this instance and return.\n *\n * Javascript function, returns Python object.\n *\n * @return {(Sk.builtin.numtype|Sk.builtin.NotImplemented)} The absolute value\n */\nSk.builtin.numtype.prototype.nb$abs = function () {\n    return Sk.builtin.NotImplemented.NotImplemented$;\n};\n\n/**\n * Compute the unary negative of this instance (i.e. -this).\n *\n * Javscript function, returns Python object.\n *\n * @return {(Sk.builtin.numtype|Sk.builtin.NotImplemented)} A copy of this instance with the value negated\n */\nSk.builtin.numtype.prototype.nb$negative = function () {\n    return Sk.builtin.NotImplemented.NotImplemented$;\n};\n\n/**\n * Compute the unary positive of this instance (i.e. +this).\n *\n * Javscript function, returns Python object.\n *\n * @return {(Sk.builtin.numtype|Sk.builtin.NotImplemented)} A copy of this instance with the value unchanged\n */\nSk.builtin.numtype.prototype.nb$positive = function () {\n    return Sk.builtin.NotImplemented.NotImplemented$;\n};\n\n/**\n * Determine if this instance is nonzero.\n *\n * Javscript function, returns Javascript object or Sk.builtin.NotImplemented.\n *\n * @return {(boolean|Sk.builtin.NotImplemented)} true if this instance is not equal to zero, false otherwise\n */\nSk.builtin.numtype.prototype.nb$nonzero = function () {\n    return Sk.builtin.NotImplemented.NotImplemented$;\n};\n\n/**\n * Determine if this instance is negative.\n *\n * Javscript function, returns Javascript object or Sk.builtin.NotImplemented.\n *\n * @return {(boolean|Sk.builtin.NotImplemented)} true if this instance is negative, false otherwise\n */\nSk.builtin.numtype.prototype.nb$isnegative = function () {\n    return Sk.builtin.NotImplemented.NotImplemented$;\n};\n\n/**\n * Determine if this instance is positive.\n *\n * Javscript function, returns Javascript object or Sk.builtin.NotImplemented.\n *\n * @return {(boolean|Sk.builtin.NotImplemented)} true if this instance is positive, false otherwise\n */\nSk.builtin.numtype.prototype.nb$ispositive = function () {\n    return Sk.builtin.NotImplemented.NotImplemented$;\n};\n","/**\n * @fileoverview\n * @suppress {checkTypes}\n */\n\n/*\n * Basic JavaScript BN library - subset useful for RSA encryption.\n *\n * Copyright (c) 2003-2005  Tom Wu\n * All Rights Reserved.\n *\n * Permission is hereby granted, free of charge, to any person obtaining\n * a copy of this software and associated documentation files (the\n * \"Software\"), to deal in the Software without restriction, including\n * without limitation the rights to use, copy, modify, merge, publish,\n * distribute, sublicense, and/or sell copies of the Software, and to\n * permit persons to whom the Software is furnished to do so, subject to\n * the following conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS-IS\" AND WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS, IMPLIED OR OTHERWISE, INCLUDING WITHOUT LIMITATION, ANY\n * WARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.\n *\n * IN NO EVENT SHALL TOM WU BE LIABLE FOR ANY SPECIAL, INCIDENTAL,\n * INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY KIND, OR ANY DAMAGES WHATSOEVER\n * RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER OR NOT ADVISED OF\n * THE POSSIBILITY OF DAMAGE, AND ON ANY THEORY OF LIABILITY, ARISING OUT\n * OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n *\n * In addition, the following condition applies:\n *\n * All redistributions must retain an intact copy of this copyright notice\n * and disclaimer.\n */\n\n\n// (public) Constructor\n/**\n * @constructor\n * @param {number|string|null} a\n * @param {number=} b\n * @param {*=} c\n */\nSk.builtin.biginteger = function (a, b, c) {\n    if (a != null) {\n        if (\"number\" == typeof a) {\n            this.fromNumber(a, b, c);\n        } else if (b == null && \"string\" != typeof a) {\n            this.fromString(a, 256);\n        } else {\n            this.fromString(a, b);\n        }\n    }\n};\n\n// Bits per digit\n//Sk.builtin.biginteger.dbits;\n\n// JavaScript engine analysis\nSk.builtin.biginteger.canary = 0xdeadbeefcafe;\nSk.builtin.biginteger.j_lm = ((Sk.builtin.biginteger.canary & 0xffffff) == 0xefcafe);\n\n// return new, unset Sk.builtin.biginteger\nSk.builtin.biginteger.nbi = function () {\n    return new Sk.builtin.biginteger(null);\n};\n\n// am: Compute w_j += (x*this_i), propagate carries,\n// c is initial carry, returns final carry.\n// c < 3*dvalue, x < 2*dvalue, this_i < dvalue\n// We need to select the fastest one that works in this environment.\n\n// am1: use a single mult and divide to get the high bits,\n// max digit bits should be 26 because\n// max internal value = 2*dvalue^2-2*dvalue (< 2^53)\nSk.builtin.biginteger.prototype.am1 = function (i, x, w, j, c, n) {\n    var v;\n    while (--n >= 0) {\n        v = x * this[i++] + w[j] + c;\n        c = Math.floor(v / 0x4000000);\n        w[j++] = v & 0x3ffffff;\n    }\n    return c;\n};\n// am2 avoids a big mult-and-extract completely.\n// Max digit bits should be <= 30 because we do bitwise ops\n// on values up to 2*hdvalue^2-hdvalue-1 (< 2^31)\nSk.builtin.biginteger.prototype.am2 = function (i, x, w, j, c, n) {\n    var m;\n    var h;\n    var l;\n    var xl = x & 0x7fff, xh = x >> 15;\n    while (--n >= 0) {\n        l = this[i] & 0x7fff;\n        h = this[i++] >> 15;\n        m = xh * l + h * xl;\n        l = xl * l + ((m & 0x7fff) << 15) + w[j] + (c & 0x3fffffff);\n        c = (l >>> 30) + (m >>> 15) + xh * h + (c >>> 30);\n        w[j++] = l & 0x3fffffff;\n    }\n    return c;\n};\n// Alternately, set max digit bits to 28 since some\n// browsers slow down when dealing with 32-bit numbers.\nSk.builtin.biginteger.prototype.am3 = function (i, x, w, j, c, n) {\n    var m;\n    var h;\n    var l;\n    var xl = x & 0x3fff, xh = x >> 14;\n    while (--n >= 0) {\n        l = this[i] & 0x3fff;\n        h = this[i++] >> 14;\n        m = xh * l + h * xl;\n        l = xl * l + ((m & 0x3fff) << 14) + w[j] + c;\n        c = (l >> 28) + (m >> 14) + xh * h;\n        w[j++] = l & 0xfffffff;\n    }\n    return c;\n};\n\n// We need to select the fastest one that works in this environment.\n//if (Sk.builtin.biginteger.j_lm && (navigator.appName == \"Microsoft Internet Explorer\")) {\n//\tSk.builtin.biginteger.prototype.am = am2;\n//\tSk.builtin.biginteger.dbits = 30;\n//} else if (Sk.builtin.biginteger.j_lm && (navigator.appName != \"Netscape\")) {\n//\tSk.builtin.biginteger.prototype.am = am1;\n//\tSk.builtin.biginteger.dbits = 26;\n//} else { // Mozilla/Netscape seems to prefer am3\n//\tSk.builtin.biginteger.prototype.am = am3;\n//\tSk.builtin.biginteger.dbits = 28;\n//}\n\n// For node.js, we pick am3 with max Sk.builtin.biginteger.dbits to 28.\nSk.builtin.biginteger.prototype.am = Sk.builtin.biginteger.prototype.am3;\nSk.builtin.biginteger.dbits = 28;\n\nSk.builtin.biginteger.prototype.DB = Sk.builtin.biginteger.dbits;\nSk.builtin.biginteger.prototype.DM = ((1 << Sk.builtin.biginteger.dbits) - 1);\nSk.builtin.biginteger.prototype.DV = (1 << Sk.builtin.biginteger.dbits);\n\nSk.builtin.biginteger.BI_FP = 52;\nSk.builtin.biginteger.prototype.FV = Math.pow(2, Sk.builtin.biginteger.BI_FP);\nSk.builtin.biginteger.prototype.F1 = Sk.builtin.biginteger.BI_FP - Sk.builtin.biginteger.dbits;\nSk.builtin.biginteger.prototype.F2 = 2 * Sk.builtin.biginteger.dbits - Sk.builtin.biginteger.BI_FP;\n\n// Digit conversions\nSk.builtin.biginteger.BI_RM = \"0123456789abcdefghijklmnopqrstuvwxyz\";\nSk.builtin.biginteger.BI_RC = [];\nvar rr, vv;\nrr = \"0\".charCodeAt(0);\nfor (vv = 0; vv <= 9; ++vv) {\n    Sk.builtin.biginteger.BI_RC[rr++] = vv;\n}\nrr = \"a\".charCodeAt(0);\nfor (vv = 10; vv < 36; ++vv) {\n    Sk.builtin.biginteger.BI_RC[rr++] = vv;\n}\nrr = \"A\".charCodeAt(0);\nfor (vv = 10; vv < 36; ++vv) {\n    Sk.builtin.biginteger.BI_RC[rr++] = vv;\n}\n\nSk.builtin.biginteger.int2char = function (n) {\n    return Sk.builtin.biginteger.BI_RM.charAt(n);\n};\nSk.builtin.biginteger.intAt = function (s, i) {\n    var c = Sk.builtin.biginteger.BI_RC[s.charCodeAt(i)];\n    return (c == null) ? -1 : c;\n};\n\n// (protected) copy this to r\nSk.builtin.biginteger.prototype.bnpCopyTo = function (r) {\n    var i;\n    for (i = this.t - 1; i >= 0; --i) {\n        r[i] = this[i];\n    }\n    r.t = this.t;\n    r.s = this.s;\n};\n\n// (protected) set from integer value x, -DV <= x < DV\nSk.builtin.biginteger.prototype.bnpFromInt = function (x) {\n    this.t = 1;\n    this.s = (x < 0) ? -1 : 0;\n    if (x > 0) {\n        this[0] = x;\n    } else if (x < -1) {\n        this[0] = x + this.DV;\n    } else {\n        this.t = 0;\n    }\n};\n\n// return bigint initialized to value\nSk.builtin.biginteger.nbv = function (i) {\n    var r = new Sk.builtin.biginteger(null);\n    r.bnpFromInt(i);\n    return r;\n};\n\n// (protected) set from string and radix\nSk.builtin.biginteger.prototype.bnpFromString = function (s, b) {\n    var x;\n    var i, mi, sh;\n    var k;\n    if (b == 16) {\n        k = 4;\n    } else if (b == 8) {\n        k = 3;\n    } else if (b == 256) {\n        k = 8;\n    }  else if (b == 2) {\n        // byte array\n        k = 1;\n    } else if (b == 32) {\n        k = 5;\n    } else if (b == 4) {\n        k = 2;\n    } else {\n        this.fromRadix(s, b);\n        return;\n    }\n    this.t = 0;\n    this.s = 0;\n    i = s.length;\n    mi = false;\n    sh = 0;\n    while (--i >= 0) {\n        x = (k == 8) ? s[i] & 0xff : Sk.builtin.biginteger.intAt(s, i);\n        if (x < 0) {\n            if (s.charAt(i) == \"-\") {\n                mi = true;\n            }\n            continue;\n        }\n        mi = false;\n        if (sh === 0) {\n            this[this.t++] = x;\n        } else if (sh + k > this.DB) {\n            this[this.t - 1] |= (x & ((1 << (this.DB - sh)) - 1)) << sh;\n            this[this.t++] = (x >> (this.DB - sh));\n        } else {\n            this[this.t - 1] |= x << sh;\n        }\n        sh += k;\n        if (sh >= this.DB) {\n            sh -= this.DB;\n        }\n    }\n    if (k == 8 && (s[0] & 0x80) !== 0) {\n        this.s = -1;\n        if (sh > 0) {\n            this[this.t - 1] |= ((1 << (this.DB - sh)) - 1) << sh;\n        }\n    }\n    this.clamp();\n    if (mi) {\n        Sk.builtin.biginteger.ZERO.subTo(this, this);\n    }\n};\n\n// (protected) clamp off excess high words\nSk.builtin.biginteger.prototype.bnpClamp = function () {\n    var c = this.s & this.DM;\n    while (this.t > 0 && this[this.t - 1] == c) {\n        --this.t;\n    }\n};\n\n// (public) return string representation in given radix\nSk.builtin.biginteger.prototype.bnToString = function (b) {\n    var p;\n    var km, d, m, r, i;\n    var k;\n    if (this.s < 0) {\n        return \"-\" + this.negate().toString(b);\n    }\n    if (b == 16) {\n        k = 4;\n    } else if (b == 8) {\n        k = 3;\n    } else if (b == 2) {\n        k = 1;\n    } else if (b == 32) {\n        k = 5;\n    } else if (b == 4) {\n        k = 2;\n    } else {\n        return this.toRadix(b);\n    }\n    km = (1 << k) - 1, m = false, r = \"\", i = this.t;\n    p = this.DB - (i * this.DB) % k;\n    if (i-- > 0) {\n        if (p < this.DB && (d = this[i] >> p) > 0) {\n            m = true;\n            r = Sk.builtin.biginteger.int2char(d);\n        }\n        while (i >= 0) {\n            if (p < k) {\n                d = (this[i] & ((1 << p) - 1)) << (k - p);\n                d |= this[--i] >> (p += this.DB - k);\n            } else {\n                d = (this[i] >> (p -= k)) & km;\n                if (p <= 0) {\n                    p += this.DB;\n                    --i;\n                }\n            }\n            if (d > 0) {\n                m = true;\n            }\n            if (m) {\n                r += Sk.builtin.biginteger.int2char(d);\n            }\n        }\n    }\n    return m ? r : \"0\";\n};\n\n// (public) -this\nSk.builtin.biginteger.prototype.bnNegate = function () {\n    var r = Sk.builtin.biginteger.nbi();\n    Sk.builtin.biginteger.ZERO.subTo(this, r);\n    return r;\n};\n\n// (public) |this|\nSk.builtin.biginteger.prototype.bnAbs = function () {\n    return (this.s < 0) ? this.negate() : this;\n};\n\n// (public) return + if this > a, - if this < a, 0 if equal\nSk.builtin.biginteger.prototype.bnCompareTo = function (a) {\n    var i;\n    var r = this.s - a.s;\n    if (r !== 0) {\n        return r;\n    }\n    i = this.t;\n    r = i - a.t;\n    if (r !== 0) {\n        return (this.s < 0) ? -r : r;\n    }\n    while (--i >= 0) {\n        if ((r = this[i] - a[i]) !== 0) {\n            return r;\n        }\n    }\n    return 0;\n};\n\n// returns bit length of the integer x\nSk.builtin.biginteger.nbits = function (x) {\n    var r = 1, t;\n    if ((t = x >>> 16) !== 0) {\n        x = t;\n        r += 16;\n    }\n    if ((t = x >> 8) !== 0) {\n        x = t;\n        r += 8;\n    }\n    if ((t = x >> 4) !== 0) {\n        x = t;\n        r += 4;\n    }\n    if ((t = x >> 2) !== 0) {\n        x = t;\n        r += 2;\n    }\n    if ((t = x >> 1) !== 0) {\n        x = t;\n        r += 1;\n    }\n    return r;\n};\n\n// (public) return the number of bits in \"this\"\nSk.builtin.biginteger.prototype.bnBitLength = function () {\n    if (this.t <= 0) {\n        return 0;\n    }\n    return this.DB * (this.t - 1) + Sk.builtin.biginteger.nbits(this[this.t - 1] ^ (this.s & this.DM));\n};\n\n// (protected) r = this << n*DB\nSk.builtin.biginteger.prototype.bnpDLShiftTo = function (n, r) {\n    var i;\n    for (i = this.t - 1; i >= 0; --i) {\n        r[i + n] = this[i];\n    }\n    for (i = n - 1; i >= 0; --i) {\n        r[i] = 0;\n    }\n    r.t = this.t + n;\n    r.s = this.s;\n};\n\n// (protected) r = this >> n*DB\nSk.builtin.biginteger.prototype.bnpDRShiftTo = function (n, r) {\n    var i;\n    for (i = n; i < this.t; ++i) {\n        r[i - n] = this[i];\n    }\n    r.t = Math.max(this.t - n, 0);\n    r.s = this.s;\n};\n\n// (protected) r = this << n\nSk.builtin.biginteger.prototype.bnpLShiftTo = function (n, r) {\n    var bs = n % this.DB;\n    var cbs = this.DB - bs;\n    var bm = (1 << cbs) - 1;\n    var ds = Math.floor(n / this.DB), c = (this.s << bs) & this.DM, i;\n    for (i = this.t - 1; i >= 0; --i) {\n        r[i + ds + 1] = (this[i] >> cbs) | c;\n        c = (this[i] & bm) << bs;\n    }\n    for (i = ds - 1; i >= 0; --i) {\n        r[i] = 0;\n    }\n    r[ds] = c;\n    r.t = this.t + ds + 1;\n    r.s = this.s;\n    r.clamp();\n};\n\n// (protected) r = this >> n\nSk.builtin.biginteger.prototype.bnpRShiftTo = function (n, r) {\n    var i;\n    var bm;\n    var cbs;\n    var bs;\n    var ds;\n    r.s = this.s;\n    ds = Math.floor(n / this.DB);\n    if (ds >= this.t) {\n        r.t = 0;\n        return;\n    }\n    bs = n % this.DB;\n    cbs = this.DB - bs;\n    bm = (1 << bs) - 1;\n    r[0] = this[ds] >> bs;\n    for (i = ds + 1; i < this.t; ++i) {\n        r[i - ds - 1] |= (this[i] & bm) << cbs;\n        r[i - ds] = this[i] >> bs;\n    }\n    if (bs > 0) {\n        r[this.t - ds - 1] |= (this.s & bm) << cbs;\n    }\n    r.t = this.t - ds;\n    r.clamp();\n};\n\n// (protected) r = this - a\nSk.builtin.biginteger.prototype.bnpSubTo = function (a, r) {\n    var i = 0, c = 0, m = Math.min(a.t, this.t);\n    while (i < m) {\n        c += this[i] - a[i];\n        r[i++] = c & this.DM;\n        c >>= this.DB;\n    }\n    if (a.t < this.t) {\n        c -= a.s;\n        while (i < this.t) {\n            c += this[i];\n            r[i++] = c & this.DM;\n            c >>= this.DB;\n        }\n        c += this.s;\n    } else {\n        c += this.s;\n        while (i < a.t) {\n            c -= a[i];\n            r[i++] = c & this.DM;\n            c >>= this.DB;\n        }\n        c -= a.s;\n    }\n    r.s = (c < 0) ? -1 : 0;\n    if (c < -1) {\n        r[i++] = this.DV + c;\n    } else if (c > 0) {\n        r[i++] = c;\n    }\n    r.t = i;\n    r.clamp();\n};\n\n// (protected) r = this * a, r != this,a (HAC 14.12)\n// \"this\" should be the larger one if appropriate.\nSk.builtin.biginteger.prototype.bnpMultiplyTo = function (a, r) {\n    var x = this.abs(), y = a.abs();\n    var i = x.t;\n    r.t = i + y.t;\n    while (--i >= 0) {\n        r[i] = 0;\n    }\n    for (i = 0; i < y.t; ++i) {\n        r[i + x.t] = x.am(0, y[i], r, i, 0, x.t);\n    }\n    r.s = 0;\n    r.clamp();\n    if (this.s != a.s) {\n        Sk.builtin.biginteger.ZERO.subTo(r, r);\n    }\n};\n\n// (protected) r = this^2, r != this (HAC 14.16)\nSk.builtin.biginteger.prototype.bnpSquareTo = function (r) {\n    var c;\n    var x = this.abs();\n    var i = r.t = 2 * x.t;\n    while (--i >= 0) {\n        r[i] = 0;\n    }\n    for (i = 0; i < x.t - 1; ++i) {\n        c = x.am(i, x[i], r, 2 * i, 0, 1);\n        if ((r[i + x.t] += x.am(i + 1, 2 * x[i], r, 2 * i + 1, c, x.t - i - 1)) >= x.DV) {\n            r[i + x.t] -= x.DV;\n            r[i + x.t + 1] = 1;\n        }\n    }\n    if (r.t > 0) {\n        r[r.t - 1] += x.am(i, x[i], r, 2 * i, 0, 1);\n    }\n    r.s = 0;\n    r.clamp();\n};\n\n// (protected) divide this by m, quotient and remainder to q, r (HAC 14.20)\n// r != q, this != m.  q or r may be null.\nSk.builtin.biginteger.prototype.bnpDivRemTo = function (m, q, r) {\n    var qd;\n    var i, j, t;\n    var d1, d2, e;\n    var yt;\n    var y0;\n    var ys;\n    var nsh;\n    var y, ts, ms;\n    var pt;\n    var pm = m.abs();\n    if (pm.t <= 0) {\n        return;\n    }\n    pt = this.abs();\n    if (pt.t < pm.t) {\n        if (q != null) {\n            q.fromInt(0);\n        }\n        if (r != null) {\n            this.copyTo(r);\n        }\n        return;\n    }\n    if (r == null) {\n        r = Sk.builtin.biginteger.nbi();\n    }\n    y = Sk.builtin.biginteger.nbi();\n    ts = this.s;\n    ms = m.s;\n    nsh = this.DB - Sk.builtin.biginteger.nbits(pm[pm.t - 1]);\t// normalize modulus\n    if (nsh > 0) {\n        pm.lShiftTo(nsh, y);\n        pt.lShiftTo(nsh, r);\n    } else {\n        pm.copyTo(y);\n        pt.copyTo(r);\n    }\n    ys = y.t;\n    y0 = y[ys - 1];\n    if (y0 === 0) {\n        return;\n    }\n    yt = y0 * (1 << this.F1) + ((ys > 1) ? y[ys - 2] >> this.F2 : 0);\n    d1 = this.FV / yt, d2 = (1 << this.F1) / yt;\n    e = 1 << this.F2;\n    i = r.t, j = i - ys;\n    t = (q == null) ? Sk.builtin.biginteger.nbi() : q;\n    y.dlShiftTo(j, t);\n    if (r.compareTo(t) >= 0) {\n        r[r.t++] = 1;\n        r.subTo(t, r);\n    }\n    Sk.builtin.biginteger.ONE.dlShiftTo(ys, t);\n    t.subTo(y, y);\t// \"negative\" y so we can replace sub with am later\n    while (y.t < ys) {\n        y[y.t++] = 0;\n    }\n    while (--j >= 0) {\n        // Estimate quotient digit\n        qd = (r[--i] == y0) ? this.DM : Math.floor(r[i] * d1 + (r[i - 1] + e) * d2);\n        if ((r[i] += y.am(0, qd, r, j, 0, ys)) < qd) {\t// Try it out\n            y.dlShiftTo(j, t);\n            r.subTo(t, r);\n            while (r[i] < --qd) {\n                r.subTo(t, r);\n            }\n        }\n    }\n    if (q != null) {\n        r.drShiftTo(ys, q);\n        if (ts != ms) {\n            Sk.builtin.biginteger.ZERO.subTo(q, q);\n        }\n    }\n    r.t = ys;\n    r.clamp();\n    if (nsh > 0) {\n        r.rShiftTo(nsh, r);\n    }\t// Denormalize remainder\n    if (ts < 0) {\n        Sk.builtin.biginteger.ZERO.subTo(r, r);\n    }\n};\n\n// (public) this mod a\nSk.builtin.biginteger.prototype.bnMod = function (a) {\n    var r = Sk.builtin.biginteger.nbi();\n    this.abs().divRemTo(a, null, r);\n    if (this.s < 0 && r.compareTo(Sk.builtin.biginteger.ZERO) > 0) {\n        a.subTo(r, r);\n    }\n    return r;\n};\n\n// Modular reduction using \"classic\" algorithm\n/**\n * @constructor\n * @extends Sk.builtin.biginteger\n */\nSk.builtin.biginteger.Classic = function (m) {\n    this.m = m;\n};\nSk.builtin.biginteger.prototype.cConvert = function (x) {\n    if (x.s < 0 || x.compareTo(this.m) >= 0) {\n        return x.mod(this.m);\n    } else {\n        return x;\n    }\n};\nSk.builtin.biginteger.prototype.cRevert = function (x) {\n    return x;\n};\nSk.builtin.biginteger.prototype.cReduce = function (x) {\n    x.divRemTo(this.m, null, x);\n};\nSk.builtin.biginteger.prototype.cMulTo = function (x, y, r) {\n    x.multiplyTo(y, r);\n    this.reduce(r);\n};\nSk.builtin.biginteger.prototype.cSqrTo = function (x, r) {\n    x.squareTo(r);\n    this.reduce(r);\n};\n\nSk.builtin.biginteger.Classic.prototype.convert = Sk.builtin.biginteger.prototype.cConvert;\nSk.builtin.biginteger.Classic.prototype.revert = Sk.builtin.biginteger.prototype.cRevert;\nSk.builtin.biginteger.Classic.prototype.reduce = Sk.builtin.biginteger.prototype.cReduce;\nSk.builtin.biginteger.Classic.prototype.mulTo = Sk.builtin.biginteger.prototype.cMulTo;\nSk.builtin.biginteger.Classic.prototype.sqrTo = Sk.builtin.biginteger.prototype.cSqrTo;\n\n// (protected) return \"-1/this % 2^DB\"; useful for Mont. reduction\n// justification:\n//         xy == 1 (mod m)\n//         xy =  1+km\n//   xy(2-xy) = (1+km)(1-km)\n// x[y(2-xy)] = 1-k^2m^2\n// x[y(2-xy)] == 1 (mod m^2)\n// if y is 1/x mod m, then y(2-xy) is 1/x mod m^2\n// should reduce x and y(2-xy) by m^2 at each step to keep size bounded.\n// JS multiply \"overflows\" differently from C/C++, so care is needed here.\nSk.builtin.biginteger.prototype.bnpInvDigit = function () {\n    var y;\n    var x;\n    if (this.t < 1) {\n        return 0;\n    }\n    x = this[0];\n    if ((x & 1) === 0) {\n        return 0;\n    }\n    y = x & 3;\t\t// y == 1/x mod 2^2\n    y = (y * (2 - (x & 0xf) * y)) & 0xf;\t// y == 1/x mod 2^4\n    y = (y * (2 - (x & 0xff) * y)) & 0xff;\t// y == 1/x mod 2^8\n    y = (y * (2 - (((x & 0xffff) * y) & 0xffff))) & 0xffff;\t// y == 1/x mod 2^16\n    // last step - calculate inverse mod DV directly;\n    // assumes 16 < DB <= 32 and assumes ability to handle 48-bit ints\n    y = (y * (2 - x * y % this.DV)) % this.DV;\t\t// y == 1/x mod 2^Sk.builtin.biginteger.dbits\n    // we really want the negative inverse, and -DV < y < DV\n    return (y > 0) ? this.DV - y : -y;\n};\n\n// Sk.builtin.Montgomery reduction\n/**\n * @constructor\n * @extends Sk.builtin.biginteger\n */\nSk.builtin.biginteger.Montgomery = function (m) {\n    this.m = m;\n    this.mp = m.invDigit();\n    this.mpl = this.mp & 0x7fff;\n    this.mph = this.mp >> 15;\n    this.um = (1 << (m.DB - 15)) - 1;\n    this.mt2 = 2 * m.t;\n};\n\n// xR mod m\nSk.builtin.biginteger.prototype.montConvert = function (x) {\n    var r = Sk.builtin.biginteger.nbi();\n    x.abs().dlShiftTo(this.m.t, r);\n    r.divRemTo(this.m, null, r);\n    if (x.s < 0 && r.compareTo(Sk.builtin.biginteger.ZERO) > 0) {\n        this.m.subTo(r, r);\n    }\n    return r;\n};\n\n// x/R mod m\nSk.builtin.biginteger.prototype.montRevert = function (x) {\n    var r = Sk.builtin.biginteger.nbi();\n    x.copyTo(r);\n    this.reduce(r);\n    return r;\n};\n\n// x = x/R mod m (HAC 14.32)\nSk.builtin.biginteger.prototype.montReduce = function (x) {\n    var u0;\n    var j;\n    var i;\n    while (x.t <= this.mt2) {\n        // pad x so am has enough room later\n        x[x.t++] = 0;\n    }\n    for (i = 0; i < this.m.t; ++i) {\n        // faster way of calculating u0 = x[i]*mp mod DV\n        j = x[i] & 0x7fff;\n        u0 = (j * this.mpl + (((j * this.mph + (x[i] >> 15) * this.mpl) & this.um) << 15)) & x.DM;\n        // use am to combine the multiply-shift-add into one call\n        j = i + this.m.t;\n        x[j] += this.m.am(0, u0, x, i, 0, this.m.t);\n        // propagate carry\n        while (x[j] >= x.DV) {\n            x[j] -= x.DV;\n            x[++j]++;\n        }\n    }\n    x.clamp();\n    x.drShiftTo(this.m.t, x);\n    if (x.compareTo(this.m) >= 0) {\n        x.subTo(this.m, x);\n    }\n};\n\n// r = \"x^2/R mod m\"; x != r\nSk.builtin.biginteger.prototype.montSqrTo = function (x, r) {\n    x.squareTo(r);\n    this.reduce(r);\n};\n\n// r = \"xy/R mod m\"; x,y != r\nSk.builtin.biginteger.prototype.montMulTo = function (x, y, r) {\n    x.multiplyTo(y, r);\n    this.reduce(r);\n};\n\nSk.builtin.biginteger.Montgomery.prototype.convert = Sk.builtin.biginteger.prototype.montConvert;\nSk.builtin.biginteger.Montgomery.prototype.revert = Sk.builtin.biginteger.prototype.montRevert;\nSk.builtin.biginteger.Montgomery.prototype.reduce = Sk.builtin.biginteger.prototype.montReduce;\nSk.builtin.biginteger.Montgomery.prototype.mulTo = Sk.builtin.biginteger.prototype.montMulTo;\nSk.builtin.biginteger.Montgomery.prototype.sqrTo = Sk.builtin.biginteger.prototype.montSqrTo;\n\n// (protected) true iff this is even\nSk.builtin.biginteger.prototype.bnpIsEven = function () {\n    return ((this.t > 0) ? (this[0] & 1) : this.s) === 0;\n};\n\n// (protected) this^e, e < 2^32, doing sqr and mul with \"r\" (HAC 14.79)\nSk.builtin.biginteger.prototype.bnpExp = function (e, z) {\n    var t;\n    var r, r2, g, i;\n    if (e > 0xffffffff || e < 1) {\n        return Sk.builtin.biginteger.ONE;\n    }\n    r = Sk.builtin.biginteger.nbi();\n    r2 = Sk.builtin.biginteger.nbi();\n    g = z.convert(this);\n    i = Sk.builtin.biginteger.nbits(e) - 1;\n    g.copyTo(r);\n    while (--i >= 0) {\n        z.sqrTo(r, r2);\n        if ((e & (1 << i)) > 0) {\n            z.mulTo(r2, g, r);\n        } else {\n            t = r;\n            r = r2;\n            r2 = t;\n        }\n    }\n    return z.revert(r);\n};\n\n// (public) this^e % m, 0 <= e < 2^32\nSk.builtin.biginteger.prototype.bnModPowInt = function (e, m) {\n    var z;\n    if (e < 256 || m.isEven()) {\n        z = new Sk.builtin.biginteger.Classic(m);\n    } else {\n        z = new Sk.builtin.biginteger.Montgomery(m);\n    }\n    return this.exp(e, z);\n};\n\n// protected\nSk.builtin.biginteger.prototype.copyTo = Sk.builtin.biginteger.prototype.bnpCopyTo;\nSk.builtin.biginteger.prototype.fromInt = Sk.builtin.biginteger.prototype.bnpFromInt;\nSk.builtin.biginteger.prototype.fromString = Sk.builtin.biginteger.prototype.bnpFromString;\nSk.builtin.biginteger.prototype.clamp = Sk.builtin.biginteger.prototype.bnpClamp;\nSk.builtin.biginteger.prototype.dlShiftTo = Sk.builtin.biginteger.prototype.bnpDLShiftTo;\nSk.builtin.biginteger.prototype.drShiftTo = Sk.builtin.biginteger.prototype.bnpDRShiftTo;\nSk.builtin.biginteger.prototype.lShiftTo = Sk.builtin.biginteger.prototype.bnpLShiftTo;\nSk.builtin.biginteger.prototype.rShiftTo = Sk.builtin.biginteger.prototype.bnpRShiftTo;\nSk.builtin.biginteger.prototype.subTo = Sk.builtin.biginteger.prototype.bnpSubTo;\nSk.builtin.biginteger.prototype.multiplyTo = Sk.builtin.biginteger.prototype.bnpMultiplyTo;\nSk.builtin.biginteger.prototype.squareTo = Sk.builtin.biginteger.prototype.bnpSquareTo;\nSk.builtin.biginteger.prototype.divRemTo = Sk.builtin.biginteger.prototype.bnpDivRemTo;\nSk.builtin.biginteger.prototype.invDigit = Sk.builtin.biginteger.prototype.bnpInvDigit;\nSk.builtin.biginteger.prototype.isEven = Sk.builtin.biginteger.prototype.bnpIsEven;\nSk.builtin.biginteger.prototype.exp = Sk.builtin.biginteger.prototype.bnpExp;\n\n// public\nSk.builtin.biginteger.prototype.toString = Sk.builtin.biginteger.prototype.bnToString;\nSk.builtin.biginteger.prototype.negate = Sk.builtin.biginteger.prototype.bnNegate;\nSk.builtin.biginteger.prototype.abs = Sk.builtin.biginteger.prototype.bnAbs;\nSk.builtin.biginteger.prototype.compareTo = Sk.builtin.biginteger.prototype.bnCompareTo;\nSk.builtin.biginteger.prototype.bitLength = Sk.builtin.biginteger.prototype.bnBitLength;\nSk.builtin.biginteger.prototype.mod = Sk.builtin.biginteger.prototype.bnMod;\nSk.builtin.biginteger.prototype.modPowInt = Sk.builtin.biginteger.prototype.bnModPowInt;\n\n// \"constants\"\nSk.builtin.biginteger.ZERO = Sk.builtin.biginteger.nbv(0);\nSk.builtin.biginteger.ONE = Sk.builtin.biginteger.nbv(1);\n\n//Copyright (c) 2005-2009  Tom Wu\n//All Rights Reserved.\n//See \"LICENSE\" for details.\n\n//Extended JavaScript BN functions, required for RSA private ops.\n\n//Version 1.1: new Sk.builtin.biginteger(\"0\", 10) returns \"proper\" zero\n\n//(public)\nSk.builtin.biginteger.prototype.bnClone = function () {\n    var r = Sk.builtin.biginteger.nbi();\n    this.copyTo(r);\n    return r;\n};\n\n//(public) return value as integer\nSk.builtin.biginteger.prototype.bnIntValue = function () {\n    if (this.s < 0) {\n        if (this.t == 1) {\n            return this[0] - this.DV;\n        } else if (this.t === 0) {\n            return -1;\n        }\n    } else if (this.t == 1) {\n        return this[0];\n    } else if (this.t === 0) {\n        return 0;\n    }\n    return ((this[1] & ((1 << (32 - this.DB)) - 1)) << this.DB) | this[0];\n};\n\n//(public) return value as byte\nSk.builtin.biginteger.prototype.bnByteValue = function () {\n    return (this.t === 0) ? this.s : (this[0] << 24) >> 24;\n};\n\n//(public) return value as short (assumes DB>=16)\nSk.builtin.biginteger.prototype.bnShortValue = function () {\n    return (this.t === 0) ? this.s : (this[0] << 16) >> 16;\n};\n\n//(protected) return x s.t. r^x < DV\nSk.builtin.biginteger.prototype.bnpChunkSize = function (r) {\n    return Math.floor(Math.LN2 * this.DB / Math.log(r));\n};\n\n//(public) 0 if this == 0, 1 if this > 0\nSk.builtin.biginteger.prototype.bnSigNum = function () {\n    if (this.s < 0) {\n        return -1;\n    } else if (this.t <= 0 || (this.t == 1 && this[0] <= 0)) {\n        return 0;\n    } else {\n        return 1;\n    }\n};\n\n//(protected) convert to radix string\nSk.builtin.biginteger.prototype.bnpToRadix = function (b) {\n    var d, y, z, r;\n    var a;\n    var cs;\n    if (b == null) {\n        b = 10;\n    }\n    if (this.signum() === 0 || b < 2 || b > 36) {\n        return \"0\";\n    }\n    cs = this.chunkSize(b);\n    a = Math.pow(b, cs);\n    d = Sk.builtin.biginteger.nbv(a);\n    y = Sk.builtin.biginteger.nbi(); z = Sk.builtin.biginteger.nbi();\n    r = \"\";\n    this.divRemTo(d, y, z);\n    while (y.signum() > 0) {\n        r = (a + z.intValue()).toString(b).substr(1) + r;\n        y.divRemTo(d, y, z);\n    }\n    return z.intValue().toString(b) + r;\n};\n\n//(protected) convert from radix string\nSk.builtin.biginteger.prototype.bnpFromRadix = function (s, b) {\n    var x;\n    var i;\n    var d, mi, j, w;\n    var cs;\n    this.fromInt(0);\n    if (b == null) {\n        b = 10;\n    }\n    cs = this.chunkSize(b);\n    d = Math.pow(b, cs);\n    mi = false;\n    j = 0;\n    w = 0;\n    for (i = 0; i < s.length; ++i) {\n        x = Sk.builtin.biginteger.intAt(s, i);\n        if (x < 0) {\n            if (s.charAt(i) == \"-\" && this.signum() === 0) {\n                mi = true;\n            }\n            if (s.charAt(i) == \".\") {\n                break;\n            }\n            continue;\n        }\n        w = b * w + x;\n        if (++j >= cs) {\n            this.dMultiply(d);\n            this.dAddOffset(w, 0);\n            j = 0;\n            w = 0;\n        }\n    }\n    if (j > 0) {\n        this.dMultiply(Math.pow(b, j));\n        this.dAddOffset(w, 0);\n    }\n    if (mi) {\n        Sk.builtin.biginteger.ZERO.subTo(this, this);\n    }\n};\n\n//(protected) alternate constructor\nSk.builtin.biginteger.prototype.bnpFromNumber = function (a, b, c) {\n    if (\"number\" == typeof b) {\n        // new Sk.builtin.biginteger(int,int,RNG)\n        if (a < 2) {\n            this.fromInt(1);\n        } else {\n            this.fromNumber(a, c);\n            if (!this.testBit(a - 1))\t{\n                // force MSB set\n                this.bitwiseTo(Sk.builtin.biginteger.ONE.shiftLeft(a - 1), Sk.builtin.biginteger.op_or, this);\n            }\n            if (this.isEven()) {\n                this.dAddOffset(1, 0);\n            } // force odd\n            while (!this.isProbablePrime(b)) {\n                this.dAddOffset(2, 0);\n                if (this.bitLength() > a) {\n                    this.subTo(Sk.builtin.biginteger.ONE.shiftLeft(a - 1), this);\n                }\n            }\n        }\n    }\n    //\tConstructor to support Java BigInteger random generation.  Forget it.\n    this.fromString(a + \"\");\n};\n\n//(public) convert to bigendian byte array\nSk.builtin.biginteger.prototype.bnToByteArray = function () {\n    var p, d, k;\n    var i = this.t, r = [];\n    r[0] = this.s;\n    p = this.DB - (i * this.DB) % 8;\n    k = 0;\n    if (i-- > 0) {\n        if (p < this.DB && (d = this[i] >> p) != (this.s & this.DM) >> p) {\n            r[k++] = d | (this.s << (this.DB - p));\n        }\n        while (i >= 0) {\n            if (p < 8) {\n                d = (this[i] & ((1 << p) - 1)) << (8 - p);\n                d |= this[--i] >> (p += this.DB - 8);\n            } else {\n                d = (this[i] >> (p -= 8)) & 0xff;\n                if (p <= 0) {\n                    p += this.DB;\n                    --i;\n                }\n            }\n            if ((d & 0x80) !== 0) {\n                d |= -256;\n            }\n            if (k === 0 && (this.s & 0x80) != (d & 0x80)) {\n                ++k;\n            }\n            if (k > 0 || d != this.s) {\n                r[k++] = d;\n            }\n        }\n    }\n    return r;\n};\n\nSk.builtin.biginteger.prototype.bnEquals = function (a) {\n    return(this.compareTo(a) === 0);\n};\nSk.builtin.biginteger.prototype.bnMin = function (a) {\n    return(this.compareTo(a) < 0) ? this : a;\n};\nSk.builtin.biginteger.prototype.bnMax = function (a) {\n    return(this.compareTo(a) > 0) ? this : a;\n};\n\n//(protected) r = this op a (bitwise)\nSk.builtin.biginteger.prototype.bnpBitwiseTo = function (a, op, r) {\n    var i, f, m = Math.min(a.t, this.t);\n    for (i = 0; i < m; ++i) {\n        r[i] = op(this[i], a[i]);\n    }\n    if (a.t < this.t) {\n        f = a.s & this.DM;\n        for (i = m; i < this.t; ++i) {\n            r[i] = op(this[i], f);\n        }\n        r.t = this.t;\n    } else {\n        f = this.s & this.DM;\n        for (i = m; i < a.t; ++i) {\n            r[i] = op(f, a[i]);\n        }\n        r.t = a.t;\n    }\n    r.s = op(this.s, a.s);\n    r.clamp();\n};\n\n//(public) this & a\nSk.builtin.biginteger.op_and = function (x, y) {\n    return x & y;\n};\nSk.builtin.biginteger.prototype.bnAnd = function (a) {\n    var r = Sk.builtin.biginteger.nbi();\n    this.bitwiseTo(a, Sk.builtin.biginteger.op_and, r);\n    return r;\n};\n\n//(public) this | a\nSk.builtin.biginteger.op_or = function (x, y) {\n    return x | y;\n};\nSk.builtin.biginteger.prototype.bnOr = function (a) {\n    var r = Sk.builtin.biginteger.nbi();\n    this.bitwiseTo(a, Sk.builtin.biginteger.op_or, r);\n    return r;\n};\n\n//(public) this ^ a\nSk.builtin.biginteger.op_xor = function (x, y) {\n    return x ^ y;\n};\nSk.builtin.biginteger.prototype.bnXor = function (a) {\n    var r = Sk.builtin.biginteger.nbi();\n    this.bitwiseTo(a, Sk.builtin.biginteger.op_xor, r);\n    return r;\n};\n\n//(public) this & ~a\nSk.builtin.biginteger.op_andnot = function (x, y) {\n    return x & ~y;\n};\nSk.builtin.biginteger.prototype.bnAndNot = function (a) {\n    var r = Sk.builtin.biginteger.nbi();\n    this.bitwiseTo(a, Sk.builtin.biginteger.op_andnot, r);\n    return r;\n};\n\n//(public) ~this\nSk.builtin.biginteger.prototype.bnNot = function () {\n    var i;\n    var r = Sk.builtin.biginteger.nbi();\n    for (i = 0; i < this.t; ++i) {\n        r[i] = this.DM & ~this[i];\n    }\n    r.t = this.t;\n    r.s = ~this.s;\n    return r;\n};\n\n//(public) this << n\nSk.builtin.biginteger.prototype.bnShiftLeft = function (n) {\n    var r = Sk.builtin.biginteger.nbi();\n    if (n < 0) {\n        this.rShiftTo(-n, r);\n    } else {\n        this.lShiftTo(n, r);\n    }\n    return r;\n};\n\n//(public) this >> n\nSk.builtin.biginteger.prototype.bnShiftRight = function (n) {\n    var r = Sk.builtin.biginteger.nbi();\n    if (n < 0) {\n        this.lShiftTo(-n, r);\n    } else {\n        this.rShiftTo(n, r);\n    }\n    return r;\n};\n\n//return index of lowest 1-bit in x, x < 2^31\nSk.builtin.biginteger.lbit = function (x) {\n    var r;\n    if (x === 0) {\n        return -1;\n    }\n    r = 0;\n    if ((x & 0xffff) === 0) {\n        x >>= 16;\n        r += 16;\n    }\n    if ((x & 0xff) === 0) {\n        x >>= 8;\n        r += 8;\n    }\n    if ((x & 0xf) === 0) {\n        x >>= 4;\n        r += 4;\n    }\n    if ((x & 3) === 0) {\n        x >>= 2;\n        r += 2;\n    }\n    if ((x & 1) === 0) {\n        ++r;\n    }\n    return r;\n};\n\n//(public) returns index of lowest 1-bit (or -1 if none)\nSk.builtin.biginteger.prototype.bnGetLowestSetBit = function () {\n    var i;\n    for (i = 0; i < this.t; ++i) {\n        if (this[i] !== 0) {\n            return i * this.DB + Sk.builtin.biginteger.lbit(this[i]);\n        }\n    }\n    if (this.s < 0) {\n        return this.t * this.DB;\n    }\n    return -1;\n};\n\n//return number of 1 bits in x\nSk.builtin.biginteger.cbit = function (x) {\n    var r = 0;\n    while (x !== 0) {\n        x &= x - 1;\n        ++r;\n    }\n    return r;\n};\n\n//(public) return number of set bits\nSk.builtin.biginteger.prototype.bnBitCount = function () {\n    var i;\n    var r = 0, x = this.s & this.DM;\n    for (i = 0; i < this.t; ++i) {\n        r += Sk.builtin.biginteger.cbit(this[i] ^ x);\n    }\n    return r;\n};\n\n//(public) true iff nth bit is set\nSk.builtin.biginteger.prototype.bnTestBit = function (n) {\n    var j = Math.floor(n / this.DB);\n    if (j >= this.t) {\n        return(this.s !== 0);\n    }\n    return((this[j] & (1 << (n % this.DB))) !== 0);\n};\n\n//(protected) this op (1<<n)\nSk.builtin.biginteger.prototype.bnpChangeBit = function (n, op) {\n    var r = Sk.builtin.biginteger.ONE.shiftLeft(n);\n    this.bitwiseTo(r, op, r);\n    return r;\n};\n\n//(public) this | (1<<n)\nSk.builtin.biginteger.prototype.bnSetBit = function (n) {\n    return this.changeBit(n, Sk.builtin.biginteger.op_or);\n};\n\n//(public) this & ~(1<<n)\nSk.builtin.biginteger.prototype.bnClearBit = function (n) {\n    return this.changeBit(n, Sk.builtin.biginteger.op_andnot);\n};\n\n//(public) this ^ (1<<n)\nSk.builtin.biginteger.prototype.bnFlipBit = function (n) {\n    return this.changeBit(n, Sk.builtin.biginteger.op_xor);\n};\n\n//(protected) r = this + a\nSk.builtin.biginteger.prototype.bnpAddTo = function (a, r) {\n    var i = 0, c = 0, m = Math.min(a.t, this.t);\n    while (i < m) {\n        c += this[i] + a[i];\n        r[i++] = c & this.DM;\n        c >>= this.DB;\n    }\n    if (a.t < this.t) {\n        c += a.s;\n        while (i < this.t) {\n            c += this[i];\n            r[i++] = c & this.DM;\n            c >>= this.DB;\n        }\n        c += this.s;\n    } else {\n        c += this.s;\n        while (i < a.t) {\n            c += a[i];\n            r[i++] = c & this.DM;\n            c >>= this.DB;\n        }\n        c += a.s;\n    }\n    r.s = (c < 0) ? -1 : 0;\n    if (c > 0) {\n        r[i++] = c;\n    } else if (c < -1) {\n        r[i++] = this.DV + c;\n    }\n    r.t = i;\n    r.clamp();\n};\n\n//(public) this + a\nSk.builtin.biginteger.prototype.bnAdd = function (a) {\n    var r = Sk.builtin.biginteger.nbi();\n    this.addTo(a, r);\n    return r;\n};\n\n//(public) this - a\nSk.builtin.biginteger.prototype.bnSubtract = function (a) {\n    var r = Sk.builtin.biginteger.nbi();\n    this.subTo(a, r);\n    return r;\n};\n\n//(public) this * a\nSk.builtin.biginteger.prototype.bnMultiply = function (a) {\n    var r = Sk.builtin.biginteger.nbi();\n    this.multiplyTo(a, r);\n    return r;\n};\n\n//(public) this / a\nSk.builtin.biginteger.prototype.bnDivide = function (a) {\n    var r = Sk.builtin.biginteger.nbi();\n    this.divRemTo(a, r, null);\n    return r;\n};\n\n//(public) this % a\nSk.builtin.biginteger.prototype.bnRemainder = function (a) {\n    var r = Sk.builtin.biginteger.nbi();\n    this.divRemTo(a, null, r);\n    return r;\n};\n\n//(public) [this/a,this%a]\nSk.builtin.biginteger.prototype.bnDivideAndRemainder = function (a) {\n    var q = Sk.builtin.biginteger.nbi(), r = Sk.builtin.biginteger.nbi();\n    this.divRemTo(a, q, r);\n    return new Array(q, r);\n};\n\n//(protected) this *= n, this >= 0, 1 < n < DV\nSk.builtin.biginteger.prototype.bnpDMultiply = function (n) {\n    this[this.t] = this.am(0, n - 1, this, 0, 0, this.t);\n    ++this.t;\n    this.clamp();\n};\n\n//(protected) this += n << w words, this >= 0\nSk.builtin.biginteger.prototype.bnpDAddOffset = function (n, w) {\n    if (n === 0) {\n        return;\n    }\n    while (this.t <= w) {\n        this[this.t++] = 0;\n    }\n    this[w] += n;\n    while (this[w] >= this.DV) {\n        this[w] -= this.DV;\n        if (++w >= this.t) {\n            this[this.t++] = 0;\n        }\n        ++this[w];\n    }\n};\n\n//A \"null\" reducer\n/**\n * @constructor\n * @extends Sk.builtin.biginteger\n */\nSk.builtin.biginteger.NullExp = function () {\n};\nSk.builtin.biginteger.prototype.nNop = function (x) {\n    return x;\n};\nSk.builtin.biginteger.prototype.nMulTo = function (x, y, r) {\n    x.multiplyTo(y, r);\n};\nSk.builtin.biginteger.prototype.nSqrTo = function (x, r) {\n    x.squareTo(r);\n};\n\nSk.builtin.biginteger.NullExp.prototype.convert = Sk.builtin.biginteger.prototype.nNop;\nSk.builtin.biginteger.NullExp.prototype.revert = Sk.builtin.biginteger.prototype.nNop;\nSk.builtin.biginteger.NullExp.prototype.mulTo = Sk.builtin.biginteger.prototype.nMulTo;\nSk.builtin.biginteger.NullExp.prototype.sqrTo = Sk.builtin.biginteger.prototype.nSqrTo;\n\n//(public) this^e\nSk.builtin.biginteger.prototype.bnPow = function (e) {\n    return this.exp(e, new Sk.builtin.biginteger.NullExp());\n};\n\n//(protected) r = lower n words of \"this * a\", a.t <= n\n//\"this\" should be the larger one if appropriate.\nSk.builtin.biginteger.prototype.bnpMultiplyLowerTo = function (a, n, r) {\n    var j;\n    var i = Math.min(this.t + a.t, n);\n    r.s = 0; // assumes a,this >= 0\n    r.t = i;\n    while (i > 0) {\n        r[--i] = 0;\n    }\n    for (j = r.t - this.t; i < j; ++i) {\n        r[i + this.t] = this.am(0, a[i], r, i, 0, this.t);\n    }\n    for (j = Math.min(a.t, n); i < j; ++i) {\n        this.am(0, a[i], r, i, 0, n - i);\n    }\n    r.clamp();\n};\n\n//(protected) r = \"this * a\" without lower n words, n > 0\n//\"this\" should be the larger one if appropriate.\nSk.builtin.biginteger.prototype.bnpMultiplyUpperTo = function (a, n, r) {\n    var i;\n    --n;\n    i = r.t = this.t + a.t - n;\n    r.s = 0; // assumes a,this >= 0\n    while (--i >= 0) {\n        r[i] = 0;\n    }\n    for (i = Math.max(n - this.t, 0); i < a.t; ++i) {\n        r[this.t + i - n] = this.am(n - i, a[i], r, 0, 0, this.t + i - n);\n    }\n    r.clamp();\n    r.drShiftTo(1, r);\n};\n\n//Barrett modular reduction\n/**\n * @constructor\n * @extends Sk.builtin.biginteger\n */\nSk.builtin.biginteger.Barrett = function (m) {\n    this.r2 = Sk.builtin.biginteger.nbi();\n    this.q3 = Sk.builtin.biginteger.nbi();\n    Sk.builtin.biginteger.ONE.dlShiftTo(2 * m.t, this.r2);\n    this.mu = this.r2.divide(m);\n    this.m = m;\n};\n\nSk.builtin.biginteger.prototype.barrettConvert = function (x) {\n    var r;\n    if (x.s < 0 || x.t > 2 * this.m.t) {\n        return x.mod(this.m);\n    } else if (x.compareTo(this.m) < 0) {\n        return x;\n    } else {\n        r = Sk.builtin.biginteger.nbi();\n        x.copyTo(r);\n        this.reduce(r);\n        return r;\n    }\n};\n\nSk.builtin.biginteger.prototype.barrettRevert = function (x) {\n    return x;\n};\n\n//x = x mod m (HAC 14.42)\nSk.builtin.biginteger.prototype.barrettReduce = function (x) {\n    x.drShiftTo(this.m.t - 1, this.r2);\n    if (x.t > this.m.t + 1) {\n        x.t = this.m.t + 1;\n        x.clamp();\n    }\n    this.mu.multiplyUpperTo(this.r2, this.m.t + 1, this.q3);\n    this.m.multiplyLowerTo(this.q3, this.m.t + 1, this.r2);\n    while (x.compareTo(this.r2) < 0) {\n        x.dAddOffset(1, this.m.t + 1);\n    }\n    x.subTo(this.r2, x);\n    while (x.compareTo(this.m) >= 0) {\n        x.subTo(this.m, x);\n    }\n};\n\n//r = x^2 mod m; x != r\nSk.builtin.biginteger.prototype.barrettSqrTo = function (x, r) {\n    x.squareTo(r);\n    this.reduce(r);\n};\n\n//r = x*y mod m; x,y != r\nSk.builtin.biginteger.prototype.barrettMulTo = function (x, y, r) {\n    x.multiplyTo(y, r);\n    this.reduce(r);\n};\n\nSk.builtin.biginteger.Barrett.prototype.convert = Sk.builtin.biginteger.prototype.barrettConvert;\nSk.builtin.biginteger.Barrett.prototype.revert = Sk.builtin.biginteger.prototype.barrettRevert;\nSk.builtin.biginteger.Barrett.prototype.reduce = Sk.builtin.biginteger.prototype.barrettReduce;\nSk.builtin.biginteger.Barrett.prototype.mulTo = Sk.builtin.biginteger.prototype.barrettMulTo;\nSk.builtin.biginteger.Barrett.prototype.sqrTo = Sk.builtin.biginteger.prototype.barrettSqrTo;\n\n//(public) this^e % m (HAC 14.85)\nSk.builtin.biginteger.prototype.bnModPow = function (e, m) {\n    var j, w, is1, r2, t;\n    var g2;\n    var g, n, k1, km;\n    var i = e.bitLength(), k, r = Sk.builtin.biginteger.nbv(1), z;\n    if (i <= 0) {\n        return r;\n    } else if (i < 18) {\n        k = 1;\n    } else if (i < 48) {\n        k = 3;\n    } else if (i < 144) {\n        k = 4;\n    } else if (i < 768) {\n        k = 5;\n    } else {\n        k = 6;\n    }\n    if (i < 8) {\n        z = new Sk.builtin.biginteger.Classic(m);\n    } else if (m.isEven()) {\n        z = new Sk.builtin.biginteger.Barrett(m);\n    } else {\n        z = new Sk.builtin.biginteger.Montgomery(m);\n    }\n\n    g = [];\n    n = 3;\n    k1 = k - 1;\n    km = (1 << k) - 1;\n    g[1] = z.convert(this);\n    if (k > 1) {\n        g2 = Sk.builtin.biginteger.nbi();\n        z.sqrTo(g[1], g2);\n        while (n <= km) {\n            g[n] = Sk.builtin.biginteger.nbi();\n            z.mulTo(g2, g[n - 2], g[n]);\n            n += 2;\n        }\n    }\n\n    j = e.t - 1;\n    is1 = true;\n    r2 = Sk.builtin.biginteger.nbi();\n    i = Sk.builtin.biginteger.nbits(e[j]) - 1;\n    while (j >= 0) {\n        if (i >= k1) {\n            w = (e[j] >> (i - k1)) & km;\n        } else {\n            w = (e[j] & ((1 << (i + 1)) - 1)) << (k1 - i);\n            if (j > 0) {\n                w |= e[j - 1] >> (this.DB + i - k1);\n            }\n        }\n\n        n = k;\n        while ((w & 1) === 0) {\n            w >>= 1;\n            --n;\n        }\n        if ((i -= n) < 0) {\n            i += this.DB;\n            --j;\n        }\n        if (is1) {\t// ret == 1, don't bother squaring or multiplying it\n            g[w].copyTo(r);\n            is1 = false;\n        } else {\n            while (n > 1) {\n                z.sqrTo(r, r2);\n                z.sqrTo(r2, r);\n                n -= 2;\n            }\n            if (n > 0) {\n                z.sqrTo(r, r2);\n            } else {\n                t = r;\n                r = r2;\n                r2 = t;\n            }\n            z.mulTo(r2, g[w], r);\n        }\n\n        while (j >= 0 && (e[j] & (1 << i)) === 0) {\n            z.sqrTo(r, r2);\n            t = r;\n            r = r2;\n            r2 = t;\n            if (--i < 0) {\n                i = this.DB - 1;\n                --j;\n            }\n        }\n    }\n    return z.revert(r);\n};\n\n//(public) gcd(this,a) (HAC 14.54)\nSk.builtin.biginteger.prototype.bnGCD = function (a) {\n    var i, g;\n    var t;\n    var x = (this.s < 0) ? this.negate() : this.clone();\n    var y = (a.s < 0) ? a.negate() : a.clone();\n    if (x.compareTo(y) < 0) {\n        t = x;\n        x = y;\n        y = t;\n    }\n    i = x.getLowestSetBit();\n    g = y.getLowestSetBit();\n    if (g < 0) {\n        return x;\n    }\n    if (i < g) {\n        g = i;\n    }\n    if (g > 0) {\n        x.rShiftTo(g, x);\n        y.rShiftTo(g, y);\n    }\n    while (x.signum() > 0) {\n        if ((i = x.getLowestSetBit()) > 0) {\n            x.rShiftTo(i, x);\n        }\n        if ((i = y.getLowestSetBit()) > 0) {\n            y.rShiftTo(i, y);\n        }\n        if (x.compareTo(y) >= 0) {\n            x.subTo(y, x);\n            x.rShiftTo(1, x);\n        } else {\n            y.subTo(x, y);\n            y.rShiftTo(1, y);\n        }\n    }\n    if (g > 0) {\n        y.lShiftTo(g, y);\n    }\n    return y;\n};\n\n//(protected) this % n, n < 2^26\nSk.builtin.biginteger.prototype.bnpModInt = function (n) {\n    var i;\n    var d, r;\n    if (n <= 0) {\n        return 0;\n    }\n    d = this.DV % n;\n    r = (this.s < 0) ? n - 1 : 0;\n    if (this.t > 0) {\n        if (d === 0) {\n            r = this[0] % n;\n        } else {\n            for (i = this.t - 1; i >= 0; --i) {\n                r = (d * r + this[i]) % n;\n            }\n        }\n    }\n    return r;\n};\n\n//(public) 1/this % m (HAC 14.61)\nSk.builtin.biginteger.prototype.bnModInverse = function (m) {\n    var a, b, c, d;\n    var u, v;\n    var ac = m.isEven();\n    if ((this.isEven() && ac) || m.signum() === 0) {\n        return Sk.builtin.biginteger.ZERO;\n    }\n    u = m.clone();\n    v = this.clone();\n    a = Sk.builtin.biginteger.nbv(1);\n    b = Sk.builtin.biginteger.nbv(0);\n    c = Sk.builtin.biginteger.nbv(0);\n    d = Sk.builtin.biginteger.nbv(1);\n    while (u.signum() !== 0) {\n        while (u.isEven()) {\n            u.rShiftTo(1, u);\n            if (ac) {\n                if (!a.isEven() || !b.isEven()) {\n                    a.addTo(this, a);\n                    b.subTo(m, b);\n                }\n                a.rShiftTo(1, a);\n            } else if (!b.isEven()) {\n                b.subTo(m, b);\n            }\n            b.rShiftTo(1, b);\n        }\n        while (v.isEven()) {\n            v.rShiftTo(1, v);\n            if (ac) {\n                if (!c.isEven() || !d.isEven()) {\n                    c.addTo(this, c);\n                    d.subTo(m, d);\n                }\n                c.rShiftTo(1, c);\n            } else if (!d.isEven()) {\n                d.subTo(m, d);\n            }\n            d.rShiftTo(1, d);\n        }\n        if (u.compareTo(v) >= 0) {\n            u.subTo(v, u);\n            if (ac) {\n                a.subTo(c, a);\n            }\n            b.subTo(d, b);\n        } else {\n            v.subTo(u, v);\n            if (ac) {\n                c.subTo(a, c);\n            }\n            d.subTo(b, d);\n        }\n    }\n    if (v.compareTo(Sk.builtin.biginteger.ONE) !== 0) {\n        return Sk.builtin.biginteger.ZERO;\n    }\n    if (d.compareTo(m) >= 0) {\n        return d.subtract(m);\n    }\n    if (d.signum() < 0) {\n        d.addTo(m, d);\n    } else {\n        return d;\n    }\n    if (d.signum() < 0) {\n        return d.add(m);\n    } else {\n        return d;\n    }\n};\n\nSk.builtin.biginteger.lowprimes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509];\nSk.builtin.biginteger.lplim = (1 << 26) / Sk.builtin.biginteger.lowprimes[Sk.builtin.biginteger.lowprimes.length - 1];\n\n//(public) test primality with certainty >= 1-.5^t\nSk.builtin.biginteger.prototype.bnIsProbablePrime = function (t) {\n    var m, j;\n    var i, x = this.abs();\n    if (x.t == 1 && x[0] <= Sk.builtin.biginteger.lowprimes[Sk.builtin.biginteger.lowprimes.length - 1]) {\n        for (i = 0; i < Sk.builtin.biginteger.lowprimes.length; ++i) {\n            if (x[0] == Sk.builtin.biginteger.lowprimes[i]) {\n                return true;\n            }\n        }\n        return false;\n    }\n    if (x.isEven()) {\n        return false;\n    }\n    i = 1;\n    while (i < Sk.builtin.biginteger.lowprimes.length) {\n        m = Sk.builtin.biginteger.lowprimes[i];\n        j = i + 1;\n        while (j < Sk.builtin.biginteger.lowprimes.length && m < Sk.builtin.biginteger.lplim) {\n            m *= Sk.builtin.biginteger.lowprimes[j++];\n        }\n        m = x.modInt(m);\n        while (i < j) {\n            if (m % Sk.builtin.biginteger.lowprimes[i++] === 0) {\n                return false;\n            }\n        }\n    }\n    return x.millerRabin(t);\n};\n\n//(protected) true if probably prime (HAC 4.24, Miller-Rabin)\nSk.builtin.biginteger.prototype.bnpMillerRabin = function (t) {\n    var j;\n    var y;\n    var i;\n    var a;\n    var r;\n    var n1 = this.subtract(Sk.builtin.biginteger.ONE);\n    var k = n1.getLowestSetBit();\n    if (k <= 0) {\n        return false;\n    }\n    r = n1.shiftRight(k);\n    t = (t + 1) >> 1;\n    if (t > Sk.builtin.biginteger.lowprimes.length) {\n        t = Sk.builtin.biginteger.lowprimes.length;\n    }\n    a = Sk.builtin.biginteger.nbi();\n    for (i = 0; i < t; ++i) {\n        a.fromInt(Sk.builtin.biginteger.lowprimes[i]);\n        y = a.modPow(r, this);\n        if (y.compareTo(Sk.builtin.biginteger.ONE) !== 0 && y.compareTo(n1) !== 0) {\n            j = 1;\n            while (j++ < k && y.compareTo(n1) !== 0) {\n                y = y.modPowInt(2, this);\n                if (y.compareTo(Sk.builtin.biginteger.ONE) === 0) {\n                    return false;\n                }\n            }\n            if (y.compareTo(n1) !== 0) {\n                return false;\n            }\n        }\n    }\n    return true;\n};\n\nSk.builtin.biginteger.prototype.isnegative = function () {\n    return this.s < 0;\n};\nSk.builtin.biginteger.prototype.ispositive = function () {\n    return this.s >= 0;\n};\nSk.builtin.biginteger.prototype.trueCompare = function (a) {\n    if (this.s >= 0 && a.s < 0) {\n        return 1;\n    }\n    if (this.s < 0 && a.s >= 0) {\n        return -1;\n    }\n    return this.compare(a);\n};\n\n//protected\nSk.builtin.biginteger.prototype.chunkSize = Sk.builtin.biginteger.prototype.bnpChunkSize;\nSk.builtin.biginteger.prototype.toRadix = Sk.builtin.biginteger.prototype.bnpToRadix;\nSk.builtin.biginteger.prototype.fromRadix = Sk.builtin.biginteger.prototype.bnpFromRadix;\nSk.builtin.biginteger.prototype.fromNumber = Sk.builtin.biginteger.prototype.bnpFromNumber;\nSk.builtin.biginteger.prototype.bitwiseTo = Sk.builtin.biginteger.prototype.bnpBitwiseTo;\nSk.builtin.biginteger.prototype.changeBit = Sk.builtin.biginteger.prototype.bnpChangeBit;\nSk.builtin.biginteger.prototype.addTo = Sk.builtin.biginteger.prototype.bnpAddTo;\nSk.builtin.biginteger.prototype.dMultiply = Sk.builtin.biginteger.prototype.bnpDMultiply;\nSk.builtin.biginteger.prototype.dAddOffset = Sk.builtin.biginteger.prototype.bnpDAddOffset;\nSk.builtin.biginteger.prototype.multiplyLowerTo = Sk.builtin.biginteger.prototype.bnpMultiplyLowerTo;\nSk.builtin.biginteger.prototype.multiplyUpperTo = Sk.builtin.biginteger.prototype.bnpMultiplyUpperTo;\nSk.builtin.biginteger.prototype.modInt = Sk.builtin.biginteger.prototype.bnpModInt;\nSk.builtin.biginteger.prototype.millerRabin = Sk.builtin.biginteger.prototype.bnpMillerRabin;\n\n//public\nSk.builtin.biginteger.prototype.clone = Sk.builtin.biginteger.prototype.bnClone;\nSk.builtin.biginteger.prototype.intValue = Sk.builtin.biginteger.prototype.bnIntValue;\nSk.builtin.biginteger.prototype.byteValue = Sk.builtin.biginteger.prototype.bnByteValue;\nSk.builtin.biginteger.prototype.shortValue = Sk.builtin.biginteger.prototype.bnShortValue;\nSk.builtin.biginteger.prototype.signum = Sk.builtin.biginteger.prototype.bnSigNum;\nSk.builtin.biginteger.prototype.toByteArray = Sk.builtin.biginteger.prototype.bnToByteArray;\nSk.builtin.biginteger.prototype.equals = Sk.builtin.biginteger.prototype.bnEquals;\nSk.builtin.biginteger.prototype.compare = Sk.builtin.biginteger.prototype.compareTo;\nSk.builtin.biginteger.prototype.min = Sk.builtin.biginteger.prototype.bnMin;\nSk.builtin.biginteger.prototype.max = Sk.builtin.biginteger.prototype.bnMax;\nSk.builtin.biginteger.prototype.and = Sk.builtin.biginteger.prototype.bnAnd;\nSk.builtin.biginteger.prototype.or = Sk.builtin.biginteger.prototype.bnOr;\nSk.builtin.biginteger.prototype.xor = Sk.builtin.biginteger.prototype.bnXor;\nSk.builtin.biginteger.prototype.andNot = Sk.builtin.biginteger.prototype.bnAndNot;\nSk.builtin.biginteger.prototype.not = Sk.builtin.biginteger.prototype.bnNot;\nSk.builtin.biginteger.prototype.shiftLeft = Sk.builtin.biginteger.prototype.bnShiftLeft;\nSk.builtin.biginteger.prototype.shiftRight = Sk.builtin.biginteger.prototype.bnShiftRight;\nSk.builtin.biginteger.prototype.getLowestSetBit = Sk.builtin.biginteger.prototype.bnGetLowestSetBit;\nSk.builtin.biginteger.prototype.bitCount = Sk.builtin.biginteger.prototype.bnBitCount;\nSk.builtin.biginteger.prototype.testBit = Sk.builtin.biginteger.prototype.bnTestBit;\nSk.builtin.biginteger.prototype.setBit = Sk.builtin.biginteger.prototype.bnSetBit;\nSk.builtin.biginteger.prototype.clearBit = Sk.builtin.biginteger.prototype.bnClearBit;\nSk.builtin.biginteger.prototype.flipBit = Sk.builtin.biginteger.prototype.bnFlipBit;\nSk.builtin.biginteger.prototype.add = Sk.builtin.biginteger.prototype.bnAdd;\nSk.builtin.biginteger.prototype.subtract = Sk.builtin.biginteger.prototype.bnSubtract;\nSk.builtin.biginteger.prototype.multiply = Sk.builtin.biginteger.prototype.bnMultiply;\nSk.builtin.biginteger.prototype.divide = Sk.builtin.biginteger.prototype.bnDivide;\nSk.builtin.biginteger.prototype.remainder = Sk.builtin.biginteger.prototype.bnRemainder;\nSk.builtin.biginteger.prototype.divideAndRemainder = Sk.builtin.biginteger.prototype.bnDivideAndRemainder;\nSk.builtin.biginteger.prototype.modPow = Sk.builtin.biginteger.prototype.bnModPow;\nSk.builtin.biginteger.prototype.modInverse = Sk.builtin.biginteger.prototype.bnModInverse;\nSk.builtin.biginteger.prototype.pow = Sk.builtin.biginteger.prototype.bnPow;\nSk.builtin.biginteger.prototype.gcd = Sk.builtin.biginteger.prototype.bnGCD;\nSk.builtin.biginteger.prototype.isProbablePrime = Sk.builtin.biginteger.prototype.bnIsProbablePrime;\n//Sk.builtin.biginteger.int2char = int2char;\n\n//Sk.builtin.biginteger interfaces not implemented in jsbn:\n\n//Sk.builtin.biginteger(int signum, byte[] magnitude)\n//double doubleValue()\n//float floatValue()\n//int hashCode()\n//long longValue()\n//static Sk.builtin.biginteger valueOf(long val)\n\n//module.exports = Sk.builtin.biginteger;\n","/* jslint nomen: true, bitwise: true */\n/* global Sk: true */\n\n/**\n * @namespace Sk.builtin\n */\n\n/**\n * @constructor\n * Sk.builtin.int_\n *\n * @description\n * Constructor for Python int. If provided number is greater than integer threshold, will return a Python long instead.\n *\n * type int, all integers are created with this method, it is also used\n * for the builtin int()\n *\n * Takes also implemented `__int__` and `__trunc__` methods for x into account\n * and tries to use `__index__` and/or `__int__` if base is not a number\n *\n * @extends {Sk.builtin.numtype}\n *\n * @param  {!(Object|number)} x    Python object or Javascript number to convert to Python int\n * @param  {!(Object|number|Sk.builtin.none)=} base Optional base, can only be used when x is Sk.builtin.str\n * @return {(Sk.builtin.int_|Sk.builtin.lng)}      Python int (or long, if overflow)\n */\nSk.builtin.int_ = function (x, base) {\n    var val;\n    var func;\n    var ret; // return value\n    var magicName; // name of magic method\n\n    if (!(this instanceof Sk.builtin.int_)) {\n        return new Sk.builtin.int_(x, base);\n    }\n\n\n    if (this instanceof Sk.builtin.bool) {\n        return this;\n    }\n\n    if (x instanceof Sk.builtin.int_ && base === undefined) {\n        this.v = x.v;\n        return this;\n    }\n\n    // if base is not of type int, try calling .__index__\n    if(base !== Sk.builtin.none.none$ && base !== undefined && !Sk.builtin.checkInt(base)) {\n        if (Sk.builtin.checkFloat(base)) {\n            throw new Sk.builtin.TypeError(\"integer argument expected, got \" + Sk.abstr.typeName(base));\n        } else if (base.__index__) {\n            base = Sk.misceval.callsimArray(base.__index__, [base]);\n        } else if(base.__int__) {\n            base = Sk.misceval.callsimArray(base.__int__, [base]);\n        } else {\n            throw new Sk.builtin.AttributeError(Sk.abstr.typeName(base) + \" instance has no attribute '__index__' or '__int__'\");\n        }\n    }\n\n    if (x instanceof Sk.builtin.str) {\n        base = Sk.builtin.asnum$(base);\n        if (base === Sk.builtin.none.none$) {\n            base = 10;\n        }\n\n        val = Sk.str2number(x.v, base, parseInt, function (x) {\n            return -x;\n        }, \"int\");\n\n        if ((val > Sk.builtin.int_.threshold$) || (val < -Sk.builtin.int_.threshold$)) {\n            // Too big for int, convert to long\n            return new Sk.builtin.lng(x, base);\n        }\n\n        this.v = val;\n        return this;\n    }\n\n    if (base !== undefined && base !== Sk.builtin.none.none$) {\n        throw new Sk.builtin.TypeError(\"int() can't convert non-string with explicit base\");\n    }\n\n    if (x === undefined || x === Sk.builtin.none) {\n        x = 0;\n    }\n\n    /**\n     * try calling special methods:\n     *  1. __int__\n     *  2. __trunc__\n     */\n    if(x !== undefined && (x.tp$getattr && (func = x.tp$getattr(Sk.builtin.str.$int_)))) {\n        // calling a method which contains im_self and im_func\n        // causes skulpt to automatically map the im_self as first argument\n        ret = Sk.misceval.callsimArray(func);\n        magicName = \"__int__\";\n    } else if(x !== undefined && x.__int__) {\n        // required for internal types\n        // __int__ method is on prototype\n        ret = Sk.misceval.callsimArray(x.__int__, [x]);\n        magicName = \"__int__\";\n    } else if(x !== undefined && (x.tp$getattr && (func = x.tp$getattr(Sk.builtin.str.$trunc)))) {\n        ret = Sk.misceval.callsimArray(func);\n        magicName = \"__trunc__\";\n    } else if(x !== undefined && x.__trunc__) {\n        ret = Sk.misceval.callsimArray(x.__trunc__, [x]);\n        magicName = \"__trunc__\";\n    }\n\n    // check return type of magic methods\n    if(ret !== undefined && !Sk.builtin.checkInt(ret)) {\n        throw new Sk.builtin.TypeError(magicName + \" returned non-Integral (type \" + Sk.abstr.typeName(ret)+\")\");\n    } else if(ret !== undefined){\n        x = ret; // valid return value, proceed in function\n    }\n\n    // check type even without magic numbers\n    if(!Sk.builtin.checkNumber(x)) {\n        throw new Sk.builtin.TypeError(\"int() argument must be a string or a number, not '\" + Sk.abstr.typeName(x) + \"'\");\n    }\n\n    x = Sk.builtin.asnum$(x);\n    if (x > Sk.builtin.int_.threshold$ || x < -Sk.builtin.int_.threshold$) {\n        return new Sk.builtin.lng(x);\n    }\n    if ((x > -1) && (x < 1)) {\n        x = 0;\n    }\n\n    this.v = parseInt(x, base);\n    return this;\n};\n\nSk.builtin.int_.$shiftconsts = [0.5, 1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096, 8192, 16384, 32768, 65536, 131072, 262144, 524288, 1048576, 2097152, 4194304, 8388608, 16777216, 33554432, 67108864, 134217728, 268435456, 536870912, 1073741824, 2147483648, 4294967296, 8589934592, 17179869184, 34359738368, 68719476736, 137438953472, 274877906944, 549755813888, 1099511627776, 2199023255552, 4398046511104, 8796093022208, 17592186044416, 35184372088832, 70368744177664, 140737488355328, 281474976710656, 562949953421312, 1125899906842624, 2251799813685248, 4503599627370496, 9007199254740992];\n\nSk.abstr.setUpInheritance(\"int\", Sk.builtin.int_, Sk.builtin.numtype);\n\n/* NOTE: See constants used for kwargs in constants.js */\n\nSk.builtin.int_.prototype.nb$int_ = function () {\n    return this;\n};\n\nSk.builtin.int_.prototype.nb$float_ = function() {\n    return new Sk.builtin.float_(this.v);\n};\n\nSk.builtin.int_.prototype.nb$lng = function () {\n    return new Sk.builtin.lng(this.v);\n};\n\n/**\n * Python wrapper of `__trunc__` dunder method.\n *\n * @instance\n */\nSk.builtin.int_.prototype.__trunc__ = new Sk.builtin.func(function(self) {\n    return self;\n});\n\n/**\n * Python wrapper of `__index__` dunder method.\n *\n * @instance\n */\nSk.builtin.int_.prototype.__index__ = new Sk.builtin.func(function(self) {\n    return self;\n});\n\n/**\n * Python wrapper of `__complex__` dunder method.\n *\n * @instance\n */\nSk.builtin.int_.prototype.__complex__ = new Sk.builtin.func(function(self) {\n    return Sk.builtin.NotImplemented.NotImplemented$;\n});\n\n/**\n * Return this instance's Javascript value.\n *\n * Javascript function, returns Javascript object.\n *\n * @return {number} This instance's value.\n */\nSk.builtin.int_.prototype.tp$index = function () {\n    return this.v;\n};\n\n/** @override */\nSk.builtin.int_.prototype.tp$hash = function () {\n    //the hash of all numbers should be an int and since javascript doesn't really\n    //care every number can be an int.\n    return new Sk.builtin.int_(this.v);\n};\n\n/**\n * Threshold to determine when types should be converted to long.\n *\n * Note: be sure to check against threshold in both positive and negative directions.\n *\n * @type {number}\n */\nSk.builtin.int_.threshold$ = Math.pow(2, 53) - 1;\n\n/**\n * Returns a copy of this instance.\n *\n * Javascript function, returns Python object.\n *\n * @return {Sk.builtin.int_} The copy\n */\nSk.builtin.int_.prototype.clone = function () {\n    return new Sk.builtin.int_(this.v);\n};\n\n/** @override */\nSk.builtin.int_.prototype.nb$add = function (other) {\n    var thisAsLong, thisAsFloat;\n    var result;\n\n    if (other instanceof Sk.builtin.int_) {\n        result = this.v + other.v;\n        if (result > Sk.builtin.int_.threshold$ ||\n            result < -Sk.builtin.int_.threshold$) {\n            thisAsLong = new Sk.builtin.lng(this.v);\n            return thisAsLong.nb$add(other);\n        }\n        return new Sk.builtin.int_(result);\n    }\n\n    if (other instanceof Sk.builtin.lng) {\n        thisAsLong = new Sk.builtin.lng(this.v);\n        return thisAsLong.nb$add(other);\n    }\n\n    if (other instanceof Sk.builtin.float_) {\n        thisAsFloat = new Sk.builtin.float_(this.v);\n        return thisAsFloat.nb$add(other);\n    }\n\n    return Sk.builtin.NotImplemented.NotImplemented$;\n};\n\n/** @override */\nSk.builtin.int_.prototype.nb$reflected_add = function (other) {\n    // Should not automatically call this.nb$add, as nb$add may have\n    // been overridden by a subclass\n    return Sk.builtin.int_.prototype.nb$add.call(this, other);\n};\n\n/** @override */\nSk.builtin.int_.prototype.nb$subtract = function (other) {\n    var thisAsLong, thisAsFloat;\n    var result;\n\n    if (other instanceof Sk.builtin.int_) {\n        result = this.v - other.v;\n        if (result > Sk.builtin.int_.threshold$ ||\n            result < -Sk.builtin.int_.threshold$) {\n            thisAsLong = new Sk.builtin.lng(this.v);\n            return thisAsLong.nb$subtract(other);\n        }\n        return new Sk.builtin.int_(result);\n    }\n\n    if (other instanceof Sk.builtin.lng) {\n        thisAsLong = new Sk.builtin.lng(this.v);\n        return thisAsLong.nb$subtract(other);\n    }\n\n    if (other instanceof Sk.builtin.float_) {\n        thisAsFloat = new Sk.builtin.float_(this.v);\n        return thisAsFloat.nb$subtract(other);\n    }\n\n    return Sk.builtin.NotImplemented.NotImplemented$;\n};\n\n/** @override */\nSk.builtin.int_.prototype.nb$reflected_subtract = function (other) {\n    // Should not automatically call this.nb$add, as nb$add may have\n    // been overridden by a subclass\n    var negative_this = this.nb$negative();\n    return Sk.builtin.int_.prototype.nb$add.call(negative_this, other);\n};\n\n/** @override */\nSk.builtin.int_.prototype.nb$multiply = function (other) {\n    var product, thisAsLong, thisAsFloat;\n\n    if (other instanceof Sk.builtin.int_) {\n        product = this.v * other.v;\n\n        if (product > Sk.builtin.int_.threshold$ ||\n            product < -Sk.builtin.int_.threshold$) {\n            thisAsLong = new Sk.builtin.lng(this.v);\n            return thisAsLong.nb$multiply(other);\n        } else {\n            return new Sk.builtin.int_(product);\n        }\n    }\n\n    if (other instanceof Sk.builtin.lng) {\n        thisAsLong = new Sk.builtin.lng(this.v);\n        return thisAsLong.nb$multiply(other);\n    }\n\n    if (other instanceof Sk.builtin.float_) {\n        thisAsFloat = new Sk.builtin.float_(this.v);\n        return thisAsFloat.nb$multiply(other);\n    }\n\n    return Sk.builtin.NotImplemented.NotImplemented$;\n};\n\n/** @override */\nSk.builtin.int_.prototype.nb$reflected_multiply = function (other) {\n    // Should not automatically call this.nb$multiply, as nb$multiply may have\n    // been overridden by a subclass\n    return Sk.builtin.int_.prototype.nb$multiply.call(this, other);\n};\n\n/** @override */\nSk.builtin.int_.prototype.nb$divide = function (other) {\n    var thisAsLong, thisAsFloat;\n    if (Sk.__future__.division) {\n        thisAsFloat = new Sk.builtin.float_(this.v);\n        return thisAsFloat.nb$divide(other);\n    }\n\n    if (other instanceof Sk.builtin.int_) {\n        return this.nb$floor_divide(other);\n    }\n\n    if (other instanceof Sk.builtin.lng) {\n        thisAsLong = new Sk.builtin.lng(this.v);\n        return thisAsLong.nb$divide(other);\n    }\n\n    if (other instanceof Sk.builtin.float_) {\n        thisAsFloat = new Sk.builtin.float_(this.v);\n        return thisAsFloat.nb$divide(other);\n    }\n\n    return Sk.builtin.NotImplemented.NotImplemented$;\n};\n\n/** @override */\nSk.builtin.int_.prototype.nb$reflected_divide = function (other) {\n    return this.nb$reflected_floor_divide(other);\n};\n\n/** @override */\nSk.builtin.int_.prototype.nb$floor_divide = function (other) {\n    var thisAsLong, thisAsFloat;\n\n    if (other instanceof Sk.builtin.int_) {\n\n        if (other.v === 0) {\n            throw new Sk.builtin.ZeroDivisionError(\"integer division or modulo by zero\");\n        }\n\n        return new Sk.builtin.int_(Math.floor(this.v / other.v));\n    }\n\n    if (other instanceof Sk.builtin.lng) {\n        thisAsLong = new Sk.builtin.lng(this.v);\n        return thisAsLong.nb$floor_divide(other);\n    }\n\n    if (other instanceof Sk.builtin.float_) {\n        thisAsFloat = new Sk.builtin.float_(this.v);\n        return thisAsFloat.nb$floor_divide(other);\n    }\n\n    return Sk.builtin.NotImplemented.NotImplemented$;\n};\n\n/** @override */\nSk.builtin.int_.prototype.nb$reflected_floor_divide = function (other) {\n    if (other instanceof Sk.builtin.int_) {\n        return other.nb$divide(this);\n    }\n\n    return Sk.builtin.NotImplemented.NotImplemented$;\n};\n\n/** @override */\nSk.builtin.int_.prototype.nb$remainder = function (other) {\n    var thisAsLong, thisAsFloat;\n    var tmp;\n    var divResult;\n\n    if (other instanceof Sk.builtin.int_) {\n        //  Javacript logic on negatives doesn't work for Python... do this instead\n        divResult = Sk.abstr.numberBinOp(this, other, \"FloorDiv\");\n        tmp = Sk.abstr.numberBinOp(divResult, other, \"Mult\");\n        tmp = Sk.abstr.numberBinOp(this, tmp, \"Sub\");\n        tmp = tmp.v;\n\n        if (other.v < 0 && tmp === 0) {\n            tmp = -0.0; // otherwise the sign gets lost by javascript modulo\n        } else if (tmp === 0 && Infinity/tmp === -Infinity) {\n            tmp = 0.0;\n        }\n\n        return new Sk.builtin.int_(tmp);\n    }\n\n    if (other instanceof Sk.builtin.lng) {\n        thisAsLong = new Sk.builtin.lng(this.v);\n        return thisAsLong.nb$remainder(other);\n    }\n\n    if (other instanceof Sk.builtin.float_) {\n        thisAsFloat = new Sk.builtin.float_(this.v);\n        return thisAsFloat.nb$remainder(other);\n    }\n\n    return Sk.builtin.NotImplemented.NotImplemented$;\n};\n\n/** @override */\nSk.builtin.int_.prototype.nb$reflected_remainder = function (other) {\n    if (other instanceof Sk.builtin.int_) {\n        return other.nb$remainder(this);\n    }\n\n    return Sk.builtin.NotImplemented.NotImplemented$;\n};\n\n/** @override */\nSk.builtin.int_.prototype.nb$divmod = function (other) {\n    var thisAsLong, thisAsFloat;\n\n    if (other instanceof Sk.builtin.int_) {\n        return new Sk.builtin.tuple([\n            this.nb$floor_divide(other),\n            this.nb$remainder(other)\n        ]);\n    }\n\n    if (other instanceof Sk.builtin.lng) {\n        thisAsLong = new Sk.builtin.lng(this.v);\n        return thisAsLong.nb$divmod(other);\n    }\n\n    if (other instanceof Sk.builtin.float_) {\n        thisAsFloat = new Sk.builtin.float_(this.v);\n        return thisAsFloat.nb$divmod(other);\n    }\n\n    return Sk.builtin.NotImplemented.NotImplemented$;\n};\n\n/** @override */\nSk.builtin.int_.prototype.nb$reflected_divmod = function (other) {\n    if (other instanceof Sk.builtin.int_) {\n        return new Sk.builtin.tuple([\n            other.nb$floor_divide(this),\n            other.nb$remainder(this)\n        ]);\n    }\n\n    return Sk.builtin.NotImplemented.NotImplemented$;\n};\n\n/** @override */\nSk.builtin.int_.prototype.nb$power = function (other, mod) {\n    var power, ret, thisAsLong, thisAsFloat;\n\n    if (other instanceof Sk.builtin.int_ && (mod === undefined || mod instanceof Sk.builtin.int_)) {\n\n        power = Math.pow(this.v, other.v);\n\n        if (power > Sk.builtin.int_.threshold$ ||\n            power < -Sk.builtin.int_.threshold$) {\n            thisAsLong = new Sk.builtin.lng(this.v);\n            ret = thisAsLong.nb$power(other, mod);\n        } else if (other.v < 0) {\n            ret = new Sk.builtin.float_(power);\n        } else {\n            ret = new Sk.builtin.int_(power);\n        }\n\n        if (mod !== undefined) {\n            if (other.v < 0) {\n                throw new Sk.builtin.TypeError(\"pow() 2nd argument cannot be negative when 3rd argument specified\");\n            }\n\n            return ret.nb$remainder(mod);\n        } else {\n            return ret;\n        }\n    }\n\n    if (other instanceof Sk.builtin.lng) {\n        thisAsLong = new Sk.builtin.lng(this.v);\n        return thisAsLong.nb$power(other);\n    }\n\n    if (other instanceof Sk.builtin.float_) {\n        thisAsFloat = new Sk.builtin.float_(this.v);\n        return thisAsFloat.nb$power(other);\n    }\n\n    return Sk.builtin.NotImplemented.NotImplemented$;\n};\n\n/** @override */\nSk.builtin.int_.prototype.nb$reflected_power = function (other, mod) {\n    if (other instanceof Sk.builtin.int_) {\n        return other.nb$power(this, mod);\n    }\n\n    return Sk.builtin.NotImplemented.NotImplemented$;\n};\n\n/** @override */\nSk.builtin.int_.prototype.nb$abs = function () {\n    return new Sk.builtin.int_(Math.abs(this.v));\n};\n\n/**\n * Compute the bitwise AND of this instance and a Python object (i.e. this & other).\n *\n * Returns NotImplemented if bitwise AND operation between int and other type is unsupported.\n *\n * Javscript function, returns Python object.\n *\n * @param  {!Sk.builtin.object} other The Python object to AND with this one\n * @return {(Sk.builtin.int_|Sk.builtin.lng|Sk.builtin.NotImplemented)} The result of the conjunction\n */\nSk.builtin.int_.prototype.nb$and = function (other) {\n    var thisAsLong, thisAsFloat;\n\n    if (other instanceof Sk.builtin.int_) {\n        var tmp;\n        other = Sk.builtin.asnum$(other);\n        tmp = this.v & other;\n        if ((tmp !== undefined) && (tmp < 0)) {\n            tmp = tmp + 4294967296; // convert back to unsigned\n        }\n\n        if (tmp !== undefined) {\n            return new Sk.builtin.int_(tmp);\n        }\n    }\n\n    if (other instanceof Sk.builtin.lng) {\n        thisAsLong = new Sk.builtin.lng(this.v);\n        return thisAsLong.nb$and(other);\n    }\n\n    return Sk.builtin.NotImplemented.NotImplemented$;\n};\n\nSk.builtin.int_.prototype.nb$reflected_and = Sk.builtin.int_.prototype.nb$and;\n\n/**\n * Compute the bitwise OR of this instance and a Python object (i.e. this | other).\n *\n * Returns NotImplemented if bitwise OR operation between int and other type is unsupported.\n *\n * Javscript function, returns Python object.\n *\n * @param  {!Sk.builtin.object} other The Python object to OR with this one\n * @return {(Sk.builtin.int_|Sk.builtin.lng|Sk.builtin.NotImplemented)} The result of the disjunction\n */\nSk.builtin.int_.prototype.nb$or = function (other) {\n    var thisAsLong;\n\n    if (other instanceof Sk.builtin.int_) {\n        var tmp;\n        other = Sk.builtin.asnum$(other);\n        tmp = this.v | other;\n        if ((tmp !== undefined) && (tmp < 0)) {\n            tmp = tmp + 4294967296; // convert back to unsigned\n        }\n\n        if (tmp !== undefined) {\n            return new Sk.builtin.int_(tmp);\n        }\n    }\n\n    if (other instanceof Sk.builtin.lng) {\n        thisAsLong = new Sk.builtin.lng(this.v);\n        return thisAsLong.nb$and(other);\n    }\n\n    return Sk.builtin.NotImplemented.NotImplemented$;\n};\n\nSk.builtin.int_.prototype.nb$reflected_or = Sk.builtin.int_.prototype.nb$or;\n\n/**\n * Compute the bitwise XOR of this instance and a Python object (i.e. this ^ other).\n *\n * Returns NotImplemented if bitwise XOR operation between int and other type is unsupported.\n *\n * Javscript function, returns Python object.\n *\n * @param  {!Sk.builtin.object} other The Python object to XOR with this one\n * @return {(Sk.builtin.int_|Sk.builtin.lng|Sk.builtin.NotImplemented)} The result of the exclusive disjunction\n */\nSk.builtin.int_.prototype.nb$xor = function (other) {\n    var thisAsLong;\n\n    if (other instanceof Sk.builtin.int_) {\n        var tmp;\n        other = Sk.builtin.asnum$(other);\n        tmp = this.v ^ other;\n        if ((tmp !== undefined) && (tmp < 0)) {\n            tmp = tmp + 4294967296; // convert back to unsigned\n        }\n\n        if (tmp !== undefined) {\n            return new Sk.builtin.int_(tmp);\n        }\n    }\n\n    if (other instanceof Sk.builtin.lng) {\n        thisAsLong = new Sk.builtin.lng(this.v);\n        return thisAsLong.nb$xor(other);\n    }\n\n    return Sk.builtin.NotImplemented.NotImplemented$;\n};\n\nSk.builtin.int_.prototype.nb$reflected_xor = Sk.builtin.int_.prototype.nb$xor;\n\n/**\n * Compute the bitwise left shift of this instance by a Python object (i.e. this << other).\n *\n * Returns NotImplemented if bitwise left shift operation between int and other type is unsupported.\n *\n * Javscript function, returns Python object.\n *\n * @param  {!Sk.builtin.object} other The Python object by which to left shift\n * @return {(Sk.builtin.int_|Sk.builtin.lng|Sk.builtin.NotImplemented)} The result of the left shift\n */\nSk.builtin.int_.prototype.nb$lshift = function (other) {\n    var thisAsLong;\n\n    if (this.v === 0) {\n        return this;\n    }\n\n    if (other instanceof Sk.builtin.int_) {\n        var tmp;\n        var shift = Sk.builtin.asnum$(other);\n\n        if (shift !== undefined) {\n            if (shift < 0) {\n                throw new Sk.builtin.ValueError(\"negative shift count\");\n            }\n\n            if (shift > 53) {\n                return new Sk.builtin.lng(this.v).nb$lshift(new Sk.builtin.int_(shift));\n            }\n\n            tmp = this.v * 2 * Sk.builtin.int_.$shiftconsts[shift];\n            if (tmp > Sk.builtin.int_.threshold$ || tmp < -Sk.builtin.int_.threshold$) {\n                // Fail, recompute with longs\n                return new Sk.builtin.lng(tmp);\n            }\n        }\n\n        if (tmp !== undefined) {\n            tmp = /** @type {number} */ (tmp);\n            return new Sk.builtin.int_(tmp);\n        }\n    }\n\n    if (other instanceof Sk.builtin.lng) {\n        thisAsLong = new Sk.builtin.lng(this.v);\n        return thisAsLong.nb$lshift(other);\n    }\n\n    return Sk.builtin.NotImplemented.NotImplemented$;\n};\n\nSk.builtin.int_.prototype.nb$reflected_lshift = function (other) {\n    if (other instanceof Sk.builtin.int_) {\n        return other.nb$lshift(this);\n    }\n\n    return Sk.builtin.NotImplemented.NotImplemented$;\n};\n\n/**\n * Compute the bitwise right shift of this instance by a Python object (i.e. this >> other).\n *\n * Returns NotImplemented if bitwise right shift operation between int and other type is unsupported.\n *\n * Javscript function, returns Python object.\n *\n * @param  {!Sk.builtin.object} other The Python object by which to right shift\n * @return {(Sk.builtin.int_|Sk.builtin.lng|Sk.builtin.NotImplemented)} The result of the right shift\n */\nSk.builtin.int_.prototype.nb$rshift = function (other) {\n    var thisAsLong;\n\n    if (other instanceof Sk.builtin.int_) {\n        var tmp;\n        var shift = Sk.builtin.asnum$(other);\n\n        if (shift !== undefined) {\n            if (shift < 0) {\n                throw new Sk.builtin.ValueError(\"negative shift count\");\n            }\n            tmp = this.v >> shift;\n            if ((this.v > 0) && (tmp < 0)) {\n                // Fix incorrect sign extension\n                tmp = tmp & (Math.pow(2, 32 - shift) - 1);\n            }\n        }\n\n        if (tmp !== undefined) {\n            tmp = /** @type {number} */ (tmp);\n            return new Sk.builtin.int_(tmp);\n        }\n    }\n\n    if (other instanceof Sk.builtin.lng) {\n        thisAsLong = new Sk.builtin.lng(this.v);\n        return thisAsLong.nb$rshift(other);\n    }\n\n    return Sk.builtin.NotImplemented.NotImplemented$;\n};\n\nSk.builtin.int_.prototype.nb$reflected_rshift = function (other) {\n    if (other instanceof Sk.builtin.int_) {\n        return other.nb$rshift(this);\n    }\n\n    return Sk.builtin.NotImplemented.NotImplemented$;\n};\n\n/**\n * Compute the bitwise inverse of this instance (i.e. ~this).\n *\n * Javscript function, returns Python object.\n *\n * @return {Sk.builtin.int_} The result of the inversion\n */\nSk.builtin.int_.prototype.nb$invert = function () {\n    return new Sk.builtin.int_(~this.v);\n};\n\n/** @override */\nSk.builtin.int_.prototype.nb$inplace_add = Sk.builtin.int_.prototype.nb$add;\n\n/** @override */\nSk.builtin.int_.prototype.nb$inplace_subtract = Sk.builtin.int_.prototype.nb$subtract;\n\n/** @override */\nSk.builtin.int_.prototype.nb$inplace_multiply = Sk.builtin.int_.prototype.nb$multiply;\n\n/** @override */\nSk.builtin.int_.prototype.nb$inplace_divide = Sk.builtin.int_.prototype.nb$divide;\n\n/** @override */\nSk.builtin.int_.prototype.nb$inplace_remainder = Sk.builtin.int_.prototype.nb$remainder;\n\n/** @override */\nSk.builtin.int_.prototype.nb$inplace_floor_divide = Sk.builtin.int_.prototype.nb$floor_divide;\n\n/** @override */\nSk.builtin.int_.prototype.nb$inplace_power = Sk.builtin.int_.prototype.nb$power;\n\n/**\n * @function\n * @name  nb$inplace_and\n * @memberOf Sk.builtin.int_.prototype\n * @description\n * Compute the bitwise AND of this instance and a Python object (i.e. this &= other).\n *\n * Returns NotImplemented if inplace bitwise AND operation between int and other type is unsupported.\n *\n * Javscript function, returns Python object.\n *\n * @param  {!Sk.builtin.object} other The Python object to AND with this one\n * @return {(Sk.builtin.int_|Sk.builtin.lng|Sk.builtin.NotImplemented)} The result of the conjunction\n */\nSk.builtin.int_.prototype.nb$inplace_and = Sk.builtin.int_.prototype.nb$and;\n\n/**\n * @function\n * @name  nb$inplace_or\n * @memberOf Sk.builtin.int_.prototype\n * @description\n * Compute the bitwise OR of this instance and a Python object (i.e. this |= other).\n *\n * Returns NotImplemented if inplace bitwise OR operation between int and other type is unsupported.\n *\n * Javscript function, returns Python object.\n *\n * @param  {!Sk.builtin.object} other The Python object to OR with this one\n * @return {(Sk.builtin.int_|Sk.builtin.lng|Sk.builtin.NotImplemented)} The result of the disjunction\n */\nSk.builtin.int_.prototype.nb$inplace_or = Sk.builtin.int_.prototype.nb$or;\n\n/**\n * @function\n * @name  nb$inplace_xor\n * @memberOf Sk.builtin.int_.prototype\n * @description\n * Compute the bitwise XOR of this instance and a Python object (i.e. this ^= other).\n *\n * Returns NotImplemented if inplace bitwise XOR operation between int and other type is unsupported.\n *\n * Javscript function, returns Python object.\n *\n * @param  {!Sk.builtin.object} other The Python object to XOR with this one\n * @return {(Sk.builtin.int_|Sk.builtin.lng|Sk.builtin.NotImplemented)} The result of the exclusive disjunction\n */\nSk.builtin.int_.prototype.nb$inplace_xor = Sk.builtin.int_.prototype.nb$xor;\n\n/**\n * @function\n * @name  nb$inplace_lshift\n * @memberOf Sk.builtin.int_.prototype\n * @description\n * Compute the bitwise left shift of this instance by a Python object (i.e. this <<= other).\n *\n * Returns NotImplemented if inplace bitwise left shift operation between int and other type is unsupported.\n *\n * Javscript function, returns Python object.\n *\n * @param  {!Sk.builtin.object} other The Python object by which to left shift\n * @return {(Sk.builtin.int_|Sk.builtin.lng|Sk.builtin.NotImplemented)} The result of the left shift\n */\nSk.builtin.int_.prototype.nb$inplace_lshift = Sk.builtin.int_.prototype.nb$lshift;\n\n/**\n * @function\n * @name  nb$inplace_rshift\n * @memberOf Sk.builtin.int_.prototype\n * @description\n * Compute the bitwise right shift of this instance by a Python object (i.e. this >>= other).\n *\n * Returns NotImplemented if inplace bitwise right shift operation between int and other type is unsupported.\n *\n * Javscript function, returns Python object.\n *\n * @param  {!Sk.builtin.object} other The Python object by which to right shift\n * @return {(Sk.builtin.int_|Sk.builtin.lng|Sk.builtin.NotImplemented)} The result of the right shift\n */\nSk.builtin.int_.prototype.nb$inplace_rshift = Sk.builtin.int_.prototype.nb$rshift;\n\n/**\n * @override\n *\n * @return {Sk.builtin.int_} A copy of this instance with the value negated.\n */\nSk.builtin.int_.prototype.nb$negative = function () {\n    return new Sk.builtin.int_(-this.v);\n};\n\n/** @override */\nSk.builtin.int_.prototype.nb$positive = function () {\n    return this.clone();\n};\n\n/** @override */\nSk.builtin.int_.prototype.nb$nonzero = function () {\n    return this.v !== 0;\n};\n\n/** @override */\nSk.builtin.int_.prototype.nb$isnegative = function () {\n    return this.v < 0;\n};\n\n/** @override */\nSk.builtin.int_.prototype.nb$ispositive = function () {\n    return this.v >= 0;\n};\n\n/**\n * Compare this instance's value to another Python object's value.\n *\n * Returns NotImplemented if comparison between int and other type is unsupported.\n *\n * Javscript function, returns Javascript object or Sk.builtin.NotImplemented.\n *\n * @return {(number|Sk.builtin.NotImplemented)} negative if this < other, zero if this == other, positive if this > other\n */\nSk.builtin.int_.prototype.numberCompare = function (other) {\n    if (other instanceof Sk.builtin.int_) {\n        return this.v - other.v;\n    }\n\n    if (other instanceof Sk.builtin.lng) {\n        return -other.longCompare(this);\n    }\n\n    if (other instanceof Sk.builtin.float_) {\n        return -other.numberCompare(this);\n    }\n\n    return Sk.builtin.NotImplemented.NotImplemented$;\n};\n\n// Despite what jshint may want us to do, these two  functions need to remain\n// as == and !=  Unless you modify the logic of numberCompare do not change\n// these.\n\n/** @override */\nSk.builtin.int_.prototype.ob$eq = function (other) {\n    if (other instanceof Sk.builtin.int_ || other instanceof Sk.builtin.lng ||\n        other instanceof Sk.builtin.float_) {\n        return new Sk.builtin.bool(this.numberCompare(other) == 0); //jshint ignore:line\n    } else if (other instanceof Sk.builtin.none) {\n        return Sk.builtin.bool.false$;\n    } else {\n        return Sk.builtin.NotImplemented.NotImplemented$;\n    }\n};\n\n/** @override */\nSk.builtin.int_.prototype.ob$ne = function (other) {\n    if (other instanceof Sk.builtin.int_ || other instanceof Sk.builtin.lng ||\n        other instanceof Sk.builtin.float_) {\n        return new Sk.builtin.bool(this.numberCompare(other) != 0); //jshint ignore:line\n    } else if (other instanceof Sk.builtin.none) {\n        return Sk.builtin.bool.true$;\n    } else {\n        return Sk.builtin.NotImplemented.NotImplemented$;\n    }\n};\n\n/** @override */\nSk.builtin.int_.prototype.ob$lt = function (other) {\n    if (other instanceof Sk.builtin.int_ || other instanceof Sk.builtin.lng ||\n        other instanceof Sk.builtin.float_) {\n        return new Sk.builtin.bool(this.numberCompare(other) < 0);\n    } else {\n        return Sk.builtin.NotImplemented.NotImplemented$;\n    }\n};\n\n/** @override */\nSk.builtin.int_.prototype.ob$le = function (other) {\n    if (other instanceof Sk.builtin.int_ || other instanceof Sk.builtin.lng ||\n        other instanceof Sk.builtin.float_) {\n        return new Sk.builtin.bool(this.numberCompare(other) <= 0);\n    } else {\n        return Sk.builtin.NotImplemented.NotImplemented$;\n    }\n};\n\n/** @override */\nSk.builtin.int_.prototype.ob$gt = function (other) {\n    if (other instanceof Sk.builtin.int_ || other instanceof Sk.builtin.lng ||\n        other instanceof Sk.builtin.float_) {\n        return new Sk.builtin.bool(this.numberCompare(other) > 0);\n    } else {\n        return Sk.builtin.NotImplemented.NotImplemented$;\n    }\n};\n\n/** @override */\nSk.builtin.int_.prototype.ob$ge = function (other) {\n    if (other instanceof Sk.builtin.int_ || other instanceof Sk.builtin.lng ||\n        other instanceof Sk.builtin.float_) {\n        return new Sk.builtin.bool(this.numberCompare(other) >= 0);\n    } else {\n        return Sk.builtin.NotImplemented.NotImplemented$;\n    }\n};\n\n/**\n * Round this instance to a given number of digits, or zero if omitted.\n *\n * Implements `__round__` dunder method.\n *\n * Javascript function, returns Python object.\n *\n * @param  {Sk.builtin.int_} self This instance.\n * @param  {Object|number=} ndigits The number of digits after the decimal point to which to round.\n * @return {Sk.builtin.int_} The rounded integer.\n */\nSk.builtin.int_.prototype.round$ = function (self, ndigits) {\n    Sk.builtin.pyCheckArgsLen(\"__round__\", arguments.length, 1, 2);\n\n    var result, multiplier, number, num10, rounded, bankRound, ndigs;\n\n    if ((ndigits !== undefined) && !Sk.misceval.isIndex(ndigits)) {\n        throw new Sk.builtin.TypeError(\"'\" + Sk.abstr.typeName(ndigits) + \"' object cannot be interpreted as an index\");\n    }\n\n    number = Sk.builtin.asnum$(self);\n    if (ndigits === undefined) {\n        ndigs = 0;\n    } else {\n        ndigs = Sk.misceval.asIndex(ndigits);\n    }\n\n    if (Sk.__future__.bankers_rounding) {\n        num10 = number * Math.pow(10, ndigs);\n        rounded = Math.round(num10);\n        bankRound = (((((num10>0)?num10:(-num10))%1)===0.5)?(((0===(rounded%2)))?rounded:(rounded-1)):rounded);\n        result = bankRound / Math.pow(10, ndigs);\n        return new Sk.builtin.int_(result);\n    } else {\n        multiplier = Math.pow(10, ndigs);\n        result = Math.round(number * multiplier) / multiplier;\n\n        return new Sk.builtin.int_(result);\n    }\n};\n\nSk.builtin.int_.prototype.__format__= function (obj, format_spec) {\n    var formatstr;\n    Sk.builtin.pyCheckArgsLen(\"__format__\", arguments.length, 2, 2);\n\n    if (!Sk.builtin.checkString(format_spec)) {\n        if (Sk.__future__.exceptions) {\n            throw new Sk.builtin.TypeError(\"format() argument 2 must be str, not \" + Sk.abstr.typeName(format_spec));\n        } else {\n            throw new Sk.builtin.TypeError(\"format expects arg 2 to be string or unicode, not \" + Sk.abstr.typeName(format_spec));\n        }\n    } else {\n        formatstr = Sk.ffi.remapToJs(format_spec);\n        if (formatstr !== \"\") {\n            throw new Sk.builtin.NotImplementedError(\"format spec is not yet implemented\");\n        }\n    }\n\n    return new Sk.builtin.str(obj);\n};\n\nSk.builtin.int_.prototype.conjugate = new Sk.builtin.func(function (self) {\n    return new Sk.builtin.int_(self.v);\n});\n\n/** @override */\nSk.builtin.int_.prototype[\"$r\"] = function () {\n    return new Sk.builtin.str(this.str$(10, true));\n};\n\n/**\n * Return the string representation of this instance.\n *\n * Javascript function, returns Python object.\n *\n * @return {Sk.builtin.str} The Python string representation of this instance.\n */\nSk.builtin.int_.prototype.tp$str = function () {\n    return new Sk.builtin.str(this.str$(10, true));\n};\n\n/**\n * Convert this instance's value to a Javascript string.\n *\n * Javascript function, returns Javascript object.\n *\n * @param {number} base The base of the value.\n * @param {boolean} sign true if the value should be signed, false otherwise.\n * @return {string} The Javascript string representation of this instance.\n */\nSk.builtin.int_.prototype.str$ = function (base, sign) {\n    var tmp;\n    var work;\n\n    if (sign === undefined) {\n        sign = true;\n    }\n\n    work = sign ? this.v : Math.abs(this.v);\n\n    if (base === undefined || base === 10) {\n        tmp = work.toString();\n    } else {\n        tmp = work.toString(base);\n    }\n\n    return tmp;\n};\n\n/**\n * Takes a JavaScript string and returns a number using the parser and negater\n *  functions (for int/long right now)\n * @param  {string} s       Javascript string to convert to a number.\n * @param  {(number)} base    The base of the number.\n * @param  {function(*, (number|undefined)): number} parser  Function which should take\n *  a string that is a postive number which only contains characters that are\n *  valid in the given base and a base and return a number.\n * @param  {function((number|Sk.builtin.biginteger)): number} negater Function which should take a\n *  number and return its negation\n * @param  {string} fname   The name of the calling function, to be used in error messages\n * @return {number}         The number equivalent of the string in the given base\n */\nSk.str2number = function (s, base, parser, negater, fname) {\n    var origs = s,\n        neg = false,\n        i,\n        ch,\n        val;\n\n    // strip whitespace from ends\n    // s = s.trim();\n    s = s.replace(/^\\s+|\\s+$/g, \"\");\n\n    // check for minus sign\n    if (s.charAt(0) === \"-\") {\n        neg = true;\n        s = s.substring(1);\n    }\n\n    // check for plus sign\n    if (s.charAt(0) === \"+\") {\n        s = s.substring(1);\n    }\n\n    if (base === null || base === undefined) {\n        base = 10;\n    } // default radix is 10, not dwim\n\n    if (base < 2 || base > 36) {\n        if (base !== 0) {\n            throw new Sk.builtin.ValueError(fname + \"() base must be >= 2 and <= 36\");\n        }\n    }\n\n    if (s.substring(0, 2).toLowerCase() === \"0x\") {\n        if (base === 16 || base === 0) {\n            s = s.substring(2);\n            base = 16;\n        } else if (base < 34) {\n            throw new Sk.builtin.ValueError(\"invalid literal for \" + fname + \"() with base \" + base + \": '\" + origs + \"'\");\n        }\n    } else if (s.substring(0, 2).toLowerCase() === \"0b\") {\n        if (base === 2 || base === 0) {\n            s = s.substring(2);\n            base = 2;\n        } else if (base < 12) {\n            throw new Sk.builtin.ValueError(\"invalid literal for \" + fname + \"() with base \" + base + \": '\" + origs + \"'\");\n        }\n    } else if (s.substring(0, 2).toLowerCase() === \"0o\") {\n        if (base === 8 || base === 0) {\n            s = s.substring(2);\n            base = 8;\n        } else if (base < 25) {\n            throw new Sk.builtin.ValueError(\"invalid literal for \" + fname + \"() with base \" + base + \": '\" + origs + \"'\");\n        }\n    } else if (s.charAt(0) === \"0\") {\n        if (s === \"0\") {\n            return 0;\n        }\n        if (base === 8 || base === 0) {\n            base = 8;\n        }\n    }\n\n    if (base === 0) {\n        base = 10;\n    }\n\n    if (s.length === 0) {\n        throw new Sk.builtin.ValueError(\"invalid literal for \" + fname + \"() with base \" + base + \": '\" + origs + \"'\");\n    }\n\n    // check all characters are valid\n    for (i = 0; i < s.length; i = i + 1) {\n        ch = s.charCodeAt(i);\n        val = base;\n        if ((ch >= 48) && (ch <= 57)) {\n            // 0-9\n            val = ch - 48;\n        } else if ((ch >= 65) && (ch <= 90)) {\n            // A-Z\n            val = ch - 65 + 10;\n        } else if ((ch >= 97) && (ch <= 122)) {\n            // a-z\n            val = ch - 97 + 10;\n        }\n\n        if (val >= base) {\n            throw new Sk.builtin.ValueError(\"invalid literal for \" + fname + \"() with base \" + base + \": '\" + origs + \"'\");\n        }\n    }\n\n    // parse number\n    val = parser(s, base);\n    if (neg) {\n        val = negater(val);\n    }\n    return val;\n};\n\nSk.exportSymbol(\"Sk.builtin.int_\", Sk.builtin.int_);\n","/**\n * @constructor\n * Sk.builtin.bool\n *\n * @description\n * Constructor for Python bool. Also used for builtin bool() function.\n *\n * Where possible, do not create a new instance but use the constants \n * Sk.builtin.bool.true$ or Sk.builtin.bool.false$. These are defined in src/constant.js\n *\n * @extends {Sk.builtin.object}\n * \n * @param  {(Object|number|boolean)} x Value to evaluate as true or false\n * @return {Sk.builtin.bool} Sk.builtin.bool.true$ if x is true, Sk.builtin.bool.false$ otherwise\n */\nSk.builtin.bool = function (x) {\n    Sk.builtin.pyCheckArgsLen(\"bool\", arguments.length, 1);\n    if (Sk.misceval.isTrue(x)) {\n        return Sk.builtin.bool.true$;\n    } else {\n        return Sk.builtin.bool.false$;\n    }\n};\n\nSk.abstr.setUpInheritance(\"bool\", Sk.builtin.bool, Sk.builtin.int_);\n\nSk.builtin.bool.prototype[\"$r\"] = function () {\n    if (this.v) {\n        return new Sk.builtin.str(\"True\");\n    }\n    return new Sk.builtin.str(\"False\");\n};\n\nSk.builtin.bool.prototype.tp$hash = function () {\n    return new Sk.builtin.int_(this.v);\n};\n\nSk.builtin.bool.prototype.__int__ = new Sk.builtin.func(function(self) {\n    var v = Sk.builtin.asnum$(self);\n\n    return new Sk.builtin.int_(v);\n});\n\nSk.builtin.bool.prototype.__float__ = new Sk.builtin.func(function(self) {\n    return new Sk.builtin.float_(Sk.ffi.remapToJs(self));\n});\n\nSk.exportSymbol(\"Sk.builtin.bool\", Sk.builtin.bool);\n","/**\n * @namespace Sk.builtin\n */\n\n/**\n * @constructor\n * Sk.builtin.float_\n *\n * @description\n * Constructor for Python float. Also used for builtin float().\n *\n * @extends {Sk.builtin.numtype}\n *\n * @param {!(Object|number|string)} x Object or number to convert to Python float.\n * @return {Sk.builtin.float_} Python float\n */\nSk.builtin.float_ = function (x) {\n    var tmp;\n    if (x === undefined) {\n        return new Sk.builtin.float_(0.0);\n    }\n\n    if (!(this instanceof Sk.builtin.float_)) {\n        return new Sk.builtin.float_(x);\n    }\n\n\n    if (x instanceof Sk.builtin.str) {\n        return Sk.builtin._str_to_float(x.v);\n    }\n\n    // Floats are just numbers\n    if (typeof x === \"number\" || x instanceof Sk.builtin.int_ || x instanceof Sk.builtin.lng || x instanceof Sk.builtin.float_) {\n        tmp = Sk.builtin.asnum$(x);\n        if (typeof tmp === \"string\") {\n            return Sk.builtin._str_to_float(tmp);\n        }\n        this.v = tmp;\n        return this;\n    }\n\n    // Convert booleans\n    if (x instanceof Sk.builtin.bool) {\n        this.v = Sk.builtin.asnum$(x);\n        return this;\n    }\n\n    // this is a special internal case\n    if(typeof x === \"boolean\") {\n        this.v = x ? 1.0 : 0.0;\n        return this;\n    }\n\n    if (typeof x === \"string\") {\n        this.v = parseFloat(x);\n        return this;\n    }\n\n    // try calling __float__\n    var special = Sk.abstr.lookupSpecial(x, Sk.builtin.str.$float_);\n    if (special != null) {\n        // method on builtin, provide this arg\n        return Sk.misceval.callsimArray(special, [x]);\n    }\n\n    throw new Sk.builtin.TypeError(\"float() argument must be a string or a number\");\n};\n\nSk.abstr.setUpInheritance(\"float\", Sk.builtin.float_, Sk.builtin.numtype);\n\nSk.builtin._str_to_float = function (str) {\n    var tmp;\n\n    if (str.match(/^-inf$/i)) {\n        tmp = -Infinity;\n    } else if (str.match(/^[+]?inf$/i)) {\n        tmp = Infinity;\n    } else if (str.match(/^[-+]?nan$/i)) {\n        tmp = NaN;\n    } else if (!isNaN(str)) {\n        tmp = parseFloat(str);\n    } else {\n        throw new Sk.builtin.ValueError(\"float: Argument: \" + str + \" is not number\");\n    }\n    return new Sk.builtin.float_(tmp);\n};\n\nSk.builtin.float_.prototype.nb$int_ = function () {\n    var v = this.v;\n\n    if (v < 0) {\n        v = Math.ceil(v);\n    } else {\n        v = Math.floor(v);\n    }\n\n    // this should take care of int/long fitting\n    return new Sk.builtin.int_(v);\n};\n\nSk.builtin.float_.prototype.nb$float_ = function() {\n    return this;\n};\n\nSk.builtin.float_.prototype.nb$lng = function () {\n    return new Sk.builtin.lng(this.v);\n};\n\n/**\n * Checks for float subtypes, though skulpt does not allow to\n * extend them for now.\n *\n * Javascript function, returns Javascript object.\n * @param {Object} op The object to check as subtype.\n * @return {boolean} true if op is a subtype of Sk.builtin.float_, false otherwise\n */\nSk.builtin.float_.PyFloat_Check = function (op) {\n    if (op === undefined) {\n        return false;\n    }\n\n    // this is a little bit hacky\n    // ToDo: subclassable builtins do not require this\n    if (Sk.builtin.checkNumber(op)) {\n        return true;\n    }\n\n    if (Sk.builtin.checkFloat(op)) {\n        return true;\n    }\n\n    if (Sk.builtin.issubclass(op.ob$type, Sk.builtin.float_)) {\n        return true;\n    }\n\n    return false;\n};\n\n/**\n * Checks if ob is a Python float.\n *\n * This method is just a wrapper, but uses the correct cpython API name.\n *\n * Javascript function, returns Javascript object.\n * @param {Object} op The object to check.\n * @return {boolean} true if op is an instance of Sk.builtin.float_, false otherwise\n */\nSk.builtin.float_.PyFloat_Check_Exact = function (op) {\n    return Sk.builtin.checkFloat(op);\n};\n\nSk.builtin.float_.PyFloat_AsDouble = function (op) {\n    var f; // nb_float;\n    var fo; // PyFloatObject *fo;\n    var val;\n\n    // it is a subclass or direct float\n    if (op && Sk.builtin.float_.PyFloat_Check(op)) {\n        return Sk.ffi.remapToJs(op);\n    }\n\n    if (op == null) {\n        throw new Error(\"bad argument for internal PyFloat_AsDouble function\");\n    }\n\n    // check if special method exists (nb_float is not implemented in skulpt, hence we use __float__)\n    f = Sk.builtin.type.typeLookup(op.ob$type, Sk.builtin.str.$float_);\n    if (f == null) {\n        throw new Sk.builtin.TypeError(\"a float is required\");\n    }\n\n    // call internal float method\n    fo = Sk.misceval.callsimArray(f, [op]);\n\n    // return value of __float__ must be a python float\n    if (!Sk.builtin.float_.PyFloat_Check(fo)) {\n        throw new Sk.builtin.TypeError(\"nb_float should return float object\");\n    }\n\n    val = Sk.ffi.remapToJs(fo);\n\n    return val;\n};\n\n/**\n * Return this instance's Javascript value.\n *\n * Javascript function, returns Javascript object.\n *\n * @return {number} This instance's value.\n */\nSk.builtin.float_.prototype.tp$index = function () {\n    return this.v;\n};\n\n/** @override */\nSk.builtin.float_.prototype.tp$hash = function () {\n    //the hash of all numbers should be an int and since javascript doesn't really\n    //care every number can be an int.\n    return this.nb$int_();\n};\n\n\n/**\n * Returns a copy of this instance.\n *\n * Javascript function, returns Python object.\n *\n * @return {Sk.builtin.float_} The copy\n */\nSk.builtin.float_.prototype.clone = function () {\n    return new Sk.builtin.float_(this.v);\n};\n\n/**\n * Returns this instance's value as a string formatted using fixed-point notation.\n *\n * Javascript function, returns Javascript object.\n *\n * @param  {Object|number} x The numer of digits to appear after the decimal point.\n * @return {string}   The string representation of this instance's value.\n */\nSk.builtin.float_.prototype.toFixed = function (x) {\n    x = Sk.builtin.asnum$(x);\n    return this.v.toFixed(x);\n};\n\n/** @override */\nSk.builtin.float_.prototype.nb$add = function (other) {\n    if (other instanceof Sk.builtin.int_ || other instanceof Sk.builtin.float_) {\n        return new Sk.builtin.float_(this.v + other.v);\n    } else if (other instanceof Sk.builtin.lng) {\n        return new Sk.builtin.float_(this.v + parseFloat(other.str$(10, true)));\n    }\n\n    return Sk.builtin.NotImplemented.NotImplemented$;\n};\n\n/** @override */\nSk.builtin.float_.prototype.nb$reflected_add = function (other) {\n    // Should not automatically call this.nb$add, as nb$add may have\n    // been overridden by a subclass\n    return Sk.builtin.float_.prototype.nb$add.call(this, other);\n};\n\n/** @override */\nSk.builtin.float_.prototype.nb$subtract = function (other) {\n    if (other instanceof Sk.builtin.int_ || other instanceof Sk.builtin.float_) {\n        return new Sk.builtin.float_(this.v - other.v);\n    } else if (other instanceof Sk.builtin.lng) {\n        return new Sk.builtin.float_(this.v - parseFloat(other.str$(10, true)));\n    }\n\n    return Sk.builtin.NotImplemented.NotImplemented$;\n};\n\n/** @override */\nSk.builtin.float_.prototype.nb$reflected_subtract = function (other) {\n    // Should not automatically call this.nb$add, as nb$add may have\n    // been overridden by a subclass\n    var negative_this = this.nb$negative();\n    return Sk.builtin.float_.prototype.nb$add.call(negative_this, other);\n};\n\n/** @override */\nSk.builtin.float_.prototype.nb$multiply = function (other) {\n    if (other instanceof Sk.builtin.int_ || other instanceof Sk.builtin.float_) {\n        return new Sk.builtin.float_(this.v * other.v);\n    } else if (other instanceof Sk.builtin.lng) {\n        return new Sk.builtin.float_(this.v * parseFloat(other.str$(10, true)));\n    }\n\n    return Sk.builtin.NotImplemented.NotImplemented$;\n};\n\n/** @override */\nSk.builtin.float_.prototype.nb$reflected_multiply = function (other) {\n    // Should not automatically call this.nb$multiply, as nb$multiply may have\n    // been overridden by a subclass\n    return Sk.builtin.float_.prototype.nb$multiply.call(this, other);\n};\n\n/** @override */\nSk.builtin.float_.prototype.nb$divide = function (other) {\n    if (other instanceof Sk.builtin.int_ || other instanceof Sk.builtin.float_) {\n\n        if (other.v === 0) {\n            throw new Sk.builtin.ZeroDivisionError(\"integer division or modulo by zero\");\n        }\n\n        if (this.v === Infinity) {\n            if (other.v === Infinity || other.v === -Infinity) {\n                return new Sk.builtin.float_(NaN);\n            } else if (other.nb$isnegative()) {\n                return new Sk.builtin.float_(-Infinity);\n            } else {\n                return new Sk.builtin.float_(Infinity);\n            }\n        }\n        if (this.v === -Infinity) {\n            if (other.v === Infinity || other.v === -Infinity) {\n                return new Sk.builtin.float_(NaN);\n            } else if (other.nb$isnegative()) {\n                return new Sk.builtin.float_(Infinity);\n            } else {\n                return new Sk.builtin.float_(-Infinity);\n            }\n        }\n\n        return new Sk.builtin.float_(this.v / other.v);\n    }\n\n    if (other instanceof Sk.builtin.lng) {\n        if (other.longCompare(Sk.builtin.biginteger.ZERO) === 0) {\n            throw new Sk.builtin.ZeroDivisionError(\"integer division or modulo by zero\");\n        }\n\n        if (this.v === Infinity) {\n            if (other.nb$isnegative()) {\n                return new Sk.builtin.float_(-Infinity);\n            } else {\n                return new Sk.builtin.float_(Infinity);\n            }\n        }\n        if (this.v === -Infinity) {\n            if (other.nb$isnegative()) {\n                return new Sk.builtin.float_(Infinity);\n            } else {\n                return new Sk.builtin.float_(-Infinity);\n            }\n        }\n\n        return new Sk.builtin.float_(this.v / parseFloat(other.str$(10, true)));\n    }\n\n    return Sk.builtin.NotImplemented.NotImplemented$;\n};\n\n/** @override */\nSk.builtin.float_.prototype.nb$reflected_divide = function (other) {\n    if (other instanceof Sk.builtin.int_ ||\n        other instanceof Sk.builtin.lng) {\n        other = new Sk.builtin.float_(other);\n    }\n\n    if (other instanceof Sk.builtin.float_) {\n        return other.nb$divide(this);\n    }\n\n    return Sk.builtin.NotImplemented.NotImplemented$;\n};\n\n/** @override */\nSk.builtin.float_.prototype.nb$floor_divide = function (other) {\n\n    if (other instanceof Sk.builtin.int_ || other instanceof Sk.builtin.float_) {\n\n        if (this.v === Infinity || this.v === -Infinity) {\n            return new Sk.builtin.float_(NaN);\n        }\n\n        if (other.v === 0) {\n            throw new Sk.builtin.ZeroDivisionError(\"integer division or modulo by zero\");\n        }\n\n        if (other.v === Infinity) {\n            if (this.nb$isnegative()) {\n                return new Sk.builtin.float_(-1);\n            } else {\n                return new Sk.builtin.float_(0);\n            }\n        }\n        if (other.v === -Infinity) {\n            if (this.nb$isnegative() || !this.nb$nonzero()) {\n                return new Sk.builtin.float_(0);\n            } else {\n                return new Sk.builtin.float_(-1);\n            }\n        }\n\n        return new Sk.builtin.float_(Math.floor(this.v / other.v));\n    }\n\n    if (other instanceof Sk.builtin.lng) {\n        if (other.longCompare(Sk.builtin.biginteger.ZERO) === 0) {\n            throw new Sk.builtin.ZeroDivisionError(\"integer division or modulo by zero\");\n        }\n\n        if (this.v === Infinity || this.v === -Infinity) {\n            return new Sk.builtin.float_(NaN);\n        }\n\n        return new Sk.builtin.float_(Math.floor(this.v / parseFloat(other.str$(10, true))));\n    }\n\n    return Sk.builtin.NotImplemented.NotImplemented$;\n};\n\n/** @override */\nSk.builtin.float_.prototype.nb$reflected_floor_divide = function (other) {\n    if (other instanceof Sk.builtin.int_ ||\n        other instanceof Sk.builtin.lng) {\n        other = new Sk.builtin.float_(other);\n    }\n\n    if (other instanceof Sk.builtin.float_) {\n        return other.nb$floor_divide(this);\n    }\n\n    return Sk.builtin.NotImplemented.NotImplemented$;\n};\n\n/** @override */\nSk.builtin.float_.prototype.nb$remainder = function (other) {\n    var thisAsLong;\n    var op2;\n    var tmp;\n    var result;\n\n    if (other instanceof Sk.builtin.int_ || other instanceof Sk.builtin.float_) {\n\n        if (other.v === 0) {\n            throw new Sk.builtin.ZeroDivisionError(\"integer division or modulo by zero\");\n        }\n\n        if (this.v === 0) {\n            return new Sk.builtin.float_(0);\n        }\n\n        if (other.v === Infinity) {\n            if (this.v === Infinity || this.v === -Infinity) {\n                return new Sk.builtin.float_(NaN);\n            } else if (this.nb$ispositive()) {\n                return new Sk.builtin.float_(this.v);\n            } else {\n                return new Sk.builtin.float_(Infinity);\n            }\n        }\n\n        //  Javacript logic on negatives doesn't work for Python... do this instead\n        tmp = this.v % other.v;\n\n        if (this.v < 0) {\n            if (other.v > 0 && tmp < 0) {\n                tmp = tmp + other.v;\n            }\n        } else {\n            if (other.v < 0 && tmp !== 0) {\n                tmp = tmp + other.v;\n            }\n        }\n\n        if (other.v < 0 && tmp === 0) {\n            tmp = -0.0; // otherwise the sign gets lost by javascript modulo\n        } else if (tmp === 0 && Infinity/tmp === -Infinity) {\n            tmp = 0.0;\n        }\n\n        return new Sk.builtin.float_(tmp);\n    }\n\n    if (other instanceof Sk.builtin.lng) {\n        if (other.longCompare(Sk.builtin.biginteger.ZERO) === 0) {\n            throw new Sk.builtin.ZeroDivisionError(\"integer division or modulo by zero\");\n        }\n\n        if (this.v === 0) {\n            return new Sk.builtin.float_(0);\n        }\n\n        op2 = parseFloat(other.str$(10, true));\n        tmp = this.v % op2;\n\n        if (tmp < 0) {\n            if (op2 > 0 && tmp !== 0) {\n                tmp = tmp + op2;\n            }\n        } else {\n            if (op2 < 0 && tmp !== 0) {\n                tmp = tmp + op2;\n            }\n        }\n\n        if (other.nb$isnegative() && tmp === 0) {\n            tmp = -0.0; // otherwise the sign gets lost by javascript modulo\n        } else if (tmp === 0 && Infinity/tmp === -Infinity) {\n            tmp = 0.0;\n        }\n\n        return new Sk.builtin.float_(tmp);\n    }\n\n    return Sk.builtin.NotImplemented.NotImplemented$;\n};\n\n/** @override */\nSk.builtin.float_.prototype.nb$reflected_remainder = function (other) {\n    if (other instanceof Sk.builtin.int_ ||\n        other instanceof Sk.builtin.lng) {\n        other = new Sk.builtin.float_(other);\n    }\n\n    if (other instanceof Sk.builtin.float_) {\n        return other.nb$remainder(this);\n    }\n\n    return Sk.builtin.NotImplemented.NotImplemented$;\n};\n\n/** @override */\nSk.builtin.float_.prototype.nb$divmod = function (other) {\n    if (other instanceof Sk.builtin.int_ ||\n        other instanceof Sk.builtin.lng) {\n        other = new Sk.builtin.float_(other);\n    }\n\n    if (other instanceof Sk.builtin.float_) {\n        return new Sk.builtin.tuple([\n            this.nb$floor_divide(other),\n            this.nb$remainder(other)\n        ]);\n    }\n\n    return Sk.builtin.NotImplemented.NotImplemented$;\n};\n\n/** @override */\nSk.builtin.float_.prototype.nb$reflected_divmod = function (other) {\n    if (other instanceof Sk.builtin.int_ ||\n        other instanceof Sk.builtin.lng) {\n        other = new Sk.builtin.float_(other);\n    }\n\n    if (other instanceof Sk.builtin.float_) {\n        return new Sk.builtin.tuple([\n            other.nb$floor_divide(this),\n            other.nb$remainder(this)\n        ]);\n    }\n\n    return Sk.builtin.NotImplemented.NotImplemented$;\n};\n\n/** @override */\nSk.builtin.float_.prototype.nb$power = function (other, mod) {\n    var thisAsLong;\n    var result;\n\n    if (other instanceof Sk.builtin.int_ || other instanceof Sk.builtin.float_) {\n        if (this.v < 0 && other.v % 1 !== 0) {\n            throw new Sk.builtin.NegativePowerError(\"cannot raise a negative number to a fractional power\");\n        }\n        if (this.v === 0 && other.v < 0) {\n            throw new Sk.builtin.NegativePowerError(\"cannot raise zero to a negative power\");\n        }\n\n        result = new Sk.builtin.float_(Math.pow(this.v, other.v));\n\n        if ((Math.abs(result.v) === Infinity) &&\n            (Math.abs(this.v) !== Infinity) &&\n            (Math.abs(other.v) !== Infinity)) {\n            throw new Sk.builtin.OverflowError(\"Numerical result out of range\");\n        }\n        return result;\n    }\n\n    if (other instanceof Sk.builtin.lng) {\n        if (this.v === 0 && other.longCompare(Sk.builtin.biginteger.ZERO) < 0) {\n            throw new Sk.builtin.NegativePowerError(\"cannot raise zero to a negative power\");\n        }\n\n        return new Sk.builtin.float_(Math.pow(this.v, parseFloat(other.str$(10, true))));\n    }\n\n    return Sk.builtin.NotImplemented.NotImplemented$;\n};\n\n/** @override */\nSk.builtin.float_.prototype.nb$reflected_power = function (n, mod) {\n    if (n instanceof Sk.builtin.int_ ||\n        n instanceof Sk.builtin.lng) {\n        n = new Sk.builtin.float_(n);\n    }\n\n    if (n instanceof Sk.builtin.float_) {\n        return n.nb$power(this, mod);\n    }\n\n    return Sk.builtin.NotImplemented.NotImplemented$;\n};\n\n/** @override */\nSk.builtin.float_.prototype.nb$abs = function () {\n    return new Sk.builtin.float_(Math.abs(this.v));\n};\n\n/** @override */\nSk.builtin.float_.prototype.nb$inplace_add = Sk.builtin.float_.prototype.nb$add;\n\n/** @override */\nSk.builtin.float_.prototype.nb$inplace_subtract = Sk.builtin.float_.prototype.nb$subtract;\n\n/** @override */\nSk.builtin.float_.prototype.nb$inplace_multiply = Sk.builtin.float_.prototype.nb$multiply;\n\n/** @override */\nSk.builtin.float_.prototype.nb$inplace_divide = Sk.builtin.float_.prototype.nb$divide;\n\n/** @override */\nSk.builtin.float_.prototype.nb$inplace_remainder = Sk.builtin.float_.prototype.nb$remainder;\n\n/** @override */\nSk.builtin.float_.prototype.nb$inplace_floor_divide = Sk.builtin.float_.prototype.nb$floor_divide;\n\n/** @override */\nSk.builtin.float_.prototype.nb$inplace_power = Sk.builtin.float_.prototype.nb$power;\n\n/**\n * @override\n *\n * @return {Sk.builtin.float_} A copy of this instance with the value negated.\n */\nSk.builtin.float_.prototype.nb$negative = function () {\n    return new Sk.builtin.float_(-this.v);\n};\n\n/** @override */\nSk.builtin.float_.prototype.nb$positive = function () {\n    return this.clone();\n};\n\n/** @override */\nSk.builtin.float_.prototype.nb$nonzero = function () {\n    return this.v !== 0;\n};\n\n/** @override */\nSk.builtin.float_.prototype.nb$isnegative = function () {\n    return this.v < 0;\n};\n\n/** @override */\nSk.builtin.float_.prototype.nb$ispositive = function () {\n    return this.v >= 0;\n};\n\n/**\n * Compare this instance's value to another Python object's value.\n *\n * Returns NotImplemented if comparison between float and other type is unsupported.\n *\n * Javscript function, returns Javascript object or Sk.builtin.NotImplemented.\n *\n * @return {(number|Sk.builtin.NotImplemented)} negative if this < other, zero if this == other, positive if this > other\n */\nSk.builtin.float_.prototype.numberCompare = function (other) {\n    var diff;\n    var tmp;\n    var thisAsLong;\n\n    if (other instanceof Sk.builtin.int_ || other instanceof Sk.builtin.float_) {\n        if (this.v == Infinity && other.v == Infinity) {\n            return 0;\n        }\n        if (this.v == -Infinity && other.v == -Infinity) {\n            return 0;\n        }\n        return this.v - other.v;\n    }\n\n    if (other instanceof Sk.builtin.lng) {\n        if (this.v % 1 === 0) {\n            thisAsLong = new Sk.builtin.lng(this.v);\n            tmp = thisAsLong.longCompare(other);\n            return tmp;\n        }\n        diff = this.nb$subtract(other);\n        if (diff instanceof Sk.builtin.float_) {\n            return diff.v;\n        } else if (diff instanceof Sk.builtin.lng) {\n            return diff.longCompare(Sk.builtin.biginteger.ZERO);\n        }\n    }\n\n    return Sk.builtin.NotImplemented.NotImplemented$;\n};\n\n// Despite what jshint may want us to do, these two  functions need to remain\n// as == and !=  Unless you modify the logic of numberCompare do not change\n// these.\n\n/** @override */\nSk.builtin.float_.prototype.ob$eq = function (other) {\n    if (other instanceof Sk.builtin.int_ ||\n        other instanceof Sk.builtin.lng ||\n        other instanceof Sk.builtin.float_) {\n        return new Sk.builtin.bool(this.numberCompare(other) == 0); //jshint ignore:line\n    } else if (other instanceof Sk.builtin.none) {\n        return Sk.builtin.bool.false$;\n    } else {\n        return Sk.builtin.NotImplemented.NotImplemented$;\n    }\n};\n\n/** @override */\nSk.builtin.float_.prototype.ob$ne = function (other) {\n    if (other instanceof Sk.builtin.int_ ||\n        other instanceof Sk.builtin.lng ||\n        other instanceof Sk.builtin.float_) {\n        return new Sk.builtin.bool(this.numberCompare(other) != 0); //jshint ignore:line\n    } else if (other instanceof Sk.builtin.none) {\n        return Sk.builtin.bool.true$;\n    } else {\n        return Sk.builtin.NotImplemented.NotImplemented$;\n    }\n};\n\n/** @override */\nSk.builtin.float_.prototype.ob$lt = function (other) {\n    if (other instanceof Sk.builtin.int_ ||\n        other instanceof Sk.builtin.lng ||\n        other instanceof Sk.builtin.float_) {\n        return new Sk.builtin.bool(this.numberCompare(other) < 0);\n    } else {\n        return Sk.builtin.NotImplemented.NotImplemented$;\n    }\n};\n\n/** @override */\nSk.builtin.float_.prototype.ob$le = function (other) {\n    if (other instanceof Sk.builtin.int_ ||\n        other instanceof Sk.builtin.lng ||\n        other instanceof Sk.builtin.float_) {\n        return new Sk.builtin.bool(this.numberCompare(other) <= 0);\n    } else {\n        return Sk.builtin.NotImplemented.NotImplemented$;\n    }\n};\n\n/** @override */\nSk.builtin.float_.prototype.ob$gt = function (other) {\n    if (other instanceof Sk.builtin.int_ ||\n        other instanceof Sk.builtin.lng ||\n        other instanceof Sk.builtin.float_) {\n        return new Sk.builtin.bool(this.numberCompare(other) > 0);\n    } else {\n        return Sk.builtin.NotImplemented.NotImplemented$;\n    }\n};\n\n/** @override */\nSk.builtin.float_.prototype.ob$ge = function (other) {\n    if (other instanceof Sk.builtin.int_ ||\n        other instanceof Sk.builtin.lng ||\n        other instanceof Sk.builtin.float_) {\n        return new Sk.builtin.bool(this.numberCompare(other) >= 0);\n    } else {\n        return Sk.builtin.NotImplemented.NotImplemented$;\n    }\n};\n\n/**\n * Round this instance to a given number of digits, or zero if omitted.\n *\n * Implements `__round__` dunder method.\n *\n * Javascript function, returns Python object.\n *\n * @param  {Sk.builtin.int_} self This instance.\n * @param  {Object|number=} ndigits The number of digits after the decimal point to which to round.\n * @return {Sk.builtin.float_|Sk.builtin.int_} The rounded float.\n */\nSk.builtin.float_.prototype.round$ = function (self, ndigits) {\n    Sk.builtin.pyCheckArgsLen(\"__round__\", arguments.length, 1, 2);\n\n    var result, multiplier, number, num10, rounded, bankRound, ndigs;\n\n    if ((ndigits !== undefined) && !Sk.misceval.isIndex(ndigits)) {\n        throw new Sk.builtin.TypeError(\"'\" + Sk.abstr.typeName(ndigits) + \"' object cannot be interpreted as an index\");\n    }\n\n    number = Sk.builtin.asnum$(self);\n    if (ndigits === undefined) {\n        ndigs = 0;\n    } else {\n        ndigs = Sk.misceval.asIndex(ndigits);\n    }\n\n    if (Sk.__future__.bankers_rounding) {\n        num10 = number * Math.pow(10, ndigs);\n        rounded = Math.round(num10);\n        bankRound = (((((num10>0)?num10:(-num10))%1)===0.5)?(((0===(rounded%2)))?rounded:(rounded-1)):rounded);\n        result = bankRound / Math.pow(10, ndigs);\n        if (ndigits === undefined) {\n            return new Sk.builtin.int_(result);\n        } else {\n            return new Sk.builtin.float_(result);\n        }\n    } else {\n        multiplier = Math.pow(10, ndigs);\n        result = Math.round(number * multiplier) / multiplier;\n\n        return new Sk.builtin.float_(result);\n    }\n};\n\nSk.builtin.float_.prototype.__format__= function (obj, format_spec) {\n    var formatstr;\n    Sk.builtin.pyCheckArgsLen(\"__format__\", arguments.length, 2, 2);\n\n    if (!Sk.builtin.checkString(format_spec)) {\n        if (Sk.__future__.exceptions) {\n            throw new Sk.builtin.TypeError(\"format() argument 2 must be str, not \" + Sk.abstr.typeName(format_spec));\n        } else {\n            throw new Sk.builtin.TypeError(\"format expects arg 2 to be string or unicode, not \" + Sk.abstr.typeName(format_spec));\n        }\n    } else {\n        formatstr = Sk.ffi.remapToJs(format_spec);\n        if (formatstr !== \"\") {\n            throw new Sk.builtin.NotImplementedError(\"format spec is not yet implemented\");\n        }\n    }\n\n    return new Sk.builtin.str(obj);\n};\n\n\nSk.builtin.float_.prototype.conjugate = new Sk.builtin.func(function (self) {\n    return new Sk.builtin.float_(self.v);\n});\n\n/** @override */\nSk.builtin.float_.prototype[\"$r\"] = function () {\n    return new Sk.builtin.str(this.str$(10, true));\n};\n\n/**\n * Return the string representation of this instance.\n *\n * Javascript function, returns Python object.\n *\n * @return {Sk.builtin.str} The Python string representation of this instance.\n */\nSk.builtin.float_.prototype.tp$str = function () {\n    return new Sk.builtin.str(this.str$(10, true));\n};\n\n/**\n * Convert this instance's value to a Javascript string.\n *\n * Javascript function, returns Javascript object.\n *\n * @param {number} base The base of the value.\n * @param {boolean} sign true if the value should be signed, false otherwise.\n * @return {string} The Javascript string representation of this instance.\n */\nSk.builtin.float_.prototype.str$ = function (base, sign) {\n    var post;\n    var pre;\n    var idx;\n    var tmp;\n    var work;\n\n    if (isNaN(this.v)) {\n        return \"nan\";\n    }\n\n    if (sign === undefined) {\n        sign = true;\n    }\n\n    if (this.v == Infinity) {\n        return \"inf\";\n    }\n    if (this.v == -Infinity && sign) {\n        return \"-inf\";\n    }\n    if (this.v == -Infinity && !sign) {\n        return \"inf\";\n    }\n\n    work = sign ? this.v : Math.abs(this.v);\n\n\n    if (base === undefined || base === 10) {\n        tmp = work.toPrecision(12);\n\n        // transform fractions with 4 or more leading zeroes into exponents\n        idx = tmp.indexOf(\".\");\n        pre = work.toString().slice(0, idx);\n        post = work.toString().slice(idx);\n\n        if (pre.match(/^-?0$/) && post.slice(1).match(/^0{4,}/)) {\n            if (tmp.length < 12) {\n                tmp = work.toExponential();\n            } else {\n                tmp = work.toExponential(11);\n            }\n        }\n\n        if (tmp.indexOf(\"e\") < 0 && tmp.indexOf(\".\") >= 0) {\n            while (tmp.charAt(tmp.length-1) == \"0\") {\n                tmp = tmp.substring(0,tmp.length-1);\n            }\n            if (tmp.charAt(tmp.length-1) == \".\") {\n                tmp = tmp + \"0\";\n            }\n        }\n\n        tmp = tmp.replace(new RegExp(\"\\\\.0+e\"), \"e\", \"i\");\n        // make exponent two digits instead of one (ie e+09 not e+9)\n        tmp = tmp.replace(/(e[-+])([1-9])$/, \"$10$2\");\n        // remove trailing zeroes before the exponent\n        tmp = tmp.replace(/0+(e.*)/, \"$1\");\n    } else {\n        tmp = work.toString(base);\n    }\n\n    // restore negative zero sign\n    if(this.v === 0 && 1/this.v === -Infinity) {\n        tmp = \"-\" + tmp;\n    }\n\n    if (tmp.indexOf(\".\") < 0 && tmp.indexOf(\"E\") < 0 && tmp.indexOf(\"e\") < 0) {\n        tmp = tmp + \".0\";\n    }\n\n    return tmp;\n};\n","var deprecatedError = new Sk.builtin.ExternalError(\"Sk.builtin.nmber is deprecated.\");\n\n/**\n * @deprecated Please use Sk.builtin.int_ or Sk.builtin.float_ constructors instead.\n * If you do not know at complile time which type of number, use Sk.builtin.assk$.\n */\nSk.builtin.nmber = function (x, skType)    /* number is a reserved word */ {\n    throw new Sk.builtin.ExternalError(\"Sk.builtin.nmber is deprecated. Please replace with Sk.builtin.int_, Sk.builtin.float_, or Sk.builtin.assk$.\");\n};\n\n/**\n * @deprecated Please use Sk.builtin.int_ or Sk.builtin.float_ instead.\n */\nSk.builtin.nmber.prototype.tp$index = function () {\n    return this.v;\n};\n\n/**\n * @deprecated Please use Sk.builtin.int_ or Sk.builtin.float_ instead.\n */\nSk.builtin.nmber.prototype.tp$hash = function () {\n    throw deprecatedError;\n};\n\n/**\n * @deprecated Please use Sk.builtin.int_ or Sk.builtin.float_ instead.\n */\nSk.builtin.nmber.fromInt$ = function (ival) {\n    throw deprecatedError;\n};\n\n/**\n * @deprecated Please use Sk.builtin.int_ or Sk.builtin.float_ instead.\n */\nSk.builtin.nmber.prototype.clone = function () {\n    throw deprecatedError;\n};\n\n/**\n * @deprecated Please use Sk.builtin.int_ or Sk.builtin.float_ instead.\n */\nSk.builtin.nmber.prototype.toFixed = function (x) {\n    throw deprecatedError;\n};\n\n/**\n * @deprecated Please use Sk.builtin.int_ or Sk.builtin.float_ instead.\n */\nSk.builtin.nmber.prototype.nb$add = function (other) {\n    throw deprecatedError;\n};\n\n/**\n * @deprecated Please use Sk.builtin.int_ or Sk.builtin.float_ instead.\n */\nSk.builtin.nmber.prototype.nb$subtract = function (other) {\n    throw deprecatedError;\n};\n\n/**\n * @deprecated Please use Sk.builtin.int_ or Sk.builtin.float_ instead.\n */\nSk.builtin.nmber.prototype.nb$multiply = function (other) {\n    throw deprecatedError;\n};\n\n/**\n * @deprecated Please use Sk.builtin.int_ or Sk.builtin.float_ instead.\n */\nSk.builtin.nmber.prototype.nb$divide = function (other) {\n    throw deprecatedError;\n};\n\n/**\n * @deprecated Please use Sk.builtin.int_ or Sk.builtin.float_ instead.\n */\nSk.builtin.nmber.prototype.nb$floor_divide = function (other) {\n    throw deprecatedError;\n};\n\n/**\n * @deprecated Please use Sk.builtin.int_ or Sk.builtin.float_ instead.\n */\nSk.builtin.nmber.prototype.nb$remainder = function (other) {\n    throw deprecatedError;\n};\n\n/**\n * @deprecated Please use Sk.builtin.int_ or Sk.builtin.float_ instead.\n */\nSk.builtin.nmber.prototype.nb$divmod = function (other) {\n    throw deprecatedError;\n\n};\n\n/**\n * @deprecated Please use Sk.builtin.int_ or Sk.builtin.float_ instead.\n */\nSk.builtin.nmber.prototype.nb$power = function (other) {\n    throw deprecatedError;\n};\n\n/**\n * @deprecated Please use Sk.builtin.int_ or Sk.builtin.float_ instead.\n */\nSk.builtin.nmber.prototype.nb$and = function (other) {\n    throw deprecatedError;\n};\n\n/**\n * @deprecated Please use Sk.builtin.int_ or Sk.builtin.float_ instead.\n */\nSk.builtin.nmber.prototype.nb$or = function (other) {\n    throw deprecatedError;\n};\n\n/**\n * @deprecated Please use Sk.builtin.int_ or Sk.builtin.float_ instead.\n */\nSk.builtin.nmber.prototype.nb$xor = function (other) {\n    throw deprecatedError;\n};\n\n/**\n * @deprecated Please use Sk.builtin.int_ or Sk.builtin.float_ instead.\n */\nSk.builtin.nmber.prototype.nb$lshift = function (other) {\n    throw deprecatedError;\n};\n\n/**\n * @deprecated Please use Sk.builtin.int_ or Sk.builtin.float_ instead.\n */\nSk.builtin.nmber.prototype.nb$rshift = function (other) {\n    throw deprecatedError;\n};\n\n/**\n * @deprecated Please use Sk.builtin.int_ or Sk.builtin.float_ instead.\n */\nSk.builtin.nmber.prototype.nb$inplace_add = Sk.builtin.nmber.prototype.nb$add;\n\n/**\n * @deprecated Please use Sk.builtin.int_ or Sk.builtin.float_ instead.\n */\nSk.builtin.nmber.prototype.nb$inplace_subtract = Sk.builtin.nmber.prototype.nb$subtract;\n\n/**\n * @deprecated Please use Sk.builtin.int_ or Sk.builtin.float_ instead.\n */\nSk.builtin.nmber.prototype.nb$inplace_multiply = Sk.builtin.nmber.prototype.nb$multiply;\n\n/**\n * @deprecated Please use Sk.builtin.int_ or Sk.builtin.float_ instead.\n */\nSk.builtin.nmber.prototype.nb$inplace_divide = Sk.builtin.nmber.prototype.nb$divide;\n\n/**\n * @deprecated Please use Sk.builtin.int_ or Sk.builtin.float_ instead.\n */\nSk.builtin.nmber.prototype.nb$inplace_remainder = Sk.builtin.nmber.prototype.nb$remainder;\n\n/**\n * @deprecated Please use Sk.builtin.int_ or Sk.builtin.float_ instead.\n */\nSk.builtin.nmber.prototype.nb$inplace_floor_divide = Sk.builtin.nmber.prototype.nb$floor_divide;\n\n/**\n * @deprecated Please use Sk.builtin.int_ or Sk.builtin.float_ instead.\n */\nSk.builtin.nmber.prototype.nb$inplace_power = Sk.builtin.nmber.prototype.nb$power;\n\n/**\n * @deprecated Please use Sk.builtin.int_ or Sk.builtin.float_ instead.\n */\nSk.builtin.nmber.prototype.nb$inplace_and = Sk.builtin.nmber.prototype.nb$and;\n\n/**\n * @deprecated Please use Sk.builtin.int_ or Sk.builtin.float_ instead.\n */\nSk.builtin.nmber.prototype.nb$inplace_or = Sk.builtin.nmber.prototype.nb$or;\n\n/**\n * @deprecated Please use Sk.builtin.int_ or Sk.builtin.float_ instead.\n */\nSk.builtin.nmber.prototype.nb$inplace_xor = Sk.builtin.nmber.prototype.nb$xor;\n\n/**\n * @deprecated Please use Sk.builtin.int_ or Sk.builtin.float_ instead.\n */\nSk.builtin.nmber.prototype.nb$inplace_lshift = Sk.builtin.nmber.prototype.nb$lshift;\n\n/**\n * @deprecated Please use Sk.builtin.int_ or Sk.builtin.float_ instead.\n */\nSk.builtin.nmber.prototype.nb$inplace_rshift = Sk.builtin.nmber.prototype.nb$rshift;\n\n/**\n * @deprecated Please use Sk.builtin.int_ or Sk.builtin.float_ instead.\n */\nSk.builtin.nmber.prototype.nb$negative = function () {\n    throw deprecatedError;\n};\n\n/**\n * @deprecated Please use Sk.builtin.int_ or Sk.builtin.float_ instead.\n */\nSk.builtin.nmber.prototype.nb$positive = function () {\n    throw deprecatedError;\n};\n\n/**\n * @deprecated Please use Sk.builtin.int_ or Sk.builtin.float_ instead.\n */\nSk.builtin.nmber.prototype.nb$nonzero = function () {\n    throw deprecatedError;\n};\n\n/**\n * @deprecated Please use Sk.builtin.int_ or Sk.builtin.float_ instead.\n */\nSk.builtin.nmber.prototype.nb$isnegative = function () {\n    throw deprecatedError;\n};\n\n/**\n * @deprecated Please use Sk.builtin.int_ or Sk.builtin.float_ instead.\n */\nSk.builtin.nmber.prototype.nb$ispositive = function () {\n    throw deprecatedError;\n};\n\n/**\n * @deprecated Please use Sk.builtin.int_ or Sk.builtin.float_ instead.\n */\nSk.builtin.nmber.prototype.numberCompare = function (other) {\n    throw deprecatedError;\n};\n\n/**\n * @deprecated Please use Sk.builtin.int_ or Sk.builtin.float_ instead.\n */\nSk.builtin.nmber.prototype.__eq__ = function (me, other) {\n    throw deprecatedError;\n};\n\n/**\n * @deprecated Please use Sk.builtin.int_ or Sk.builtin.float_ instead.\n */\nSk.builtin.nmber.prototype.__ne__ = function (me, other) {\n    throw deprecatedError;\n};\n\n/**\n * @deprecated Please use Sk.builtin.int_ or Sk.builtin.float_ instead.\n */\nSk.builtin.nmber.prototype.__lt__ = function (me, other) {\n    throw deprecatedError;\n};\n\n/**\n * @deprecated Please use Sk.builtin.int_ or Sk.builtin.float_ instead.\n */\nSk.builtin.nmber.prototype.__le__ = function (me, other) {\n    throw deprecatedError;\n};\n\n/**\n * @deprecated Please use Sk.builtin.int_ or Sk.builtin.float_ instead.\n */\nSk.builtin.nmber.prototype.__gt__ = function (me, other) {\n    throw deprecatedError;\n};\n\n/**\n * @deprecated Please use Sk.builtin.int_ or Sk.builtin.float_ instead.\n */\nSk.builtin.nmber.prototype.__ge__ = function (me, other) {\n    throw deprecatedError;\n};\n\n/**\n * @deprecated Please use Sk.builtin.int_ or Sk.builtin.float_ instead.\n */\nSk.builtin.nmber.prototype.round$ = function (self, ndigits) {\n    throw deprecatedError;\n};\n\n/**\n * @deprecated Please use Sk.builtin.int_ or Sk.builtin.float_ instead.\n */\nSk.builtin.nmber.prototype[\"$r\"] = function () {\n    throw deprecatedError;\n};\n\n/**\n * @deprecated Please use Sk.builtin.int_ or Sk.builtin.float_ instead.\n */\nSk.builtin.nmber.prototype.tp$str = function () {\n    throw deprecatedError;\n};\n\n/**\n * @deprecated Please use Sk.builtin.int_ or Sk.builtin.float_ instead.\n */\nSk.builtin.nmber.prototype.str$ = function (base, sign) {\n    throw deprecatedError;\n};\n\nSk.exportSymbol(\"Sk.builtin.nmber\", Sk.builtin.nmber);\n","/* global Sk: true, goog:true */\n\n// long aka \"bignumber\" implementation\n//\n//  Using javascript BigInteger by Tom Wu\n/**\n * @constructor\n * Sk.builtin.lng\n *\n * @description\n * Constructor for Python long. Also used for builtin long().\n *\n * @extends {Sk.builtin.numtype}\n *\n * @param {*} x Object or number to convert to Python long.\n * @param {number=} base Optional base.\n * @return {Sk.builtin.lng} Python long\n */\nSk.builtin.lng = function (x, base) {   /* long is a reserved word */\n    base = Sk.builtin.asnum$(base);\n    if (!(this instanceof Sk.builtin.lng)) {\n        return new Sk.builtin.lng(x, base);\n    }\n\n\n    if (x === undefined) {\n        this.biginteger = new Sk.builtin.biginteger(0);\n        return this;\n    }\n    if (x instanceof Sk.builtin.lng) {\n        this.biginteger = x.biginteger.clone();\n        return this;\n    }\n    if (x instanceof Sk.builtin.biginteger) {\n        this.biginteger = x;\n        return this;\n    }\n    if (x instanceof String || typeof x === \"string\") {\n        return Sk.longFromStr(x, base);\n    }\n    if (x instanceof Sk.builtin.str) {\n        return Sk.longFromStr(x.v, base);\n    }\n\n    if ((x !== undefined) && (!Sk.builtin.checkString(x) && !Sk.builtin.checkNumber(x))) {\n        if (x === true) {\n            x = 1;\n        } else if (x === false) {\n            x = 0;\n        } else {\n            throw new Sk.builtin.TypeError(\"long() argument must be a string or a number, not '\" + Sk.abstr.typeName(x) + \"'\");\n        }\n    }\n\n    x = Sk.builtin.asnum$nofloat(x);\n    this.biginteger = new Sk.builtin.biginteger(x);\n    return this;\n};\n\nSk.abstr.setUpInheritance(\"long\", Sk.builtin.lng, Sk.builtin.numtype);\n\n/* NOTE: See constants used for kwargs in constants.js */\n\nSk.builtin.lng.prototype.tp$index = function () {\n    return parseInt(this.str$(10, true), 10);\n};\n\nSk.builtin.lng.prototype.tp$hash = function () {\n    return new Sk.builtin.int_(this.tp$index());\n};\n\nSk.builtin.lng.prototype.nb$int_ = function() {\n    if (this.cantBeInt()) {\n        return new Sk.builtin.lng(this);\n    }\n\n    return new Sk.builtin.int_(this.toInt$());\n};\n\nSk.builtin.lng.prototype.__format__= function (obj, format_spec) {\n    var formatstr;\n    Sk.builtin.pyCheckArgsLen(\"__format__\", arguments.length, 2, 2);\n\n    if (!Sk.builtin.checkString(format_spec)) {\n        if (Sk.__future__.exceptions) {\n            throw new Sk.builtin.TypeError(\"format() argument 2 must be str, not \" + Sk.abstr.typeName(format_spec));\n        } else {\n            throw new Sk.builtin.TypeError(\"format expects arg 2 to be string or unicode, not \" + Sk.abstr.typeName(format_spec));\n        }\n    } else {\n        formatstr = Sk.ffi.remapToJs(format_spec);\n        if (formatstr !== \"\") {\n            throw new Sk.builtin.NotImplementedError(\"format spec is not yet implemented\");\n        }\n    }\n\n    return new Sk.builtin.str(obj);\n};\n\nSk.builtin.lng.prototype.round$ = function (self, ndigits) {\n    Sk.builtin.pyCheckArgsLen(\"__round__\", arguments.length, 1, 2);\n\n    var result, multiplier, number, num10, rounded, bankRound, ndigs;\n\n    if ((ndigits !== undefined) && !Sk.misceval.isIndex(ndigits)) {\n        throw new Sk.builtin.TypeError(\"'\" + Sk.abstr.typeName(ndigits) + \"' object cannot be interpreted as an index\");\n    }\n\n    number = Sk.builtin.asnum$(self);\n    if (ndigits === undefined) {\n        ndigs = 0;\n    } else {\n        ndigs = Sk.misceval.asIndex(ndigits);\n    }\n\n    if (Sk.__future__.bankers_rounding) {\n        num10 = number * Math.pow(10, ndigs);\n        rounded = Math.round(num10);\n        bankRound = (((((num10>0)?num10:(-num10))%1)===0.5)?(((0===(rounded%2)))?rounded:(rounded-1)):rounded);\n        result = bankRound / Math.pow(10, ndigs);\n        return new Sk.builtin.lng(result);\n    } else {\n        multiplier = Math.pow(10, ndigs);\n        result = Math.round(number * multiplier) / multiplier;\n\n        return new Sk.builtin.lng(result);\n    }\n};\n\nSk.builtin.lng.prototype.__index__ = new Sk.builtin.func(function(self) {\n    return self.nb$int_(self);\n});\n\nSk.builtin.lng.prototype.nb$lng_ = function () {\n    return this;\n};\n\nSk.builtin.lng.prototype.nb$float_ = function() {\n    return new Sk.builtin.float_(Sk.ffi.remapToJs(this));\n};\n\n//    Threshold to determine when types should be converted to long\n//Sk.builtin.lng.threshold$ = Sk.builtin.int_.threshold$;\n\nSk.builtin.lng.MAX_INT$ = new Sk.builtin.lng(Sk.builtin.int_.threshold$);\nSk.builtin.lng.MIN_INT$ = new Sk.builtin.lng(-Sk.builtin.int_.threshold$);\n\nSk.builtin.lng.prototype.cantBeInt = function () {\n    return (this.longCompare(Sk.builtin.lng.MAX_INT$) > 0) || (this.longCompare(Sk.builtin.lng.MIN_INT$) < 0);\n};\n\nSk.builtin.lng.fromInt$ = function (ival) {\n    return new Sk.builtin.lng(ival);\n};\n\n// js string (not Sk.builtin.str) -> long. used to create longs in transformer, respects\n// 0x, 0o, 0b, etc.\nSk.longFromStr = function (s, base) {\n    // l/L are valid digits with base >= 22\n    // Sk.asserts.assert(s.charAt(s.length - 1) !== \"L\" && s.charAt(s.length - 1) !== 'l', \"L suffix should be removed before here\");\n\n    var parser = function (s, base) {\n            if (base === 10) {\n                return new Sk.builtin.biginteger(s);\n            }\n            return new Sk.builtin.biginteger(s, base);\n        },\n        biginteger = Sk.str2number(s, base, parser, function (x) {\n            return x.negate();\n        }, \"long\");\n\n    return new Sk.builtin.lng(biginteger);\n};\nSk.exportSymbol(\"Sk.longFromStr\", Sk.longFromStr);\n\nSk.builtin.lng.prototype.toInt$ = function () {\n    return this.biginteger.intValue();\n};\n\nSk.builtin.lng.prototype.clone = function () {\n    return new Sk.builtin.lng(this);\n};\n\nSk.builtin.lng.prototype.conjugate = new Sk.builtin.func(function (self) {\n    return self.clone();\n});\n\nSk.builtin.lng.prototype.nb$add = function (other) {\n    var thisAsFloat;\n\n    if (other instanceof Sk.builtin.float_) {\n        thisAsFloat = new Sk.builtin.float_(this.str$(10, true));\n        return thisAsFloat.nb$add(other);\n    }\n\n    if (other instanceof Sk.builtin.int_) {\n        //    Promote an int to long\n        other = new Sk.builtin.lng(other.v);\n    }\n\n    if (other instanceof Sk.builtin.lng) {\n        return new Sk.builtin.lng(this.biginteger.add(other.biginteger));\n    }\n\n    if (other instanceof Sk.builtin.biginteger) {\n        return new Sk.builtin.lng(this.biginteger.add(other));\n    }\n\n    return Sk.builtin.NotImplemented.NotImplemented$;\n};\n\n/** @override */\nSk.builtin.lng.prototype.nb$reflected_add = function (other) {\n    // Should not automatically call this.nb$add, as nb$add may have\n    // been overridden by a subclass\n    return Sk.builtin.lng.prototype.nb$add.call(this, other);\n};\n\nSk.builtin.lng.prototype.nb$inplace_add = Sk.builtin.lng.prototype.nb$add;\n\nSk.builtin.lng.prototype.nb$subtract = function (other) {\n    var thisAsFloat;\n\n    if (other instanceof Sk.builtin.float_) {\n        thisAsFloat = new Sk.builtin.float_(this.str$(10, true));\n        return thisAsFloat.nb$subtract(other);\n    }\n\n    if (other instanceof Sk.builtin.int_) {\n        //    Promote an int to long\n        other = new Sk.builtin.lng(other.v);\n    }\n\n    if (other instanceof Sk.builtin.lng) {\n        return new Sk.builtin.lng(this.biginteger.subtract(other.biginteger));\n    }\n\n    if (other instanceof Sk.builtin.biginteger) {\n        return new Sk.builtin.lng(this.biginteger.subtract(other));\n    }\n\n    return Sk.builtin.NotImplemented.NotImplemented$;\n};\n\n/** @override */\nSk.builtin.lng.prototype.nb$reflected_subtract = function (other) {\n    // Should not automatically call this.nb$add, as nb$add may have\n    // been overridden by a subclass\n    var negative_this = this.nb$negative();\n    return Sk.builtin.lng.prototype.nb$add.call(negative_this, other);\n};\n\nSk.builtin.lng.prototype.nb$inplace_subtract = Sk.builtin.lng.prototype.nb$subtract;\n\nSk.builtin.lng.prototype.nb$multiply = function (other) {\n    var thisAsFloat;\n\n    if (other instanceof Sk.builtin.float_) {\n        thisAsFloat = new Sk.builtin.float_(this.str$(10, true));\n        return thisAsFloat.nb$multiply(other);\n    }\n\n    if (other instanceof Sk.builtin.int_) {\n        other = new Sk.builtin.lng(other.v);\n    }\n\n    if (other instanceof Sk.builtin.lng) {\n        return new Sk.builtin.lng(this.biginteger.multiply(other.biginteger));\n    }\n\n    if (other instanceof Sk.builtin.biginteger) {\n        return new Sk.builtin.lng(this.biginteger.multiply(other));\n    }\n\n    return Sk.builtin.NotImplemented.NotImplemented$;\n};\n\n/** @override */\nSk.builtin.lng.prototype.nb$reflected_multiply = function (other) {\n    // Should not automatically call this.nb$multiply, as nb$multiply may have\n    // been overridden by a subclass\n    return Sk.builtin.lng.prototype.nb$multiply.call(this, other);\n};\n\nSk.builtin.lng.prototype.nb$inplace_multiply = Sk.builtin.lng.prototype.nb$multiply;\n\nSk.builtin.lng.prototype.nb$divide = function (other) {\n    var thisAsFloat, thisneg, otherneg, result;\n\n    if (other instanceof Sk.builtin.float_) {\n        thisAsFloat = new Sk.builtin.float_(this.str$(10, true));\n        return thisAsFloat.nb$divide(other);\n    }\n\n    if (other instanceof Sk.builtin.int_) {\n        //    Promote an int to long\n        other = new Sk.builtin.lng(other.v);\n    }\n\n    //    Standard, long result mode\n\n    if (other instanceof Sk.builtin.lng) {\n        //    Special logic to round DOWN towards negative infinity for negative results\n        thisneg = this.nb$isnegative();\n        otherneg = other.nb$isnegative();\n        if ((thisneg && !otherneg) || (otherneg && !thisneg)) {\n            result = this.biginteger.divideAndRemainder(other.biginteger);\n            //    If remainder is zero or positive, just return division result\n            if (result[1].trueCompare(Sk.builtin.biginteger.ZERO) === 0) {\n                //    No remainder, just return result\n                return new Sk.builtin.lng(result[0]);\n            }\n            //    Reminder... subtract 1 from the result (like rounding to neg infinity)\n            result = result[0].subtract(Sk.builtin.biginteger.ONE);\n            return new Sk.builtin.lng(result);\n        }\n        return new Sk.builtin.lng(this.biginteger.divide(other.biginteger));\n    }\n\n    return Sk.builtin.NotImplemented.NotImplemented$;\n};\n\nSk.builtin.lng.prototype.nb$reflected_divide = function (other) {\n    var thisneg, otherneg, result;\n\n    if (other instanceof Sk.builtin.int_) {\n        //  Promote an int to long\n        other = new Sk.builtin.lng(other.v);\n    }\n\n    //    Standard, long result mode\n    if (other instanceof Sk.builtin.lng) {\n        return other.nb$divide(this);\n    }\n\n    return Sk.builtin.NotImplemented.NotImplemented$;\n};\n\nSk.builtin.lng.prototype.nb$floor_divide = function (other) {\n    var thisAsFloat;\n\n    if (other instanceof Sk.builtin.float_) {\n        thisAsFloat = new Sk.builtin.float_(this.str$(10, true));\n        return thisAsFloat.nb$floor_divide(other);\n    }\n\n    if (other instanceof Sk.builtin.int_) {\n        //  Promote an int to long\n        other = new Sk.builtin.lng(other.v);\n    }\n\n    //    Standard, long result mode\n    if (other instanceof Sk.builtin.lng) {\n        return other.nb$divide(this);\n    }\n\n    return Sk.builtin.NotImplemented.NotImplemented$;\n};\n\nSk.builtin.lng.prototype.nb$divmod = function (other) {\n    if (other instanceof Sk.builtin.int_) {\n        // Promote an int to long\n        other = new Sk.builtin.lng(other.v);\n    }\n\n    if (other instanceof Sk.builtin.lng) {\n        return new Sk.builtin.tuple([\n            this.nb$floor_divide(other),\n            this.nb$remainder(other)\n        ]);\n    }\n\n    return Sk.builtin.NotImplemented.NotImplemented$;\n};\n\nSk.builtin.lng.prototype.nb$reflected_divmod = function (other) {\n    if (other instanceof Sk.builtin.int_) {\n        // Promote an int to long\n        other = new Sk.builtin.lng(other.v);\n    }\n\n    if (other instanceof Sk.builtin.lng) {\n        return new Sk.builtin.tuple([\n            other.nb$floor_divide(this),\n            other.nb$remainder(this)\n        ]);\n    }\n\n    return Sk.builtin.NotImplemented.NotImplemented$;\n};\n\nSk.builtin.lng.prototype.nb$inplace_divide = Sk.builtin.lng.prototype.nb$divide;\n\nSk.builtin.lng.prototype.nb$floor_divide = Sk.builtin.lng.prototype.nb$divide;\n\nSk.builtin.lng.prototype.nb$reflected_floor_divide = Sk.builtin.lng.prototype.nb$reflected_divide;\n\nSk.builtin.lng.prototype.nb$inplace_floor_divide = Sk.builtin.lng.prototype.nb$floor_divide;\n\nSk.builtin.lng.prototype.nb$remainder = function (other) {\n    var thisAsFloat, tmp;\n\n    if (this.biginteger.trueCompare(Sk.builtin.biginteger.ZERO) === 0) {\n        if (other instanceof Sk.builtin.float_) {\n            return new Sk.builtin.float_(0);\n        }\n        return new Sk.builtin.lng(0);\n    }\n\n    if (other instanceof Sk.builtin.float_) {\n        thisAsFloat = new Sk.builtin.float_(this.str$(10, true));\n        return thisAsFloat.nb$remainder(other);\n    }\n\n    if (other instanceof Sk.builtin.int_) {\n        //    Promote an int to long\n        other = new Sk.builtin.lng(other.v);\n    }\n\n    if (other instanceof Sk.builtin.lng) {\n\n        tmp = new Sk.builtin.lng(this.biginteger.remainder(other.biginteger));\n        if (this.nb$isnegative()) {\n            if (other.nb$ispositive() && tmp.nb$nonzero()) {\n                tmp = tmp.nb$add(other).nb$remainder(other);\n            }\n        } else {\n            if (other.nb$isnegative() && tmp.nb$nonzero()) {\n                tmp = tmp.nb$add(other);\n            }\n        }\n        return tmp;\n    }\n\n    return Sk.builtin.NotImplemented.NotImplemented$;\n};\n\nSk.builtin.lng.prototype.nb$reflected_remainder = function (other) {\n    if (other instanceof Sk.builtin.int_) {\n        other = new Sk.builtin.lng(other.v);\n    }\n\n    if (other instanceof Sk.builtin.lng) {\n        return other.nb$remainder(this);\n    }\n\n    return Sk.builtin.NotImplemented.NotImplemented$;\n};\n\nSk.builtin.lng.prototype.nb$inplace_remainder = Sk.builtin.lng.prototype.nb$remainder;\n\nSk.builtin.lng.prototype.nb$divmod = function (other) {\n    var thisAsFloat;\n\n    if (other === Sk.builtin.bool.true$) {\n        other = new Sk.builtin.lng(1);\n    }\n\n    if (other === Sk.builtin.bool.false$) {\n        other = new Sk.builtin.lng(0);\n    }\n\n    if (other instanceof Sk.builtin.int_) {\n        other = new Sk.builtin.lng(other.v);\n    }\n\n    if (other instanceof Sk.builtin.lng) {\n        return new Sk.builtin.tuple([\n            this.nb$floor_divide(other),\n            this.nb$remainder(other)\n        ]);\n    }\n\n    if (other instanceof Sk.builtin.float_) {\n        thisAsFloat = new Sk.builtin.float_(this.str$(10, true));\n        return thisAsFloat.nb$divmod(other);\n    }\n\n    return Sk.builtin.NotImplemented.NotImplemented$;\n};\n\n/**\n * @param {number|Object} n\n * @param {number|Object=} mod\n * @suppress {checkTypes}\n */\nSk.builtin.lng.prototype.nb$power = function (n, mod) {\n    var thisAsFloat;\n    if (mod !== undefined) {\n        n = new Sk.builtin.biginteger(Sk.builtin.asnum$(n));\n        mod = new Sk.builtin.biginteger(Sk.builtin.asnum$(mod));\n\n        return new Sk.builtin.lng(this.biginteger.modPowInt(n, mod));\n    }\n\n    if (n instanceof Sk.builtin.float_ ||\n        (n instanceof Sk.builtin.int_ && n.v < 0)) {\n        thisAsFloat = new Sk.builtin.float_(this.str$(10, true));\n        return thisAsFloat.nb$power(n);\n    }\n\n    if (n instanceof Sk.builtin.int_) {\n        //    Promote an int to long\n        n = new Sk.builtin.lng(n.v);\n    }\n\n    if (n instanceof Sk.builtin.lng) {\n        if (mod !== undefined) {\n            n = new Sk.builtin.biginteger(Sk.builtin.asnum$(n));\n            mod = new Sk.builtin.biginteger(Sk.builtin.asnum$(mod));\n\n            return new Sk.builtin.lng(this.biginteger.modPowInt(n, mod));\n        }\n\n        if (n.nb$isnegative()) {\n            thisAsFloat = new Sk.builtin.float_(this.str$(10, true));\n            return thisAsFloat.nb$power(n);\n        }\n        return new Sk.builtin.lng(this.biginteger.pow(n.biginteger));\n    }\n\n    if (n instanceof Sk.builtin.biginteger) {\n        if (mod !== undefined) {\n            mod = new Sk.builtin.biginteger(Sk.builtin.asnum$(mod));\n\n            return new Sk.builtin.lng(this.biginteger.modPowInt(n, mod));\n        }\n\n        if (n.isnegative()) {\n            thisAsFloat = new Sk.builtin.float_(this.str$(10, true));\n            return thisAsFloat.nb$power(n);\n        }\n        return new Sk.builtin.lng(this.biginteger.pow(n));\n    }\n\n    return Sk.builtin.NotImplemented.NotImplemented$;\n};\n\nSk.builtin.lng.prototype.nb$reflected_power = function (n, mod) {\n    if (n instanceof Sk.builtin.int_) {\n        // Promote an int to long\n        n = new Sk.builtin.lng(n.v);\n    }\n\n    if (n instanceof Sk.builtin.lng) {\n        return n.nb$power(this, mod);\n    }\n\n    return Sk.builtin.NotImplemented.NotImplemented$;\n};\n\nSk.builtin.lng.prototype.nb$inplace_power = Sk.builtin.lng.prototype.nb$power;\n\n/**\n * Compute the absolute value of this instance and return.\n *\n * Javascript function, returns Python object.\n *\n * @return {Sk.builtin.lng} The absolute value\n */\nSk.builtin.lng.prototype.nb$abs = function () {\n    return new Sk.builtin.lng(this.biginteger.bnAbs());\n};\n\nSk.builtin.lng.prototype.nb$lshift = function (other) {\n\n    if (other instanceof Sk.builtin.int_) {\n        //  Promote an int to long\n        other = new Sk.builtin.lng(other.v);\n    }\n\n    if (other instanceof Sk.builtin.lng) {\n        if (other.biginteger.signum() < 0) {\n            throw new Sk.builtin.ValueError(\"negative shift count\");\n        }\n        return new Sk.builtin.lng(this.biginteger.shiftLeft(other.biginteger));\n    }\n    if (other instanceof Sk.builtin.biginteger) {\n        if (other.signum() < 0) {\n            throw new Sk.builtin.ValueError(\"negative shift count\");\n        }\n        return new Sk.builtin.lng(this.biginteger.shiftLeft(other));\n    }\n\n    return Sk.builtin.NotImplemented.NotImplemented$;\n};\n\nSk.builtin.lng.prototype.nb$reflected_lshift = function (other) {\n    if (other instanceof Sk.builtin.int_) {\n        // Promote an int to long\n        other = new Sk.builtin.lng(other.v);\n    }\n\n    if (other instanceof Sk.builtin.lng) {\n        return other.nb$lshift(this);\n    }\n\n    return Sk.builtin.NotImplemented.NotImplemented$;\n};\n\nSk.builtin.lng.prototype.nb$inplace_lshift = Sk.builtin.lng.prototype.nb$lshift;\n\nSk.builtin.lng.prototype.nb$rshift = function (other) {\n    if (other instanceof Sk.builtin.int_) {\n        //  Promote an int to long\n        other = new Sk.builtin.lng(other.v);\n    }\n\n    if (other instanceof Sk.builtin.lng) {\n        if (other.biginteger.signum() < 0) {\n            throw new Sk.builtin.ValueError(\"negative shift count\");\n        }\n        return new Sk.builtin.lng(this.biginteger.shiftRight(other.biginteger));\n    }\n    if (other instanceof Sk.builtin.biginteger) {\n        if (other.signum() < 0) {\n            throw new Sk.builtin.ValueError(\"negative shift count\");\n        }\n        return new Sk.builtin.lng(this.biginteger.shiftRight(other));\n    }\n\n    return Sk.builtin.NotImplemented.NotImplemented$;\n};\n\nSk.builtin.lng.prototype.nb$reflected_rshift = function (other) {\n    if (other instanceof Sk.builtin.int_) {\n        // Promote an int to long\n        other = new Sk.builtin.lng(other.v);\n    }\n\n    if (other instanceof Sk.builtin.lng) {\n        return other.nb$rshift(this);\n    }\n\n    return Sk.builtin.NotImplemented.NotImplemented$;\n};\n\nSk.builtin.lng.prototype.nb$inplace_rshift = Sk.builtin.lng.prototype.nb$rshift;\n\nSk.builtin.lng.prototype.nb$and = function (other) {\n    if (other instanceof Sk.builtin.int_) {\n        //  Promote an int to long\n        other = new Sk.builtin.lng(other.v);\n    }\n\n    if (other instanceof Sk.builtin.lng) {\n        return new Sk.builtin.lng(this.biginteger.and(other.biginteger));\n    }\n    if (other instanceof Sk.builtin.biginteger) {\n        return new Sk.builtin.lng(this.biginteger.and(other));\n    }\n\n    return Sk.builtin.NotImplemented.NotImplemented$;\n};\n\nSk.builtin.lng.prototype.nb$reflected_and = Sk.builtin.lng.prototype.nb$and;\n\nSk.builtin.lng.prototype.nb$inplace_and = Sk.builtin.lng.prototype.nb$and;\n\nSk.builtin.lng.prototype.nb$or = function (other) {\n    if (other instanceof Sk.builtin.int_) {\n        //  Promote an int to long\n        other = new Sk.builtin.lng(other.v);\n    }\n\n    if (other instanceof Sk.builtin.lng) {\n        return new Sk.builtin.lng(this.biginteger.or(other.biginteger));\n    }\n    if (other instanceof Sk.builtin.biginteger) {\n        return new Sk.builtin.lng(this.biginteger.or(other));\n    }\n\n    return Sk.builtin.NotImplemented.NotImplemented$;\n};\n\n\nSk.builtin.lng.prototype.nb$reflected_or = Sk.builtin.lng.prototype.nb$or;\n\nSk.builtin.lng.prototype.nb$inplace_or = Sk.builtin.lng.prototype.nb$or;\n\nSk.builtin.lng.prototype.nb$xor = function (other) {\n    if (other instanceof Sk.builtin.int_) {\n        //  Promote an int to long\n        other = new Sk.builtin.lng(other.v);\n    }\n\n    if (other instanceof Sk.builtin.lng) {\n        return new Sk.builtin.lng(this.biginteger.xor(other.biginteger));\n    }\n    if (other instanceof Sk.builtin.biginteger) {\n        return new Sk.builtin.lng(this.biginteger.xor(other));\n    }\n\n    return Sk.builtin.NotImplemented.NotImplemented$;\n};\n\nSk.builtin.lng.prototype.nb$reflected_xor = Sk.builtin.lng.prototype.nb$xor;\n\nSk.builtin.lng.prototype.nb$inplace_xor = Sk.builtin.lng.prototype.nb$xor;\n\n/**\n * @override\n *\n * @return {Sk.builtin.lng} A copy of this instance with the value negated.\n */\nSk.builtin.lng.prototype.nb$negative = function () {\n    return new Sk.builtin.lng(this.biginteger.negate());\n};\n\nSk.builtin.lng.prototype.nb$invert = function () {\n    return new Sk.builtin.lng(this.biginteger.not());\n};\n\nSk.builtin.lng.prototype.nb$positive = function () {\n    return this.clone();\n};\n\nSk.builtin.lng.prototype.nb$nonzero = function () {\n    return this.biginteger.trueCompare(Sk.builtin.biginteger.ZERO) !== 0;\n};\n\nSk.builtin.lng.prototype.nb$isnegative = function () {\n    return this.biginteger.isnegative();\n};\n\nSk.builtin.lng.prototype.nb$ispositive = function () {\n    return !this.biginteger.isnegative();\n};\n\nSk.builtin.lng.prototype.longCompare = function (other) {\n    var otherAsLong, thisAsFloat;\n\n    if (typeof other === \"number\") {\n        other = new Sk.builtin.lng(other);\n    }\n\n    if (other instanceof Sk.builtin.int_ ||\n        (other instanceof Sk.builtin.float_ && other.v % 1 === 0)) {\n        otherAsLong = new Sk.builtin.lng(other.v);\n        return this.longCompare(otherAsLong);\n    }\n\n    if (other instanceof Sk.builtin.float_) {\n        thisAsFloat = new Sk.builtin.float_(this);\n        return thisAsFloat.numberCompare(other);\n    }\n\n    if (other instanceof Sk.builtin.lng) {\n        return this.biginteger.subtract(other.biginteger);\n    } else if (other instanceof Sk.builtin.biginteger) {\n        return this.biginteger.subtract(other);\n    }\n\n    return Sk.builtin.NotImplemented.NotImplemented$;\n};\n\n//tests fail if ===\nSk.builtin.lng.prototype.ob$eq = function (other) {\n    if (other instanceof Sk.builtin.int_ || other instanceof Sk.builtin.lng ||\n        other instanceof Sk.builtin.float_) {\n        return new Sk.builtin.bool(this.longCompare(other) == 0); //jshint ignore:line\n    } else if (other instanceof Sk.builtin.none) {\n        return Sk.builtin.bool.false$;\n    } else {\n        return Sk.builtin.NotImplemented.NotImplemented$;\n    }\n};\n\nSk.builtin.lng.prototype.ob$ne = function (other) {\n    if (other instanceof Sk.builtin.int_ || other instanceof Sk.builtin.lng ||\n        other instanceof Sk.builtin.float_) {\n        return new Sk.builtin.bool(this.longCompare(other) != 0); //jshint ignore:line\n    } else if (other instanceof Sk.builtin.none) {\n        return Sk.builtin.bool.true$;\n    } else {\n        return Sk.builtin.NotImplemented.NotImplemented$;\n    }\n};\n\nSk.builtin.lng.prototype.ob$lt = function (other) {\n    if (other instanceof Sk.builtin.int_ || other instanceof Sk.builtin.lng ||\n        other instanceof Sk.builtin.float_) {\n        return new Sk.builtin.bool(this.longCompare(other) < 0);\n    } else {\n        return Sk.builtin.NotImplemented.NotImplemented$;\n    }\n};\n\nSk.builtin.lng.prototype.ob$le = function (other) {\n    if (other instanceof Sk.builtin.int_ || other instanceof Sk.builtin.lng ||\n        other instanceof Sk.builtin.float_) {\n        return new Sk.builtin.bool(this.longCompare(other) <= 0);\n    } else {\n        return Sk.builtin.NotImplemented.NotImplemented$;\n    }\n};\n\nSk.builtin.lng.prototype.ob$gt = function (other) {\n    if (other instanceof Sk.builtin.int_ || other instanceof Sk.builtin.lng ||\n        other instanceof Sk.builtin.float_) {\n        return new Sk.builtin.bool(this.longCompare(other) > 0);\n    } else {\n        return Sk.builtin.NotImplemented.NotImplemented$;\n    }\n};\n\nSk.builtin.lng.prototype.ob$ge = function (other) {\n    if (other instanceof Sk.builtin.int_ || other instanceof Sk.builtin.lng ||\n        other instanceof Sk.builtin.float_) {\n        return new Sk.builtin.bool(this.longCompare(other) >= 0);\n    } else {\n        return Sk.builtin.NotImplemented.NotImplemented$;\n    }\n};\n\nSk.builtin.lng.prototype.$r = function () {\n    return new Sk.builtin.str(this.str$(10, true) + \"L\");\n};\n\nSk.builtin.lng.prototype.tp$str = function () {\n    return new Sk.builtin.str(this.str$(10, true));\n};\n\nSk.builtin.lng.prototype.str$ = function (base, sign) {\n    var work;\n    if (sign === undefined) {\n        sign = true;\n    }\n\n    work = sign ? this.biginteger : this.biginteger.abs();\n\n    if (base === undefined || base === 10) {\n        return work.toString();\n    }\n\n    //    Another base... convert...\n    return work.toString(base);\n};\n","/**\n * hypot is a ESCMA6 function and maybe not available across all browsers\n */\nMath.hypot = Math.hypot || function() {\n    var y = 0;\n    var length = arguments.length;\n\n    for (var i = 0; i < length; i++) {\n        if (arguments[i] === Infinity || arguments[i] === -Infinity) {\n            return Infinity;\n        }\n        y += arguments[i] * arguments[i];\n    }\n    return Math.sqrt(y);\n};\n\n/**\n * complex_new see https://hg.python.org/cpython/file/f0e2caad4200/Objects/complexobject.c#l911\n * @constructor\n * @param {Object} real part of the complex number\n * @param {?Object=} imag part of the complex number\n * @this {Sk.builtin.object}\n *\n * Prefering here == instead of ===, otherwise also undefined has to be matched explicitly\n *\n * FIXME: it seems that we somehow need to call __float__/__int__ if arguments provide those methods\n *\n */\nSk.builtin.complex = function (real, imag) {\n    Sk.builtin.pyCheckArgsLen(\"complex\", arguments.length, 0, 2);\n\n    var r, i, tmp; // PyObject\n    var nbr, nbi; // real, imag as numbers\n    var own_r = false;\n    var cr = {}; // PyComplexObject\n    var ci = {}; // PyComplexObject\n    var cr_is_complex = false;\n    var ci_is_complex = false;\n\n    // not sure why this is required\n    if (!(this instanceof Sk.builtin.complex)) {\n        return new Sk.builtin.complex(real, imag);\n    }\n\n\n    // check if kwargs\n    // ToDo: this is only a temporary replacement\n    r = real == null ? Sk.builtin.bool.false$ : real; // r = Py_False;\n    i = imag;\n\n    // handle case if passed in arguments are of type complex\n    if (r instanceof Sk.builtin.complex && i == null) {\n        return real;\n    }\n\n    if (r != null && Sk.builtin.checkString(r)) {\n        if(i != null) {\n            throw new Sk.builtin.TypeError(\"complex() can't take second arg if first is a string\");\n        }\n\n        return Sk.builtin.complex.complex_subtype_from_string(r);\n    }\n\n    if (i != null && Sk.builtin.checkString(i)) {\n        throw new Sk.builtin.TypeError(\"complex() second arg can't be a string\");\n    }\n\n\n    // try_complex_special_method\n    tmp = Sk.builtin.complex.try_complex_special_method(r);\n    if (tmp != null && tmp !== Sk.builtin.NotImplemented.NotImplemented$) {\n        if (!Sk.builtin.checkComplex(tmp)) {\n            throw new Sk.builtin.TypeError(\"__complex__ should return a complex object\");\n        }\n\n        r = tmp;\n    }\n\n    // this check either returns a javascript number or the passed object\n    // but it actually, should check for r->ob_type->tp_as_number\n    // this check is useless\n    nbr = Sk.builtin.asnum$(r);\n    if (i != null) {\n        nbi = Sk.builtin.asnum$(i);\n    }\n\n    // this function mimics the tp_as_number->nb_float check in cpython\n    var nb_float = function(op) {\n        if(Sk.builtin.checkNumber(op)) {\n            return true;\n        }\n\n        if(Sk.builtin.type.typeLookup(op.ob$type, Sk.builtin.str.$float_) !== undefined) {\n            return true;\n        }\n    };\n\n    // check for valid arguments\n    if (nbr == null || (!nb_float(r) && !Sk.builtin.checkComplex(r)) || ((i != null) && (nbi == null || (!nb_float(i) && !Sk.builtin.checkComplex(i))))) {\n        throw new Sk.builtin.TypeError(\"complex() argument must be a string or number\");\n    }\n\n    /* If we get this far, then the \"real\" and \"imag\" parts should\n       both be treated as numbers, and the constructor should return a\n       complex number equal to (real + imag*1j).\n\n       Note that we do NOT assume the input to already be in canonical\n       form; the \"real\" and \"imag\" parts might themselves be complex\n       numbers, which slightly complicates the code below. */\n\n    if (Sk.builtin.complex._complex_check(r)) {\n        /* Note that if r is of a complex subtype, we're only\n        retaining its real & imag parts here, and the return\n        value is (properly) of the builtin complex type. */\n        cr.real = r.real.v;\n        cr.imag = r.imag.v;\n        cr_is_complex = true;\n    } else {\n        /* The \"real\" part really is entirely real, and contributes\n        nothing in the imaginary direction.\n        Just treat it as a double. */\n        tmp = Sk.builtin.float_.PyFloat_AsDouble(r); // tmp = PyNumber_Float(r);\n\n        if (tmp == null) {\n            return null;\n        }\n\n        cr.real = tmp;\n        cr.imag = 0.0;\n    }\n\n    if (i == null) {\n        ci.real = 0.0;\n    } else if (Sk.builtin.complex._complex_check(i)) {\n        ci.real = i.real.v;\n        ci.imag = i.imag.v;\n        ci_is_complex = true;\n    } else {\n        /* The \"imag\" part really is entirely imaginary, and\n        contributes nothing in the real direction.\n        Just treat it as a double. */\n        tmp = Sk.builtin.float_.PyFloat_AsDouble(i);\n\n        if (tmp == null) {\n            return null;\n        }\n\n        ci.real = tmp;\n        ci.imag = 0.0;\n    }\n\n    /*  If the input was in canonical form, then the \"real\" and \"imag\"\n    parts are real numbers, so that ci.imag and cr.imag are zero.\n    We need this correction in case they were not real numbers. */\n\n    if (ci_is_complex === true) {\n        cr.real -= ci.imag;\n    }\n\n    if (cr_is_complex === true) {\n        ci.real += cr.imag;\n    }\n\n    // adjust for negated imaginary literal\n    if (cr.real === 0 && (ci.real < 0 || Sk.builtin.complex._isNegativeZero(ci.real))) {\n        cr.real = -0;\n    }\n\n    // save them as properties\n    this.real = new Sk.builtin.float_(cr.real);\n    this.imag = new Sk.builtin.float_(ci.real);\n\n    return this;\n};\n\nSk.abstr.setUpInheritance(\"complex\", Sk.builtin.complex, Sk.builtin.numtype);\n//Sk.builtin.complex.co_kwargs = true;\n\nSk.builtin.complex.prototype.__class__ = Sk.builtin.complex;\n\nSk.builtin.complex.prototype.nb$int_ = function () {\n    throw new Sk.builtin.TypeError(\"can't convert complex to int\");\n};\n\nSk.builtin.complex.prototype.nb$float_ = function() {\n    throw new Sk.builtin.TypeError(\"can't convert complex to float\");\n};\n\nSk.builtin.complex.prototype.nb$lng = function () {\n    throw new Sk.builtin.TypeError(\"can't convert complex to long\");\n};\n\nSk.builtin.complex.prototype.__doc__ = new Sk.builtin.str(\"complex(real[, imag]) -> complex number\\n\\nCreate a complex number from a real part and an optional imaginary part.\\nThis is equivalent to (real + imag*1j) where imag defaults to 0.\");\n\nSk.builtin.complex._isNegativeZero = function (val) {\n    if (val !== 0) {\n        return false;\n    }\n\n    return 1/val === -Infinity;\n};\n\n/**\n * Internal method to check if op has __complex__\n */\nSk.builtin.complex.try_complex_special_method = function (op) {\n    var f; // PyObject\n    var res;\n\n    // return early\n    if (op == null) {\n        return null;\n    }\n\n    // the lookup special method does already all the magic\n    f = Sk.abstr.lookupSpecial(op, Sk.builtin.str.$complex);\n\n    if (f != null) {\n        // method on builtin, provide this arg\n        res = Sk.misceval.callsimArray(f, [op]);\n\n        return res;\n    }\n\n    return null;\n};\n\n/**\n    Check if given argument is number or complex and always\n    returns complex type.\n */\nSk.builtin.complex.check_number_or_complex = function (other) {\n    /* exit early */\n    if (!Sk.builtin.checkNumber(other) && other.tp$name !== \"complex\") {\n        throw new Sk.builtin.TypeError(\"unsupported operand type(s) for +: 'complex' and '\" + Sk.abstr.typeName(other) + \"'\");\n    }\n\n    /* converting to complex allows us to use always only one formula */\n    if (Sk.builtin.checkNumber(other)) {\n        other = new Sk.builtin.complex(other); // create complex\n    }\n\n    return other;\n};\n\n/**\n    Parses a string repr of a complex number\n */\nSk.builtin.complex.complex_subtype_from_string = function (val) {\n    var index;\n    var start;\n    var val_wws;              // val with removed beginning ws and (\n    var x = 0.0, y = 0.0;     // real, imag parts\n    var got_bracket = false;  // flag for braces\n    var len;                  // total length of val\n    var match;                // regex result\n\n    // first check if val is javascript string or python string\n    if (Sk.builtin.checkString(val)) {\n        val = Sk.ffi.remapToJs(val);\n    } else if (typeof val !== \"string\") {\n        throw new TypeError(\"provided unsupported string-alike argument\");\n    }\n\n    /* This is an python specific error, this does not do any harm in js, but we want\n     * to be as close to the orginial impl. as possible.\n     *\n     * Check also for empty strings. They are not allowed.\n     */\n    if (val.indexOf(\"\\0\") !== -1 || val.length === 0 || val === \"\") {\n        throw new Sk.builtin.ValueError(\"complex() arg is a malformed string\");\n    }\n\n    // transform to unicode\n    // ToDo: do we need this?\n    index = 0; // first char\n\n    // do some replacements for javascript floats\n    val = val.replace(/inf|infinity/gi, \"Infinity\");\n    val = val.replace(/nan/gi, \"NaN\");\n\n    /* position on first nonblank */\n    start = 0;\n    while (val[index] === \" \") {\n        index++;\n    }\n\n    if (val[index] === \"(\") {\n        /* skip over possible bracket from repr(). */\n        got_bracket = true;\n        index++;\n        while (val[index] === \" \") {\n            index++;\n        }\n    }\n\n    /* a valid complex string usually takes one of the three forms:\n\n        <float>                - real part only\n        <float>j               - imaginary part only\n        <float><signed-float>j - real and imaginary parts\n\n        where <float> represents any numeric string that's accepted by the\n        float constructor (including 'nan', 'inf', 'infinity', etc.), and\n        <signed-float> is any string of the form <float> whose first character\n        is '+' or '-'.\n\n        For backwards compatibility, the extra forms\n\n          <float><sign>j\n          <sign>j\n          j\n\n        are also accepted, though support for these forms my be removed from\n        a future version of Python.\n     *      This is a complete regular expression for matching any valid python floats, e.g.:\n     *          - 1.0\n     *          - 0.\n     *          - .1\n     *          - nan/inf/infinity\n     *          - +-1.0\n     *          - +3.E-3\n     *\n     *      In order to work, this pattern requires only lower case characters\n     *      There is case insensitive group option in js.\n     *\n     *      the [eE] could be refactored to soley e\n     */\n    var float_regex2 = /^(?:[+-]?(?:(?:(?:\\d*\\.\\d+)|(?:\\d+\\.?))(?:[eE][+-]?\\d+)?|NaN|Infinity))/;\n    val_wws = val.substr(index); // val with removed whitespace and \"(\"\n\n    /* first try to match a float at the beginning */\n    match = val_wws.match(float_regex2);\n    if (match !== null) {\n        // one of the first 4 cases\n        index += match[0].length;\n\n        /* <float>j */\n        if (val[index] === \"j\" || val[index] === \"J\") {\n            y = parseFloat(match[0]);\n            index++;\n        } else if(val[index] === \"+\" || val[index] === \"-\") {\n            /* <float><signed-float>j | <float><sign>j */\n            x = parseFloat(match[0]);\n\n            match = val.substr(index).match(float_regex2);\n            if (match !== null) {\n                /* <float><signed-float>j */\n                y = parseFloat(match[0]);\n                index += match[0].length;\n            } else {\n                /* <float><sign>j */\n                y = val[index] === \"+\" ? 1.0 : -1.0;\n                index++;\n            }\n\n            if (val[index] !== \"j\" && val[index] !== \"J\") {\n                throw new Sk.builtin.ValueError(\"complex() arg is malformed string\");\n            }\n\n            index++;\n        } else {\n            /* <float> */\n            x = parseFloat(match[0]);\n        }\n    } else {\n        // maybe <sign>j or j\n        match = match = val_wws.match(/^([+-]?[jJ])/);\n        if (match !== null) {\n            if (match[0].length === 1) {\n                y = 1.0; // must be j\n            } else {\n                y = match[0][0] === \"+\" ? 1.0 : -1.0;\n            }\n\n            index += match[0].length;\n        }\n    }\n\n    while (val[index] === \" \") {\n        index++;\n    }\n\n    if (got_bracket) {\n        /* if there was an opening parenthesis, then the corresponding\n           closing parenthesis should be right here */\n        if (val[index] !== \")\") {\n            throw new Sk.builtin.ValueError(\"complex() arg is malformed string\");\n        }\n\n        index++;\n\n        while (val[index] === \" \") {\n            index++;\n        }\n    }\n\n    /* we should now be at the end of the string */\n    if (val.length !== index) {\n        throw new Sk.builtin.ValueError(\"complex() arg is malformed string\");\n    }\n\n    // return here complex number parts\n    return new Sk.builtin.complex(new Sk.builtin.float_(x), new Sk.builtin.float_(y));\n};\n\n/**\n    _PyHASH_IMAG refers to _PyHASH_MULTIPLIER which refers to 1000003\n */\nSk.builtin.complex.prototype.tp$hash = function () {\n    return new Sk.builtin.int_(this.tp$getattr(Sk.builtin.str.$imag).v * 1000003 + this.tp$getattr(Sk.builtin.str.$real).v);\n};\n\nSk.builtin.complex.prototype.nb$add = function (other) {\n    var real;\n    var imag;\n\n    other = Sk.builtin.complex.check_number_or_complex(other);\n\n    real = this.tp$getattr(Sk.builtin.str.$real).v + other.tp$getattr(Sk.builtin.str.$real).v;\n    imag = this.tp$getattr(Sk.builtin.str.$imag).v + other.tp$getattr(Sk.builtin.str.$imag).v;\n\n    return new Sk.builtin.complex(new Sk.builtin.float_(real), new Sk.builtin.float_(imag));\n};\n\n/* internal subtract/diff function that calls internal float diff */\nSk.builtin.complex._c_diff = function (a, b) {\n    var r, i; // Py_Float\n    r = a.real.nb$subtract.call(a.real, b.real);\n    i = a.imag.nb$subtract.call(a.imag, b.imag);\n\n    return new Sk.builtin.complex(r, i);\n};\n\nSk.builtin.complex.prototype.nb$subtract = function (other) {\n    var result; // Py_complex\n    var a, b; // Py_complex\n\n    a = Sk.builtin.complex.check_number_or_complex(this);\n    b = Sk.builtin.complex.check_number_or_complex(other);\n\n    result = Sk.builtin.complex._c_diff(a, b);\n\n    return result;\n};\n\nSk.builtin.complex.prototype.nb$multiply = function (other) {\n    var real;\n    var imag;\n    var a, b; // Py_complex\n\n    a = this;\n    b = Sk.builtin.complex.check_number_or_complex(other);\n\n    real = a.real.v * b.real.v - a.imag.v * b.imag.v;\n    imag = a.real.v * b.imag.v + a.imag.v * b.real.v;\n\n    return new Sk.builtin.complex(new Sk.builtin.float_(real), new Sk.builtin.float_(imag));\n};\n\n/**\n * Otherwise google closure complains about ZeroDivisionError not being\n * defined\n * @suppress {missingProperties}\n *\n * implementation based on complexobject.c:c_quot\n */\nSk.builtin.complex.prototype.nb$divide = function (other) {\n    var real;\n    var imag;\n\n    other = Sk.builtin.complex.check_number_or_complex(other);\n\n    var ratio;\n    var denom;\n\n    // other == b\n    var breal = other.real.v;\n    var bimag = other.imag.v;\n    // this == a\n    var areal = this.real.v;\n    var aimag = this.imag.v;\n\n    var abs_breal = Math.abs(breal);\n    var abs_bimag = Math.abs(bimag);\n\n    if (abs_breal >= abs_bimag) {\n        // divide tops and bottom by breal\n        if (abs_breal === 0.0) {\n            throw new Sk.builtin.ZeroDivisionError(\"complex division by zero\");\n        } else {\n            ratio = bimag / breal;\n            denom = breal + bimag * ratio;\n            real = (areal + aimag * ratio) / denom;\n            imag = (aimag - areal * ratio) / denom;\n        }\n    } else if (abs_bimag >= abs_breal) {\n        // divide tops and bottom by b.imag\n        ratio = breal / bimag;\n        denom = breal * ratio + bimag;\n        Sk.asserts.assert(bimag !== 0.0);\n        real = (areal * ratio + aimag) / denom;\n        imag = (aimag * ratio - areal) / denom;\n    } else {\n        // At least one of b.real or b.imag is a NaN\n        real = NaN;\n        imag = NaN;\n    }\n\n    return new Sk.builtin.complex(new Sk.builtin.float_(real), new Sk.builtin.float_(imag));\n};\n\nSk.builtin.complex.prototype.nb$floor_divide = function (other) {\n    throw new Sk.builtin.TypeError(\"can't take floor of complex number.\");\n};\n\nSk.builtin.complex.prototype.nb$remainder = function (other) {\n    throw new Sk.builtin.TypeError(\"can't mod complex numbers.\");\n};\n\n/**\n * @param {?Object=} z, modulo operation\n */\nSk.builtin.complex.prototype.nb$power = function (other, z) {\n    var p;\n    var exponent;\n    var int_exponent;\n    var a, b;\n\n    // none is allowed\n    if (z != null && !Sk.builtin.checkNone(z)) {\n        throw new Sk.builtin.ValueError(\"complex modulo\");\n    }\n\n    a = this;\n    b = Sk.builtin.complex.check_number_or_complex(other);\n\n    exponent = b;\n    int_exponent = b.real.v | 0; // js convert to int\n    if (exponent.imag.v === 0.0 && exponent.real.v === int_exponent) {\n        p = Sk.builtin.complex.c_powi(a, int_exponent);\n    } else {\n        p = Sk.builtin.complex.c_pow(a, exponent);\n    }\n\n    return p;\n};\n\n// power of complex a and complex exponent b\nSk.builtin.complex.c_pow = function (a, b) {\n    var real, imag; // Py_complex\n\n    var vabs;\n    var len;\n    var at;\n    var phase;\n\n    // other == b\n    var breal = b.real.v;\n    var bimag = b.imag.v;\n    // this == a\n    var areal = a.real.v;\n    var aimag = a.imag.v;\n\n    if (breal === 0.0 && bimag === 0.0) {\n        real = 1.0;\n        imag = 0.0;\n    } else if (areal === 0.0 && aimag === 0.0) {\n        if(bimag !== 0.0 || breal < 0.0) {\n            throw new Sk.builtin.ZeroDivisionError(\"complex division by zero\");\n        }\n\n        real = 0.0;\n        imag = 0.0;\n    } else {\n        vabs = Math.hypot(areal, aimag);\n        len = Math.pow(vabs, breal);\n        at = Math.atan2(aimag, areal);\n        phase = at * breal;\n\n        if(bimag !== 0.0) {\n            len /= Math.exp(at * bimag);\n            phase += bimag * Math.log(vabs);\n        }\n\n        real = len * Math.cos(phase);\n        imag = len * Math.sin(phase);\n    }\n\n    return new Sk.builtin.complex(new Sk.builtin.float_(real), new Sk.builtin.float_(imag));\n};\n\n// power of complex x and integer exponent n\nSk.builtin.complex.c_powi = function (x, n) {\n    var cn; // Py_complex\n    var c1;\n\n    if (n > 100 || n < -100) {\n        cn = new Sk.builtin.complex(new Sk.builtin.float_(n), new Sk.builtin.float_(0.0));\n        return Sk.builtin.complex.c_pow(x, cn);\n    } else if (n > 0) {\n        return Sk.builtin.complex.c_powu(x, n);\n    } else {\n        //  return c_quot(c_1,c_powu(x,-n));\n        c1 = new Sk.builtin.complex(new Sk.builtin.float_(1.0), new Sk.builtin.float_(0.0));\n        return c1.nb$divide(Sk.builtin.complex.c_powu(x,-n));\n    }\n};\n\nSk.builtin.complex.c_powu = function (x, n) {\n    var r, p; // Py_complex\n    var mask = 1;\n    r = new Sk.builtin.complex(new Sk.builtin.float_(1.0), new Sk.builtin.float_(0.0));\n    p = x;\n\n    while (mask > 0 && n >= mask) {\n        if (n & mask) {\n            r = r.nb$multiply(p);\n        }\n\n        mask <<= 1;\n        p = p.nb$multiply(p);\n    }\n\n    return r;\n};\n\n\nSk.builtin.complex.prototype.nb$inplace_add = Sk.builtin.complex.prototype.nb$add;\n\nSk.builtin.complex.prototype.nb$inplace_subtract = Sk.builtin.complex.prototype.nb$subtract;\n\nSk.builtin.complex.prototype.nb$inplace_multiply = Sk.builtin.complex.prototype.nb$multiply;\n\nSk.builtin.complex.prototype.nb$inplace_divide = Sk.builtin.complex.prototype.nb$divide;\n\nSk.builtin.complex.prototype.nb$inplace_remainder = Sk.builtin.complex.prototype.nb$remainder;\n\nSk.builtin.complex.prototype.nb$inplace_floor_divide = Sk.builtin.complex.prototype.nb$floor_divide;\n\nSk.builtin.complex.prototype.nb$inplace_power = Sk.builtin.complex.prototype.nb$power;\n\nSk.builtin.complex.prototype.nb$negative = function () {\n    var real;\n    var imag;\n    // this == a\n    var areal = this.real.v;\n    var aimag = this.imag.v;\n\n    real = -areal;\n    imag = -aimag;\n\n    return new Sk.builtin.complex(new Sk.builtin.float_(real), new Sk.builtin.float_(imag));\n};\n\nSk.builtin.complex.prototype.nb$positive = function () {\n    return Sk.builtin.complex.check_number_or_complex(this);\n};\n\n/**\n *  check if op is instance of complex or a sub-type\n */\nSk.builtin.complex._complex_check = function (op) {\n    if (op === undefined) {\n        return false;\n    }\n\n    if (op instanceof Sk.builtin.complex || (op.tp$name && op.tp$name === \"complex\")) {\n        return true;\n    }\n\n    // check if type of ob is a subclass\n    if (Sk.builtin.issubclass(new Sk.builtin.type(op), Sk.builtin.complex)) {\n        return true;\n    }\n\n    return false;\n};\n\nSk.builtin.complex.prototype.tp$richcompare = function (w, op) {\n    var result;\n    var equal;\n    var i;\n\n    if (op !== \"Eq\" && op !== \"NotEq\") {\n        if(Sk.builtin.checkNumber(w) || Sk.builtin.complex._complex_check(w)) {\n            throw new Sk.builtin.TypeError(\"no ordering relation is defined for complex numbers\");\n        }\n\n        return Sk.builtin.NotImplemented.NotImplemented$;\n    }\n\n    // assert(PyComplex_Check(v)));\n    i = Sk.builtin.complex.check_number_or_complex(this);\n    var _real = i.tp$getattr(Sk.builtin.str.$real).v;\n    var _imag = i.tp$getattr(Sk.builtin.str.$imag).v;\n\n    if (Sk.builtin.checkInt(w)) {\n        /* Check for 0.0 imaginary part first to avoid the rich\n         * comparison when possible.\n         */\n\n        // if true, the complex number has just a real part\n        if (_imag === 0.0) {\n            equal = Sk.misceval.richCompareBool(new Sk.builtin.float_(_real), w, op);\n            result = new Sk.builtin.bool(equal);\n            return result;\n        } else {\n            equal = false;\n        }\n    } else if (Sk.builtin.checkFloat(w)) {\n        equal = (_real === Sk.builtin.float_.PyFloat_AsDouble(w) && _imag === 0.0);\n    } else if (Sk.builtin.complex._complex_check(w)) {\n        // ToDo: figure if we need to call to_complex\n        var w_real = w.tp$getattr(Sk.builtin.str.$real).v;\n        var w_imag = w.tp$getattr(Sk.builtin.str.$imag).v;\n        equal = _real === w_real && _imag === w_imag;\n    } else {\n        return Sk.builtin.NotImplemented.NotImplemented$;\n    }\n\n    // invert result if op == NotEq\n    if(op === \"NotEq\") {\n        equal = !equal;\n    }\n\n    // wrap as bool\n    result = new Sk.builtin.bool(equal);\n\n    return result;\n};\n\n// Despite what jshint may want us to do, these two  functions need to remain\n// as == and !=  Unless you modify the logic of numberCompare do not change\n// these.\nSk.builtin.complex.prototype.__eq__ = function (me, other) {\n    return Sk.builtin.complex.prototype.tp$richcompare.call(me, other, \"Eq\");\n};\n\nSk.builtin.complex.prototype.__ne__ = function (me, other) {\n    return Sk.builtin.complex.prototype.tp$richcompare.call(me, other, \"NotEq\");\n};\n\n/**\n * Do we really need to implement those? Otherwise I can't find in Sk.abstr a place where this particular\n * expcetion is thrown.git co\n */\nSk.builtin.complex.prototype.__lt__ = function (me, other) {\n    throw new Sk.builtin.TypeError(\"unorderable types: \" + Sk.abstr.typeName(me) + \" < \" + Sk.abstr.typeName(other));\n};\n\nSk.builtin.complex.prototype.__le__ = function (me, other) {\n    throw new Sk.builtin.TypeError(\"unorderable types: \" + Sk.abstr.typeName(me) + \" <= \" + Sk.abstr.typeName(other));\n};\n\nSk.builtin.complex.prototype.__gt__ = function (me, other) {\n    throw new Sk.builtin.TypeError(\"unorderable types: \" + Sk.abstr.typeName(me) + \" > \" + Sk.abstr.typeName(other));\n};\n\nSk.builtin.complex.prototype.__ge__ = function (me, other) {\n    throw new Sk.builtin.TypeError(\"unorderable types: \" + Sk.abstr.typeName(me) + \" >= \" + Sk.abstr.typeName(other));\n};\n\nSk.builtin.complex.prototype.__float__ = function (self) {\n    throw new Sk.builtin.TypeError(\"can't convert complex to float\");\n};\n\nSk.builtin.complex.prototype.__int__ = function (self) {\n    throw new Sk.builtin.TypeError(\"can't convert complex to int\");\n};\n\n\nSk.builtin.complex.prototype._internalGenericGetAttr = Sk.builtin.object.prototype.GenericGetAttr;\n\n/**\n * Custom getattr impl. to get the c.real and c.imag to work. Though we should\n * consider to implement tp$members that always are attributs on the class and\n * will be used in the genericgetattr method.\n * Would be super easy to implement the readonly stuff too.\n *\n */\nSk.builtin.complex.prototype.tp$getattr = function (name) {\n    if (name != null && (Sk.builtin.checkString(name) || typeof name === \"string\")) {\n        var _name = name;\n\n        // get javascript string\n        if (Sk.builtin.checkString(name)) {\n            _name = Sk.ffi.remapToJs(name);\n        }\n\n        if (_name === \"real\" || _name === \"imag\") {\n            return this[_name];\n        }\n    }\n\n    // if we have not returned yet, try the genericgetattr\n    return this._internalGenericGetAttr(name);\n};\n\n\nSk.builtin.complex.prototype.tp$setattr = function (name, value) {\n    if (name != null && (Sk.builtin.checkString(name) || typeof name === \"string\")) {\n        var _name = name;\n\n        // get javascript string\n        if (Sk.builtin.checkString(name)) {\n            _name = Sk.ffi.remapToJs(name);\n        }\n\n        if (_name === \"real\" || _name === \"imag\") {\n            throw new Sk.builtin.AttributeError(\"readonly attribute\");\n        }\n    }\n\n    // builtin: --> all is readonly (I am not happy with this)\n    throw new Sk.builtin.AttributeError(\"'complex' object attribute '\" + name + \"' is readonly\");\n};\n\n/**\n * Internal format function for repr and str\n * It is not intended for __format__ calls\n *\n * This functions assumes, that v is always instance of Sk.builtin.complex\n */\nSk.builtin.complex.complex_format = function (v, precision, format_code){\n    function copysign (a, b) {\n        return b < 0 ? -Math.abs(a) : Math.abs(a);\n    }\n\n    if (v == null || !Sk.builtin.complex._complex_check(v)) {\n        throw new Error(\"Invalid internal method call: Sk.complex.complex_format() called with invalid value type.\");\n    }\n\n    var result; // PyObject\n\n    var pre = \"\";\n    var im = \"\";\n    var re = null;\n    var lead = \"\";\n    var tail = \"\";\n\n    if (v.real.v === 0.0 && copysign(1.0, v.real.v) == 1.0) {\n        re = \"\";\n        im = Sk.builtin.complex.PyOS_double_to_string(v.imag.v, format_code, precision, 0, null);\n        // im = v.imag.v;\n    } else {\n        /* Format imaginary part with sign, real part without */\n        pre = Sk.builtin.complex.PyOS_double_to_string(v.real.v, format_code, precision, 0, null);\n        re = pre;\n\n        im = Sk.builtin.complex.PyOS_double_to_string(v.imag.v, format_code, precision, Sk.builtin.complex.PyOS_double_to_string.Py_DTSF_SIGN, null);\n\n        if (v.imag.v === 0 && 1/v.imag.v === -Infinity && im && im[0] !== \"-\"){\n            im = \"-\" + im; // force negative zero sign\n        }\n\n        lead = \"(\";\n        tail = \")\";\n    }\n\n    result = \"\" + lead + re + im + \"j\" + tail; // concat all parts\n\n    return new Sk.builtin.str(result);\n};\n\nSk.builtin.complex.prototype[\"$r\"] = function () {\n    return Sk.builtin.complex.complex_format(this, 0, \"r\");\n};\n\nSk.builtin.complex.prototype.tp$str = function () {\n    return Sk.builtin.complex.complex_format(this, null, \"g\"); // g, 12 == Py_Float_STR_PRECISION\n};\n\n/**\n * https://hg.python.org/cpython/file/3cf2990d19ab/Objects/complexobject.c#l907\n * also see _PyComplex_FormatAdvanced\n *\n * We currently use the signature (self, format_spec) instead of (self, args). So we do\n * not need to unwrap the args.\n */\nSk.builtin.complex.prototype.int$format = function __format__(self, format_spec){\n    var result; // PyObject\n\n    if (format_spec == null) {\n        return null;\n    }\n\n    if (Sk.builtin.checkString(format_spec)) {\n        result = Sk.builtin.complex._PyComplex_FormatAdvanced(self, format_spec);\n\n        return result;\n    }\n\n\n    throw new Sk.builtin.TypeError(\"__format__ requires str or unicode\");\n};\nSk.builtin.complex.prototype.int$format.co_name = new Sk.builtin.str(\"__format__\");\nSk.builtin.complex.prototype.__format__ = new Sk.builtin.func(Sk.builtin.complex.prototype.int$format);\n\nSk.builtin.complex._PyComplex_FormatAdvanced = function(self, format_spec) {\n    throw new Sk.builtin.NotImplementedError(\"__format__ is not implemented for complex type.\");\n};\n\n/**\n    Return true if float or double are is neither infinite nor NAN, else false\n    Value is already a Javascript object\n */\nSk.builtin.complex._is_finite = function (val) {\n    return !isNaN(val) && val !== Infinity && val !== -Infinity;\n};\n\nSk.builtin.complex._is_infinity = function (val) {\n    return val === Infinity || val === -Infinity;\n};\n\n/**\n * @suppress {missingProperties}\n */\nSk.builtin.complex.prototype.int$abs = function __abs__(self) {\n    var result;\n    var _real = self.real.v;\n    var _imag = self.imag.v;\n\n    if (!Sk.builtin.complex._is_finite(_real) || !Sk.builtin.complex._is_finite(_imag)) {\n        /* C99 rules: if either the real or the imaginary part is an\n           infinity, return infinity, even if the other part is a\n           NaN.\n        */\n\n        if (Sk.builtin.complex._is_infinity(_real)) {\n            result = Math.abs(_real);\n            return new Sk.builtin.float_(result);\n        }\n\n        if (Sk.builtin.complex._is_infinity(_imag)) {\n            result = Math.abs(_imag);\n            return new Sk.builtin.float_(result);\n        }\n\n        /* either the real or imaginary part is a NaN,\n           and neither is infinite. Result should be NaN. */\n\n        return new Sk.builtin.float_(NaN);\n    }\n\n    result = Math.hypot(_real, _imag);\n\n    if (!Sk.builtin.complex._is_finite(result)) {\n        throw new Sk.builtin.OverflowError(\"absolute value too large\");\n    }\n\n    return new Sk.builtin.float_(result);\n};\nSk.builtin.complex.prototype.int$abs.co_name = new Sk.builtin.str(\"__abs__\");\nSk.builtin.complex.prototype.__abs__ = new Sk.builtin.func(Sk.builtin.complex.prototype.int$abs);\n\nSk.builtin.complex.prototype.int$bool = function __bool__(self) {\n    return new Sk.builtin.bool(self.tp$getattr(Sk.builtin.str.$real).v || self.tp$getattr(Sk.builtin.str.$real).v);\n};\nSk.builtin.complex.prototype.int$bool.co_name = new Sk.builtin.str(\"__bool__\");\nSk.builtin.complex.prototype.__bool__ = new Sk.builtin.func(Sk.builtin.complex.prototype.int$bool);\n\nSk.builtin.complex.prototype.int$truediv = function __truediv__(self, other){\n    Sk.builtin.pyCheckArgsLen(\"__truediv__\", arguments.length, 1, 1, true);\n    return self.nb$divide.call(self, other);\n};\nSk.builtin.complex.prototype.int$truediv.co_name = new Sk.builtin.str(\"__truediv__\");\nSk.builtin.complex.prototype.__truediv__ = new Sk.builtin.func(Sk.builtin.complex.prototype.int$truediv);\n\nSk.builtin.complex.prototype.int$hash = function __hash__(self){\n    Sk.builtin.pyCheckArgsLen(\"__hash__\", arguments.length, 0, 0, true);\n\n    return self.tp$hash.call(self);\n};\nSk.builtin.complex.prototype.int$hash.co_name = new Sk.builtin.str(\"__hash__\");\nSk.builtin.complex.prototype.__hash__ = new Sk.builtin.func(Sk.builtin.complex.prototype.int$hash);\n\nSk.builtin.complex.prototype.int$add = function __add__(self, other){\n    Sk.builtin.pyCheckArgsLen(\"__add__\", arguments.length, 1, 1, true);\n    return self.nb$add.call(self, other);\n};\nSk.builtin.complex.prototype.int$add.co_name = new Sk.builtin.str(\"__add__\");\nSk.builtin.complex.prototype.__add__ = new Sk.builtin.func(Sk.builtin.complex.prototype.int$add);\n\n\nSk.builtin.complex.prototype.int$repr = function __repr__(self){\n    Sk.builtin.pyCheckArgsLen(\"__repr__\", arguments.length, 0, 0, true);\n\n    return self[\"r$\"].call(self);\n};\nSk.builtin.complex.prototype.int$repr.co_name = new Sk.builtin.str(\"__repr__\");\nSk.builtin.complex.prototype.__repr__ = new Sk.builtin.func(Sk.builtin.complex.prototype.int$repr);\n\nSk.builtin.complex.prototype.int$str = function __str__(self){\n    Sk.builtin.pyCheckArgsLen(\"__str__\", arguments.length, 0, 0, true);\n\n    return self.tp$str.call(self);\n};\nSk.builtin.complex.prototype.int$str.co_name = new Sk.builtin.str(\"__str__\");\nSk.builtin.complex.prototype.__str__ = new Sk.builtin.func(Sk.builtin.complex.prototype.int$str);\n\nSk.builtin.complex.prototype.int$sub = function __sub__(self, other){\n    Sk.builtin.pyCheckArgsLen(\"__sub__\", arguments.length, 1, 1, true);\n    return self.nb$subtract.call(self, other);\n};\nSk.builtin.complex.prototype.int$sub.co_name = new Sk.builtin.str(\"__sub__\");\nSk.builtin.complex.prototype.__sub__ = new Sk.builtin.func(Sk.builtin.complex.prototype.int$sub);\n\nSk.builtin.complex.prototype.int$mul = function __mul__(self, other){\n    Sk.builtin.pyCheckArgsLen(\"__mul__\", arguments.length, 1, 1, true);\n    return self.nb$multiply.call(self, other);\n};\nSk.builtin.complex.prototype.int$mul.co_name = new Sk.builtin.str(\"__mul__\");\nSk.builtin.complex.prototype.__mul__ = new Sk.builtin.func(Sk.builtin.complex.prototype.int$mul);\n\nSk.builtin.complex.prototype.int$div = function __div__(self, other){\n    Sk.builtin.pyCheckArgsLen(\"__div__\", arguments.length, 1, 1, true);\n    return self.nb$divide.call(self, other);\n};\nSk.builtin.complex.prototype.int$div.co_name = new Sk.builtin.str(\"__div__\");\nSk.builtin.complex.prototype.__div__ = new Sk.builtin.func(Sk.builtin.complex.prototype.int$div);\n\nSk.builtin.complex.prototype.int$floordiv = function __floordiv__(self, other){\n    Sk.builtin.pyCheckArgsLen(\"__floordiv__\", arguments.length, 1, 1, true);\n    return self.nb$floor_divide.call(self, other);\n};\nSk.builtin.complex.prototype.int$floordiv.co_name = new Sk.builtin.str(\"__floordiv__\");\nSk.builtin.complex.prototype.__floordiv__ = new Sk.builtin.func(Sk.builtin.complex.prototype.int$floordiv);\n\nSk.builtin.complex.prototype.int$mod = function __mod__(self, other){\n    Sk.builtin.pyCheckArgsLen(\"__mod__\", arguments.length, 1, 1, true);\n    return self.nb$remainder.call(self, other);\n};\nSk.builtin.complex.prototype.int$mod.co_name = new Sk.builtin.str(\"__mod__\");\nSk.builtin.complex.prototype.__mod__ = new Sk.builtin.func(Sk.builtin.complex.prototype.int$mod);\n\nSk.builtin.complex.prototype.int$pow = function __pow__(self, other, z){\n    Sk.builtin.pyCheckArgsLen(\"__pow__\", arguments.length, 1, 2, true);\n    return self.nb$power.call(self, other, z);\n};\nSk.builtin.complex.prototype.int$pow.co_name = new Sk.builtin.str(\"__pow__\");\nSk.builtin.complex.prototype.__pow__ = new Sk.builtin.func(Sk.builtin.complex.prototype.int$pow);\n\nSk.builtin.complex.prototype.int$neg = function __neg__(self){\n    Sk.builtin.pyCheckArgsLen(\"__neg__\", arguments.length, 0, 0, true);\n    return self.nb$negative.call(self);\n};\nSk.builtin.complex.prototype.__neg__ = new Sk.builtin.func(Sk.builtin.complex.prototype.int$neg);\n\nSk.builtin.complex.prototype.int$pos = function __pos__(self){\n    Sk.builtin.pyCheckArgsLen(\"__pos__\", arguments.length, 0, 0, true);\n    return self.nb$positive.call(self);\n};\nSk.builtin.complex.prototype.int$pos.co_name = new Sk.builtin.str(\"__pos__\");\nSk.builtin.complex.prototype.__pos__ = new Sk.builtin.func(Sk.builtin.complex.prototype.int$pos);\n\nSk.builtin.complex.prototype.int$conjugate = function conjugate(self){\n    Sk.builtin.pyCheckArgsLen(\"conjugate\", arguments.length, 0, 0, true);\n    var _imag = self.imag.v;\n    _imag = -_imag;\n\n    return new Sk.builtin.complex(self.real, new Sk.builtin.float_(_imag));\n};\nSk.builtin.complex.prototype.int$conjugate.co_name = new Sk.builtin.str(\"conjugate\");\nSk.builtin.complex.prototype.conjugate = new Sk.builtin.func(Sk.builtin.complex.prototype.int$conjugate);\n\n// deprecated\nSk.builtin.complex.prototype.int$divmod = function __divmod__(self, other){\n    Sk.builtin.pyCheckArgsLen(\"__divmod__\", arguments.length, 1, 1, true);\n\n    var div, mod; // Py_complex\n    var d, m, z; // PyObject\n    var a, b; // Py_complex\n    a = Sk.builtin.complex.check_number_or_complex(self);\n    b = Sk.builtin.complex.check_number_or_complex(other);\n\n    div = a.nb$divide.call(a, b); // the raw divisor value\n\n    div.real = new Sk.builtin.float_(Math.floor(div.real.v));\n    div.imag = new Sk.builtin.float_(0.0);\n\n    mod = a.nb$subtract.call(a, b.nb$multiply.call(b, div));\n\n    z = new Sk.builtin.tuple([div, mod]);\n\n    return z;\n};\nSk.builtin.complex.prototype.int$divmod.co_name = new Sk.builtin.str(\"__divmod__\");\nSk.builtin.complex.prototype.__divmod__ = new Sk.builtin.func(Sk.builtin.complex.prototype.int$divmod);\n\nSk.builtin.complex.prototype.int$getnewargs = function __getnewargs__(self){\n    Sk.builtin.pyCheckArgsLen(\"__getnewargs__\", arguments.length, 0, 0, true);\n\n    return new Sk.builtin.tuple([self.real, self.imag]);\n};\nSk.builtin.complex.prototype.int$getnewargs.co_name = new Sk.builtin.str(\"__getnewargs__\");\nSk.builtin.complex.prototype.__getnewargs__ = new Sk.builtin.func(Sk.builtin.complex.prototype.int$getnewargs);\n\nSk.builtin.complex.prototype.int$nonzero = function __nonzero__(self){\n    Sk.builtin.pyCheckArgsLen(\"__nonzero__\", arguments.length, 0, 0, true);\n\n    if(self.real.v !== 0.0 || self.imag.v !== 0.0) {\n        return Sk.builtin.bool.true$;\n    } else {\n        return Sk.builtin.bool.false$;\n    }\n};\nSk.builtin.complex.prototype.int$nonzero.co_name = new Sk.builtin.str(\"__nonzero__\");\nSk.builtin.complex.prototype.__nonzero__ = new Sk.builtin.func(Sk.builtin.complex.prototype.int$nonzero);\n\n\n// ToDo: think about inplace methods too\nSk.exportSymbol(\"Sk.builtin.complex\", Sk.builtin.complex);\n\n\n/**\n * Convert a double val to a string using supplied format_code, precision, and flags.\n *\n * format_code must be one of 'e', 'E', 'f', 'F', 'g', 'G' or 'r'. For 'r', the supplied precision must be 0 and is ignored. The 'r' format code specifies the standard repr() format.\n *\n * flags can be zero or more of the values Py_DTSF_SIGN, Py_DTSF_ADD_DOT_0, or Py_DTSF_ALT, or-ed together:\n *\n * Py_DTSF_SIGN means to always precede the returned string with a sign character, even if val is non-negative.\n * Py_DTSF_ADD_DOT_0 means to ensure that the returned string will not look like an integer.\n * Py_DTSF_ALT means to apply alternate formatting rules. See the documentation for the PyOS_snprintf() '#' specifier for details.\n * If ptype is non-NULL, then the value it points to will be set to one of Py_DTST_FINITE, Py_DTST_INFINITE, or Py_DTST_NAN, signifying that val is a finite number, an\n * infinite number, or not a number, respectively.\n */\nSk.builtin.complex.PyOS_double_to_string = function(val, format_code, precision, flags, type) {\n    var format;\n    var buf;\n    var t;\n    var exp;\n    var upper = false;\n\n    // Validate format code, and map upper and lower case\n    switch(format_code) {\n        case \"e\": /* exponent */\n        case \"f\": /* fixed */\n        case \"g\": /* general */\n            break;\n        case \"E\":\n            upper = true;\n            format_code = \"e\";\n            break;\n        case \"F\":\n            upper = true;\n            format_code = \"f\";\n            break;\n        case \"r\": /* repr format */\n            // Supplied precision is unused, must be 0.\n            if(precision !== 0) {\n                throw new Error(\"Bad internall call\"); // only happens when somebody messes up calling this in js\n            }\n\n            // repr() precision is 17 significant decimal digits\n            precision = 17;\n            format_code = \"g\";\n            break;\n        default:\n            throw new Error(\"Bad internall call\");\n    }\n\n    // no need for buffer size calculation like in cpython\n\n    // Handle nan and inf\n    if(isNaN(val)) {\n        buf = \"nan\";\n        t = Sk.builtin.complex.PyOS_double_to_string.Py_DTST_NAN;\n    } else if (val === Infinity) {\n        buf = \"inf\";\n        t = Sk.builtin.complex.PyOS_double_to_string.Py_DTST_INFINITE;\n    } else if (val === -Infinity) {\n        buf = \"-inf\";\n        t = Sk.builtin.complex.PyOS_double_to_string.Py_DTST_INFINITE;\n    } else {\n        t = Sk.builtin.complex.PyOS_double_to_string.Py_DTST_FINITE;\n        if(flags & Sk.builtin.complex.PyOS_double_to_string.Py_DTSF_ADD_DOT_0) {\n            format_code = \"g\"; // \"Z\"; _PyOS_ascii_formatd converts \"Z\" to \"g\"\n        }\n\n        // ToDo: call snprintf here\n        // ToDo: call ascii_formatd\n        var format_str = \"%\";\n        format_str += flags & Sk.builtin.complex.PyOS_double_to_string.Py_DTSF_ALT ? \"#\" : \"\";\n\n        if(precision != null) {\n            format_str += \".\";\n            format_str += precision;\n        }\n\n        format_str += format_code;\n        format_str = new Sk.builtin.str(format_str);\n\n        /**\n         * We cann call nb$remainder with val, because it gets unwrapped and it doesn't matter if it is\n         * already a javascript number. If we do not pass a float, we can't distinguish between ints and floats\n         * and therefore we can't adjust the sign of the zero accordingly\n         */\n        buf = format_str.nb$remainder(new Sk.builtin.float_(val));\n        buf = buf.v; // get javascript string\n    }\n\n    /**\n     * Add sign when requested. It's convenient (esp. when formatting complex numbers) to\n     * include sign even for inf and nan.\n     */\n    if(flags & Sk.builtin.complex.PyOS_double_to_string.Py_DTSF_SIGN && buf[0] !== \"-\") {\n        buf = \"+\" + buf;\n    }\n\n    if(upper) {\n        // Convert to upper case\n        buf = buf.toUpperCase();\n    }\n\n    return buf;\n};\n\n/* PyOS_double_to_string's \"flags\" parameter can be set to 0 or more of: */\nSk.builtin.complex.PyOS_double_to_string.Py_DTSF_SIGN = 0x01; // always add the sign\nSk.builtin.complex.PyOS_double_to_string.Py_DTSF_ADD_DOT_0 = 0x02; // if the result is an integer add \".0\"\nSk.builtin.complex.PyOS_double_to_string.Py_DTSF_ALT = 0x04; // \"alternate\" formatting. it's format_code specific\n\n/* PyOS_double_to_string's \"type\", if non-NULL, will be set to one of: */\nSk.builtin.complex.PyOS_double_to_string.Py_DTST_FINITE = 0;\nSk.builtin.complex.PyOS_double_to_string.Py_DTST_INFINITE = 1;\nSk.builtin.complex.PyOS_double_to_string.Py_DTST_NAN = 2;\n","/**\n * @constructor\n * @param {Object} start\n * @param {Object=} stop\n * @param {Object=} step\n */\nSk.builtin.slice = function slice (start, stop, step) {\n    Sk.builtin.pyCheckArgsLen(\"slice\", arguments.length, 1, 3, false, false);\n\n    if ((step !== undefined) && Sk.misceval.isIndex(step) && (Sk.misceval.asIndex(step) === 0)) {\n        throw new Sk.builtin.ValueError(\"slice step cannot be zero\");\n    }\n\n    if (!(this instanceof Sk.builtin.slice)) {\n        return new Sk.builtin.slice(start, stop, step);\n    }\n\n\n    if (stop === undefined && step === undefined) {\n        stop = start;\n        start = Sk.builtin.none.none$;\n    }\n    if (stop === undefined) {\n        stop = Sk.builtin.none.none$;\n    }\n    if (step === undefined) {\n        step = Sk.builtin.none.none$;\n    }\n    this.start = start;\n    this.stop = stop;\n    this.step = step;\n\n    this.__class__ = Sk.builtin.slice;\n\n    this[\"$d\"] = new Sk.builtin.dict([Sk.builtin.slice$start, this.start,\n                                      Sk.builtin.slice$stop, this.stop,\n                                      Sk.builtin.slice$step, this.step]);\n\n    return this;\n};\n\nSk.abstr.setUpInheritance(\"slice\", Sk.builtin.slice, Sk.builtin.object);\n\nSk.builtin.slice.prototype[\"$r\"] = function () {\n    var a = Sk.builtin.repr(this.start).v;\n    var b = Sk.builtin.repr(this.stop).v;\n    var c = Sk.builtin.repr(this.step).v;\n    return new Sk.builtin.str(\"slice(\" + a + \", \" + b + \", \" + c + \")\");\n};\n\nSk.builtin.slice.prototype.tp$richcompare = function (w, op) {\n    // w not a slice\n    var t1, t2;\n    if (!w.__class__ || w.__class__ != Sk.builtin.slice) {\n        // shortcuts for eq/not\n        if (op === \"Eq\") {\n            return false;\n        }\n        if (op === \"NotEq\") {\n            return true;\n        }\n\n        // todo; other types should have an arbitrary order\n        return false;\n    }\n\n    // This is how CPython does it\n    t1 = new Sk.builtin.tuple([this.start, this.stop, this.step]);\n    t2 = new Sk.builtin.tuple([w.start, w.stop, w.step]);\n\n    return t1.tp$richcompare(t2, op);\n};\n\n/* Internal indices function */\nSk.builtin.slice.prototype.slice_indices_ = function (length) {\n    var start, stop, step;\n\n    if (Sk.builtin.checkNone(this.start)) {\n        start = null;\n    } else if (Sk.misceval.isIndex(this.start)) {\n        start = Sk.misceval.asIndex(this.start);\n    } else {\n        throw new Sk.builtin.TypeError(\"slice indices must be integers or None\");\n    }\n\n    if (Sk.builtin.checkNone(this.stop)) {\n        stop = null;\n    } else if (Sk.misceval.isIndex(this.stop)) {\n        stop = Sk.misceval.asIndex(this.stop);\n    } else {\n        throw new Sk.builtin.TypeError(\"slice indices must be integers or None\");\n    }\n\n    if (Sk.builtin.checkNone(this.step)) {\n        step = null;\n    } else if (Sk.misceval.isIndex(this.step)) {\n        step = Sk.misceval.asIndex(this.step);\n    } else {\n        throw new Sk.builtin.TypeError(\"slice indices must be integers or None\");\n    }\n\n    // this seems ugly, better way?\n    if (step === null) {\n        step = 1;\n    }\n    if (step > 0) {\n        if (start === null) {\n            start = 0;\n        }\n        if (stop === null) {\n            stop = length;\n        }\n        if (stop > length) {\n            stop = length;\n        }\n        if (start < 0) {\n            start = length + start;\n            if (start < 0) {\n                start = 0;\n            }\n        }\n        if (stop < 0) {\n            stop = length + stop;\n        }\n    } else {\n        if (start === null) {\n            start = length - 1;\n        }\n        if (start >= length) {\n            start = length - 1;\n        }\n        if (stop === null) {\n            stop = -1;\n        } else if (stop < 0) {\n            stop = length + stop;\n            if (stop < 0) {\n                stop = -1;\n            }\n        }\n        if (start < 0) {\n            start = length + start;\n        }\n    }\n\n    return [start, stop, step];\n};\n\nSk.builtin.slice.prototype[\"indices\"] = new Sk.builtin.func(function (self, length) {\n    Sk.builtin.pyCheckArgsLen(\"indices\", arguments.length, 2, 2, false, false);\n\n    length = Sk.builtin.asnum$(length);\n    var sss = self.slice_indices_(length);\n\n    return new Sk.builtin.tuple([\n        new Sk.builtin.int_(sss[0]), \n        new Sk.builtin.int_(sss[1]), \n        new Sk.builtin.int_(sss[2])\n    ]);\n});\n\nSk.builtin.slice.prototype.sssiter$ = function (wrt, f) {\n    var i;\n    var wrtv = Sk.builtin.asnum$(wrt);\n    var sss = this.slice_indices_(typeof wrtv === \"number\" ? wrtv : wrt.v.length);\n    if (sss[2] > 0) {\n        for (i = sss[0]; i < sss[1]; i += sss[2]) {\n            if (f(i, wrtv) === false) {\n                return;\n            }\n        }\t//\twrt or wrtv? RNL\n    } else {\n        for (i = sss[0]; i > sss[1]; i += sss[2]) {\n            if (f(i, wrtv) === false) {\n                return;\n            }\n        }\t//\twrt or wrtv? RNL\n\n    }\n};\n\nSk.builtin.slice$start = new Sk.builtin.str(\"start\");\nSk.builtin.slice$stop = new Sk.builtin.str(\"stop\");\nSk.builtin.slice$step = new Sk.builtin.str(\"step\");\n","/**\n * @constructor\n * @param {Array.<Object>} S\n */\nSk.builtin.set = function (S) {\n    var it, i;\n    var S_list;\n    if (!(this instanceof Sk.builtin.set)) {\n        Sk.builtin.pyCheckArgsLen(\"set\", arguments.length, 0, 1);\n        return new Sk.builtin.set(S);\n    }\n\n\n    if (typeof(S) === \"undefined\") {\n        S = [];\n    }\n\n    this.set_reset_();\n    S_list = new Sk.builtin.list(S);\n    // python sorts sets on init, but not thereafter.\n    // Skulpt seems to init a new set each time you add/remove something\n    //Sk.builtin.list.prototype['sort'].func_code(S);\n    for (it = Sk.abstr.iter(S_list), i = it.tp$iternext(); i !== undefined; i = it.tp$iternext()) {\n        Sk.builtin.set.prototype[\"add\"].func_code(this, i);\n    }\n\n    this.__class__ = Sk.builtin.set;\n\n    this[\"v\"] = this.v;\n    return this;\n};\nSk.abstr.setUpInheritance(\"set\", Sk.builtin.set, Sk.builtin.object);\nSk.abstr.markUnhashable(Sk.builtin.set);\n\nSk.builtin.set.prototype.set_reset_ = function () {\n    this.v = new Sk.builtin.dict([]);\n};\n\nSk.builtin.set.prototype[\"$r\"] = function () {\n    var it, i;\n    var ret = [];\n    for (it = Sk.abstr.iter(this), i = it.tp$iternext(); i !== undefined; i = it.tp$iternext()) {\n        ret.push(Sk.misceval.objectRepr(i).v);\n    }\n\n    if(Sk.__future__.set_repr) {\n        if (ret.length === 0) {\n            return new Sk.builtin.str(\"set()\");\n        } else {\n            return new Sk.builtin.str(\"{\" + ret.join(\", \") + \"}\");\n        }\n    } else {\n        return new Sk.builtin.str(\"set([\" + ret.join(\", \") + \"])\");\n    }\n};\n\nSk.builtin.set.prototype.ob$eq = function (other) {\n\n    if (this === other) {\n        return Sk.builtin.bool.true$;\n    }\n\n    if (!(other instanceof Sk.builtin.set)) {\n        return Sk.builtin.bool.false$;\n    }\n\n    if (Sk.builtin.set.prototype.sq$length.call(this) !==\n        Sk.builtin.set.prototype.sq$length.call(other)) {\n        return Sk.builtin.bool.false$;\n    }\n\n    return this[\"issubset\"].func_code(this, other);\n};\n\nSk.builtin.set.prototype.ob$ne = function (other) {\n\n    if (this === other) {\n        return Sk.builtin.bool.false$;\n    }\n\n    if (!(other instanceof Sk.builtin.set)) {\n        return Sk.builtin.bool.true$;\n    }\n\n    if (Sk.builtin.set.prototype.sq$length.call(this) !==\n        Sk.builtin.set.prototype.sq$length.call(other)) {\n        return Sk.builtin.bool.true$;\n    }\n\n    if (this[\"issubset\"].func_code(this, other).v) {\n        return Sk.builtin.bool.false$;\n    } else {\n        return Sk.builtin.bool.true$;\n    }\n};\n\nSk.builtin.set.prototype.ob$lt = function (other) {\n\n    if (this === other) {\n        return Sk.builtin.bool.false$;\n    }\n\n    if (Sk.builtin.set.prototype.sq$length.call(this) >=\n        Sk.builtin.set.prototype.sq$length.call(other)) {\n        return Sk.builtin.bool.false$;\n    }\n\n    return this[\"issubset\"].func_code(this, other);\n};\n\nSk.builtin.set.prototype.ob$le = function (other) {\n\n    if (this === other) {\n        return Sk.builtin.bool.true$;\n    }\n\n    if (Sk.builtin.set.prototype.sq$length.call(this) >\n        Sk.builtin.set.prototype.sq$length.call(other)) {\n        return Sk.builtin.bool.false$;\n    }\n\n    return this[\"issubset\"].func_code(this, other);\n};\n\nSk.builtin.set.prototype.ob$gt = function (other) {\n\n    if (this === other) {\n        return Sk.builtin.bool.false$;\n    }\n\n    if (Sk.builtin.set.prototype.sq$length.call(this) <=\n        Sk.builtin.set.prototype.sq$length.call(other)) {\n        return Sk.builtin.bool.false$;\n    }\n\n    return this[\"issuperset\"].func_code(this, other);\n};\n\nSk.builtin.set.prototype.ob$ge = function (other) {\n\n    if (this === other) {\n        return Sk.builtin.bool.true$;\n    }\n\n    if (Sk.builtin.set.prototype.sq$length.call(this) <\n        Sk.builtin.set.prototype.sq$length.call(other)) {\n        return Sk.builtin.bool.false$;\n    }\n\n    return this[\"issuperset\"].func_code(this, other);\n};\n\nSk.builtin.set.prototype.nb$and = function(other){\n    return this[\"intersection\"].func_code(this, other);\n};\n\nSk.builtin.set.prototype.nb$or = function(other){\n    return this[\"union\"].func_code(this, other);\n};\n\nSk.builtin.set.prototype.nb$xor = function(other){\n    return this[\"symmetric_difference\"].func_code(this, other);\n};\n\nSk.builtin.set.prototype.nb$subtract = function(other){\n    return this[\"difference\"].func_code(this, other);\n};\n\nSk.builtin.set.prototype[\"__iter__\"] = new Sk.builtin.func(function (self) {\n    Sk.builtin.pyCheckArgsLen(\"__iter__\", arguments.length, 0, 0, false, true);\n    return new Sk.builtin.set_iter_(self);\n});\n\nSk.builtin.set.prototype.tp$iter = function () {\n    return new Sk.builtin.set_iter_(this);\n};\n\nSk.builtin.set.prototype.sq$length = function () {\n    return this[\"v\"].mp$length();\n};\n\nSk.builtin.set.prototype.sq$contains = function(ob) {\n    return this[\"v\"].sq$contains(ob);\n};\n\nSk.builtin.set.prototype[\"isdisjoint\"] = new Sk.builtin.func(function (self, other) {\n    // requires all items in self to not be in other\n    var isIn;\n    var it, item;\n\n    Sk.builtin.pyCheckArgsLen(\"isdisjoint\", arguments.length, 2, 2);\n    if (!Sk.builtin.checkIterable(other)) {\n        throw new Sk.builtin.TypeError(\"'\" + Sk.abstr.typeName(other) + \"' object is not iterable\");\n    }\n\n    for (it = Sk.abstr.iter(self), item = it.tp$iternext(); item !== undefined; item = it.tp$iternext()) {\n        isIn = Sk.abstr.sequenceContains(other, item);\n        if (isIn) {\n            return Sk.builtin.bool.false$;\n        }\n    }\n    return Sk.builtin.bool.true$;\n});\n\nSk.builtin.set.prototype[\"issubset\"] = new Sk.builtin.func(function (self, other) {\n    var isIn;\n    var it, item;\n    var selfLength, otherLength;\n\n    Sk.builtin.pyCheckArgsLen(\"issubset\", arguments.length, 2, 2);\n    if (!Sk.builtin.checkIterable(other)) {\n        throw new Sk.builtin.TypeError(\"'\" + Sk.abstr.typeName(other) + \"' object is not iterable\");\n    }\n\n    selfLength = self.sq$length();\n    otherLength = other.sq$length();\n\n    if (selfLength > otherLength) {\n        // every item in this set can't be in other if it's shorter!\n        return Sk.builtin.bool.false$;\n    }\n    for (it = Sk.abstr.iter(self), item = it.tp$iternext(); item !== undefined; item = it.tp$iternext()) {\n        isIn = Sk.abstr.sequenceContains(other, item);\n        if (!isIn) {\n            return Sk.builtin.bool.false$;\n        }\n    }\n    return Sk.builtin.bool.true$;\n});\n\nSk.builtin.set.prototype[\"issuperset\"] = new Sk.builtin.func(function (self, other) {\n    Sk.builtin.pyCheckArgsLen(\"issuperset\", arguments.length, 2, 2);\n    return Sk.builtin.set.prototype[\"issubset\"].func_code(other, self);\n});\n\nSk.builtin.set.prototype[\"union\"] = new Sk.builtin.func(function (self) {\n    var S, i, new_args;\n\n    Sk.builtin.pyCheckArgsLen(\"union\", arguments.length, 1);\n\n    S = Sk.builtin.set.prototype[\"copy\"].func_code(self);\n    new_args = [S];\n    for (i = 1; i < arguments.length; i++) {\n        new_args.push(arguments[i]);\n    }\n\n    Sk.builtin.set.prototype[\"update\"].func_code.apply(null, new_args);\n    return S;\n});\n\nSk.builtin.set.prototype[\"intersection\"] = new Sk.builtin.func(function (self) {\n    var S, i, new_args;\n\n    Sk.builtin.pyCheckArgsLen(\"intersection\", arguments.length, 1);\n\n    S = Sk.builtin.set.prototype[\"copy\"].func_code(self);\n    new_args = [S];\n    for (i = 1; i < arguments.length; i++) {\n        new_args.push(arguments[i]);\n    }\n\n    Sk.builtin.set.prototype[\"intersection_update\"].func_code.apply(null, new_args);\n    return S;\n});\n\nSk.builtin.set.prototype[\"difference\"] = new Sk.builtin.func(function (self, other) {\n    var S, i, new_args;\n\n    Sk.builtin.pyCheckArgsLen(\"difference\", arguments.length, 2);\n\n    S = Sk.builtin.set.prototype[\"copy\"].func_code(self);\n    new_args = [S];\n    for (i = 1; i < arguments.length; i++) {\n        new_args.push(arguments[i]);\n    }\n\n    Sk.builtin.set.prototype[\"difference_update\"].func_code.apply(null, new_args);\n    return S;\n});\n\nSk.builtin.set.prototype[\"symmetric_difference\"] = new Sk.builtin.func(function (self, other) {\n    var it, item, S;\n\n    Sk.builtin.pyCheckArgsLen(\"symmetric_difference\", arguments.length, 2, 2);\n\n    S = Sk.builtin.set.prototype[\"union\"].func_code(self, other);\n    for (it = Sk.abstr.iter(S), item = it.tp$iternext(); item !== undefined; item = it.tp$iternext()) {\n        if (Sk.abstr.sequenceContains(self, item) && Sk.abstr.sequenceContains(other, item)) {\n            Sk.builtin.set.prototype[\"discard\"].func_code(S, item);\n        }\n    }\n    return S;\n});\n\nSk.builtin.set.prototype[\"copy\"] = new Sk.builtin.func(function (self) {\n    Sk.builtin.pyCheckArgsLen(\"copy\", arguments.length, 1, 1);\n    return new Sk.builtin.set(self);\n});\n\nSk.builtin.set.prototype[\"update\"] = new Sk.builtin.func(function (self, other) {\n    var i, it, item, arg;\n\n    Sk.builtin.pyCheckArgsLen(\"update\", arguments.length, 2);\n\n    for (i = 1; i < arguments.length; i++) {\n        arg = arguments[i];\n        if (!Sk.builtin.checkIterable(arg)) {\n            throw new Sk.builtin.TypeError(\"'\" + Sk.abstr.typeName(arg) + \"' object is not iterable\");\n        }\n        for (it = Sk.abstr.iter(arg), item = it.tp$iternext();\n            item !== undefined;\n            item = it.tp$iternext()) {\n            Sk.builtin.set.prototype[\"add\"].func_code(self, item);\n        }\n    }\n\n    return Sk.builtin.none.none$;\n});\n\nSk.builtin.set.prototype[\"intersection_update\"] = new Sk.builtin.func(function (self, other) {\n    var i, it, item;\n\n    Sk.builtin.pyCheckArgsLen(\"intersection_update\", arguments.length, 2);\n    for (i = 1; i < arguments.length; i++) {\n        if (!Sk.builtin.checkIterable(arguments[i])) {\n            throw new Sk.builtin.TypeError(\"'\" + Sk.abstr.typeName(arguments[i]) +\n                                           \"' object is not iterable\");\n        }\n    }\n\n    for (it = Sk.abstr.iter(self), item = it.tp$iternext(); item !== undefined; item = it.tp$iternext()) {\n        for (i = 1; i < arguments.length; i++) {\n            if (!Sk.abstr.sequenceContains(arguments[i], item)) {\n                Sk.builtin.set.prototype[\"discard\"].func_code(self, item);\n                break;\n            }\n        }\n    }\n    return Sk.builtin.none.none$;\n});\n\nSk.builtin.set.prototype[\"difference_update\"] = new Sk.builtin.func(function (self, other) {\n    var i, it, item;\n\n    Sk.builtin.pyCheckArgsLen(\"difference_update\", arguments.length, 2);\n    for (i = 1; i < arguments.length; i++) {\n        if (!Sk.builtin.checkIterable(arguments[i])) {\n            throw new Sk.builtin.TypeError(\"'\" + Sk.abstr.typeName(arguments[i]) +\n                                           \"' object is not iterable\");\n        }\n    }\n\n    for (it = Sk.abstr.iter(self), item = it.tp$iternext(); item !== undefined; item = it.tp$iternext()) {\n        for (i = 1; i < arguments.length; i++) {\n            if (Sk.abstr.sequenceContains(arguments[i], item)) {\n                Sk.builtin.set.prototype[\"discard\"].func_code(self, item);\n                break;\n            }\n        }\n    }\n    return Sk.builtin.none.none$;\n});\n\nSk.builtin.set.prototype[\"symmetric_difference_update\"] = new Sk.builtin.func(function (self, other) {\n    Sk.builtin.pyCheckArgsLen(\"symmetric_difference_update\", arguments.length, 2, 2);\n\n    var sd = Sk.builtin.set.prototype[\"symmetric_difference\"].func_code(self, other);\n    self.set_reset_();\n    Sk.builtin.set.prototype[\"update\"].func_code(self, sd);\n    return Sk.builtin.none.none$;\n});\n\n\nSk.builtin.set.prototype[\"add\"] = new Sk.builtin.func(function (self, item) {\n    Sk.builtin.pyCheckArgsLen(\"add\", arguments.length, 2, 2);\n\n    self.v.mp$ass_subscript(item, true);\n    return Sk.builtin.none.none$;\n});\n\nSk.builtin.set.prototype[\"discard\"] = new Sk.builtin.func(function (self, item) {\n    Sk.builtin.pyCheckArgsLen(\"discard\", arguments.length, 2, 2);\n\n    Sk.builtin.dict.prototype[\"pop\"].func_code(self.v, item,\n                                               Sk.builtin.none.none$);\n    return Sk.builtin.none.none$;\n});\n\nSk.builtin.set.prototype[\"pop\"] = new Sk.builtin.func(function (self) {\n    var it, item;\n\n    Sk.builtin.pyCheckArgsLen(\"pop\", arguments.length, 1, 1);\n\n    if (self.sq$length() === 0) {\n        throw new Sk.builtin.KeyError(\"pop from an empty set\");\n    }\n\n    it = Sk.abstr.iter(self);\n    item = it.tp$iternext();\n    Sk.builtin.set.prototype[\"discard\"].func_code(self, item);\n    return item;\n});\n\nSk.builtin.set.prototype[\"remove\"] = new Sk.builtin.func(function (self, item) {\n    Sk.builtin.pyCheckArgsLen(\"remove\", arguments.length, 2, 2);\n\n    self.v.mp$del_subscript(item);\n    return Sk.builtin.none.none$;\n});\n\nSk.exportSymbol(\"Sk.builtin.set\", Sk.builtin.set);\n\n/**\n * @constructor\n * @param {Object} obj\n */\nSk.builtin.set_iter_ = function (obj) {\n    var allkeys, k, i, bucket, buckets;\n    if (!(this instanceof Sk.builtin.set_iter_)) {\n        return new Sk.builtin.set_iter_(obj);\n    }\n    this.$obj = obj;\n    this.tp$iter = this;\n    allkeys = [];\n    buckets = obj.v.buckets;\n    for (k in buckets) {\n        if (buckets.hasOwnProperty(k)) {\n            bucket = buckets[k];\n            if (bucket && bucket.$hash !== undefined && bucket.items !== undefined) {\n                // skip internal stuff. todo; merge pyobj and this\n                for (i = 0; i < bucket.items.length; i++) {\n                    allkeys.push(bucket.items[i].lhs);\n                }\n            }\n        }\n    }\n    this.$index = 0;\n    this.$keys = allkeys;\n    this.tp$iternext = function () {\n        if (this.$index >= this.$keys.length) {\n            return undefined;\n        }\n        return this.$keys[this.$index++];\n    };\n    this.$r = function () {\n        return new Sk.builtin.str(\"setiterator\");\n    };\n    return this;\n};\n\nSk.abstr.setUpInheritance(\"setiterator\", Sk.builtin.set_iter_, Sk.builtin.object);\n\nSk.builtin.set_iter_.prototype.__class__ = Sk.builtin.set_iter_;\n\nSk.builtin.set_iter_.prototype.__iter__ = new Sk.builtin.func(function (self) {\n    Sk.builtin.pyCheckArgsLen(\"__iter__\", arguments.length, 0, 0, true, false);\n    return self;\n});\n\nSk.builtin.set_iter_.prototype.next$ = function (self) {\n    var ret = self.tp$iternext();\n    if (ret === undefined) {\n        throw new Sk.builtin.StopIteration();\n    }\n    return ret;\n};\n","/*\n\tImplementation of the Python3 print version. Due to Python2 grammar we have\n\tto mimic the named keywords after *args as kwargs. Though this does not change\n\tanything for the internal implementation\n\n*/\nvar print_f = function function_print(kwa) {\n    Sk.builtin.pyCheckArgsLen(\"print\", arguments.length, 0, Infinity, true, false);\n    var args = Array.prototype.slice.call(arguments, 1);\n    var kwargs = new Sk.builtins.dict(kwa);\n    var _kwargs = Sk.ffi.remapToJs(kwargs);\n\n    // defaults, null for None\n    var kw_list = {\n        \"sep\": \" \",\n        \"end\": \"\\n\",\n        \"file\": null\n    };\n\n    var remap_val;\n    var is_none;\n\n    // check for sep; string or None\n    remap_val = kwargs.mp$lookup(new Sk.builtin.str(\"sep\"));\n    if(remap_val !== undefined) {\n        is_none = Sk.builtin.checkNone(remap_val);\n        if(Sk.builtin.checkString(remap_val) || is_none) {\n            kw_list[\"sep\"] = is_none ? kw_list[\"sep\"] : Sk.ffi.remapToJs(remap_val); // only reassign for string\n        } else {\n            throw new Sk.builtin.TypeError(\"sep must be None or a string, not \" + Sk.abstr.typeName(remap_val));\n        }\n    }\n\n    // check for end; string or None\n    remap_val = kwargs.mp$lookup(new Sk.builtin.str(\"end\"));\n    if(remap_val !== undefined) {\n        is_none = Sk.builtin.checkNone(remap_val);\n        if(Sk.builtin.checkString(remap_val) || is_none) {\n            kw_list[\"end\"] = is_none ? kw_list[\"end\"] : Sk.ffi.remapToJs(remap_val); // only reassign for string\n        } else {\n            throw new Sk.builtin.TypeError(\"end must be None or a string, not \" + Sk.abstr.typeName(remap_val));\n        }\n    }\n\n    // check for file\n    // allow None, though just keep null or check if value has attribute write\n    remap_val = kwargs.mp$lookup(new Sk.builtin.str(\"file\"));\n    if(remap_val !== undefined) {\n        is_none = Sk.builtin.checkNone(remap_val);\n        if(is_none || remap_val.tp$getattr(\"write\") !== undefined) {\n            kw_list[\"file\"] = is_none ? kw_list[\"file\"] : remap_val;\n        } else {\n            throw new Sk.builtin.AttributeError(\"'\" + Sk.abstr.typeName(remap_val) + \"' object has no attribute 'write'\");\n        }\n    }\n\n    // loop through outputs and create output string\n    var s = \"\";\n    var i;\n    for(i = 0; i < args.length; i++) {\n        s += (new Sk.builtin.str(args[i])).v; // get str repr\n        s += kw_list.sep;\n    }\n\n    if(args.length > 0 && kw_list.sep.length > 0) {\n        s = s.substring(0, s.length-kw_list.sep.length);\n    }\n\n    s += kw_list.end;\n\n    if(kw_list.file !== null) {\n        // currently not tested, though it seems that we need to see how we should access the write function in a correct manner\n        Sk.misceval.callsimArray(kw_list.file.write, [kw_list.file, new Sk.builtin.str(s)]); // callsim to write function\n    } else {\n        return Sk.misceval.chain(Sk.importModule(\"sys\", false, true), function(sys) {\n            return Sk.misceval.apply(sys[\"$d\"][\"stdout\"][\"write\"], undefined, undefined, undefined, [sys[\"$d\"][\"stdout\"], new Sk.builtin.str(s)]);\n        });\n    }\n    // ToDo:\n    // cpython print function may receive another flush kwarg that flushes the output stream immediatelly\n};\n\nprint_f.co_kwargs = true;\nSk.builtin.print = new Sk.builtin.func(print_f);\n\nSk.builtin.print.__doc__ = new Sk.builtin.str(\"print(value, ..., sep=' ', end='\\\\n', file=sys.stdout, flush=False)\\n\\nPrints the values to a stream, or to sys.stdout by default.\\nOptional keyword arguments:\\nfile:  a file-like object (stream); defaults to the current sys.stdout.\\nsep:   string inserted between values, default a space.\\nend:   string appended after the last value, default a newline.\\nflush: whether to forcibly flush the stream.\");\n","/**\n * @constructor\n */\nSk.builtin.module = function module () {\n};\nSk.exportSymbol(\"Sk.builtin.module\", Sk.builtin.module);\n\nSk.builtin.module.prototype.ob$type = Sk.builtin.type.makeIntoTypeObj(\"module\", Sk.builtin.module);\nSk.builtin.module.prototype.tp$getattr = Sk.builtin.object.prototype.GenericGetAttr;\nSk.builtin.module.prototype.tp$setattr = Sk.builtin.object.prototype.GenericSetAttr;\nSk.builtin.module.prototype.tp$name = \"module\";\n","Sk.builtin.structseq_types = {};\n\nSk.builtin.make_structseq = function (module, name, fields, doc) {\n    var nm = module + \".\" + name;\n    var flds = [];\n    var docs = [];\n    var i;\n    for (var key in fields) {\n        flds.push(key);\n        docs.push(fields[key]);\n    }\n\n    /**\n     * @constructor\n     * @extends Sk.builtin.tuple\n     * @param {!Array<Object>|Object} arg\n     */\n    var cons = function structseq_constructor(arg) {\n        Sk.builtin.pyCheckArgsLen(nm, arguments.length, 1, 1);\n        var o;\n        var it, i, /** @type {!Array<Object>} */v;\n        if (!(this instanceof Sk.builtin.structseq_types[nm])) {\n            o = Object.create(Sk.builtin.structseq_types[nm].prototype);\n            o.constructor.apply(o, arguments);\n            return o;\n        }\n\n        if (Array.isArray(arg)) {\n            v = arg;\n        } else {\n            v = [];\n            for (it = Sk.abstr.iter(arg), i = it.tp$iternext(); i !== undefined; i = it.tp$iternext()) {\n                v.push(i);\n            }\n            if (v.length != flds.length) {\n                throw new Sk.builtin.TypeError(nm + \"() takes a \" + flds.length + \"-sequence (\" + v.length + \"-sequence given)\");\n            }\n        }\n\n        Sk.builtin.tuple.call(this, v);\n\n        this.__class__ = Sk.builtin.structseq_types[nm];\n    };\n\n    Sk.builtin.structseq_types[nm] = cons;\n\n    Sk.abstr.inherits(cons, Sk.builtin.tuple);\n    if (doc) {\n        cons.prototype.__doc__ = doc;\n    }\n    cons.prototype.tp$name = nm;\n    cons.prototype.ob$type = Sk.builtin.type.makeIntoTypeObj(nm, Sk.builtin.structseq_types[nm]);\n    cons.prototype.ob$type[\"$d\"] = new Sk.builtin.dict([]);\n    cons.prototype.ob$type[\"$d\"].mp$ass_subscript(Sk.builtin.type.basesStr_, new Sk.builtin.tuple([Sk.builtin.tuple]));\n    //var mro = Sk.builtin.type.buildMRO(cons.prototype.ob$type);\n    //cons.prototype.ob$type[\"$d\"].mp$ass_subscript(Sk.builtin.type.mroStr_, mro);\n    //cons.prototype.ob$type.tp$mro = mro;\n    cons.prototype.__getitem__ = new Sk.builtin.func(function (self, index) {\n        return Sk.builtin.tuple.prototype.mp$subscript.call(self, index);\n    });\n    cons.prototype.__reduce__ = new Sk.builtin.func(function (self) {\n        throw new Sk.builtin.Exception(\"__reduce__ is not implemented\");\n    });\n\n    cons.prototype[\"$r\"] = function () {\n        var ret;\n        var i;\n        var bits;\n        if (this.v.length === 0) {\n            return new Sk.builtin.str(nm + \"()\");\n        }\n        bits = [];\n        for (i = 0; i < this.v.length; ++i) {\n            bits[i] = flds[i] + \"=\" + Sk.misceval.objectRepr(this.v[i]).v;\n        }\n        ret = bits.join(\", \");\n        if (this.v.length === 1) {\n            ret += \",\";\n        }\n        return new Sk.builtin.str(nm + \"(\" + ret + \")\");\n    };\n    cons.prototype.tp$setattr = function (pyName, value) {\n        throw new Sk.builtin.AttributeError(\"readonly property\");\n    };\n\n    cons.prototype.tp$getattr = function (pyName) {\n        var jsName = pyName.$jsstr();\n        var i = flds.indexOf(jsName);\n        if (i >= 0) {\n            return this.v[i];\n        } else {\n            return  Sk.builtin.object.prototype.GenericGetAttr(pyName);\n        }\n    };\n\n    return cons;\n};\nSk.exportSymbol(\"Sk.builtin.make_structseq\", Sk.builtin.make_structseq);\n","/**\n * @constructor\n * @param {Function} code javascript code object for the function\n * @param {Object} globals where this function was defined\n * @param {Object} args arguments to the original call (stored into locals for\n * the generator to reenter)\n * @param {Object=} closure dict of free variables\n * @param {Object=} closure2 another dict of free variables that will be\n * merged into 'closure'. there's 2 to simplify generated code (one is $free,\n * the other is $cell)\n *\n * co_varnames and co_name come from generated code, must access as dict.\n */\nSk.builtin.generator = function (code, globals, args, closure, closure2) {\n    var k;\n    var i;\n    if (!code) {\n        return;\n    } // ctor hack\n\n    if (!(this instanceof Sk.builtin.generator)) {\n        return new Sk.builtin.generator(code, globals, args, closure, closure2);\n    }\n\n\n    this.func_code = code;\n    this.func_globals = globals || null;\n    this[\"gi$running\"] = false;\n    this[\"gi$resumeat\"] = 0;\n    this[\"gi$sentvalue\"] = undefined;\n    this[\"gi$locals\"] = {};\n    this[\"gi$cells\"] = {};\n    if (args.length > 0) {\n        // store arguments into locals because they have to be maintained\n        // too. 'fast' var lookups are locals in generator functions.\n        for (i = 0; i < code[\"co_varnames\"].length; ++i) {\n            this[\"gi$locals\"][code[\"co_varnames\"][i]] = args[i];\n        }\n    }\n    if (closure2 !== undefined) {\n        // todo; confirm that modification here can't cause problems\n        for (k in closure2) {\n            closure[k] = closure2[k];\n        }\n    }\n    //print(JSON.stringify(closure));\n    this.func_closure = closure;\n    return this;\n};\nSk.exportSymbol(\"Sk.builtin.generator\", Sk.builtin.generator);\n\nSk.abstr.setUpInheritance(\"generator\", Sk.builtin.generator, Sk.builtin.object);\n\n\nSk.builtin.generator.prototype.tp$iter = function () {\n    return this;\n};\n\nSk.builtin.generator.prototype.tp$iternext = function (canSuspend, yielded) {\n    var ret;\n    var args;\n    var self = this;\n    this[\"gi$running\"] = true;\n    if (yielded === undefined) {\n        yielded = null;\n    }\n    this[\"gi$sentvalue\"] = yielded;\n\n    // note: functions expect 'this' to be globals to avoid having to\n    // slice/unshift onto the main args\n    args = [ this ];\n    if (this.func_closure) {\n        args.push(this.func_closure);\n    }\n    ret = this.func_code.apply(this.func_globals, args);\n    return (function finishIteration(ret) {\n        if (ret instanceof Sk.misceval.Suspension) {\n            if (canSuspend) {\n                return new Sk.misceval.Suspension(finishIteration, ret);\n            } else {\n                ret = Sk.misceval.retryOptionalSuspensionOrThrow(ret);\n            }\n        }\n        //print(\"ret\", JSON.stringify(ret));\n        self[\"gi$running\"] = false;\n        Sk.asserts.assert(ret !== undefined);\n        if (ret !== Sk.builtin.none.none$) {\n            // returns a pair: resume target and yielded value\n            self[\"gi$resumeat\"] = ret[0];\n            ret = ret[1];\n        } else {\n            // todo; StopIteration\n            return undefined;\n        }\n        //print(\"returning:\", JSON.stringify(ret));\n        return ret;\n    })(ret);\n};\n\nSk.builtin.generator.prototype.next$ = function (self) {\n    return self.tp$iternext(true);\n};\n\nSk.builtin.generator.prototype[\"$r\"] = function () {\n    return new Sk.builtin.str(\"<generator object \" + this.func_code[\"co_name\"].v + \">\");\n};\n\nSk.builtin.generator.prototype[\"send\"] = new Sk.builtin.func(function (self, value) {\n    return self.tp$iternext(true, value);\n});\n\n/**\n * Creates a generator with the specified next function and additional\n * instance data. Useful in Javascript-implemented modules to implement\n * the __iter__ method.\n */\nSk.builtin.makeGenerator = function (next, data) {\n    var key;\n    var gen = new Sk.builtin.generator(null, null, null);\n    gen.tp$iternext = next;\n\n    for (key in data) {\n        if (data.hasOwnProperty(key)) {\n            gen[key] = data[key];\n        }\n    }\n\n    return gen;\n};\nSk.exportSymbol(\"Sk.builtin.makeGenerator\", Sk.builtin.makeGenerator);\n","/**\n * @constructor\n * @param {Sk.builtin.str} name\n * @param {Sk.builtin.str} mode\n * @param {Object} buffering\n */\nSk.builtin.file = function (name, mode, buffering) {\n    var i;\n    var elem;\n\n    if (!(this instanceof Sk.builtin.file)) {\n        return new Sk.builtin.file(name, mode, buffering);\n    }\n\n    this.mode = mode;\n    this.name = Sk.ffi.remapToJs(name);\n    this.closed = false;\n\n    if (this.name === \"/dev/stdout\") {\n        this.data$ = Sk.builtin.none.none$;\n        this.fileno = 1;\n    } else if (this.name === \"/dev/stdin\") {\n        this.fileno = 0;\n    } else if (this.name === \"/dev/stderr\") {\n        this.fileno = 2;\n    } else {\n        if (Sk.inBrowser) {  // todo:  Maybe provide a replaceable function for non-import files\n            this.fileno = 10;\n            elem = document.getElementById(name.v);\n            if (elem == null) {\n                if (mode.v == \"w\" || mode.v == \"a\") {\n                    this.data$ = \"\";\n                } else {\n                    throw new Sk.builtin.IOError(\"[Errno 2] No such file or directory: '\" + name.v + \"'\");\n                }\n            } else {\n                if (elem.nodeName.toLowerCase() == \"textarea\") {\n                    this.data$ = elem.value;\n                } else {\n                    this.data$ = elem.textContent;\n                }\n            }\n        } else {\n            this.fileno = 11;\n            this.data$ = Sk.read(name.v);\n        }\n\n        this.lineList = this.data$.split(\"\\n\");\n        this.lineList = this.lineList.slice(0, -1);\n\n        for (i in this.lineList) {\n            this.lineList[i] = this.lineList[i] + \"\\n\";\n        }\n        this.currentLine = 0;\n    }\n    this.pos$ = 0;\n\n    this.__class__ = Sk.builtin.file;\n\n    if (Sk.fileopen && this.fileno >= 10) {\n        Sk.fileopen(this);\n    }\n\n    return this;\n};\n\nSk.abstr.setUpInheritance(\"file\", Sk.builtin.file, Sk.builtin.object);\n\nSk.builtin.file.prototype[\"$r\"] = function () {\n    return new Sk.builtin.str(\"<\" +\n        (this.closed ? \"closed\" : \"open\") +\n        \"file '\" +\n        this.name +\n        \"', mode '\" +\n        Sk.ffi.remapToJs(this.mode) +\n        \"'>\");\n};\n\nSk.builtin.file.prototype[\"__enter__\"] = new Sk.builtin.func(function __enter__(self) {\n    return self;\n});\n\nSk.builtin.file.prototype[\"__exit__\"] = new Sk.builtin.func(function __exit__(self) {\n    return Sk.misceval.callsimArray(Sk.builtin.file.prototype[\"close\"], [self]);\n});\n\nSk.builtin.file.prototype.tp$iter = function () {\n    var allLines = this.lineList;\n    var currentLine = this.currentLine;\n\n    var ret =\n    {\n        tp$iter    : function () {\n            return ret;\n        },\n        $obj       : this,\n        $index     : currentLine,\n        $lines     : allLines,\n        tp$iternext: function () {\n            if (ret.$index >= ret.$lines.length) {\n                return undefined;\n            }\n            return new Sk.builtin.str(ret.$lines[ret.$index++]);\n        }\n    };\n    return ret;\n};\n\nSk.builtin.file.prototype[\"close\"] = new Sk.builtin.func(function close(self) {\n    self.closed = true;\n    return Sk.builtin.none.none$;\n});\n\nSk.builtin.file.prototype[\"flush\"] = new Sk.builtin.func(function flush(self) {\n});\n\nSk.builtin.file.prototype[\"fileno\"] = new Sk.builtin.func(function fileno(self) {\n    return this.fileno;\n}); // > 0, not 1/2/3\n\nSk.builtin.file.prototype[\"isatty\"] = new Sk.builtin.func(function isatty(self) {\n    return false;\n});\n\nSk.builtin.file.prototype[\"read\"] = new Sk.builtin.func(function read(self, size) {\n    var ret;\n    var len = self.data$.length;\n    var l_size;\n    if (self.closed) {\n        throw new Sk.builtin.ValueError(\"I/O operation on closed file\");\n    }\n\n    if (size === undefined) {\n        l_size = len;\n    } else {\n        l_size = Sk.ffi.remapToJs(size);\n    }\n\n    ret = new Sk.builtin.str(self.data$.substr(self.pos$, l_size));\n    if(size === undefined){\n        self.pos$ = len;\n    }else{\n        self.pos$ += Sk.ffi.remapToJs(size);\n    }\n    if (self.pos$ >= len) {\n        self.pos$ = len;\n    }\n\n    return ret;\n});\n\nSk.builtin.file.$readline = function (self, size, prompt) {\n    if (self.fileno === 0) {\n        var x, susp;\n\n        var lprompt = Sk.ffi.remapToJs(prompt);\n\n        lprompt = lprompt ? lprompt : \"\";\n\n        x = Sk.inputfun(lprompt);\n\n        if (x instanceof Promise) {\n            susp = new Sk.misceval.Suspension();\n\n            susp.resume = function() {\n                if (susp.data.error) {\n                    throw susp.data.error;\n                }\n\n                return new Sk.builtin.str(susp.data.result);\n            };\n\n            susp.data = {\n                type: \"Sk.promise\",\n                promise: x\n            };\n\n            return susp;\n        } else {\n            return new Sk.builtin.str(x);\n        }\n    } else {\n        var line = \"\";\n        if (self.currentLine < self.lineList.length) {\n            line = self.lineList[self.currentLine];\n            self.currentLine++;\n        }\n        return new Sk.builtin.str(line);\n    }\n};\n\nSk.builtin.file.prototype[\"readline\"] = new Sk.builtin.func(function readline(self, size) {\n    return Sk.builtin.file.$readline(self, size, undefined);\n});\n\nSk.builtin.file.prototype[\"readlines\"] = new Sk.builtin.func(function readlines(self, sizehint) {\n    if (self.fileno === 0) {\n        return new Sk.builtin.NotImplementedError(\"readlines ins't implemented because the web doesn't support Ctrl+D\");\n    }\n\n    var i;\n    var arr = [];\n    for (i = self.currentLine; i < self.lineList.length; i++) {\n        arr.push(new Sk.builtin.str(self.lineList[i]));\n    }\n    return new Sk.builtin.list(arr);\n});\n\nSk.builtin.file.prototype[\"seek\"] = new Sk.builtin.func(function seek(self, offset, whence) {\n    var l_offset =  Sk.ffi.remapToJs(offset);\n\n    if (whence === undefined) {\n        whence = 0;\n    }\n    if (whence === 0) {\n        self.pos$ = l_offset;\n    } else if (whence == 1) {\n        self.pos$ = self.data$.length + l_offset;\n    } else if (whence == 2) {\n        self.pos$ = self.data$.length + l_offset;\n    }\n\n    return Sk.builtin.none.none$;\n});\n\nSk.builtin.file.prototype[\"tell\"] = new Sk.builtin.func(function tell(self) {\n    return Sk.ffi.remapToPy(self.pos$);\n});\n\nSk.builtin.file.prototype[\"truncate\"] = new Sk.builtin.func(function truncate(self, size) {\n    Sk.asserts.fail();\n});\n\nSk.builtin.file.prototype[\"write\"] = new Sk.builtin.func(function write(self, str) {\n    var mode = Sk.ffi.remapToJs(self.mode);\n    if (mode === \"w\" || mode === \"wb\" || mode === \"a\" || mode === \"ab\") {\n        if (Sk.filewrite) {\n            if (self.closed) {\n                throw new Sk.builtin.ValueError(\"I/O operation on closed file\");\n            }\n\n            if (self.fileno === 1) {\n                Sk.output(Sk.ffi.remapToJs(str));\n            } else {\n                Sk.filewrite(self, str);\n            }\n        } else {\n            if (self.fileno === 1) {\n                Sk.output(Sk.ffi.remapToJs(str));\n            } else {\n                Sk.asserts.fail();\n            }\n        }\n    } else {\n        throw new Sk.builtin.IOError(\"File not open for writing\");\n    }\n});\n\n\nSk.exportSymbol(\"Sk.builtin.file\", Sk.builtin.file);\n","/**\n * @namespace Sk.ffi\n *\n */\n\nSk.ffi = Sk.ffi || {};\n\n/**\n * maps from Javascript Object/Array/string to Python dict/list/str.\n *\n * only works on basic objects that are being used as storage, doesn't handle\n * functions, etc.\n */\nSk.ffi.remapToPy = function (obj) {\n    var k;\n    var kvs;\n    var i;\n    var arr;\n\n    if (obj === null || typeof obj === \"undefined\") {\n        return Sk.builtin.none.none$;\n    }\n\n    if (obj.ob$type) {\n        return obj;\n    }\n\n    if (obj instanceof Sk.misceval.Suspension) {\n        return obj;\n    }\n\n    if (Object.prototype.toString.call(obj) === \"[object Array]\") {\n        arr = [];\n        for (i = 0; i < obj.length; ++i) {\n            arr.push(Sk.ffi.remapToPy(obj[i]));\n        }\n        return new Sk.builtin.list(arr);\n    }\n\n    if (typeof obj === \"object\") {\n        kvs = [];\n        for (k in obj) {\n            kvs.push(Sk.ffi.remapToPy(k));\n            kvs.push(Sk.ffi.remapToPy(obj[k]));\n        }\n        return new Sk.builtin.dict(kvs);\n    }\n\n    if (typeof obj === \"string\") {\n        return new Sk.builtin.str(obj);\n    }\n\n    if (typeof obj === \"number\") {\n        return Sk.builtin.assk$(obj);\n    }\n\n    if (typeof obj === \"boolean\") {\n        return new Sk.builtin.bool(obj);\n    } else if (typeof obj === \"undefined\") {\n        return Sk.builtin.none.none$;\n    }\n\n    if (typeof obj === \"function\") {\n        return new Sk.builtin.func(obj);\n    }\n\n    Sk.asserts.fail(\"unhandled remap type \" + typeof(obj));\n};\nSk.exportSymbol(\"Sk.ffi.remapToPy\", Sk.ffi.remapToPy);\n\n/**\n * Maps from Python dict/list/str/number to Javascript Object/Array/string/number.\n *\n * If obj is a\n *\n * @param obj {Object}  Any Python object (except a function)\n *\n */\nSk.ffi.remapToJs = function (obj) {\n    var i;\n    var kAsJs;\n    var v;\n    var iter, k;\n    var ret;\n    if (obj instanceof Sk.builtin.dict) {\n        ret = {};\n        for (iter = obj.tp$iter(), k = iter.tp$iternext();\n            k !== undefined;\n            k = iter.tp$iternext()) {\n            v = obj.mp$subscript(k);\n            if (v === undefined) {\n                v = null;\n            }\n            kAsJs = Sk.ffi.remapToJs(k);\n            // todo; assert that this is a reasonble lhs?\n            ret[kAsJs] = Sk.ffi.remapToJs(v);\n        }\n        return ret;\n    } else if (obj instanceof Sk.builtin.list || obj instanceof Sk.builtin.tuple) {\n        ret = [];\n        for (i = 0; i < obj.v.length; ++i) {\n            ret.push(Sk.ffi.remapToJs(obj.v[i]));\n        }\n        return ret;\n    } else if (obj instanceof Sk.builtin.bool) {\n        return obj.v ? true : false;\n    } else if (obj instanceof Sk.builtin.int_) {\n        return Sk.builtin.asnum$(obj);\n    } else if (obj instanceof Sk.builtin.float_) {\n        return Sk.builtin.asnum$(obj);\n    } else if (obj instanceof Sk.builtin.lng) {\n        return Sk.builtin.asnum$(obj);\n    } else if (typeof obj === \"number\" || typeof obj === \"boolean\" || typeof obj === \"string\") {\n        return obj;\n    } else if (obj === undefined) {\n        return undefined;\n    } else {\n        return obj.v;\n    }\n};\nSk.exportSymbol(\"Sk.ffi.remapToJs\", Sk.ffi.remapToJs);\n\nSk.ffi.callback = function (fn) {\n    if (fn === undefined) {\n        return fn;\n    }\n    return function () {\n        return Sk.misceval.apply(fn, undefined, undefined, undefined, Array.prototype.slice.call(arguments, 0));\n    };\n};\nSk.exportSymbol(\"Sk.ffi.callback\", Sk.ffi.callback);\n\nSk.ffi.stdwrap = function (type, towrap) {\n    var inst = new type();\n    inst[\"v\"] = towrap;\n    return inst;\n};\nSk.exportSymbol(\"Sk.ffi.stdwrap\", Sk.ffi.stdwrap);\n\n/**\n * for when the return type might be one of a variety of basic types.\n * number|string, etc.\n */\nSk.ffi.basicwrap = function (obj) {\n    if (obj instanceof Sk.builtin.int_) {\n        return Sk.builtin.asnum$(obj);\n    }\n    if (obj instanceof Sk.builtin.float_) {\n        return Sk.builtin.asnum$(obj);\n    }\n    if (obj instanceof Sk.builtin.lng) {\n        return Sk.builtin.asnum$(obj);\n    }\n    if (typeof obj === \"number\" || typeof obj === \"boolean\") {\n        return obj;\n    }\n    if (typeof obj === \"string\") {\n        return new Sk.builtin.str(obj);\n    }\n    Sk.asserts.fail(\"unexpected type for basicwrap\");\n};\nSk.exportSymbol(\"Sk.ffi.basicwrap\", Sk.ffi.basicwrap);\n\nSk.ffi.unwrapo = function (obj) {\n    if (obj === undefined) {\n        return undefined;\n    }\n    return obj[\"v\"];\n};\nSk.exportSymbol(\"Sk.ffi.unwrapo\", Sk.ffi.unwrapo);\n\nSk.ffi.unwrapn = function (obj) {\n    if (obj === null) {\n        return null;\n    }\n    return obj[\"v\"];\n};\nSk.exportSymbol(\"Sk.ffi.unwrapn\", Sk.ffi.unwrapn);\n","/**\n  * Builds an iterator that outputs the items from the inputted object\n  * @constructor\n  * @param {*} obj must support iter protocol (has __iter__ and next methods), if sentinel defined:\n  * obj must be callable\n  * @param {*=} sentinel optional if defined returns an object that makes a call to obj until\n  * sentinel is reached\n  * @extends Sk.builtin.object\n  *\n  * @description\n  * Constructor for Python iterator.\n  *\n  */\nSk.builtin.iterator = function (obj, sentinel) {\n    var objit;\n    if (obj instanceof Sk.builtin.generator) {\n        return obj;\n    }\n    objit = Sk.abstr.lookupSpecial(obj, Sk.builtin.str.$iter);\n    if (objit) {\n        return Sk.misceval.callsimArray(objit, [obj]);\n    }\n    this.sentinel = sentinel;\n    this.flag = false;\n    this.idx = 0;\n    this.obj = obj;\n    if (sentinel === undefined) {\n        this.getitem = Sk.abstr.lookupSpecial(obj, Sk.builtin.str.$getitem);\n        this.$r = function () {\n            return new Sk.builtin.str(\"<iterator object>\");\n        };\n    } else {\n        this.call = Sk.abstr.lookupSpecial(obj, Sk.builtin.str.$call);\n        this.$r = function () {\n            return new Sk.builtin.str(\"<callable-iterator object>\");\n        };\n    }\n    return this;\n};\n\nSk.abstr.setUpInheritance(\"iterator\", Sk.builtin.iterator, Sk.builtin.object);\n\nSk.builtin.iterator.prototype.__class__ = Sk.builtin.iterator;\n\nSk.builtin.iterator.prototype.__iter__ = new Sk.builtin.func(function (self) {\n    return self.tp$iter();\n});\n\nSk.builtin.iterator.prototype.tp$iter =  function () {\n    return this;\n};\n\nSk.builtin.iterator.prototype.tp$iternext = function (canSuspend) {\n    var r;\n    var self = this;\n\n    if (this.flag === true) {\n        // Iterator has already completed\n        return undefined;\n    }\n\n    if (this.getitem) {\n        r = Sk.misceval.tryCatch(function() {\n            return Sk.misceval.callsimOrSuspendArray(self.getitem, [self.obj, Sk.ffi.remapToPy(self.idx++)]);\n        }, function(e) {\n            if (e instanceof Sk.builtin.StopIteration || e instanceof Sk.builtin.IndexError) {\n                return undefined;\n            } else {\n                throw e;\n            }\n        });\n        return canSuspend ? r : Sk.misceval.retryOptionalSuspensionOrThrow(r);\n    }\n\n    var checkSentinel = function (ret) {\n        // Iteration is complete if ret value is the sentinel\n        if (Sk.misceval.richCompareBool(ret, self.sentinel, \"Eq\")) {\n            self.flag = true;\n            return undefined;\n        }\n        return ret;\n    };\n\n    if (this.call) {\n        r = Sk.misceval.chain(Sk.misceval.callsimOrSuspendArray(this.call, [this.obj]), checkSentinel);\n    } else {\n        var obj = /** @type {Object} */ (this.obj);\n        r = Sk.misceval.chain(Sk.misceval.callsimOrSuspendArray(obj), checkSentinel);\n    }\n\n    return canSuspend ? r : Sk.misceval.retryOptionalSuspensionOrThrow(r);\n};\n\nSk.builtin.iterator.prototype.next$ = function (self) {\n    var ret = self.tp$iternext();\n    if (!ret) {\n        throw new Sk.builtin.StopIteration();\n    }\n    return ret;\n};\n\nSk.exportSymbol(\"Sk.builtin.iterator\", Sk.builtin.iterator);\n","/**\n * @constructor\n * @param {Object} iterable\n * @param {number=} start\n * @extends Sk.builtin.object\n */\nSk.builtin.enumerate = function (iterable, start) {\n    var it;\n    if (!(this instanceof Sk.builtin.enumerate)) {\n        return new Sk.builtin.enumerate(iterable, start);\n    }\n\n\n    Sk.builtin.pyCheckArgsLen(\"enumerate\", arguments.length, 1, 2);\n    if (!Sk.builtin.checkIterable(iterable)) {\n        throw new Sk.builtin.TypeError(\"'\" + Sk.abstr.typeName(iterable) + \"' object is not iterable\");\n    }\n    if (start !== undefined) {\n        if (!Sk.misceval.isIndex(start)) {\n            throw new Sk.builtin.TypeError(\"'\" + Sk.abstr.typeName(start) + \"' object cannot be interpreted as an index\");\n        } else {\n            start = Sk.misceval.asIndex(start);\n        }\n    } else {\n        start = 0;\n    }\n\n    it = iterable.tp$iter();\n\n    this.tp$iter = function () {\n        return this;\n    };\n    this.$index = start;\n    this.tp$iternext = function () {\n        // todo; StopIteration\n        var idx;\n        var next = it.tp$iternext();\n        if (next === undefined) {\n            return undefined;\n        }\n        idx = new Sk.builtin.int_(this.$index++);\n        return new Sk.builtin.tuple([idx, next]);\n    };\n\n    this.__class__ = Sk.builtin.enumerate;\n\n    return this;\n};\n\nSk.abstr.setUpInheritance(\"enumerate\", Sk.builtin.enumerate, Sk.builtin.object);\n\nSk.builtin.enumerate.prototype[\"__iter__\"] = new Sk.builtin.func(function (self) {\n    return self.tp$iter();\n});\n\nSk.builtin.enumerate.prototype.next$ = function (self) {\n    return self.tp$iternext();\n};\n\nSk.builtin.enumerate.prototype[\"$r\"] = function () {\n    return new Sk.builtin.str(\"<enumerate object>\");\n};\n","//\"\"\"Token constants (from somewhere).\"\"\"\n\nvar __all__ = [\"tok_name\", \"ISTERMINAL\", \"ISNONTERMINAL\", \"ISEOF\"];\n\n// #  This file is automatically generated; please don't muck it up!\n// #\n// #  To update the symbols in this file, 'cd' to the top directory of\n// #  the python source tree after building the interpreter and run:\n// #\n// #    ./python Lib/token.py\n\n// #--start constants--\nvar tokens = {\n    T_ENDMARKER: 0,\n    T_NAME: 1,\n    T_NUMBER: 2,\n    T_STRING: 3,\n    T_NEWLINE: 4,\n    T_INDENT: 5,\n    T_DEDENT: 6,\n    T_LPAR: 7,\n    T_RPAR: 8,\n    T_LSQB: 9,\n    T_RSQB: 10,\n    T_COLON: 11,\n    T_COMMA: 12,\n    T_SEMI: 13,\n    T_PLUS: 14,\n    T_MINUS: 15,\n    T_STAR: 16,\n    T_SLASH: 17,\n    T_VBAR: 18,\n    T_AMPER: 19,\n    T_LESS: 20,\n    T_GREATER: 21,\n    T_EQUAL: 22,\n    T_DOT: 23,\n    T_PERCENT: 24,\n    T_LBRACE: 25,\n    T_RBRACE: 26,\n    T_EQEQUAL: 27,\n    T_NOTEQUAL: 28,\n    T_LESSEQUAL: 29,\n    T_GREATEREQUAL: 30,\n    T_TILDE: 31,\n    T_CIRCUMFLEX: 32,\n    T_LEFTSHIFT: 33,\n    T_RIGHTSHIFT: 34,\n    T_DOUBLESTAR: 35,\n    T_PLUSEQUAL: 36,\n    T_MINEQUAL: 37,\n    T_STAREQUAL: 38,\n    T_SLASHEQUAL: 39,\n    T_PERCENTEQUAL: 40,\n    T_AMPEREQUAL: 41,\n    T_VBAREQUAL: 42,\n    T_CIRCUMFLEXEQUAL: 43,\n    T_LEFTSHIFTEQUAL: 44,\n    T_RIGHTSHIFTEQUAL: 45,\n    T_DOUBLESTAREQUAL: 46,\n    T_DOUBLESLASH: 47,\n    T_DOUBLESLASHEQUAL: 48,\n    T_AT: 49,\n    T_ATEQUAL: 50,\n    T_RARROW: 51,\n    T_ELLIPSIS: 52,\n    T_OP: 53,\n    T_AWAIT: 54,\n    T_ASYNC: 55,\n    T_ERRORTOKEN: 56,\n\n    //special cases\n    T_NT_OFFSET: 256,\n    T_N_TOKENS: 60,\n\n    //taken from tokenize.py\n    T_COMMENT: 57,\n    T_NL: 58,\n    T_ENCODING: 59\n};\n// #--end constants--\n\nvar EXACT_TOKEN_TYPES = {\n    \"!=\": tokens.NOTEQUAL,\n    \"%\": tokens.PERCENT,\n    \"%=\": tokens.PERCENTEQUAL,\n    \"&\": tokens.AMPER,\n    \"&=\": tokens.AMPEREQUAL,\n    \"(\": tokens.LPAR,\n    \")\": tokens.RPAR,\n    \"*\": tokens.STAR,\n    \"**\": tokens.DOUBLESTAR,\n    \"**=\": tokens.DOUBLESTAREQUAL,\n    \"*=\": tokens.STAREQUAL,\n    \"+\": tokens.PLUS,\n    \"+=\": tokens.PLUSEQUAL,\n    \",\": tokens.COMMA,\n    \"-\": tokens.MINUS,\n    \"-=\": tokens.MINEQUAL,\n    \"->\": tokens.RARROW,\n    \".\": tokens.DOT,\n    \"...\": tokens.ELLIPSIS,\n    \"/\": tokens.SLASH,\n    \"//\": tokens.DOUBLESLASH,\n    \"//=\": tokens.DOUBLESLASHEQUAL,\n    \"/=\": tokens.SLASHEQUAL,\n    \":\": tokens.COLON,\n    \":=\": tokens.COLONEQUAL,\n    \";\": tokens.SEMI,\n    \"<\": tokens.LESS,\n    \"<<\": tokens.LEFTSHIFT,\n    \"<<=\": tokens.LEFTSHIFTEQUAL,\n    \"<=\": tokens.LESSEQUAL,\n    \"=\": tokens.EQUAL,\n    \"==\": tokens.EQEQUAL,\n    \">\": tokens.GREATER,\n    \">=\": tokens.GREATEREQUAL,\n    \">>\": tokens.RIGHTSHIFT,\n    \">>=\": tokens.RIGHTSHIFTEQUAL,\n    \"@\": tokens.AT,\n    \"@=\": tokens.ATEQUAL,\n    \"[\": tokens.LSQB,\n    \"]\": tokens.RSQB,\n    \"^\": tokens.CIRCUMFLEX,\n    \"^=\": tokens.CIRCUMFLEXEQUAL,\n    \"{\": tokens.LBRACE,\n    \"|\": tokens.VBAR,\n    \"|=\": tokens.VBAREQUAL,\n    \"}\": tokens.RBRACE,\n    \"~\": tokens.TILDE,\n};\n\nvar tok_name = {};\n(function() {\n    for (var i in tokens) {\n        tok_name[tokens[i]] = i;\n    }\n})();\n\n__all__.concat(Object.keys(tok_name).map(function (k) { return tok_name[k]; }));\n\nfunction ISTERMINAL(x) {\n    return x < tokens.T_NT_OFFSET;\n}\n\nfunction ISNONTERMINAL(x) {\n    return x >= tokens.T_NT_OFFSET;\n}\n\nfunction ISEOF(x) {\n    return x == tokens.T_ENDMARKER;\n}\n\nSk.token = {};\nSk.token.tokens = tokens;\nSk.token.tok_name = tok_name;\nSk.token.EXACT_TOKEN_TYPES = EXACT_TOKEN_TYPES;\nSk.token.ISTERMINAL = ISTERMINAL;\nSk.token.ISNONTERMINAL = ISNONTERMINAL;\nSk.token.ISEOF = ISEOF;\n\nSk.exportSymbol(\"Sk.token\", Sk.token);\nSk.exportSymbol(\"Sk.token.tokens\", Sk.token.tokens);\nSk.exportSymbol(\"Sk.token.tok_name\", Sk.token.tok_name);\nSk.exportSymbol(\"Sk.token.EXACT_TOKEN_TYPES\");\nSk.exportSymbol(\"Sk.token.ISTERMINAL\", Sk.token.ISTERMINAL);\nSk.exportSymbol(\"Sk.token.ISNONTERMINAL\", Sk.token.ISNONTERMINAL);\nSk.exportSymbol(\"Sk.token.ISEOF\", Sk.token.ISEOF);\n","var tokens = Sk.token.tokens\n\nconst TokenError = Error;\nconst IndentationError = Error;\n\n/**\n *\n * @constructor\n * @param {number} type\n * @param {string} string\n * @param {Array<number>} start\n * @param {Array<number>} end\n * @param {string} line\n */\nfunction TokenInfo(type, string, start, end, line) {\n    this.type = type;\n    this.string = string;\n    this.start = start;\n    this.end = end;\n    this.line = line;\n}\n\nTokenInfo.prototype.exact_type = function() {\n    if (this.type == tokens.T_OP && this.string in Sk.token.EXACT_TOKEN_TYPES) {\n    return Sk.token.EXACT_TOKEN_TYPES[this.string]\n    } else {\n        return this.type\n    }\n}\n\n/** @param {...*} x */\nfunction group (x) {\n    var args = Array.prototype.slice.call(arguments);\n    return \"(\" + args.join(\"|\") + \")\";\n}\n\n/** @param {...*} x */\nfunction any (x) {\n    return group.apply(null, arguments) + \"*\";\n}\n\n/** @param {...*} x */\nfunction maybe (x) {\n    return group.apply(null, arguments) + \"?\";\n}\n\nvar reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g,\n    reHasRegExpChar = RegExp(reRegExpChar.source);\n\nfunction regexEscape(string) {\n    return (string && reHasRegExpChar.test(string))\n        ? string.replace(reRegExpChar, '\\\\$&')\n        : string;\n}\n\n/**\n * Iterable contains\n * @template T\n * @param {Iterable<T>} a\n * @param {T} obj\n */\nfunction contains (a, obj) {\n    var i = a.length;\n    while (i--) {\n        if (a[i] === obj) {\n            return true;\n        }\n    }\n    return false;\n}\n\nfunction rstrip (input, what) {\n    var i;\n    for (i = input.length; i > 0; --i) {\n        if (what.indexOf(input.charAt(i - 1)) === -1) {\n            break;\n        }\n    }\n    return input.substring(0, i);\n}\n\n/**\n * test if string is an identifier\n *\n * @param {str} string\n * @returns {boolean}\n */\nfunction isidentifier(str) {\n    var normalized = str.normalize('NFKC');\n    var the_underscore = '_';\n    var Lu = '[A-Z]';\n    var Ll = '[a-z]';\n    var Lt = '[\\\\u{10B99}-\\\\u{10B9C}\\\\u{112A9}\\\\u{115DC}-\\\\u{115DD}\\\\u034F\\\\u115F-\\\\u1160\\\\u17B4-\\\\u17B5\\\\u2065\\\\u3164\\\\uFFA0\\\\uFFF0-\\\\uFFF8\\\\u{E0000}\\\\u{E0002}-\\\\u{E001F}\\\\u{E0080}-\\\\u{E00FF}\\\\u{E01F0}-\\\\u{E0FFF}\\\\u{112A9}\\\\u00D7]';\n    var Lm = '[\\\\u02B0-\\\\u02C1\\\\u02C6-\\\\u02D1\\\\u02E0-\\\\u02E4\\\\u02EC\\\\u02EE\\\\u0374\\\\u037A\\\\u0559\\\\u06E5-\\\\u06E6\\\\u07F4-\\\\u07F5\\\\u0971\\\\u1C78-\\\\u1C7D\\\\u1D2C-\\\\u1D6A\\\\u1DFD-\\\\u1DFF\\\\u2E2F\\\\u30FC\\\\uA67F\\\\uA69C-\\\\uA69D\\\\uA717-\\\\uA71F\\\\uA788\\\\uA7F8-\\\\uA7F9\\\\uAB5C-\\\\uAB5F\\\\uFF70\\\\uFF9E-\\\\uFF9F\\\\u{16F93}-\\\\u{16F9F}\\\\u02D0-\\\\u02D1\\\\u0640\\\\u07FA\\\\u0E46\\\\u0EC6\\\\u1843\\\\u1AA7\\\\u1C7B\\\\u3005\\\\u3031-\\\\u3035\\\\u309D-\\\\u309E\\\\u30FC-\\\\u30FE\\\\uA015\\\\uA60C\\\\uA9CF\\\\uA9E6\\\\uAA70\\\\uAADD\\\\uAAF3-\\\\uAAF4\\\\uFF70\\\\u{16B42}-\\\\u{16B43}\\\\u{16FE0}-\\\\u{16FE1}\\\\u02B0-\\\\u02B8\\\\u02C0-\\\\u02C1\\\\u02E0-\\\\u02E4\\\\u037A\\\\u1D2C-\\\\u1D6A\\\\u1D78\\\\u1D9B-\\\\u1DBF\\\\u2071\\\\u207F\\\\u2090-\\\\u209C\\\\u2C7C-\\\\u2C7D\\\\uA69C-\\\\uA69D\\\\uA770\\\\uA7F8-\\\\uA7F9\\\\uAB5C-\\\\uAB5F\\\\uFF9E-\\\\uFF9F\\\\u02B2\\\\u1D62\\\\u1DA4\\\\u1DA8\\\\u2071\\\\u2C7C\\\\u2E18-\\\\u2E19\\\\u2E2F]';\n    var Lo = '[\\\\u2135-\\\\u2138\\\\u{1EE00}-\\\\u{1EE03}\\\\u{1EE05}-\\\\u{1EE1F}\\\\u{1EE21}-\\\\u{1EE22}\\\\u{1EE24}\\\\u{1EE27}\\\\u{1EE29}-\\\\u{1EE32}\\\\u{1EE34}-\\\\u{1EE37}\\\\u{1EE39}\\\\u{1EE3B}\\\\u{1EE42}\\\\u{1EE47}\\\\u{1EE49}\\\\u{1EE4B}\\\\u{1EE4D}-\\\\u{1EE4F}\\\\u{1EE51}-\\\\u{1EE52}\\\\u{1EE54}\\\\u{1EE57}\\\\u{1EE59}\\\\u{1EE5B}\\\\u{1EE5D}\\\\u{1EE5F}\\\\u{1EE61}-\\\\u{1EE62}\\\\u{1EE64}\\\\u{1EE67}-\\\\u{1EE6A}\\\\u{1EE6C}-\\\\u{1EE72}\\\\u{1EE74}-\\\\u{1EE77}\\\\u{1EE79}-\\\\u{1EE7C}\\\\u{1EE7E}\\\\u{1EE80}-\\\\u{1EE89}\\\\u{1EE8B}-\\\\u{1EE9B}\\\\u{1EEA1}-\\\\u{1EEA3}\\\\u{1EEA5}-\\\\u{1EEA9}\\\\u{1EEAB}-\\\\u{1EEBB}\\\\u3006\\\\u3400-\\\\u4DB5\\\\u4E00-\\\\u9FEF\\\\uF900-\\\\uFA6D\\\\uFA70-\\\\uFAD9\\\\u{17000}-\\\\u{187F1}\\\\u{18800}-\\\\u{18AF2}\\\\u{1B170}-\\\\u{1B2FB}\\\\u{20000}-\\\\u{2A6D6}\\\\u{2A700}-\\\\u{2B734}\\\\u{2B740}-\\\\u{2B81D}\\\\u{2B820}-\\\\u{2CEA1}\\\\u{2CEB0}-\\\\u{2EBE0}\\\\u{2F800}-\\\\u{2FA1D}\\\\uAAC0\\\\uAAC2\\\\uFE20-\\\\uFE2F\\\\u{10D22}-\\\\u{10D23}\\\\u{1135D}\\\\u00AA\\\\u00BA\\\\u3400-\\\\u4DB5\\\\u4E00-\\\\u9FEF\\\\uFA0E-\\\\uFA0F\\\\uFA11\\\\uFA13-\\\\uFA14\\\\uFA1F\\\\uFA21\\\\uFA23-\\\\uFA24\\\\uFA27-\\\\uFA29\\\\u{20000}-\\\\u{2A6D6}\\\\u{2A700}-\\\\u{2B734}\\\\u{2B740}-\\\\u{2B81D}\\\\u{2B820}-\\\\u{2CEA1}\\\\u{2CEB0}-\\\\u{2EBE0}\\\\u115F-\\\\u1160\\\\u3164\\\\uFFA0\\\\u0673\\\\u17A3-\\\\u17A4\\\\u0E40-\\\\u0E44\\\\u0EC0-\\\\u0EC4\\\\u19B5-\\\\u19B7\\\\u19BA\\\\uAAB5-\\\\uAAB6\\\\uAAB9\\\\uAABB-\\\\uAABC]';\n    var Nl = '[\\\\u3007\\\\u3021-\\\\u3029\\\\u3038-\\\\u303A\\\\u2170-\\\\u217F\\\\u2160-\\\\u216F]';\n    var Mn = '[\\\\u104A-\\\\u104B\\\\u102B-\\\\u102C\\\\u102D-\\\\u1030\\\\u1031\\\\u1032-\\\\u1036\\\\u1038\\\\u103B-\\\\u103C\\\\u103D-\\\\u103E\\\\u1056-\\\\u1057\\\\u1058-\\\\u1059\\\\u105E-\\\\u1060\\\\u1062\\\\u1067-\\\\u1068\\\\u1071-\\\\u1074\\\\u1082\\\\u1083-\\\\u1084\\\\u1085-\\\\u1086\\\\u109C\\\\u109D\\\\u1037\\\\u1039-\\\\u103A\\\\u1087-\\\\u108C\\\\u108D\\\\u108F\\\\u109A-\\\\u109B\\\\uA9E5\\\\uAA7B\\\\uAA7C\\\\uAA7D\\\\uA9E6\\\\uAA70\\\\u104A-\\\\u104B]';\n    var Mc = '[\\\\u0903\\\\u093B\\\\u093E-\\\\u0940\\\\u0949-\\\\u094C\\\\u094E-\\\\u094F\\\\u0982-\\\\u0983\\\\u09BE-\\\\u09C0\\\\u09C7-\\\\u09C8\\\\u09CB-\\\\u09CC\\\\u09D7\\\\u0A03\\\\u0A3E-\\\\u0A40\\\\u0A83\\\\u0ABE-\\\\u0AC0\\\\u0AC9\\\\u0ACB-\\\\u0ACC\\\\u0B02-\\\\u0B03\\\\u0B3E\\\\u0B40\\\\u0B47-\\\\u0B48\\\\u0B4B-\\\\u0B4C\\\\u0B57\\\\u0BBE-\\\\u0BBF\\\\u0BC1-\\\\u0BC2\\\\u0BC6-\\\\u0BC8\\\\u0BCA-\\\\u0BCC\\\\u0BD7\\\\u0C01-\\\\u0C03\\\\u0C41-\\\\u0C44\\\\u0C82-\\\\u0C83\\\\u0CBE\\\\u0CC0-\\\\u0CC4\\\\u0CC7-\\\\u0CC8\\\\u0CCA-\\\\u0CCB\\\\u0CD5-\\\\u0CD6\\\\u0D02-\\\\u0D03\\\\u0D3E-\\\\u0D40\\\\u0D46-\\\\u0D48\\\\u0D4A-\\\\u0D4C\\\\u0D57\\\\u0D82-\\\\u0D83\\\\u0DCF-\\\\u0DD1\\\\u0DD8-\\\\u0DDF\\\\u0DF2-\\\\u0DF3\\\\u0F7F\\\\u102B-\\\\u102C\\\\u1031\\\\u1038\\\\u103B-\\\\u103C\\\\u1056-\\\\u1057\\\\u1062\\\\u1067-\\\\u1068\\\\u1083-\\\\u1084\\\\u109C\\\\u17B6\\\\u17BE-\\\\u17C5\\\\u17C7-\\\\u17C8\\\\u1923-\\\\u1926\\\\u1929-\\\\u192B\\\\u1930-\\\\u1931\\\\u1933-\\\\u1938\\\\u1A19-\\\\u1A1A\\\\u1A55\\\\u1A57\\\\u1A61\\\\u1A63-\\\\u1A64\\\\u1A6D-\\\\u1A72\\\\u1B04\\\\u1B35\\\\u1B3B\\\\u1B3D-\\\\u1B41\\\\u1B43\\\\u1B82\\\\u1BA1\\\\u1BA6-\\\\u1BA7\\\\u1BE7\\\\u1BEA-\\\\u1BEC\\\\u1BEE\\\\u1C24-\\\\u1C2B\\\\u1C34-\\\\u1C35\\\\u1CF2-\\\\u1CF3\\\\uA823-\\\\uA824\\\\uA827\\\\uA880-\\\\uA881\\\\uA8B4-\\\\uA8C3\\\\uA952\\\\uA983\\\\uA9B4-\\\\uA9B5\\\\uA9BA-\\\\uA9BB\\\\uA9BD-\\\\uA9BF\\\\uAA2F-\\\\uAA30\\\\uAA33-\\\\uAA34\\\\uAA4D\\\\uAAEB\\\\uAAEE-\\\\uAAEF\\\\uAAF5\\\\uABE3-\\\\uABE4\\\\uABE6-\\\\uABE7\\\\uABE9-\\\\uABEA\\\\u{11000}\\\\u{11002}\\\\u{11082}\\\\u{110B0}-\\\\u{110B2}\\\\u{110B7}-\\\\u{110B8}\\\\u{1112C}\\\\u{11145}-\\\\u{11146}\\\\u{11182}\\\\u{111B3}-\\\\u{111B5}\\\\u{111BF}\\\\u{1122C}-\\\\u{1122E}\\\\u{11232}-\\\\u{11233}\\\\u{112E0}-\\\\u{112E2}\\\\u{11302}-\\\\u{11303}\\\\u{1133E}-\\\\u{1133F}\\\\u{11341}-\\\\u{11344}\\\\u{11347}-\\\\u{11348}\\\\u{1134B}-\\\\u{1134C}\\\\u{11357}\\\\u{11362}-\\\\u{11363}\\\\u{11435}-\\\\u{11437}\\\\u{11440}-\\\\u{11441}\\\\u{11445}\\\\u{114B0}-\\\\u{114B2}\\\\u{114B9}\\\\u{114BB}-\\\\u{114BE}\\\\u{114C1}\\\\u{115AF}-\\\\u{115B1}\\\\u{115B8}-\\\\u{115BB}\\\\u{115BE}\\\\u{11630}-\\\\u{11632}\\\\u{1163B}-\\\\u{1163C}\\\\u{1163E}\\\\u{116AC}\\\\u{116AE}-\\\\u{116AF}\\\\u{11720}-\\\\u{11721}\\\\u{11726}\\\\u{1182C}-\\\\u{1182E}\\\\u{11838}\\\\u{11A39}\\\\u{11A57}-\\\\u{11A58}\\\\u{11A97}\\\\u{11C2F}\\\\u{11C3E}\\\\u{11CA9}\\\\u{11CB1}\\\\u{11CB4}\\\\u{11D8A}-\\\\u{11D8E}\\\\u{11D93}-\\\\u{11D94}\\\\u{11D96}\\\\u{11EF5}-\\\\u{11EF6}\\\\u{16F51}-\\\\u{16F7E}\\\\u0F3E-\\\\u0F3F\\\\u1087-\\\\u108C\\\\u108F\\\\u109A-\\\\u109B\\\\u1B44\\\\u1BAA\\\\u1CE1\\\\u1CF7\\\\u302E-\\\\u302F\\\\uA953\\\\uA9C0\\\\uAA7B\\\\uAA7D\\\\uABEC\\\\u{111C0}\\\\u{11235}\\\\u{1134D}\\\\u{116B6}\\\\u{1D16D}-\\\\u{1D172}\\\\u09BE\\\\u09D7\\\\u0B3E\\\\u0B57\\\\u0BBE\\\\u0BD7\\\\u0CC2\\\\u0CD5-\\\\u0CD6\\\\u0D3E\\\\u0D57\\\\u0DCF\\\\u0DDF\\\\u302E-\\\\u302F\\\\u{1133E}\\\\u{11357}\\\\u{114B0}\\\\u{114BD}\\\\u{115AF}\\\\u{1D165}\\\\u{1D16E}-\\\\u{1D172}]';\n    var Nd = '[\\\\u{1D7CE}-\\\\u{1D7FF}\\\\uFF10-\\\\uFF19]';\n    var Pc = '\\\\u2040';\n    var Other_ID_Start = '[\\\\u1885-\\\\u1886\\\\u2118\\\\u212E\\\\u309B-\\\\u309C]';\n    var Other_ID_Continue = '[\\\\u00B7\\\\u0387\\\\u1369-\\\\u1371\\\\u19DA]';\n    var id_start = group(Lu, Ll,Lt, Lm, Lo, Nl, the_underscore, Other_ID_Start);\n    var id_continue = group(id_start, Mn, Mc, Nd, Pc, Other_ID_Continue);\n    var r;\n    // Fall back if we don't support unicode\n    if (RegExp().unicode === false) {\n        r = new RegExp('^' + id_start + '+' + id_continue + '*$', 'u');\n    } else {\n        id_start = group(Lu, Ll, the_underscore);\n        id_continue = group(id_start, '[0-9]');\n        r = new RegExp('^' + id_start + '+' + id_continue + '*$');\n    }\n    return r.test(normalized);\n}\n\n/* we have to use string and ctor to be able to build patterns up. + on /.../\n * does something strange.\n * Note: we use unicode matching for names (\"\\w\") but ascii matching for\n * number literals.\n *\n * I don't know if the comment above is still actually correct */\nvar Whitespace = \"[ \\\\f\\\\t]*\";\nvar Comment_ = \"#[^\\\\r\\\\n]*\";\nvar Ignore = Whitespace + any('\\\\\\\\\\\\r?\\\\n' + Whitespace) + maybe(Comment_)\nvar Name = \"\\\\w+\";\n\n\nvar Exponent = \"[eE][-+]?[0-9](?:_?[0-9])*\";\nvar Pointfloat = group('[0-9](?:_?[0-9])*\\\\.(?:[0-9](?:_?[0-9])*)?',\n                       '\\\\.[0-9](?:_?[0-9])*') + maybe(Exponent)\nvar Expfloat = \"[0-9](?:_?[0-9])*\" + Exponent;\nvar Floatnumber = group(Pointfloat, Expfloat);\nvar Imagnumber = group(\"[0-9](?:_?[0-9])*[jJ]\", Floatnumber + \"[jJ]\");\n\n// Return the empty string, plus all of the valid string prefixes.\nfunction _all_string_prefixes() {\n    return [\n        '', 'FR', 'RF', 'Br', 'BR', 'Fr', 'r', 'B', 'R', 'b', 'bR',\n        'f', 'rb', 'rB', 'F', 'Rf', 'U', 'rF', 'u', 'RB', 'br', 'fR',\n        'fr', 'rf', 'Rb'];\n}\n\n// Note that since _all_string_prefixes includes the empty string,\n//  StringPrefix can be the empty string (making it optional).\nvar StringPrefix = group.apply(null, _all_string_prefixes())\n\n// these regexes differ from python because .exec doesn't do the\n// same thing as .match in python. It's more like .search.\n// .match matches from the start of the string.\n// to get the same behaviour we can add a ^ to the start of the\n// regex\n// Tail end of ' string.\nvar Single = \"^[^'\\\\\\\\]*(?:\\\\\\\\.[^'\\\\\\\\]*)*'\";\n// Tail end of \" string.\nvar Double = '^[^\"\\\\\\\\]*(?:\\\\\\\\.[^\"\\\\\\\\]*)*\"';\n// Tail end of ''' string.\nvar Single3 = \"^[^'\\\\\\\\]*(?:(?:\\\\\\\\.|'(?!''))[^'\\\\\\\\]*)*'''\";\n// Tail end of \"\"\" string.\nvar Double3 = '^[^\"\\\\\\\\]*(?:(?:\\\\\\\\.|\"(?!\"\"))[^\"\\\\\\\\]*)*\"\"\"';\nvar Triple = group(StringPrefix + \"'''\", StringPrefix + '\"\"\"');\n// Single-line ' or \" string.\nvar String_ = group(StringPrefix + \"'[^\\\\n'\\\\\\\\]*(?:\\\\\\\\.[^\\\\n'\\\\\\\\]*)*'\",\n                    StringPrefix + '\"[^\\\\n\"\\\\\\\\]*(?:\\\\\\\\.[^\\\\n\"\\\\\\\\]*)*\"');\n\n// Sorting in reverse order puts the long operators before their prefixes.\n// Otherwise if = came before ==, == would get recognized as two instances\n// of =.\nvar EXACT_TOKENS_SORTED = Object.keys(Sk.token.EXACT_TOKEN_TYPES).sort();\nvar Special = group.apply(this, EXACT_TOKENS_SORTED.reverse().map(function (t) { return regexEscape(t); }));\nvar Funny = group('\\\\r?\\\\n', Special);\n\n// these aren't actually used\n// var PlainToken = group(Number_, Funny, String_, Name);\n// var Token = Ignore + PlainToken;\n\n// First (or only) line of ' or \" string.\nvar ContStr = group(StringPrefix + \"'[^\\\\n'\\\\\\\\]*(?:\\\\\\\\.[^\\\\n'\\\\\\\\]*)*\" +\n                group(\"'\", '\\\\\\\\\\\\r?\\\\n'),\n                StringPrefix + '\"[^\\\\n\"\\\\\\\\]*(?:\\\\\\\\.[^\\\\n\"\\\\\\\\]*)*' +\n                group('\"', '\\\\\\\\\\\\r?\\\\n'))\nvar PseudoExtras = group('\\\\\\\\\\\\r?\\\\n|$', Comment_, Triple);\n\n// For a given string prefix plus quotes, endpats maps it to a regex\n//  to match the remainder of that string. _prefix can be empty, for\n//  a normal single or triple quoted string (with no prefix).\nvar endpats = {}\nvar prefixes = _all_string_prefixes();\nfor (let _prefix of prefixes) {\n    endpats[_prefix + \"'\"] = Single\n    endpats[_prefix + '\"'] = Double\n    endpats[_prefix + \"'''\"] = Single3\n    endpats[_prefix + '\"\"\"'] = Double3\n}\n\n// A set of all of the single and triple quoted string prefixes,\n//  including the opening quotes.\nlet single_quoted = []\nlet triple_quoted = []\nfor (let t of prefixes) {\n    single_quoted.push(t + '\"');\n    single_quoted.push(t + \"'\");\n    triple_quoted.push(t + '\"\"\"');\n    triple_quoted.push(t + \"'''\");\n}\n\nvar tabsize = 8\n\n/**\n * internal tokenize function\n *\n * @param {function(): string} readline\n * @param {string} encoding\n * @param {function(TokenInfo): void} yield_\n */\nfunction _tokenize(readline, encoding, yield_) {\n    // we make these regexes here because they can\n    // be changed by the configuration.\n    var LSuffix = Sk.__future__.l_suffix ? '(?:L?)' : '';\n    var Hexnumber = '0[xX](?:_?[0-9a-fA-F])+' + LSuffix;\n    var Binnumber = '0[bB](?:_?[01])+' + LSuffix;\n    var Octnumber = '0([oO])(?:_?[0-7])+' + LSuffix;\n    var SilentOctnumber = '0([oO]?)(?:_?[0-7])+' + LSuffix;\n    var Decnumber = '(?:0(?:_?0)*|[1-9](?:_?[0-9])*)' + LSuffix;\n    var Intnumber = group(Hexnumber, Binnumber,\n                          (Sk.__future__.silent_octal_literal ? SilentOctnumber : Octnumber), Decnumber);\n    var Number_ = group(Imagnumber, Floatnumber, Intnumber);\n    var PseudoToken = Whitespace + group(PseudoExtras, Number_, Funny, ContStr, Name);\n\n    var lnum = 0,\n        parenlev = 0,\n        continued = 0,\n        numchars = '0123456789',\n        contstr = '',\n        needcont = 0,\n        contline = null,\n        indents = [0],\n        capos = null,\n        endprog = undefined,\n        strstart = undefined,\n        end = undefined,\n        pseudomatch = undefined;\n\n    if (encoding !== undefined) {\n        if (encoding == \"utf-8-sig\") {\n            // BOM will already have been stripped.\n            encoding = \"utf-8\";\n        }\n\n        yield_(new TokenInfo(tokens.T_ENCODING, encoding, [0, 0], [0, 0], ''));\n    }\n\n    var last_line = '';\n    var line = '';\n    while (true) {                                // loop over lines in stream\n        try {\n            // We capture the value of the line variable here because\n            // readline uses the empty string '' to signal end of input,\n            // hence `line` itself will always be overwritten at the end\n            // of this loop.\n            last_line = line;\n            line = readline();\n        } catch (Exception) {\n            line = '';\n        }\n\n        // lets pretend this doesn't exist for now.\n        // if encoding is not None:\n        //     line = line.decode(encoding)\n        lnum += 1;\n        var pos = 0;\n        var max = line.length;\n\n        if (contstr) {                       // continued string\n            if (!line) {\n                throw new TokenError(\"EOF in multi-line string\", strstart);\n            }\n            endprog.lastIndex = 0;\n            var endmatch = endprog.exec(line);\n            if (endmatch) {\n                pos = end = endmatch[0].length;\n                yield_(new TokenInfo(tokens.T_STRING, contstr + line.substring(0, end),\n                       strstart, [lnum, end], contline + line));\n                contstr = '';\n                needcont = 0;\n                contline = null;\n            } else if (needcont && line.substring(line.length - 2) !== \"\\\\\\n\" && line.substring(line.length - 3) !== \"\\\\\\r\\n\") {\n                yield_(new TokenInfo(tokens.T_ERRORTOKEN, contstr + line,\n                           strstart, [lnum, line.length], contline));\n                contstr = '';\n                contline = null;\n                continue;\n            } else {\n                contstr = contstr + line;\n                contline = contline + line;\n                continue;\n            }\n        } else if (parenlev == 0 && !continued) {  // new statement\n            if (!line) { break; }\n            var column = 0;\n            while (pos < max) {              // measure leading whitespace\n                if (line[pos] == ' ') {\n                    column += 1\n                } else if (line[pos] == '\\t') {\n                    column = Math.floor(column/tabsize + 1) * tabsize;\n                } else if (line[pos] == '\\f') {\n                    column = 0\n                } else {\n                    break;\n                };\n                pos += 1\n            }\n\n            if (pos == max) {\n                break;\n            }\n\n            if (contains('#\\r\\n', line[pos])) {       // skip comments or blank lines\n                if (line[pos] == '#') {\n                    var comment_token = rstrip(line.substring(pos), '\\r\\n');\n                    yield_(new TokenInfo(tokens.T_COMMENT, comment_token,\n                           [lnum, pos], [lnum, pos + comment_token.length], line));\n                    pos += comment_token.length;\n                }\n\n                yield_(new TokenInfo(tokens.T_NL, line.substring(pos),\n                           [lnum, pos], [lnum, line.length], line));\n                continue;\n            }\n\n            if (column > indents[indents.length - 1]) {           // count indents or dedents\n                indents.push(column);\n                yield_(new TokenInfo(tokens.T_INDENT, line.substring(pos), [lnum, 0], [lnum, pos], line));\n            }\n\n            while (column < indents[indents.length - 1]) {\n                if (!contains(indents, column)) {\n                    throw new IndentationError(\n                        \"unindent does not match any outer indentation level\",\n                        [\"<tokenize>\", lnum, pos, line]);\n                }\n\n                indents = indents.slice(0, -1);\n\n                yield_(new TokenInfo(tokens.T_DEDENT, '', [lnum, pos], [lnum, pos], line));\n            }\n        } else {                                  // continued statement\n            if (!line) {\n                throw new TokenError(\"EOF in multi-line statement\", [lnum, 0]);\n            }\n            continued = 0;\n        }\n\n        while (pos < max) {\n            //console.log(\"pos:\"+pos+\":\"+max);\n            // js regexes don't return any info about matches, other than the\n            // content. we'd like to put a \\w+ before pseudomatch, but then we\n            // can't get any data\n            capos = line.charAt(pos);\n            while (capos === ' ' || capos === '\\f' || capos === '\\t') {\n                pos += 1;\n                capos = line.charAt(pos);\n            }\n\n            pseudomatch = RegExp(PseudoToken).exec(line.substring(pos))\n            if (pseudomatch) {                                // scan for tokens\n                var start = pos;\n                var end = start + pseudomatch[1].length;\n                var spos = [lnum, start];\n                var epos = [lnum, end];\n                var pos = end;\n                if (start == end) {\n                    continue;\n                }\n\n                var token = line.substring(start, end);\n                var initial = line[start];\n                //console.log(\"token:\",token, \"initial:\",initial, start, end);\n                if (contains(numchars, initial) ||                 // ordinary number\n                    (initial == '.' && token != '.' && token != '...')) {\n                    yield_(new TokenInfo(tokens.T_NUMBER, token, spos, epos, line));\n                } else if (contains('\\r\\n', initial)) {\n                    if (parenlev > 0) {\n                        yield_(new TokenInfo(tokens.T_NL, token, spos, epos, line));\n                    } else {\n                        yield_(new TokenInfo(tokens.T_NEWLINE, token, spos, epos, line));\n                    }\n                } else if (initial == '#') {\n                    //assert not token.endswith(\"\\n\")\n                    yield_(new TokenInfo(tokens.T_COMMENT, token, spos, epos, line));\n                } else if (contains(triple_quoted, token)) {\n                    endprog = RegExp(endpats[token]);\n                    endmatch = endprog.exec(line.substring(pos));\n                    if (endmatch) {                       // all on one line\n                        pos = endmatch[0].length + pos;\n                        token = line.substring(start, pos);\n                        yield_(new TokenInfo(tokens.T_STRING, token, spos, [lnum, pos], line));\n                    } else {\n                        strstart = [lnum, start];           // multiple lines\n                        contstr = line.substring(start);\n                        contline = line;\n                        break;\n                    }\n                // Check up to the first 3 chars of the token to see if\n                //  they're in the single_quoted set. If so, they start\n                //  a string.\n                // We're using the first 3, because we're looking for\n                //  \"rb'\" (for example) at the start of the token. If\n                //  we switch to longer prefixes, this needs to be\n                //  adjusted.\n                // Note that initial == token[:1].\n                // Also note that single quote checking must come after\n                //  triple quote checking (above).\n                } else if (contains(single_quoted, initial) ||\n                           contains(single_quoted, token.substring(0, 2)) ||\n                           contains(single_quoted, token.substring(0, 3))) {\n                    if (token[token.length - 1] == '\\n') {                // continued string\n                        strstart = [lnum, start];\n                        // Again, using the first 3 chars of the\n                        //  token. This is looking for the matching end\n                        //  regex for the correct type of quote\n                        //  character. So it's really looking for\n                        //  endpats[\"'\"] or endpats['\"'], by trying to\n                        //  skip string prefix characters, if any.\n                        endprog = RegExp(endpats[initial] ||\n                                           endpats[token[1]] ||\n                                           endpats[token[2]]);\n                        contstr = line.substring(start);\n                        needcont = 1;\n                        contline = line;\n                        break;\n                    } else {                                  // ordinary string\n                        yield_(new TokenInfo(tokens.T_STRING, token, spos, epos, line));\n                    }\n\n                } else if (isidentifier(initial)) {              // ordinary name\n                    yield_(new TokenInfo(tokens.T_NAME, token, spos, epos, line));\n                } else if (initial == '\\\\') {                  // continued stmt\n                    continued = 1\n                } else {\n                    if (contains('([{', initial)) {\n                        parenlev += 1\n                    } else if (contains(')]}', initial)) {\n                        parenlev -= 1\n                    }\n                    yield_(new TokenInfo(tokens.T_OP, token, spos, epos, line));\n                }\n            } else {\n                yield_(new TokenInfo(tokens.T_ERRORTOKEN, line[pos],\n                           [lnum, pos], [lnum, pos+1], line));\n                pos += 1;\n            }\n        }\n    }\n\n    // Add an implicit NEWLINE if the input doesn't end in one\n    if (last_line && !contains('\\r\\n', last_line[last_line.length - 1])) {\n        yield_(new TokenInfo(tokens.T_NEWLINE, '', [lnum - 1, last_line.length], [lnum - 1, last_line.length + 1], ''));\n    }\n    for (var i in indents.slice(1)) {                 // pop remaining indent levels\n        yield_(new TokenInfo(tokens.T_DEDENT, '', [lnum, 0], [lnum, 0], ''));\n    }\n\n    yield_(new TokenInfo(tokens.T_ENDMARKER, '', [lnum, 0], [lnum, 0], ''));\n}\n\nSk._tokenize = _tokenize;\n\nSk.exportSymbol(\"Sk._tokenize\", Sk._tokenize);","// generated by pgen/main.py\nSk.OpMap = {\n\"(\": Sk.token.tokens.T_LPAR,\n\")\": Sk.token.tokens.T_RPAR,\n\"[\": Sk.token.tokens.T_LSQB,\n\"]\": Sk.token.tokens.T_RSQB,\n\":\": Sk.token.tokens.T_COLON,\n\",\": Sk.token.tokens.T_COMMA,\n\";\": Sk.token.tokens.T_SEMI,\n\"+\": Sk.token.tokens.T_PLUS,\n\"-\": Sk.token.tokens.T_MINUS,\n\"*\": Sk.token.tokens.T_STAR,\n\"/\": Sk.token.tokens.T_SLASH,\n\"|\": Sk.token.tokens.T_VBAR,\n\"&\": Sk.token.tokens.T_AMPER,\n\"<\": Sk.token.tokens.T_LESS,\n\">\": Sk.token.tokens.T_GREATER,\n\"=\": Sk.token.tokens.T_EQUAL,\n\".\": Sk.token.tokens.T_DOT,\n\"%\": Sk.token.tokens.T_PERCENT,\n\"`\": Sk.token.tokens.T_BACKQUOTE,\n\"{\": Sk.token.tokens.T_LBRACE,\n\"}\": Sk.token.tokens.T_RBRACE,\n\"@\": Sk.token.tokens.T_AT,\n\"==\": Sk.token.tokens.T_EQEQUAL,\n\"!=\": Sk.token.tokens.T_NOTEQUAL,\n\"<>\": Sk.token.tokens.T_NOTEQUAL,\n\"<=\": Sk.token.tokens.T_LESSEQUAL,\n\">=\": Sk.token.tokens.T_GREATEREQUAL,\n\"~\": Sk.token.tokens.T_TILDE,\n\"^\": Sk.token.tokens.T_CIRCUMFLEX,\n\"<<\": Sk.token.tokens.T_LEFTSHIFT,\n\">>\": Sk.token.tokens.T_RIGHTSHIFT,\n\"**\": Sk.token.tokens.T_DOUBLESTAR,\n\"+=\": Sk.token.tokens.T_PLUSEQUAL,\n\"-=\": Sk.token.tokens.T_MINEQUAL,\n\"*=\": Sk.token.tokens.T_STAREQUAL,\n\"/=\": Sk.token.tokens.T_SLASHEQUAL,\n\"%=\": Sk.token.tokens.T_PERCENTEQUAL,\n\"&=\": Sk.token.tokens.T_AMPEREQUAL,\n\"|=\": Sk.token.tokens.T_VBAREQUAL,\n\"^=\": Sk.token.tokens.T_CIRCUMFLEXEQUAL,\n\"<<=\": Sk.token.tokens.T_LEFTSHIFTEQUAL,\n\">>=\": Sk.token.tokens.T_RIGHTSHIFTEQUAL,\n\"**=\": Sk.token.tokens.T_DOUBLESTAREQUAL,\n\"//\": Sk.token.tokens.T_DOUBLESLASH,\n\"//=\": Sk.token.tokens.T_DOUBLESLASHEQUAL,\n\"->\": Sk.token.tokens.T_RARROW\n};\nSk.ParseTables = {\nsym:\n{and_expr: 257,\n and_test: 258,\n annassign: 259,\n arglist: 260,\n argument: 261,\n arith_expr: 262,\n assert_stmt: 263,\n async_funcdef: 264,\n async_stmt: 265,\n atom: 266,\n atom_expr: 267,\n augassign: 268,\n break_stmt: 269,\n classdef: 270,\n comp_for: 271,\n comp_if: 272,\n comp_iter: 273,\n comp_op: 274,\n comparison: 275,\n compound_stmt: 276,\n continue_stmt: 277,\n debugger_stmt: 278,\n decorated: 279,\n decorator: 280,\n decorators: 281,\n del_stmt: 282,\n dictorsetmaker: 283,\n dotted_as_name: 284,\n dotted_as_names: 285,\n dotted_name: 286,\n encoding_decl: 287,\n eval_input: 288,\n except_clause: 289,\n expr: 290,\n expr_stmt: 291,\n exprlist: 292,\n factor: 293,\n file_input: 294,\n flow_stmt: 295,\n for_stmt: 296,\n funcdef: 297,\n global_stmt: 298,\n if_stmt: 299,\n import_as_name: 300,\n import_as_names: 301,\n import_from: 302,\n import_name: 303,\n import_stmt: 304,\n lambdef: 305,\n lambdef_nocond: 306,\n nonlocal_stmt: 307,\n not_test: 308,\n or_test: 309,\n parameters: 310,\n pass_stmt: 311,\n power: 312,\n print_stmt: 313,\n raise_stmt: 314,\n return_stmt: 315,\n shift_expr: 316,\n simple_stmt: 317,\n single_input: 256,\n sliceop: 318,\n small_stmt: 319,\n star_expr: 320,\n stmt: 321,\n subscript: 322,\n subscriptlist: 323,\n suite: 324,\n term: 325,\n test: 326,\n test_nocond: 327,\n testlist: 328,\n testlist_comp: 329,\n testlist_star_expr: 330,\n tfpdef: 331,\n trailer: 332,\n try_stmt: 333,\n typedargslist: 334,\n varargslist: 335,\n vfpdef: 336,\n while_stmt: 337,\n with_item: 338,\n with_stmt: 339,\n xor_expr: 340,\n yield_arg: 341,\n yield_expr: 342,\n yield_stmt: 343},\nnumber2symbol:\n{256: 'single_input',\n 257: 'and_expr',\n 258: 'and_test',\n 259: 'annassign',\n 260: 'arglist',\n 261: 'argument',\n 262: 'arith_expr',\n 263: 'assert_stmt',\n 264: 'async_funcdef',\n 265: 'async_stmt',\n 266: 'atom',\n 267: 'atom_expr',\n 268: 'augassign',\n 269: 'break_stmt',\n 270: 'classdef',\n 271: 'comp_for',\n 272: 'comp_if',\n 273: 'comp_iter',\n 274: 'comp_op',\n 275: 'comparison',\n 276: 'compound_stmt',\n 277: 'continue_stmt',\n 278: 'debugger_stmt',\n 279: 'decorated',\n 280: 'decorator',\n 281: 'decorators',\n 282: 'del_stmt',\n 283: 'dictorsetmaker',\n 284: 'dotted_as_name',\n 285: 'dotted_as_names',\n 286: 'dotted_name',\n 287: 'encoding_decl',\n 288: 'eval_input',\n 289: 'except_clause',\n 290: 'expr',\n 291: 'expr_stmt',\n 292: 'exprlist',\n 293: 'factor',\n 294: 'file_input',\n 295: 'flow_stmt',\n 296: 'for_stmt',\n 297: 'funcdef',\n 298: 'global_stmt',\n 299: 'if_stmt',\n 300: 'import_as_name',\n 301: 'import_as_names',\n 302: 'import_from',\n 303: 'import_name',\n 304: 'import_stmt',\n 305: 'lambdef',\n 306: 'lambdef_nocond',\n 307: 'nonlocal_stmt',\n 308: 'not_test',\n 309: 'or_test',\n 310: 'parameters',\n 311: 'pass_stmt',\n 312: 'power',\n 313: 'print_stmt',\n 314: 'raise_stmt',\n 315: 'return_stmt',\n 316: 'shift_expr',\n 317: 'simple_stmt',\n 318: 'sliceop',\n 319: 'small_stmt',\n 320: 'star_expr',\n 321: 'stmt',\n 322: 'subscript',\n 323: 'subscriptlist',\n 324: 'suite',\n 325: 'term',\n 326: 'test',\n 327: 'test_nocond',\n 328: 'testlist',\n 329: 'testlist_comp',\n 330: 'testlist_star_expr',\n 331: 'tfpdef',\n 332: 'trailer',\n 333: 'try_stmt',\n 334: 'typedargslist',\n 335: 'varargslist',\n 336: 'vfpdef',\n 337: 'while_stmt',\n 338: 'with_item',\n 339: 'with_stmt',\n 340: 'xor_expr',\n 341: 'yield_arg',\n 342: 'yield_expr',\n 343: 'yield_stmt'},\ndfas:\n{256: [[[[1, 1], [2, 1], [3, 2]], [[0, 1]], [[2, 1]]],\n       {2: 1,\n        4: 1,\n        5: 1,\n        6: 1,\n        7: 1,\n        8: 1,\n        9: 1,\n        10: 1,\n        11: 1,\n        12: 1,\n        13: 1,\n        14: 1,\n        15: 1,\n        16: 1,\n        17: 1,\n        18: 1,\n        19: 1,\n        20: 1,\n        21: 1,\n        22: 1,\n        23: 1,\n        24: 1,\n        25: 1,\n        26: 1,\n        27: 1,\n        28: 1,\n        29: 1,\n        30: 1,\n        31: 1,\n        32: 1,\n        33: 1,\n        34: 1,\n        35: 1,\n        36: 1,\n        37: 1,\n        38: 1,\n        39: 1,\n        40: 1,\n        41: 1,\n        42: 1,\n        43: 1}],\n 257: [[[[44, 1]], [[45, 0], [0, 1]]],\n       {6: 1,\n        7: 1,\n        9: 1,\n        11: 1,\n        12: 1,\n        20: 1,\n        23: 1,\n        26: 1,\n        27: 1,\n        30: 1,\n        34: 1,\n        37: 1,\n        38: 1,\n        43: 1}],\n 258: [[[[46, 1]], [[47, 0], [0, 1]]],\n       {6: 1,\n        7: 1,\n        8: 1,\n        9: 1,\n        11: 1,\n        12: 1,\n        20: 1,\n        23: 1,\n        26: 1,\n        27: 1,\n        30: 1,\n        34: 1,\n        37: 1,\n        38: 1,\n        43: 1}],\n 259: [[[[48, 1]], [[49, 2]], [[50, 3], [0, 2]], [[49, 4]], [[0, 4]]],\n       {48: 1}],\n 260: [[[[51, 1]], [[52, 2], [0, 1]], [[51, 1], [0, 2]]],\n       {6: 1,\n        7: 1,\n        8: 1,\n        9: 1,\n        11: 1,\n        12: 1,\n        15: 1,\n        16: 1,\n        20: 1,\n        23: 1,\n        26: 1,\n        27: 1,\n        30: 1,\n        34: 1,\n        37: 1,\n        38: 1,\n        43: 1,\n        53: 1}],\n 261: [[[[49, 1], [16, 2], [53, 2]],\n        [[50, 2], [54, 3], [0, 1]],\n        [[49, 3]],\n        [[0, 3]]],\n       {6: 1,\n        7: 1,\n        8: 1,\n        9: 1,\n        11: 1,\n        12: 1,\n        15: 1,\n        16: 1,\n        20: 1,\n        23: 1,\n        26: 1,\n        27: 1,\n        30: 1,\n        34: 1,\n        37: 1,\n        38: 1,\n        43: 1,\n        53: 1}],\n 262: [[[[55, 1]], [[30, 0], [43, 0], [0, 1]]],\n       {6: 1,\n        7: 1,\n        9: 1,\n        11: 1,\n        12: 1,\n        20: 1,\n        23: 1,\n        26: 1,\n        27: 1,\n        30: 1,\n        34: 1,\n        37: 1,\n        38: 1,\n        43: 1}],\n 263: [[[[25, 1]], [[49, 2]], [[52, 3], [0, 2]], [[49, 4]], [[0, 4]]],\n       {25: 1}],\n 264: [[[[10, 1]], [[56, 2]], [[0, 2]]], {10: 1}],\n 265: [[[[10, 1]], [[57, 2], [56, 2], [58, 2]], [[0, 2]]], {10: 1}],\n 266: [[[[6, 1],\n         [7, 2],\n         [27, 1],\n         [9, 1],\n         [11, 1],\n         [12, 3],\n         [34, 4],\n         [37, 5],\n         [20, 1],\n         [26, 1]],\n        [[0, 1]],\n        [[7, 2], [0, 2]],\n        [[59, 1], [60, 6]],\n        [[61, 1], [62, 7], [63, 7]],\n        [[64, 1], [63, 8]],\n        [[59, 1]],\n        [[61, 1]],\n        [[64, 1]]],\n       {6: 1, 7: 1, 9: 1, 11: 1, 12: 1, 20: 1, 26: 1, 27: 1, 34: 1, 37: 1}],\n 267: [[[[38, 1], [65, 2]], [[65, 2]], [[66, 2], [0, 2]]],\n       {6: 1,\n        7: 1,\n        9: 1,\n        11: 1,\n        12: 1,\n        20: 1,\n        26: 1,\n        27: 1,\n        34: 1,\n        37: 1,\n        38: 1}],\n 268: [[[[67, 1],\n         [68, 1],\n         [69, 1],\n         [70, 1],\n         [71, 1],\n         [72, 1],\n         [73, 1],\n         [74, 1],\n         [75, 1],\n         [76, 1],\n         [77, 1],\n         [78, 1],\n         [79, 1]],\n        [[0, 1]]],\n       {67: 1,\n        68: 1,\n        69: 1,\n        70: 1,\n        71: 1,\n        72: 1,\n        73: 1,\n        74: 1,\n        75: 1,\n        76: 1,\n        77: 1,\n        78: 1,\n        79: 1}],\n 269: [[[[14, 1]], [[0, 1]]], {14: 1}],\n 270: [[[[13, 1]],\n        [[26, 2]],\n        [[48, 3], [34, 4]],\n        [[80, 5]],\n        [[61, 6], [81, 7]],\n        [[0, 5]],\n        [[48, 3]],\n        [[61, 6]]],\n       {13: 1}],\n 271: [[[[10, 1], [33, 2]],\n        [[33, 2]],\n        [[82, 3]],\n        [[83, 4]],\n        [[84, 5]],\n        [[85, 6], [0, 5]],\n        [[0, 6]]],\n       {10: 1, 33: 1}],\n 272: [[[[36, 1]], [[86, 2]], [[85, 3], [0, 2]], [[0, 3]]], {36: 1}],\n 273: [[[[87, 1], [54, 1]], [[0, 1]]], {10: 1, 33: 1, 36: 1}],\n 274: [[[[88, 1],\n         [89, 1],\n         [8, 2],\n         [90, 1],\n         [88, 1],\n         [83, 1],\n         [91, 1],\n         [92, 3],\n         [93, 1],\n         [94, 1]],\n        [[0, 1]],\n        [[83, 1]],\n        [[8, 1], [0, 3]]],\n       {8: 1, 83: 1, 88: 1, 89: 1, 90: 1, 91: 1, 92: 1, 93: 1, 94: 1}],\n 275: [[[[95, 1]], [[96, 0], [0, 1]]],\n       {6: 1,\n        7: 1,\n        9: 1,\n        11: 1,\n        12: 1,\n        20: 1,\n        23: 1,\n        26: 1,\n        27: 1,\n        30: 1,\n        34: 1,\n        37: 1,\n        38: 1,\n        43: 1}],\n 276: [[[[97, 1],\n         [98, 1],\n         [58, 1],\n         [99, 1],\n         [57, 1],\n         [100, 1],\n         [56, 1],\n         [101, 1],\n         [102, 1]],\n        [[0, 1]]],\n       {4: 1, 10: 1, 13: 1, 21: 1, 22: 1, 33: 1, 36: 1, 41: 1, 42: 1}],\n 277: [[[[40, 1]], [[0, 1]]], {40: 1}],\n 278: [[[[18, 1]], [[0, 1]]], {18: 1}],\n 279: [[[[103, 1]], [[56, 2], [104, 2], [99, 2]], [[0, 2]]], {41: 1}],\n 280: [[[[41, 1]],\n        [[105, 2]],\n        [[34, 4], [2, 3]],\n        [[0, 3]],\n        [[61, 5], [81, 6]],\n        [[2, 3]],\n        [[61, 5]]],\n       {41: 1}],\n 281: [[[[106, 1]], [[106, 1], [0, 1]]], {41: 1}],\n 282: [[[[39, 1]], [[82, 2]], [[0, 2]]], {39: 1}],\n 283: [[[[49, 1], [107, 2], [53, 3]],\n        [[48, 4], [54, 5], [52, 6], [0, 1]],\n        [[54, 5], [52, 6], [0, 2]],\n        [[95, 7]],\n        [[49, 7]],\n        [[0, 5]],\n        [[49, 8], [107, 8], [0, 6]],\n        [[54, 5], [52, 9], [0, 7]],\n        [[52, 6], [0, 8]],\n        [[49, 10], [53, 11], [0, 9]],\n        [[48, 12]],\n        [[95, 13]],\n        [[49, 13]],\n        [[52, 9], [0, 13]]],\n       {6: 1,\n        7: 1,\n        8: 1,\n        9: 1,\n        11: 1,\n        12: 1,\n        15: 1,\n        16: 1,\n        20: 1,\n        23: 1,\n        26: 1,\n        27: 1,\n        30: 1,\n        34: 1,\n        37: 1,\n        38: 1,\n        43: 1,\n        53: 1}],\n 284: [[[[105, 1]], [[108, 2], [0, 1]], [[26, 3]], [[0, 3]]], {26: 1}],\n 285: [[[[109, 1]], [[52, 0], [0, 1]]], {26: 1}],\n 286: [[[[26, 1]], [[110, 0], [0, 1]]], {26: 1}],\n 287: [[[[26, 1]], [[0, 1]]], {26: 1}],\n 288: [[[[111, 1]], [[2, 1], [112, 2]], [[0, 2]]],\n       {6: 1,\n        7: 1,\n        8: 1,\n        9: 1,\n        11: 1,\n        12: 1,\n        15: 1,\n        20: 1,\n        23: 1,\n        26: 1,\n        27: 1,\n        30: 1,\n        34: 1,\n        37: 1,\n        38: 1,\n        43: 1}],\n 289: [[[[113, 1]],\n        [[49, 2], [0, 1]],\n        [[108, 3], [52, 3], [0, 2]],\n        [[49, 4]],\n        [[0, 4]]],\n       {113: 1}],\n 290: [[[[114, 1]], [[115, 0], [0, 1]]],\n       {6: 1,\n        7: 1,\n        9: 1,\n        11: 1,\n        12: 1,\n        20: 1,\n        23: 1,\n        26: 1,\n        27: 1,\n        30: 1,\n        34: 1,\n        37: 1,\n        38: 1,\n        43: 1}],\n 291: [[[[116, 1]],\n        [[117, 2], [50, 3], [118, 4], [0, 1]],\n        [[111, 4], [62, 4]],\n        [[116, 5], [62, 5]],\n        [[0, 4]],\n        [[50, 3], [0, 5]]],\n       {6: 1,\n        7: 1,\n        8: 1,\n        9: 1,\n        11: 1,\n        12: 1,\n        15: 1,\n        16: 1,\n        20: 1,\n        23: 1,\n        26: 1,\n        27: 1,\n        30: 1,\n        34: 1,\n        37: 1,\n        38: 1,\n        43: 1}],\n 292: [[[[95, 1], [107, 1]], [[52, 2], [0, 1]], [[95, 1], [107, 1], [0, 2]]],\n       {6: 1,\n        7: 1,\n        9: 1,\n        11: 1,\n        12: 1,\n        16: 1,\n        20: 1,\n        23: 1,\n        26: 1,\n        27: 1,\n        30: 1,\n        34: 1,\n        37: 1,\n        38: 1,\n        43: 1}],\n 293: [[[[119, 2], [30, 1], [23, 1], [43, 1]], [[120, 2]], [[0, 2]]],\n       {6: 1,\n        7: 1,\n        9: 1,\n        11: 1,\n        12: 1,\n        20: 1,\n        23: 1,\n        26: 1,\n        27: 1,\n        30: 1,\n        34: 1,\n        37: 1,\n        38: 1,\n        43: 1}],\n 294: [[[[2, 0], [112, 1], [121, 0]], [[0, 1]]],\n       {2: 1,\n        4: 1,\n        5: 1,\n        6: 1,\n        7: 1,\n        8: 1,\n        9: 1,\n        10: 1,\n        11: 1,\n        12: 1,\n        13: 1,\n        14: 1,\n        15: 1,\n        16: 1,\n        17: 1,\n        18: 1,\n        19: 1,\n        20: 1,\n        21: 1,\n        22: 1,\n        23: 1,\n        24: 1,\n        25: 1,\n        26: 1,\n        27: 1,\n        28: 1,\n        29: 1,\n        30: 1,\n        31: 1,\n        32: 1,\n        33: 1,\n        34: 1,\n        35: 1,\n        36: 1,\n        37: 1,\n        38: 1,\n        39: 1,\n        40: 1,\n        41: 1,\n        42: 1,\n        43: 1,\n        112: 1}],\n 295: [[[[122, 1], [123, 1], [124, 1], [125, 1], [126, 1]], [[0, 1]]],\n       {5: 1, 14: 1, 24: 1, 31: 1, 40: 1}],\n 296: [[[[33, 1]],\n        [[82, 2]],\n        [[83, 3]],\n        [[111, 4]],\n        [[48, 5]],\n        [[80, 6]],\n        [[127, 7], [0, 6]],\n        [[48, 8]],\n        [[80, 9]],\n        [[0, 9]]],\n       {33: 1}],\n 297: [[[[4, 1]],\n        [[26, 2]],\n        [[128, 3]],\n        [[129, 4], [48, 5]],\n        [[49, 6]],\n        [[80, 7]],\n        [[48, 5]],\n        [[0, 7]]],\n       {4: 1}],\n 298: [[[[32, 1]], [[26, 2]], [[52, 1], [0, 2]]], {32: 1}],\n 299: [[[[36, 1]],\n        [[49, 2]],\n        [[48, 3]],\n        [[80, 4]],\n        [[127, 5], [130, 1], [0, 4]],\n        [[48, 6]],\n        [[80, 7]],\n        [[0, 7]]],\n       {36: 1}],\n 300: [[[[26, 1]], [[108, 2], [0, 1]], [[26, 3]], [[0, 3]]], {26: 1}],\n 301: [[[[131, 1]], [[52, 2], [0, 1]], [[131, 1], [0, 2]]], {26: 1}],\n 302: [[[[35, 1]],\n        [[105, 2], [20, 3], [110, 3]],\n        [[29, 4]],\n        [[105, 2], [20, 3], [29, 4], [110, 3]],\n        [[132, 5], [16, 5], [34, 6]],\n        [[0, 5]],\n        [[132, 7]],\n        [[61, 5]]],\n       {35: 1}],\n 303: [[[[29, 1]], [[133, 2]], [[0, 2]]], {29: 1}],\n 304: [[[[134, 1], [135, 1]], [[0, 1]]], {29: 1, 35: 1}],\n 305: [[[[15, 1]], [[48, 2], [136, 3]], [[49, 4]], [[48, 2]], [[0, 4]]],\n       {15: 1}],\n 306: [[[[15, 1]], [[48, 2], [136, 3]], [[86, 4]], [[48, 2]], [[0, 4]]],\n       {15: 1}],\n 307: [[[[19, 1]], [[26, 2]], [[52, 1], [0, 2]]], {19: 1}],\n 308: [[[[8, 1], [137, 2]], [[46, 2]], [[0, 2]]],\n       {6: 1,\n        7: 1,\n        8: 1,\n        9: 1,\n        11: 1,\n        12: 1,\n        20: 1,\n        23: 1,\n        26: 1,\n        27: 1,\n        30: 1,\n        34: 1,\n        37: 1,\n        38: 1,\n        43: 1}],\n 309: [[[[138, 1]], [[139, 0], [0, 1]]],\n       {6: 1,\n        7: 1,\n        8: 1,\n        9: 1,\n        11: 1,\n        12: 1,\n        20: 1,\n        23: 1,\n        26: 1,\n        27: 1,\n        30: 1,\n        34: 1,\n        37: 1,\n        38: 1,\n        43: 1}],\n 310: [[[[34, 1]], [[61, 2], [140, 3]], [[0, 2]], [[61, 2]]], {34: 1}],\n 311: [[[[28, 1]], [[0, 1]]], {28: 1}],\n 312: [[[[141, 1]], [[53, 2], [0, 1]], [[120, 3]], [[0, 3]]],\n       {6: 1,\n        7: 1,\n        9: 1,\n        11: 1,\n        12: 1,\n        20: 1,\n        26: 1,\n        27: 1,\n        34: 1,\n        37: 1,\n        38: 1}],\n 313: [[[[17, 1]],\n        [[49, 2], [142, 3], [0, 1]],\n        [[52, 4], [0, 2]],\n        [[49, 5]],\n        [[49, 2], [0, 4]],\n        [[52, 6], [0, 5]],\n        [[49, 7]],\n        [[52, 8], [0, 7]],\n        [[49, 7], [0, 8]]],\n       {17: 1}],\n 314: [[[[5, 1]],\n        [[49, 2], [0, 1]],\n        [[35, 3], [52, 3], [0, 2]],\n        [[49, 4]],\n        [[52, 5], [0, 4]],\n        [[49, 6]],\n        [[0, 6]]],\n       {5: 1}],\n 315: [[[[24, 1]], [[111, 2], [0, 1]], [[0, 2]]], {24: 1}],\n 316: [[[[143, 1]], [[142, 0], [144, 0], [0, 1]]],\n       {6: 1,\n        7: 1,\n        9: 1,\n        11: 1,\n        12: 1,\n        20: 1,\n        23: 1,\n        26: 1,\n        27: 1,\n        30: 1,\n        34: 1,\n        37: 1,\n        38: 1,\n        43: 1}],\n 317: [[[[145, 1]], [[2, 2], [146, 3]], [[0, 2]], [[145, 1], [2, 2]]],\n       {5: 1,\n        6: 1,\n        7: 1,\n        8: 1,\n        9: 1,\n        11: 1,\n        12: 1,\n        14: 1,\n        15: 1,\n        16: 1,\n        17: 1,\n        18: 1,\n        19: 1,\n        20: 1,\n        23: 1,\n        24: 1,\n        25: 1,\n        26: 1,\n        27: 1,\n        28: 1,\n        29: 1,\n        30: 1,\n        31: 1,\n        32: 1,\n        34: 1,\n        35: 1,\n        37: 1,\n        38: 1,\n        39: 1,\n        40: 1,\n        43: 1}],\n 318: [[[[48, 1]], [[49, 2], [0, 1]], [[0, 2]]], {48: 1}],\n 319: [[[[147, 1],\n         [148, 1],\n         [149, 1],\n         [150, 1],\n         [151, 1],\n         [152, 1],\n         [153, 1],\n         [154, 1],\n         [155, 1],\n         [156, 1]],\n        [[0, 1]]],\n       {5: 1,\n        6: 1,\n        7: 1,\n        8: 1,\n        9: 1,\n        11: 1,\n        12: 1,\n        14: 1,\n        15: 1,\n        16: 1,\n        17: 1,\n        18: 1,\n        19: 1,\n        20: 1,\n        23: 1,\n        24: 1,\n        25: 1,\n        26: 1,\n        27: 1,\n        28: 1,\n        29: 1,\n        30: 1,\n        31: 1,\n        32: 1,\n        34: 1,\n        35: 1,\n        37: 1,\n        38: 1,\n        39: 1,\n        40: 1,\n        43: 1}],\n 320: [[[[16, 1]], [[95, 2]], [[0, 2]]], {16: 1}],\n 321: [[[[1, 1], [3, 1]], [[0, 1]]],\n       {4: 1,\n        5: 1,\n        6: 1,\n        7: 1,\n        8: 1,\n        9: 1,\n        10: 1,\n        11: 1,\n        12: 1,\n        13: 1,\n        14: 1,\n        15: 1,\n        16: 1,\n        17: 1,\n        18: 1,\n        19: 1,\n        20: 1,\n        21: 1,\n        22: 1,\n        23: 1,\n        24: 1,\n        25: 1,\n        26: 1,\n        27: 1,\n        28: 1,\n        29: 1,\n        30: 1,\n        31: 1,\n        32: 1,\n        33: 1,\n        34: 1,\n        35: 1,\n        36: 1,\n        37: 1,\n        38: 1,\n        39: 1,\n        40: 1,\n        41: 1,\n        42: 1,\n        43: 1}],\n 322: [[[[49, 1], [48, 2]],\n        [[48, 2], [0, 1]],\n        [[49, 3], [157, 4], [0, 2]],\n        [[157, 4], [0, 3]],\n        [[0, 4]]],\n       {6: 1,\n        7: 1,\n        8: 1,\n        9: 1,\n        11: 1,\n        12: 1,\n        15: 1,\n        20: 1,\n        23: 1,\n        26: 1,\n        27: 1,\n        30: 1,\n        34: 1,\n        37: 1,\n        38: 1,\n        43: 1,\n        48: 1}],\n 323: [[[[158, 1]], [[52, 2], [0, 1]], [[158, 1], [0, 2]]],\n       {6: 1,\n        7: 1,\n        8: 1,\n        9: 1,\n        11: 1,\n        12: 1,\n        15: 1,\n        20: 1,\n        23: 1,\n        26: 1,\n        27: 1,\n        30: 1,\n        34: 1,\n        37: 1,\n        38: 1,\n        43: 1,\n        48: 1}],\n 324: [[[[1, 1], [2, 2]],\n        [[0, 1]],\n        [[159, 3]],\n        [[121, 4]],\n        [[160, 1], [121, 4]]],\n       {2: 1,\n        5: 1,\n        6: 1,\n        7: 1,\n        8: 1,\n        9: 1,\n        11: 1,\n        12: 1,\n        14: 1,\n        15: 1,\n        16: 1,\n        17: 1,\n        18: 1,\n        19: 1,\n        20: 1,\n        23: 1,\n        24: 1,\n        25: 1,\n        26: 1,\n        27: 1,\n        28: 1,\n        29: 1,\n        30: 1,\n        31: 1,\n        32: 1,\n        34: 1,\n        35: 1,\n        37: 1,\n        38: 1,\n        39: 1,\n        40: 1,\n        43: 1}],\n 325: [[[[120, 1]], [[161, 0], [16, 0], [162, 0], [41, 0], [163, 0], [0, 1]]],\n       {6: 1,\n        7: 1,\n        9: 1,\n        11: 1,\n        12: 1,\n        20: 1,\n        23: 1,\n        26: 1,\n        27: 1,\n        30: 1,\n        34: 1,\n        37: 1,\n        38: 1,\n        43: 1}],\n 326: [[[[84, 1], [164, 2]],\n        [[36, 3], [0, 1]],\n        [[0, 2]],\n        [[84, 4]],\n        [[127, 5]],\n        [[49, 2]]],\n       {6: 1,\n        7: 1,\n        8: 1,\n        9: 1,\n        11: 1,\n        12: 1,\n        15: 1,\n        20: 1,\n        23: 1,\n        26: 1,\n        27: 1,\n        30: 1,\n        34: 1,\n        37: 1,\n        38: 1,\n        43: 1}],\n 327: [[[[165, 1], [84, 1]], [[0, 1]]],\n       {6: 1,\n        7: 1,\n        8: 1,\n        9: 1,\n        11: 1,\n        12: 1,\n        15: 1,\n        20: 1,\n        23: 1,\n        26: 1,\n        27: 1,\n        30: 1,\n        34: 1,\n        37: 1,\n        38: 1,\n        43: 1}],\n 328: [[[[49, 1]], [[52, 2], [0, 1]], [[49, 1], [0, 2]]],\n       {6: 1,\n        7: 1,\n        8: 1,\n        9: 1,\n        11: 1,\n        12: 1,\n        15: 1,\n        20: 1,\n        23: 1,\n        26: 1,\n        27: 1,\n        30: 1,\n        34: 1,\n        37: 1,\n        38: 1,\n        43: 1}],\n 329: [[[[49, 1], [107, 1]],\n        [[54, 2], [52, 3], [0, 1]],\n        [[0, 2]],\n        [[49, 4], [107, 4], [0, 3]],\n        [[52, 3], [0, 4]]],\n       {6: 1,\n        7: 1,\n        8: 1,\n        9: 1,\n        11: 1,\n        12: 1,\n        15: 1,\n        16: 1,\n        20: 1,\n        23: 1,\n        26: 1,\n        27: 1,\n        30: 1,\n        34: 1,\n        37: 1,\n        38: 1,\n        43: 1}],\n 330: [[[[49, 1], [107, 1]], [[52, 2], [0, 1]], [[49, 1], [107, 1], [0, 2]]],\n       {6: 1,\n        7: 1,\n        8: 1,\n        9: 1,\n        11: 1,\n        12: 1,\n        15: 1,\n        16: 1,\n        20: 1,\n        23: 1,\n        26: 1,\n        27: 1,\n        30: 1,\n        34: 1,\n        37: 1,\n        38: 1,\n        43: 1}],\n 331: [[[[26, 1]], [[48, 2], [0, 1]], [[49, 3]], [[0, 3]]], {26: 1}],\n 332: [[[[34, 1], [110, 2], [37, 3]],\n        [[61, 4], [81, 5]],\n        [[26, 4]],\n        [[166, 6]],\n        [[0, 4]],\n        [[61, 4]],\n        [[64, 4]]],\n       {34: 1, 37: 1, 110: 1}],\n 333: [[[[21, 1]],\n        [[48, 2]],\n        [[80, 3]],\n        [[167, 4], [168, 5]],\n        [[48, 6]],\n        [[48, 7]],\n        [[80, 8]],\n        [[80, 9]],\n        [[167, 4], [127, 10], [168, 5], [0, 8]],\n        [[0, 9]],\n        [[48, 11]],\n        [[80, 12]],\n        [[168, 5], [0, 12]]],\n       {21: 1}],\n 334: [[[[16, 1], [169, 2], [53, 3]],\n        [[169, 4], [52, 5], [0, 1]],\n        [[50, 6], [52, 7], [0, 2]],\n        [[169, 8]],\n        [[52, 5], [0, 4]],\n        [[169, 9], [53, 3], [0, 5]],\n        [[49, 10]],\n        [[16, 11], [169, 2], [53, 3], [0, 7]],\n        [[52, 12], [0, 8]],\n        [[50, 13], [52, 5], [0, 9]],\n        [[52, 7], [0, 10]],\n        [[169, 14], [52, 15], [0, 11]],\n        [[0, 12]],\n        [[49, 4]],\n        [[52, 15], [0, 14]],\n        [[169, 16], [53, 3], [0, 15]],\n        [[50, 17], [52, 15], [0, 16]],\n        [[49, 14]]],\n       {16: 1, 26: 1, 53: 1}],\n 335: [[[[16, 1], [53, 2], [170, 3]],\n        [[170, 5], [52, 4], [0, 1]],\n        [[170, 6]],\n        [[50, 7], [52, 8], [0, 3]],\n        [[53, 2], [170, 9], [0, 4]],\n        [[52, 4], [0, 5]],\n        [[52, 10], [0, 6]],\n        [[49, 11]],\n        [[16, 12], [53, 2], [170, 3], [0, 8]],\n        [[50, 13], [52, 4], [0, 9]],\n        [[0, 10]],\n        [[52, 8], [0, 11]],\n        [[52, 15], [170, 14], [0, 12]],\n        [[49, 5]],\n        [[52, 15], [0, 14]],\n        [[53, 2], [170, 16], [0, 15]],\n        [[50, 17], [52, 15], [0, 16]],\n        [[49, 14]]],\n       {16: 1, 26: 1, 53: 1}],\n 336: [[[[26, 1]], [[0, 1]]], {26: 1}],\n 337: [[[[22, 1]],\n        [[49, 2]],\n        [[48, 3]],\n        [[80, 4]],\n        [[127, 5], [0, 4]],\n        [[48, 6]],\n        [[80, 7]],\n        [[0, 7]]],\n       {22: 1}],\n 338: [[[[49, 1]], [[108, 2], [0, 1]], [[95, 3]], [[0, 3]]],\n       {6: 1,\n        7: 1,\n        8: 1,\n        9: 1,\n        11: 1,\n        12: 1,\n        15: 1,\n        20: 1,\n        23: 1,\n        26: 1,\n        27: 1,\n        30: 1,\n        34: 1,\n        37: 1,\n        38: 1,\n        43: 1}],\n 339: [[[[42, 1]], [[171, 2]], [[48, 3], [52, 1]], [[80, 4]], [[0, 4]]],\n       {42: 1}],\n 340: [[[[172, 1]], [[173, 0], [0, 1]]],\n       {6: 1,\n        7: 1,\n        9: 1,\n        11: 1,\n        12: 1,\n        20: 1,\n        23: 1,\n        26: 1,\n        27: 1,\n        30: 1,\n        34: 1,\n        37: 1,\n        38: 1,\n        43: 1}],\n 341: [[[[111, 2], [35, 1]], [[49, 2]], [[0, 2]]],\n       {6: 1,\n        7: 1,\n        8: 1,\n        9: 1,\n        11: 1,\n        12: 1,\n        15: 1,\n        20: 1,\n        23: 1,\n        26: 1,\n        27: 1,\n        30: 1,\n        34: 1,\n        35: 1,\n        37: 1,\n        38: 1,\n        43: 1}],\n 342: [[[[31, 1]], [[174, 2], [0, 1]], [[0, 2]]], {31: 1}],\n 343: [[[[62, 1]], [[0, 1]]], {31: 1}]},\nstates:\n[[[[1, 1], [2, 1], [3, 2]], [[0, 1]], [[2, 1]]],\n [[[44, 1]], [[45, 0], [0, 1]]],\n [[[46, 1]], [[47, 0], [0, 1]]],\n [[[48, 1]], [[49, 2]], [[50, 3], [0, 2]], [[49, 4]], [[0, 4]]],\n [[[51, 1]], [[52, 2], [0, 1]], [[51, 1], [0, 2]]],\n [[[49, 1], [16, 2], [53, 2]],\n  [[50, 2], [54, 3], [0, 1]],\n  [[49, 3]],\n  [[0, 3]]],\n [[[55, 1]], [[30, 0], [43, 0], [0, 1]]],\n [[[25, 1]], [[49, 2]], [[52, 3], [0, 2]], [[49, 4]], [[0, 4]]],\n [[[10, 1]], [[56, 2]], [[0, 2]]],\n [[[10, 1]], [[57, 2], [56, 2], [58, 2]], [[0, 2]]],\n [[[6, 1],\n   [7, 2],\n   [27, 1],\n   [9, 1],\n   [11, 1],\n   [12, 3],\n   [34, 4],\n   [37, 5],\n   [20, 1],\n   [26, 1]],\n  [[0, 1]],\n  [[7, 2], [0, 2]],\n  [[59, 1], [60, 6]],\n  [[61, 1], [62, 7], [63, 7]],\n  [[64, 1], [63, 8]],\n  [[59, 1]],\n  [[61, 1]],\n  [[64, 1]]],\n [[[38, 1], [65, 2]], [[65, 2]], [[66, 2], [0, 2]]],\n [[[67, 1],\n   [68, 1],\n   [69, 1],\n   [70, 1],\n   [71, 1],\n   [72, 1],\n   [73, 1],\n   [74, 1],\n   [75, 1],\n   [76, 1],\n   [77, 1],\n   [78, 1],\n   [79, 1]],\n  [[0, 1]]],\n [[[14, 1]], [[0, 1]]],\n [[[13, 1]],\n  [[26, 2]],\n  [[48, 3], [34, 4]],\n  [[80, 5]],\n  [[61, 6], [81, 7]],\n  [[0, 5]],\n  [[48, 3]],\n  [[61, 6]]],\n [[[10, 1], [33, 2]],\n  [[33, 2]],\n  [[82, 3]],\n  [[83, 4]],\n  [[84, 5]],\n  [[85, 6], [0, 5]],\n  [[0, 6]]],\n [[[36, 1]], [[86, 2]], [[85, 3], [0, 2]], [[0, 3]]],\n [[[87, 1], [54, 1]], [[0, 1]]],\n [[[88, 1],\n   [89, 1],\n   [8, 2],\n   [90, 1],\n   [88, 1],\n   [83, 1],\n   [91, 1],\n   [92, 3],\n   [93, 1],\n   [94, 1]],\n  [[0, 1]],\n  [[83, 1]],\n  [[8, 1], [0, 3]]],\n [[[95, 1]], [[96, 0], [0, 1]]],\n [[[97, 1],\n   [98, 1],\n   [58, 1],\n   [99, 1],\n   [57, 1],\n   [100, 1],\n   [56, 1],\n   [101, 1],\n   [102, 1]],\n  [[0, 1]]],\n [[[40, 1]], [[0, 1]]],\n [[[18, 1]], [[0, 1]]],\n [[[103, 1]], [[56, 2], [104, 2], [99, 2]], [[0, 2]]],\n [[[41, 1]],\n  [[105, 2]],\n  [[34, 4], [2, 3]],\n  [[0, 3]],\n  [[61, 5], [81, 6]],\n  [[2, 3]],\n  [[61, 5]]],\n [[[106, 1]], [[106, 1], [0, 1]]],\n [[[39, 1]], [[82, 2]], [[0, 2]]],\n [[[49, 1], [107, 2], [53, 3]],\n  [[48, 4], [54, 5], [52, 6], [0, 1]],\n  [[54, 5], [52, 6], [0, 2]],\n  [[95, 7]],\n  [[49, 7]],\n  [[0, 5]],\n  [[49, 8], [107, 8], [0, 6]],\n  [[54, 5], [52, 9], [0, 7]],\n  [[52, 6], [0, 8]],\n  [[49, 10], [53, 11], [0, 9]],\n  [[48, 12]],\n  [[95, 13]],\n  [[49, 13]],\n  [[52, 9], [0, 13]]],\n [[[105, 1]], [[108, 2], [0, 1]], [[26, 3]], [[0, 3]]],\n [[[109, 1]], [[52, 0], [0, 1]]],\n [[[26, 1]], [[110, 0], [0, 1]]],\n [[[26, 1]], [[0, 1]]],\n [[[111, 1]], [[2, 1], [112, 2]], [[0, 2]]],\n [[[113, 1]],\n  [[49, 2], [0, 1]],\n  [[108, 3], [52, 3], [0, 2]],\n  [[49, 4]],\n  [[0, 4]]],\n [[[114, 1]], [[115, 0], [0, 1]]],\n [[[116, 1]],\n  [[117, 2], [50, 3], [118, 4], [0, 1]],\n  [[111, 4], [62, 4]],\n  [[116, 5], [62, 5]],\n  [[0, 4]],\n  [[50, 3], [0, 5]]],\n [[[95, 1], [107, 1]], [[52, 2], [0, 1]], [[95, 1], [107, 1], [0, 2]]],\n [[[119, 2], [30, 1], [23, 1], [43, 1]], [[120, 2]], [[0, 2]]],\n [[[2, 0], [112, 1], [121, 0]], [[0, 1]]],\n [[[122, 1], [123, 1], [124, 1], [125, 1], [126, 1]], [[0, 1]]],\n [[[33, 1]],\n  [[82, 2]],\n  [[83, 3]],\n  [[111, 4]],\n  [[48, 5]],\n  [[80, 6]],\n  [[127, 7], [0, 6]],\n  [[48, 8]],\n  [[80, 9]],\n  [[0, 9]]],\n [[[4, 1]],\n  [[26, 2]],\n  [[128, 3]],\n  [[129, 4], [48, 5]],\n  [[49, 6]],\n  [[80, 7]],\n  [[48, 5]],\n  [[0, 7]]],\n [[[32, 1]], [[26, 2]], [[52, 1], [0, 2]]],\n [[[36, 1]],\n  [[49, 2]],\n  [[48, 3]],\n  [[80, 4]],\n  [[127, 5], [130, 1], [0, 4]],\n  [[48, 6]],\n  [[80, 7]],\n  [[0, 7]]],\n [[[26, 1]], [[108, 2], [0, 1]], [[26, 3]], [[0, 3]]],\n [[[131, 1]], [[52, 2], [0, 1]], [[131, 1], [0, 2]]],\n [[[35, 1]],\n  [[105, 2], [20, 3], [110, 3]],\n  [[29, 4]],\n  [[105, 2], [20, 3], [29, 4], [110, 3]],\n  [[132, 5], [16, 5], [34, 6]],\n  [[0, 5]],\n  [[132, 7]],\n  [[61, 5]]],\n [[[29, 1]], [[133, 2]], [[0, 2]]],\n [[[134, 1], [135, 1]], [[0, 1]]],\n [[[15, 1]], [[48, 2], [136, 3]], [[49, 4]], [[48, 2]], [[0, 4]]],\n [[[15, 1]], [[48, 2], [136, 3]], [[86, 4]], [[48, 2]], [[0, 4]]],\n [[[19, 1]], [[26, 2]], [[52, 1], [0, 2]]],\n [[[8, 1], [137, 2]], [[46, 2]], [[0, 2]]],\n [[[138, 1]], [[139, 0], [0, 1]]],\n [[[34, 1]], [[61, 2], [140, 3]], [[0, 2]], [[61, 2]]],\n [[[28, 1]], [[0, 1]]],\n [[[141, 1]], [[53, 2], [0, 1]], [[120, 3]], [[0, 3]]],\n [[[17, 1]],\n  [[49, 2], [142, 3], [0, 1]],\n  [[52, 4], [0, 2]],\n  [[49, 5]],\n  [[49, 2], [0, 4]],\n  [[52, 6], [0, 5]],\n  [[49, 7]],\n  [[52, 8], [0, 7]],\n  [[49, 7], [0, 8]]],\n [[[5, 1]],\n  [[49, 2], [0, 1]],\n  [[35, 3], [52, 3], [0, 2]],\n  [[49, 4]],\n  [[52, 5], [0, 4]],\n  [[49, 6]],\n  [[0, 6]]],\n [[[24, 1]], [[111, 2], [0, 1]], [[0, 2]]],\n [[[143, 1]], [[142, 0], [144, 0], [0, 1]]],\n [[[145, 1]], [[2, 2], [146, 3]], [[0, 2]], [[145, 1], [2, 2]]],\n [[[48, 1]], [[49, 2], [0, 1]], [[0, 2]]],\n [[[147, 1],\n   [148, 1],\n   [149, 1],\n   [150, 1],\n   [151, 1],\n   [152, 1],\n   [153, 1],\n   [154, 1],\n   [155, 1],\n   [156, 1]],\n  [[0, 1]]],\n [[[16, 1]], [[95, 2]], [[0, 2]]],\n [[[1, 1], [3, 1]], [[0, 1]]],\n [[[49, 1], [48, 2]],\n  [[48, 2], [0, 1]],\n  [[49, 3], [157, 4], [0, 2]],\n  [[157, 4], [0, 3]],\n  [[0, 4]]],\n [[[158, 1]], [[52, 2], [0, 1]], [[158, 1], [0, 2]]],\n [[[1, 1], [2, 2]], [[0, 1]], [[159, 3]], [[121, 4]], [[160, 1], [121, 4]]],\n [[[120, 1]], [[161, 0], [16, 0], [162, 0], [41, 0], [163, 0], [0, 1]]],\n [[[84, 1], [164, 2]],\n  [[36, 3], [0, 1]],\n  [[0, 2]],\n  [[84, 4]],\n  [[127, 5]],\n  [[49, 2]]],\n [[[165, 1], [84, 1]], [[0, 1]]],\n [[[49, 1]], [[52, 2], [0, 1]], [[49, 1], [0, 2]]],\n [[[49, 1], [107, 1]],\n  [[54, 2], [52, 3], [0, 1]],\n  [[0, 2]],\n  [[49, 4], [107, 4], [0, 3]],\n  [[52, 3], [0, 4]]],\n [[[49, 1], [107, 1]], [[52, 2], [0, 1]], [[49, 1], [107, 1], [0, 2]]],\n [[[26, 1]], [[48, 2], [0, 1]], [[49, 3]], [[0, 3]]],\n [[[34, 1], [110, 2], [37, 3]],\n  [[61, 4], [81, 5]],\n  [[26, 4]],\n  [[166, 6]],\n  [[0, 4]],\n  [[61, 4]],\n  [[64, 4]]],\n [[[21, 1]],\n  [[48, 2]],\n  [[80, 3]],\n  [[167, 4], [168, 5]],\n  [[48, 6]],\n  [[48, 7]],\n  [[80, 8]],\n  [[80, 9]],\n  [[167, 4], [127, 10], [168, 5], [0, 8]],\n  [[0, 9]],\n  [[48, 11]],\n  [[80, 12]],\n  [[168, 5], [0, 12]]],\n [[[16, 1], [169, 2], [53, 3]],\n  [[169, 4], [52, 5], [0, 1]],\n  [[50, 6], [52, 7], [0, 2]],\n  [[169, 8]],\n  [[52, 5], [0, 4]],\n  [[169, 9], [53, 3], [0, 5]],\n  [[49, 10]],\n  [[16, 11], [169, 2], [53, 3], [0, 7]],\n  [[52, 12], [0, 8]],\n  [[50, 13], [52, 5], [0, 9]],\n  [[52, 7], [0, 10]],\n  [[169, 14], [52, 15], [0, 11]],\n  [[0, 12]],\n  [[49, 4]],\n  [[52, 15], [0, 14]],\n  [[169, 16], [53, 3], [0, 15]],\n  [[50, 17], [52, 15], [0, 16]],\n  [[49, 14]]],\n [[[16, 1], [53, 2], [170, 3]],\n  [[170, 5], [52, 4], [0, 1]],\n  [[170, 6]],\n  [[50, 7], [52, 8], [0, 3]],\n  [[53, 2], [170, 9], [0, 4]],\n  [[52, 4], [0, 5]],\n  [[52, 10], [0, 6]],\n  [[49, 11]],\n  [[16, 12], [53, 2], [170, 3], [0, 8]],\n  [[50, 13], [52, 4], [0, 9]],\n  [[0, 10]],\n  [[52, 8], [0, 11]],\n  [[52, 15], [170, 14], [0, 12]],\n  [[49, 5]],\n  [[52, 15], [0, 14]],\n  [[53, 2], [170, 16], [0, 15]],\n  [[50, 17], [52, 15], [0, 16]],\n  [[49, 14]]],\n [[[26, 1]], [[0, 1]]],\n [[[22, 1]],\n  [[49, 2]],\n  [[48, 3]],\n  [[80, 4]],\n  [[127, 5], [0, 4]],\n  [[48, 6]],\n  [[80, 7]],\n  [[0, 7]]],\n [[[49, 1]], [[108, 2], [0, 1]], [[95, 3]], [[0, 3]]],\n [[[42, 1]], [[171, 2]], [[48, 3], [52, 1]], [[80, 4]], [[0, 4]]],\n [[[172, 1]], [[173, 0], [0, 1]]],\n [[[111, 2], [35, 1]], [[49, 2]], [[0, 2]]],\n [[[31, 1]], [[174, 2], [0, 1]], [[0, 2]]],\n [[[62, 1]], [[0, 1]]]],\nlabels:\n[[0, 'EMPTY'],\n [317, null],\n [4, null],\n [276, null],\n [1, 'def'],\n [1, 'raise'],\n [1, 'True'],\n [3, null],\n [1, 'not'],\n [1, 'null'],\n [55, null],\n [2, null],\n [25, null],\n [1, 'class'],\n [1, 'break'],\n [1, 'lambda'],\n [16, null],\n [1, 'print'],\n [1, 'debugger'],\n [1, 'nonlocal'],\n [52, null],\n [1, 'try'],\n [1, 'while'],\n [31, null],\n [1, 'return'],\n [1, 'assert'],\n [1, null],\n [1, 'False'],\n [1, 'pass'],\n [1, 'import'],\n [15, null],\n [1, 'yield'],\n [1, 'global'],\n [1, 'for'],\n [7, null],\n [1, 'from'],\n [1, 'if'],\n [9, null],\n [54, null],\n [1, 'del'],\n [1, 'continue'],\n [49, null],\n [1, 'with'],\n [14, null],\n [316, null],\n [19, null],\n [308, null],\n [1, 'and'],\n [11, null],\n [326, null],\n [22, null],\n [261, null],\n [12, null],\n [35, null],\n [271, null],\n [325, null],\n [297, null],\n [339, null],\n [296, null],\n [26, null],\n [283, null],\n [8, null],\n [342, null],\n [329, null],\n [10, null],\n [266, null],\n [332, null],\n [45, null],\n [38, null],\n [40, null],\n [50, null],\n [46, null],\n [41, null],\n [42, null],\n [36, null],\n [43, null],\n [48, null],\n [44, null],\n [37, null],\n [39, null],\n [324, null],\n [260, null],\n [292, null],\n [1, 'in'],\n [309, null],\n [273, null],\n [327, null],\n [272, null],\n [28, null],\n [21, null],\n [27, null],\n [29, null],\n [1, 'is'],\n [30, null],\n [20, null],\n [290, null],\n [274, null],\n [333, null],\n [299, null],\n [270, null],\n [337, null],\n [279, null],\n [265, null],\n [281, null],\n [264, null],\n [286, null],\n [280, null],\n [320, null],\n [1, 'as'],\n [284, null],\n [23, null],\n [328, null],\n [0, null],\n [1, 'except'],\n [340, null],\n [18, null],\n [330, null],\n [268, null],\n [259, null],\n [312, null],\n [293, null],\n [321, null],\n [269, null],\n [277, null],\n [314, null],\n [315, null],\n [343, null],\n [1, 'else'],\n [310, null],\n [51, null],\n [1, 'elif'],\n [300, null],\n [301, null],\n [285, null],\n [303, null],\n [302, null],\n [335, null],\n [275, null],\n [258, null],\n [1, 'or'],\n [334, null],\n [267, null],\n [34, null],\n [262, null],\n [33, null],\n [319, null],\n [13, null],\n [295, null],\n [263, null],\n [304, null],\n [311, null],\n [307, null],\n [313, null],\n [282, null],\n [298, null],\n [291, null],\n [278, null],\n [318, null],\n [322, null],\n [5, null],\n [6, null],\n [47, null],\n [17, null],\n [24, null],\n [305, null],\n [306, null],\n [323, null],\n [289, null],\n [1, 'finally'],\n [331, null],\n [336, null],\n [338, null],\n [257, null],\n [32, null],\n [341, null]],\nkeywords:\n{'False': 27,\n 'null': 9,\n 'True': 6,\n 'and': 47,\n 'as': 108,\n 'assert': 25,\n 'break': 14,\n 'class': 13,\n 'continue': 40,\n 'debugger': 18,\n 'def': 4,\n 'del': 39,\n 'elif': 130,\n 'else': 127,\n 'except': 113,\n 'finally': 168,\n 'for': 33,\n 'from': 35,\n 'global': 32,\n 'if': 36,\n 'import': 29,\n 'in': 83,\n 'is': 92,\n 'lambda': 15,\n 'nonlocal': 19,\n 'not': 8,\n 'or': 139,\n 'pass': 28,\n 'print': 17,\n 'raise': 5,\n 'return': 24,\n 'try': 21,\n 'while': 22,\n 'with': 42,\n 'yield': 31},\ntokens:\n{0: 112,\n 1: 26,\n 2: 11,\n 3: 7,\n 4: 2,\n 5: 159,\n 6: 160,\n 7: 34,\n 8: 61,\n 9: 37,\n 10: 64,\n 11: 48,\n 12: 52,\n 13: 146,\n 14: 43,\n 15: 30,\n 16: 16,\n 17: 162,\n 18: 115,\n 19: 45,\n 20: 94,\n 21: 89,\n 22: 50,\n 23: 110,\n 24: 163,\n 25: 12,\n 26: 59,\n 27: 90,\n 28: 88,\n 29: 91,\n 30: 93,\n 31: 23,\n 32: 173,\n 33: 144,\n 34: 142,\n 35: 53,\n 36: 74,\n 37: 78,\n 38: 68,\n 39: 79,\n 40: 69,\n 41: 72,\n 42: 73,\n 43: 75,\n 44: 77,\n 45: 67,\n 46: 71,\n 47: 161,\n 48: 76,\n 49: 41,\n 50: 70,\n 51: 129,\n 52: 20,\n 54: 38,\n 55: 10},\nstart: 256\n};\n","// low level parser to a concrete syntax tree, derived from cpython's lib2to3\n\n/**\n *\n * @constructor\n * @param {Object} grammar\n *\n * p = new Parser(grammar);\n * p.setup([start]);\n * foreach input token:\n *     if p.addtoken(...):\n *         break\n * root = p.rootnode\n *\n * can throw SyntaxError\n */\nfunction Parser (filename, grammar) {\n    this.filename = filename;\n    this.grammar = grammar;\n    this.p_flags = 0;\n    return this;\n}\n\n// all possible parser flags\nParser.FUTURE_PRINT_FUNCTION = \"print_function\";\nParser.FUTURE_UNICODE_LITERALS = \"unicode_literals\";\nParser.FUTURE_DIVISION = \"division\";\nParser.FUTURE_ABSOLUTE_IMPORT = \"absolute_import\";\nParser.FUTURE_WITH_STATEMENT = \"with_statement\";\nParser.FUTURE_NESTED_SCOPES = \"nested_scopes\";\nParser.FUTURE_GENERATORS = \"generators\";\nParser.CO_FUTURE_PRINT_FUNCTION = 0x10000;\nParser.CO_FUTURE_UNICODE_LITERALS = 0x20000;\nParser.CO_FUTURE_DIVISON = 0x2000;\nParser.CO_FUTURE_ABSOLUTE_IMPORT = 0x4000;\nParser.CO_FUTURE_WITH_STATEMENT = 0x8000;\n\nParser.prototype.setup = function (start) {\n    var stackentry;\n    var newnode;\n    start = start || this.grammar.start;\n    //print(\"START:\"+start);\n\n    newnode =\n    {\n        type    : start,\n        value   : null,\n        context : null,\n        children: []\n    };\n    stackentry =\n    {\n        dfa  : this.grammar.dfas[start],\n        state: 0,\n        node : newnode\n    };\n    this.stack = [stackentry];\n    this.used_names = {};\n};\n\nfunction findInDfa (a, obj) {\n    var i = a.length;\n    while (i--) {\n        if (a[i][0] === obj[0] && a[i][1] === obj[1]) {\n            return true;\n        }\n    }\n    return false;\n}\n\n\n// Add a token; return true if we're done\nParser.prototype.addtoken = function (type, value, context) {\n    var errline;\n    var itsfirst;\n    var itsdfa;\n    var state;\n    var v;\n    var t;\n    var newstate;\n    var i;\n    var a;\n    var arcs;\n    var first;\n    var states;\n    var tp;\n    var ilabel = this.classify(type, value, context);\n    //print(\"ilabel:\"+ilabel);\n\n    OUTERWHILE:\n    while (true) {\n        tp = this.stack[this.stack.length - 1];\n        states = tp.dfa[0];\n        first = tp.dfa[1];\n        arcs = states[tp.state];\n\n        // look for a state with this label\n        for (a = 0; a < arcs.length; ++a) {\n            i = arcs[a][0];\n            newstate = arcs[a][1];\n            t = this.grammar.labels[i][0];\n            v = this.grammar.labels[i][1];\n            if (ilabel === i) {\n                // look it up in the list of labels\n                Sk.asserts.assert(t < 256);\n                // shift a token; we're done with it\n                this.shift(type, value, newstate, context);\n                // pop while we are in an accept-only state\n                state = newstate;\n                //print(\"before:\"+JSON.stringify(states[state]) + \":state:\"+state+\":\"+JSON.stringify(states[state]));\n                /* jshint ignore:start */\n                while (states[state].length === 1\n                    && states[state][0][0] === 0\n                    && states[state][0][1] === state) {\n                    // states[state] == [(0, state)])\n                    this.pop();\n                    //print(\"in after pop:\"+JSON.stringify(states[state]) + \":state:\"+state+\":\"+JSON.stringify(states[state]));\n                    if (this.stack.length === 0) {\n                        // done!\n                        return true;\n                    }\n                    tp = this.stack[this.stack.length - 1];\n                    state = tp.state;\n                    states = tp.dfa[0];\n                    first = tp.dfa[1];\n                    //print(JSON.stringify(states), JSON.stringify(first));\n                    //print(\"bottom:\"+JSON.stringify(states[state]) + \":state:\"+state+\":\"+JSON.stringify(states[state]));\n                }\n                /* jshint ignore:end */\n                // done with this token\n                //print(\"DONE, return false\");\n                return false;\n            } else if (t >= 256) {\n                itsdfa = this.grammar.dfas[t];\n                itsfirst = itsdfa[1];\n                if (itsfirst.hasOwnProperty(ilabel)) {\n                    // push a symbol\n                    this.push(t, this.grammar.dfas[t], newstate, context);\n                    continue OUTERWHILE;\n                }\n            }\n        }\n\n        //print(\"findInDfa: \" + JSON.stringify(arcs)+\" vs. \" + tp.state);\n        if (findInDfa(arcs, [0, tp.state])) {\n            // an accepting state, pop it and try somethign else\n            //print(\"WAA\");\n            this.pop();\n            if (this.stack.length === 0) {\n                throw new Sk.builtin.SyntaxError(\"too much input\", this.filename);\n            }\n        } else {\n            // no transition\n            errline = context[0][0];\n            throw new Sk.builtin.SyntaxError(\"bad input\", this.filename, errline, context);\n        }\n    }\n};\n\n// turn a token into a label\nParser.prototype.classify = function (type, value, context) {\n    var ilabel;\n    if (type === Sk.token.tokens.T_NAME) {\n        this.used_names[value] = true;\n        ilabel = this.grammar.keywords.hasOwnProperty(value) && this.grammar.keywords[value];\n\n        /* Check for handling print as an builtin function */\n        if(value === \"print\" && (this.p_flags & Parser.CO_FUTURE_PRINT_FUNCTION || Sk.__future__.print_function === true)) {\n            ilabel = false; // ilabel determines if the value is a keyword\n        }\n\n        if (ilabel) {\n            //print(\"is keyword\");\n            return ilabel;\n        }\n    }\n    ilabel = this.grammar.tokens.hasOwnProperty(type) && this.grammar.tokens[type];\n    if (!ilabel) {\n        // throw new Sk.builtin.SyntaxError(\"bad token\", type, value, context);\n        // Questionable modification to put line number in position 2\n        // like everywhere else and filename in position 1.\n        throw new Sk.builtin.SyntaxError(\"bad token\", this.filename, context[0][0], context);\n    }\n    return ilabel;\n};\n\n// shift a token\nParser.prototype.shift = function (type, value, newstate, context) {\n    var dfa = this.stack[this.stack.length - 1].dfa;\n    var state = this.stack[this.stack.length - 1].state;\n    var node = this.stack[this.stack.length - 1].node;\n    //print(\"context\", context);\n    var newnode = {\n        type      : type,\n        value     : value,\n        lineno    : context[0][0],         // throwing away end here to match cpython\n        col_offset: context[0][1],\n        children  : null\n    };\n    if (newnode) {\n        node.children.push(newnode);\n    }\n    this.stack[this.stack.length - 1] = {\n        dfa  : dfa,\n        state: newstate,\n        node : node\n    };\n};\n\n// push a nonterminal\nParser.prototype.push = function (type, newdfa, newstate, context) {\n    var dfa = this.stack[this.stack.length - 1].dfa;\n    var node = this.stack[this.stack.length - 1].node;\n    var newnode = {\n        type      : type,\n        value     : null,\n        lineno    : context[0][0],      // throwing away end here to match cpython\n        col_offset: context[0][1],\n        children  : []\n    };\n    this.stack[this.stack.length - 1] = {\n        dfa  : dfa,\n        state: newstate,\n        node : node\n    };\n    this.stack.push({\n        dfa  : newdfa,\n        state: 0,\n        node : newnode\n    });\n};\n\n//var ac = 0;\n//var bc = 0;\n\n// pop a nonterminal\nParser.prototype.pop = function () {\n    var node;\n    var pop = this.stack.pop();\n    var newnode = pop.node;\n    //print(\"POP\");\n    if (newnode) {\n        //print(\"A\", ac++, newnode.type);\n        //print(\"stacklen:\"+this.stack.length);\n        if (this.stack.length !== 0) {\n            //print(\"B\", bc++);\n            node = this.stack[this.stack.length - 1].node;\n            node.children.push(newnode);\n        } else {\n            //print(\"C\");\n            this.rootnode = newnode;\n            this.rootnode.used_names = this.used_names;\n        }\n    }\n};\n\n/**\n * parser for interactive input. returns a function that should be called with\n * lines of input as they are entered. the function will return false\n * until the input is complete, when it will return the rootnode of the parse.\n *\n * @param {string} filename\n * @param {string=} style root of parse tree (optional)\n */\nfunction makeParser (filename, style) {\n    if (style === undefined) {\n        style = \"file_input\";\n    }\n    var p = new Parser(filename, Sk.ParseTables);\n    // for closure's benefit\n    if (style === \"file_input\") {\n        p.setup(Sk.ParseTables.sym.file_input);\n    } else {\n        Sk.asserts.fail(\"todo;\");\n    }\n    return p;\n}\n\nSk.parse = function parse (filename, input) {\n    var T_COMMENT = Sk.token.tokens.T_COMMENT;\n    var T_NL = Sk.token.tokens.T_NL;\n    var T_OP = Sk.token.tokens.T_OP;\n    var T_ENDMARKER = Sk.token.tokens.T_ENDMARKER;\n    var T_ENCODING = Sk.token.tokens.T_ENCODING;\n\n    var endmarker_seen = false;\n    var parser = makeParser(filename);\n\n    /**\n     * takes a string splits it on '\\n' and returns a function that returns\n     * @param {Array<string>} input\n     * @returns {function(): string}\n     */\n    function readline(input) {\n        var lines = input.split(\"\\n\").reverse().map(function (l) { return l + \"\\n\"; });\n\n        return function() {\n            if (lines.length === 0) {\n                throw new Sk.builtin.Exception(\"EOF\");\n            }\n\n            return lines.pop();\n        };\n    }\n\n    Sk._tokenize(readline(input), \"utf-8\", function (tokenInfo) {\n        var s_lineno = tokenInfo.start[0];\n        var s_column = tokenInfo.start[1];\n        var type = null;\n        var prefix, lineno, column;\n\n        /* I don't know\n         if (s_lineno !== lineno && s_column !== column)\n         {\n         // todo; update prefix and line/col\n         }\n         */\n\n        if (tokenInfo.type === T_COMMENT || tokenInfo.type === T_NL || tokenInfo.type === T_ENCODING) {\n            prefix += tokenInfo.value;\n            lineno = tokenInfo.end[0];\n            column = tokenInfo.end[1];\n            if (tokenInfo.string[tokenInfo.string.length - 1] === \"\\n\") {\n                lineno += 1;\n                column = 0;\n            }\n        } else {\n            if (tokenInfo.type === T_OP) {\n                type = Sk.OpMap[tokenInfo.string];\n            }\n\n            parser.addtoken(type || tokenInfo.type, tokenInfo.string, [tokenInfo.start, tokenInfo.end, tokenInfo.line]);\n\n            if (tokenInfo.type === T_ENDMARKER) {\n                endmarker_seen = true;\n            }\n        }\n    });\n\n    if (!endmarker_seen) {\n        throw new Sk.builtin.SyntaxError(\"incomplete input\", this.filename);\n    }\n\n    /**\n     * Small adjustments here in order to return th flags and the cst\n     */\n    return {\"cst\": parser.rootnode, \"flags\": parser.p_flags};\n};\n\nSk.parseTreeDump = function parseTreeDump (n, indent) {\n    //return JSON.stringify(n, null, 2);\n    var i;\n    var ret;\n    indent = indent || \"\";\n    ret = \"\";\n    ret += indent;\n    if (n.type >= 256) { // non-term\n        ret += Sk.ParseTables.number2symbol[n.type] + \"\\n\";\n        for (i = 0; i < n.children.length; ++i) {\n            ret += Sk.parseTreeDump(n.children[i], indent + \"  \");\n        }\n    } else {\n        ret += Sk.token.tok_name[n.type] + \": \" + new Sk.builtin.str(n.value)[\"$r\"]().v + \"\\n\";\n    }\n    return ret;\n};\n\n\nSk.exportSymbol(\"Sk.Parser\", Parser);\nSk.exportSymbol(\"Sk.parse\", Sk.parse);\nSk.exportSymbol(\"Sk.parseTreeDump\", Sk.parseTreeDump);\n","/* File automatically generated by asdl_js.py. */\n\n/* Object that holds all nodes */\nSk.astnodes = {};\n\n/* ----- expr_context ----- */\n/** @constructor */\nSk.astnodes.Load = function Load() {}\n/** @constructor */\nSk.astnodes.Store = function Store() {}\n/** @constructor */\nSk.astnodes.Del = function Del() {}\n/** @constructor */\nSk.astnodes.AugLoad = function AugLoad() {}\n/** @constructor */\nSk.astnodes.AugStore = function AugStore() {}\n/** @constructor */\nSk.astnodes.Param = function Param() {}\n\n/* ----- boolop ----- */\n/** @constructor */\nSk.astnodes.And = function And() {}\n/** @constructor */\nSk.astnodes.Or = function Or() {}\n\n/* ----- operator ----- */\n/** @constructor */\nSk.astnodes.Add = function Add() {}\n/** @constructor */\nSk.astnodes.Sub = function Sub() {}\n/** @constructor */\nSk.astnodes.Mult = function Mult() {}\n/** @constructor */\nSk.astnodes.MatMult = function MatMult() {}\n/** @constructor */\nSk.astnodes.Div = function Div() {}\n/** @constructor */\nSk.astnodes.Mod = function Mod() {}\n/** @constructor */\nSk.astnodes.Pow = function Pow() {}\n/** @constructor */\nSk.astnodes.LShift = function LShift() {}\n/** @constructor */\nSk.astnodes.RShift = function RShift() {}\n/** @constructor */\nSk.astnodes.BitOr = function BitOr() {}\n/** @constructor */\nSk.astnodes.BitXor = function BitXor() {}\n/** @constructor */\nSk.astnodes.BitAnd = function BitAnd() {}\n/** @constructor */\nSk.astnodes.FloorDiv = function FloorDiv() {}\n\n/* ----- unaryop ----- */\n/** @constructor */\nSk.astnodes.Invert = function Invert() {}\n/** @constructor */\nSk.astnodes.Not = function Not() {}\n/** @constructor */\nSk.astnodes.UAdd = function UAdd() {}\n/** @constructor */\nSk.astnodes.USub = function USub() {}\n\n/* ----- cmpop ----- */\n/** @constructor */\nSk.astnodes.Eq = function Eq() {}\n/** @constructor */\nSk.astnodes.NotEq = function NotEq() {}\n/** @constructor */\nSk.astnodes.Lt = function Lt() {}\n/** @constructor */\nSk.astnodes.LtE = function LtE() {}\n/** @constructor */\nSk.astnodes.Gt = function Gt() {}\n/** @constructor */\nSk.astnodes.GtE = function GtE() {}\n/** @constructor */\nSk.astnodes.Is = function Is() {}\n/** @constructor */\nSk.astnodes.IsNot = function IsNot() {}\n/** @constructor */\nSk.astnodes.In = function In() {}\n/** @constructor */\nSk.astnodes.NotIn = function NotIn() {}\n\n\n\n\n\n\n\n/* ---------------------- */\n/* constructors for nodes */\n/* ---------------------- */\n\n\n\n\n\n/** @constructor */\nSk.astnodes.Module = function Module(/* {asdl_seq *} */ body, /* {string} */\n                                          docstring)\n{\n    this.body = body;\n    this.docstring = docstring;\n    return this;\n}\n\n/** @constructor */\nSk.astnodes.Interactive = function Interactive(/* {asdl_seq *} */ body)\n{\n    this.body = body;\n    return this;\n}\n\n/** @constructor */\nSk.astnodes.Expression = function Expression(/* {expr_ty} */ body)\n{\n    this.body = body;\n    return this;\n}\n\n/** @constructor */\nSk.astnodes.Suite = function Suite(/* {asdl_seq *} */ body)\n{\n    this.body = body;\n    return this;\n}\n\n/** @constructor */\nSk.astnodes.FunctionDef = function FunctionDef(/* {identifier} */ name, /*\n                                                    {arguments__ty} */ args, /*\n                                                    {asdl_seq *} */ body, /*\n                                                    {asdl_seq *} */\n                                                    decorator_list, /*\n                                                    {expr_ty} */ returns, /*\n                                                    {string} */ docstring, /*\n                                                    {int} */ lineno, /* {int}\n                                                    */ col_offset)\n{\n    Sk.asserts.assert(lineno !== null && lineno !== undefined);\n    Sk.asserts.assert(col_offset !== null && col_offset !== undefined);\n    this.name = name;\n    this.args = args;\n    this.body = body;\n    this.decorator_list = decorator_list;\n    this.returns = returns;\n    this.docstring = docstring;\n    this.lineno = lineno;\n    this.col_offset = col_offset;\n    return this;\n}\n\n/** @constructor */\nSk.astnodes.AsyncFunctionDef = function AsyncFunctionDef(/* {identifier} */\n                                                              name, /*\n                                                              {arguments__ty}\n                                                              */ args, /*\n                                                              {asdl_seq *} */\n                                                              body, /*\n                                                              {asdl_seq *} */\n                                                              decorator_list,\n                                                              /* {expr_ty} */\n                                                              returns, /*\n                                                              {string} */\n                                                              docstring, /*\n                                                              {int} */ lineno,\n                                                              /* {int} */\n                                                              col_offset)\n{\n    Sk.asserts.assert(lineno !== null && lineno !== undefined);\n    Sk.asserts.assert(col_offset !== null && col_offset !== undefined);\n    this.name = name;\n    this.args = args;\n    this.body = body;\n    this.decorator_list = decorator_list;\n    this.returns = returns;\n    this.docstring = docstring;\n    this.lineno = lineno;\n    this.col_offset = col_offset;\n    return this;\n}\n\n/** @constructor */\nSk.astnodes.ClassDef = function ClassDef(/* {identifier} */ name, /* {asdl_seq\n                                              *} */ bases, /* {asdl_seq *} */\n                                              keywords, /* {asdl_seq *} */\n                                              body, /* {asdl_seq *} */\n                                              decorator_list, /* {string} */\n                                              docstring, /* {int} */ lineno, /*\n                                              {int} */ col_offset)\n{\n    Sk.asserts.assert(lineno !== null && lineno !== undefined);\n    Sk.asserts.assert(col_offset !== null && col_offset !== undefined);\n    this.name = name;\n    this.bases = bases;\n    this.keywords = keywords;\n    this.body = body;\n    this.decorator_list = decorator_list;\n    this.docstring = docstring;\n    this.lineno = lineno;\n    this.col_offset = col_offset;\n    return this;\n}\n\n/** @constructor */\nSk.astnodes.Return = function Return(/* {expr_ty} */ value, /* {int} */ lineno,\n                                          /* {int} */ col_offset)\n{\n    Sk.asserts.assert(lineno !== null && lineno !== undefined);\n    Sk.asserts.assert(col_offset !== null && col_offset !== undefined);\n    this.value = value;\n    this.lineno = lineno;\n    this.col_offset = col_offset;\n    return this;\n}\n\n/** @constructor */\nSk.astnodes.Delete = function Delete(/* {asdl_seq *} */ targets, /* {int} */\n                                          lineno, /* {int} */ col_offset)\n{\n    Sk.asserts.assert(lineno !== null && lineno !== undefined);\n    Sk.asserts.assert(col_offset !== null && col_offset !== undefined);\n    this.targets = targets;\n    this.lineno = lineno;\n    this.col_offset = col_offset;\n    return this;\n}\n\n/** @constructor */\nSk.astnodes.Assign = function Assign(/* {asdl_seq *} */ targets, /* {expr_ty}\n                                          */ value, /* {int} */ lineno, /*\n                                          {int} */ col_offset)\n{\n    Sk.asserts.assert(lineno !== null && lineno !== undefined);\n    Sk.asserts.assert(col_offset !== null && col_offset !== undefined);\n    this.targets = targets;\n    this.value = value;\n    this.lineno = lineno;\n    this.col_offset = col_offset;\n    return this;\n}\n\n/** @constructor */\nSk.astnodes.AugAssign = function AugAssign(/* {expr_ty} */ target, /*\n                                                {operator_ty} */ op, /*\n                                                {expr_ty} */ value, /* {int} */\n                                                lineno, /* {int} */ col_offset)\n{\n    Sk.asserts.assert(lineno !== null && lineno !== undefined);\n    Sk.asserts.assert(col_offset !== null && col_offset !== undefined);\n    this.target = target;\n    this.op = op;\n    this.value = value;\n    this.lineno = lineno;\n    this.col_offset = col_offset;\n    return this;\n}\n\n/** @constructor */\nSk.astnodes.AnnAssign = function AnnAssign(/* {expr_ty} */ target, /* {expr_ty}\n                                                */ annotation, /* {expr_ty} */\n                                                value, /* {int} */ simple, /*\n                                                {int} */ lineno, /* {int} */\n                                                col_offset)\n{\n    Sk.asserts.assert(lineno !== null && lineno !== undefined);\n    Sk.asserts.assert(col_offset !== null && col_offset !== undefined);\n    this.target = target;\n    this.annotation = annotation;\n    this.value = value;\n    this.simple = simple;\n    this.lineno = lineno;\n    this.col_offset = col_offset;\n    return this;\n}\n\n/** @constructor */\nSk.astnodes.For = function For(/* {expr_ty} */ target, /* {expr_ty} */ iter, /*\n                                    {asdl_seq *} */ body, /* {asdl_seq *} */\n                                    orelse, /* {int} */ lineno, /* {int} */\n                                    col_offset)\n{\n    Sk.asserts.assert(lineno !== null && lineno !== undefined);\n    Sk.asserts.assert(col_offset !== null && col_offset !== undefined);\n    this.target = target;\n    this.iter = iter;\n    this.body = body;\n    this.orelse = orelse;\n    this.lineno = lineno;\n    this.col_offset = col_offset;\n    return this;\n}\n\n/** @constructor */\nSk.astnodes.AsyncFor = function AsyncFor(/* {expr_ty} */ target, /* {expr_ty}\n                                              */ iter, /* {asdl_seq *} */ body,\n                                              /* {asdl_seq *} */ orelse, /*\n                                              {int} */ lineno, /* {int} */\n                                              col_offset)\n{\n    Sk.asserts.assert(lineno !== null && lineno !== undefined);\n    Sk.asserts.assert(col_offset !== null && col_offset !== undefined);\n    this.target = target;\n    this.iter = iter;\n    this.body = body;\n    this.orelse = orelse;\n    this.lineno = lineno;\n    this.col_offset = col_offset;\n    return this;\n}\n\n/** @constructor */\nSk.astnodes.While = function While(/* {expr_ty} */ test, /* {asdl_seq *} */\n                                        body, /* {asdl_seq *} */ orelse, /*\n                                        {int} */ lineno, /* {int} */ col_offset)\n{\n    Sk.asserts.assert(lineno !== null && lineno !== undefined);\n    Sk.asserts.assert(col_offset !== null && col_offset !== undefined);\n    this.test = test;\n    this.body = body;\n    this.orelse = orelse;\n    this.lineno = lineno;\n    this.col_offset = col_offset;\n    return this;\n}\n\n/** @constructor */\nSk.astnodes.If = function If(/* {expr_ty} */ test, /* {asdl_seq *} */ body, /*\n                                  {asdl_seq *} */ orelse, /* {int} */ lineno,\n                                  /* {int} */ col_offset)\n{\n    Sk.asserts.assert(lineno !== null && lineno !== undefined);\n    Sk.asserts.assert(col_offset !== null && col_offset !== undefined);\n    this.test = test;\n    this.body = body;\n    this.orelse = orelse;\n    this.lineno = lineno;\n    this.col_offset = col_offset;\n    return this;\n}\n\n/** @constructor */\nSk.astnodes.With = function With(/* {asdl_seq *} */ items, /* {asdl_seq *} */\n                                      body, /* {int} */ lineno, /* {int} */\n                                      col_offset)\n{\n    Sk.asserts.assert(lineno !== null && lineno !== undefined);\n    Sk.asserts.assert(col_offset !== null && col_offset !== undefined);\n    this.items = items;\n    this.body = body;\n    this.lineno = lineno;\n    this.col_offset = col_offset;\n    return this;\n}\n\n/** @constructor */\nSk.astnodes.AsyncWith = function AsyncWith(/* {asdl_seq *} */ items, /*\n                                                {asdl_seq *} */ body, /* {int}\n                                                */ lineno, /* {int} */\n                                                col_offset)\n{\n    Sk.asserts.assert(lineno !== null && lineno !== undefined);\n    Sk.asserts.assert(col_offset !== null && col_offset !== undefined);\n    this.items = items;\n    this.body = body;\n    this.lineno = lineno;\n    this.col_offset = col_offset;\n    return this;\n}\n\n/** @constructor */\nSk.astnodes.Raise = function Raise(/* {expr_ty} */ exc, /* {expr_ty} */ cause,\n                                        /* {expr_ty} */ inst, /* {expr_ty} */\n                                        tback, /* {int} */ lineno, /* {int} */\n                                        col_offset)\n{\n    Sk.asserts.assert(lineno !== null && lineno !== undefined);\n    Sk.asserts.assert(col_offset !== null && col_offset !== undefined);\n    this.exc = exc;\n    this.cause = cause;\n    this.inst = inst;\n    this.tback = tback;\n    this.lineno = lineno;\n    this.col_offset = col_offset;\n    return this;\n}\n\n/** @constructor */\nSk.astnodes.Try = function Try(/* {asdl_seq *} */ body, /* {asdl_seq *} */\n                                    handlers, /* {asdl_seq *} */ orelse, /*\n                                    {asdl_seq *} */ finalbody, /* {int} */\n                                    lineno, /* {int} */ col_offset)\n{\n    Sk.asserts.assert(lineno !== null && lineno !== undefined);\n    Sk.asserts.assert(col_offset !== null && col_offset !== undefined);\n    this.body = body;\n    this.handlers = handlers;\n    this.orelse = orelse;\n    this.finalbody = finalbody;\n    this.lineno = lineno;\n    this.col_offset = col_offset;\n    return this;\n}\n\n/** @constructor */\nSk.astnodes.Assert = function Assert(/* {expr_ty} */ test, /* {expr_ty} */ msg,\n                                          /* {int} */ lineno, /* {int} */\n                                          col_offset)\n{\n    Sk.asserts.assert(lineno !== null && lineno !== undefined);\n    Sk.asserts.assert(col_offset !== null && col_offset !== undefined);\n    this.test = test;\n    this.msg = msg;\n    this.lineno = lineno;\n    this.col_offset = col_offset;\n    return this;\n}\n\n/** @constructor */\nSk.astnodes.Import = function Import(/* {asdl_seq *} */ names, /* {int} */\n                                          lineno, /* {int} */ col_offset)\n{\n    Sk.asserts.assert(lineno !== null && lineno !== undefined);\n    Sk.asserts.assert(col_offset !== null && col_offset !== undefined);\n    this.names = names;\n    this.lineno = lineno;\n    this.col_offset = col_offset;\n    return this;\n}\n\n/** @constructor */\nSk.astnodes.ImportFrom = function ImportFrom(/* {identifier} */ module, /*\n                                                  {asdl_seq *} */ names, /*\n                                                  {int} */ level, /* {int} */\n                                                  lineno, /* {int} */\n                                                  col_offset)\n{\n    Sk.asserts.assert(lineno !== null && lineno !== undefined);\n    Sk.asserts.assert(col_offset !== null && col_offset !== undefined);\n    this.module = module;\n    this.names = names;\n    this.level = level;\n    this.lineno = lineno;\n    this.col_offset = col_offset;\n    return this;\n}\n\n/** @constructor */\nSk.astnodes.Global = function Global(/* {asdl_seq *} */ names, /* {int} */\n                                          lineno, /* {int} */ col_offset)\n{\n    Sk.asserts.assert(lineno !== null && lineno !== undefined);\n    Sk.asserts.assert(col_offset !== null && col_offset !== undefined);\n    this.names = names;\n    this.lineno = lineno;\n    this.col_offset = col_offset;\n    return this;\n}\n\n/** @constructor */\nSk.astnodes.Nonlocal = function Nonlocal(/* {asdl_seq *} */ names, /* {int} */\n                                              lineno, /* {int} */ col_offset)\n{\n    Sk.asserts.assert(lineno !== null && lineno !== undefined);\n    Sk.asserts.assert(col_offset !== null && col_offset !== undefined);\n    this.names = names;\n    this.lineno = lineno;\n    this.col_offset = col_offset;\n    return this;\n}\n\n/** @constructor */\nSk.astnodes.Expr = function Expr(/* {expr_ty} */ value, /* {int} */ lineno, /*\n                                      {int} */ col_offset)\n{\n    Sk.asserts.assert(lineno !== null && lineno !== undefined);\n    Sk.asserts.assert(col_offset !== null && col_offset !== undefined);\n    this.value = value;\n    this.lineno = lineno;\n    this.col_offset = col_offset;\n    return this;\n}\n\n/** @constructor */\nSk.astnodes.Pass = function Pass(/* {int} */ lineno, /* {int} */ col_offset)\n{\n    Sk.asserts.assert(lineno !== null && lineno !== undefined);\n    Sk.asserts.assert(col_offset !== null && col_offset !== undefined);\n    this.lineno = lineno;\n    this.col_offset = col_offset;\n    return this;\n}\n\n/** @constructor */\nSk.astnodes.Break = function Break(/* {int} */ lineno, /* {int} */ col_offset)\n{\n    Sk.asserts.assert(lineno !== null && lineno !== undefined);\n    Sk.asserts.assert(col_offset !== null && col_offset !== undefined);\n    this.lineno = lineno;\n    this.col_offset = col_offset;\n    return this;\n}\n\n/** @constructor */\nSk.astnodes.Continue = function Continue(/* {int} */ lineno, /* {int} */\n                                              col_offset)\n{\n    Sk.asserts.assert(lineno !== null && lineno !== undefined);\n    Sk.asserts.assert(col_offset !== null && col_offset !== undefined);\n    this.lineno = lineno;\n    this.col_offset = col_offset;\n    return this;\n}\n\n/** @constructor */\nSk.astnodes.Print = function Print(/* {expr_ty} */ dest, /* {asdl_seq *} */\n                                        values, /* {int} */ nl, /* {int} */\n                                        lineno, /* {int} */ col_offset)\n{\n    Sk.asserts.assert(lineno !== null && lineno !== undefined);\n    Sk.asserts.assert(col_offset !== null && col_offset !== undefined);\n    this.dest = dest;\n    this.values = values;\n    this.nl = nl;\n    this.lineno = lineno;\n    this.col_offset = col_offset;\n    return this;\n}\n\n/** @constructor */\nSk.astnodes.Debugger = function Debugger(/* {int} */ lineno, /* {int} */\n                                              col_offset)\n{\n    Sk.asserts.assert(lineno !== null && lineno !== undefined);\n    Sk.asserts.assert(col_offset !== null && col_offset !== undefined);\n    this.lineno = lineno;\n    this.col_offset = col_offset;\n    return this;\n}\n\n/** @constructor */\nSk.astnodes.BoolOp = function BoolOp(/* {boolop_ty} */ op, /* {asdl_seq *} */\n                                          values, /* {int} */ lineno, /* {int}\n                                          */ col_offset)\n{\n    Sk.asserts.assert(lineno !== null && lineno !== undefined);\n    Sk.asserts.assert(col_offset !== null && col_offset !== undefined);\n    this.op = op;\n    this.values = values;\n    this.lineno = lineno;\n    this.col_offset = col_offset;\n    return this;\n}\n\n/** @constructor */\nSk.astnodes.BinOp = function BinOp(/* {expr_ty} */ left, /* {operator_ty} */\n                                        op, /* {expr_ty} */ right, /* {int} */\n                                        lineno, /* {int} */ col_offset)\n{\n    Sk.asserts.assert(lineno !== null && lineno !== undefined);\n    Sk.asserts.assert(col_offset !== null && col_offset !== undefined);\n    this.left = left;\n    this.op = op;\n    this.right = right;\n    this.lineno = lineno;\n    this.col_offset = col_offset;\n    return this;\n}\n\n/** @constructor */\nSk.astnodes.UnaryOp = function UnaryOp(/* {unaryop_ty} */ op, /* {expr_ty} */\n                                            operand, /* {int} */ lineno, /*\n                                            {int} */ col_offset)\n{\n    Sk.asserts.assert(lineno !== null && lineno !== undefined);\n    Sk.asserts.assert(col_offset !== null && col_offset !== undefined);\n    this.op = op;\n    this.operand = operand;\n    this.lineno = lineno;\n    this.col_offset = col_offset;\n    return this;\n}\n\n/** @constructor */\nSk.astnodes.Lambda = function Lambda(/* {arguments__ty} */ args, /* {expr_ty}\n                                          */ body, /* {int} */ lineno, /* {int}\n                                          */ col_offset)\n{\n    Sk.asserts.assert(lineno !== null && lineno !== undefined);\n    Sk.asserts.assert(col_offset !== null && col_offset !== undefined);\n    this.args = args;\n    this.body = body;\n    this.lineno = lineno;\n    this.col_offset = col_offset;\n    return this;\n}\n\n/** @constructor */\nSk.astnodes.IfExp = function IfExp(/* {expr_ty} */ test, /* {expr_ty} */ body,\n                                        /* {expr_ty} */ orelse, /* {int} */\n                                        lineno, /* {int} */ col_offset)\n{\n    Sk.asserts.assert(lineno !== null && lineno !== undefined);\n    Sk.asserts.assert(col_offset !== null && col_offset !== undefined);\n    this.test = test;\n    this.body = body;\n    this.orelse = orelse;\n    this.lineno = lineno;\n    this.col_offset = col_offset;\n    return this;\n}\n\n/** @constructor */\nSk.astnodes.Dict = function Dict(/* {asdl_seq *} */ keys, /* {asdl_seq *} */\n                                      values, /* {int} */ lineno, /* {int} */\n                                      col_offset)\n{\n    Sk.asserts.assert(lineno !== null && lineno !== undefined);\n    Sk.asserts.assert(col_offset !== null && col_offset !== undefined);\n    this.keys = keys;\n    this.values = values;\n    this.lineno = lineno;\n    this.col_offset = col_offset;\n    return this;\n}\n\n/** @constructor */\nSk.astnodes.Set = function Set(/* {asdl_seq *} */ elts, /* {int} */ lineno, /*\n                                    {int} */ col_offset)\n{\n    Sk.asserts.assert(lineno !== null && lineno !== undefined);\n    Sk.asserts.assert(col_offset !== null && col_offset !== undefined);\n    this.elts = elts;\n    this.lineno = lineno;\n    this.col_offset = col_offset;\n    return this;\n}\n\n/** @constructor */\nSk.astnodes.ListComp = function ListComp(/* {expr_ty} */ elt, /* {asdl_seq *}\n                                              */ generators, /* {int} */\n                                              lineno, /* {int} */ col_offset)\n{\n    Sk.asserts.assert(lineno !== null && lineno !== undefined);\n    Sk.asserts.assert(col_offset !== null && col_offset !== undefined);\n    this.elt = elt;\n    this.generators = generators;\n    this.lineno = lineno;\n    this.col_offset = col_offset;\n    return this;\n}\n\n/** @constructor */\nSk.astnodes.SetComp = function SetComp(/* {expr_ty} */ elt, /* {asdl_seq *} */\n                                            generators, /* {int} */ lineno, /*\n                                            {int} */ col_offset)\n{\n    Sk.asserts.assert(lineno !== null && lineno !== undefined);\n    Sk.asserts.assert(col_offset !== null && col_offset !== undefined);\n    this.elt = elt;\n    this.generators = generators;\n    this.lineno = lineno;\n    this.col_offset = col_offset;\n    return this;\n}\n\n/** @constructor */\nSk.astnodes.DictComp = function DictComp(/* {expr_ty} */ key, /* {expr_ty} */\n                                              value, /* {asdl_seq *} */\n                                              generators, /* {int} */ lineno,\n                                              /* {int} */ col_offset)\n{\n    Sk.asserts.assert(lineno !== null && lineno !== undefined);\n    Sk.asserts.assert(col_offset !== null && col_offset !== undefined);\n    this.key = key;\n    this.value = value;\n    this.generators = generators;\n    this.lineno = lineno;\n    this.col_offset = col_offset;\n    return this;\n}\n\n/** @constructor */\nSk.astnodes.GeneratorExp = function GeneratorExp(/* {expr_ty} */ elt, /*\n                                                      {asdl_seq *} */\n                                                      generators, /* {int} */\n                                                      lineno, /* {int} */\n                                                      col_offset)\n{\n    Sk.asserts.assert(lineno !== null && lineno !== undefined);\n    Sk.asserts.assert(col_offset !== null && col_offset !== undefined);\n    this.elt = elt;\n    this.generators = generators;\n    this.lineno = lineno;\n    this.col_offset = col_offset;\n    return this;\n}\n\n/** @constructor */\nSk.astnodes.Await = function Await(/* {expr_ty} */ value, /* {int} */ lineno,\n                                        /* {int} */ col_offset)\n{\n    Sk.asserts.assert(lineno !== null && lineno !== undefined);\n    Sk.asserts.assert(col_offset !== null && col_offset !== undefined);\n    this.value = value;\n    this.lineno = lineno;\n    this.col_offset = col_offset;\n    return this;\n}\n\n/** @constructor */\nSk.astnodes.Yield = function Yield(/* {expr_ty} */ value, /* {int} */ lineno,\n                                        /* {int} */ col_offset)\n{\n    Sk.asserts.assert(lineno !== null && lineno !== undefined);\n    Sk.asserts.assert(col_offset !== null && col_offset !== undefined);\n    this.value = value;\n    this.lineno = lineno;\n    this.col_offset = col_offset;\n    return this;\n}\n\n/** @constructor */\nSk.astnodes.YieldFrom = function YieldFrom(/* {expr_ty} */ value, /* {int} */\n                                                lineno, /* {int} */ col_offset)\n{\n    Sk.asserts.assert(lineno !== null && lineno !== undefined);\n    Sk.asserts.assert(col_offset !== null && col_offset !== undefined);\n    this.value = value;\n    this.lineno = lineno;\n    this.col_offset = col_offset;\n    return this;\n}\n\n/** @constructor */\nSk.astnodes.Compare = function Compare(/* {expr_ty} */ left, /* {asdl_int_seq\n                                            *} */ ops, /* {asdl_seq *} */\n                                            comparators, /* {int} */ lineno, /*\n                                            {int} */ col_offset)\n{\n    Sk.asserts.assert(lineno !== null && lineno !== undefined);\n    Sk.asserts.assert(col_offset !== null && col_offset !== undefined);\n    this.left = left;\n    this.ops = ops;\n    this.comparators = comparators;\n    this.lineno = lineno;\n    this.col_offset = col_offset;\n    return this;\n}\n\n/** @constructor */\nSk.astnodes.Call = function Call(/* {expr_ty} */ func, /* {asdl_seq *} */ args,\n                                      /* {asdl_seq *} */ keywords, /* {int} */\n                                      lineno, /* {int} */ col_offset)\n{\n    Sk.asserts.assert(lineno !== null && lineno !== undefined);\n    Sk.asserts.assert(col_offset !== null && col_offset !== undefined);\n    this.func = func;\n    this.args = args;\n    this.keywords = keywords;\n    this.lineno = lineno;\n    this.col_offset = col_offset;\n    return this;\n}\n\n/** @constructor */\nSk.astnodes.Num = function Num(/* {object} */ n, /* {int} */ lineno, /* {int}\n                                    */ col_offset)\n{\n    Sk.asserts.assert(lineno !== null && lineno !== undefined);\n    Sk.asserts.assert(col_offset !== null && col_offset !== undefined);\n    this.n = n;\n    this.lineno = lineno;\n    this.col_offset = col_offset;\n    return this;\n}\n\n/** @constructor */\nSk.astnodes.Str = function Str(/* {string} */ s, /* {int} */ lineno, /* {int}\n                                    */ col_offset)\n{\n    Sk.asserts.assert(lineno !== null && lineno !== undefined);\n    Sk.asserts.assert(col_offset !== null && col_offset !== undefined);\n    this.s = s;\n    this.lineno = lineno;\n    this.col_offset = col_offset;\n    return this;\n}\n\n/** @constructor */\nSk.astnodes.FormattedValue = function FormattedValue(/* {expr_ty} */ value, /*\n                                                          {int} */ conversion,\n                                                          /* {expr_ty} */\n                                                          format_spec, /* {int}\n                                                          */ lineno, /* {int}\n                                                          */ col_offset)\n{\n    Sk.asserts.assert(lineno !== null && lineno !== undefined);\n    Sk.asserts.assert(col_offset !== null && col_offset !== undefined);\n    this.value = value;\n    this.conversion = conversion;\n    this.format_spec = format_spec;\n    this.lineno = lineno;\n    this.col_offset = col_offset;\n    return this;\n}\n\n/** @constructor */\nSk.astnodes.JoinedStr = function JoinedStr(/* {asdl_seq *} */ values, /* {int}\n                                                */ lineno, /* {int} */\n                                                col_offset)\n{\n    Sk.asserts.assert(lineno !== null && lineno !== undefined);\n    Sk.asserts.assert(col_offset !== null && col_offset !== undefined);\n    this.values = values;\n    this.lineno = lineno;\n    this.col_offset = col_offset;\n    return this;\n}\n\n/** @constructor */\nSk.astnodes.Bytes = function Bytes(/* {bytes} */ s, /* {int} */ lineno, /*\n                                        {int} */ col_offset)\n{\n    Sk.asserts.assert(lineno !== null && lineno !== undefined);\n    Sk.asserts.assert(col_offset !== null && col_offset !== undefined);\n    this.s = s;\n    this.lineno = lineno;\n    this.col_offset = col_offset;\n    return this;\n}\n\n/** @constructor */\nSk.astnodes.NameConstant = function NameConstant(/* {singleton} */ value, /*\n                                                      {int} */ lineno, /* {int}\n                                                      */ col_offset)\n{\n    Sk.asserts.assert(lineno !== null && lineno !== undefined);\n    Sk.asserts.assert(col_offset !== null && col_offset !== undefined);\n    this.value = value;\n    this.lineno = lineno;\n    this.col_offset = col_offset;\n    return this;\n}\n\n/** @constructor */\nSk.astnodes.Ellipsis = function Ellipsis(/* {int} */ lineno, /* {int} */\n                                              col_offset)\n{\n    Sk.asserts.assert(lineno !== null && lineno !== undefined);\n    Sk.asserts.assert(col_offset !== null && col_offset !== undefined);\n    this.lineno = lineno;\n    this.col_offset = col_offset;\n    return this;\n}\n\n/** @constructor */\nSk.astnodes.Constant = function Constant(/* {constant} */ value, /* {int} */\n                                              lineno, /* {int} */ col_offset)\n{\n    Sk.asserts.assert(lineno !== null && lineno !== undefined);\n    Sk.asserts.assert(col_offset !== null && col_offset !== undefined);\n    this.value = value;\n    this.lineno = lineno;\n    this.col_offset = col_offset;\n    return this;\n}\n\n/** @constructor */\nSk.astnodes.Attribute = function Attribute(/* {expr_ty} */ value, /*\n                                                {identifier} */ attr, /*\n                                                {expr_context_ty} */ ctx, /*\n                                                {int} */ lineno, /* {int} */\n                                                col_offset)\n{\n    Sk.asserts.assert(lineno !== null && lineno !== undefined);\n    Sk.asserts.assert(col_offset !== null && col_offset !== undefined);\n    this.value = value;\n    this.attr = attr;\n    this.ctx = ctx;\n    this.lineno = lineno;\n    this.col_offset = col_offset;\n    return this;\n}\n\n/** @constructor */\nSk.astnodes.Subscript = function Subscript(/* {expr_ty} */ value, /* {slice_ty}\n                                                */ slice, /* {expr_context_ty}\n                                                */ ctx, /* {int} */ lineno, /*\n                                                {int} */ col_offset)\n{\n    Sk.asserts.assert(lineno !== null && lineno !== undefined);\n    Sk.asserts.assert(col_offset !== null && col_offset !== undefined);\n    this.value = value;\n    this.slice = slice;\n    this.ctx = ctx;\n    this.lineno = lineno;\n    this.col_offset = col_offset;\n    return this;\n}\n\n/** @constructor */\nSk.astnodes.Starred = function Starred(/* {expr_ty} */ value, /*\n                                            {expr_context_ty} */ ctx, /* {int}\n                                            */ lineno, /* {int} */ col_offset)\n{\n    Sk.asserts.assert(lineno !== null && lineno !== undefined);\n    Sk.asserts.assert(col_offset !== null && col_offset !== undefined);\n    this.value = value;\n    this.ctx = ctx;\n    this.lineno = lineno;\n    this.col_offset = col_offset;\n    return this;\n}\n\n/** @constructor */\nSk.astnodes.Name = function Name(/* {identifier} */ id, /* {expr_context_ty} */\n                                      ctx, /* {int} */ lineno, /* {int} */\n                                      col_offset)\n{\n    Sk.asserts.assert(lineno !== null && lineno !== undefined);\n    Sk.asserts.assert(col_offset !== null && col_offset !== undefined);\n    this.id = id;\n    this.ctx = ctx;\n    this.lineno = lineno;\n    this.col_offset = col_offset;\n    return this;\n}\n\n/** @constructor */\nSk.astnodes.List = function List(/* {asdl_seq *} */ elts, /* {expr_context_ty}\n                                      */ ctx, /* {int} */ lineno, /* {int} */\n                                      col_offset)\n{\n    Sk.asserts.assert(lineno !== null && lineno !== undefined);\n    Sk.asserts.assert(col_offset !== null && col_offset !== undefined);\n    this.elts = elts;\n    this.ctx = ctx;\n    this.lineno = lineno;\n    this.col_offset = col_offset;\n    return this;\n}\n\n/** @constructor */\nSk.astnodes.Tuple = function Tuple(/* {asdl_seq *} */ elts, /*\n                                        {expr_context_ty} */ ctx, /* {int} */\n                                        lineno, /* {int} */ col_offset)\n{\n    Sk.asserts.assert(lineno !== null && lineno !== undefined);\n    Sk.asserts.assert(col_offset !== null && col_offset !== undefined);\n    this.elts = elts;\n    this.ctx = ctx;\n    this.lineno = lineno;\n    this.col_offset = col_offset;\n    return this;\n}\n\n/** @constructor */\nSk.astnodes.Slice = function Slice(/* {expr_ty} */ lower, /* {expr_ty} */\n                                        upper, /* {expr_ty} */ step)\n{\n    this.lower = lower;\n    this.upper = upper;\n    this.step = step;\n    return this;\n}\n\n/** @constructor */\nSk.astnodes.ExtSlice = function ExtSlice(/* {asdl_seq *} */ dims)\n{\n    this.dims = dims;\n    return this;\n}\n\n/** @constructor */\nSk.astnodes.Index = function Index(/* {expr_ty} */ value)\n{\n    this.value = value;\n    return this;\n}\n\n/** @constructor */\nSk.astnodes.comprehension = function comprehension(/* {expr_ty} */ target, /*\n                                                        {expr_ty} */ iter, /*\n                                                        {asdl_seq *} */ ifs, /*\n                                                        {int} */ is_async)\n{\n    this.target = target;\n    this.iter = iter;\n    this.ifs = ifs;\n    this.is_async = is_async;\n    return this;\n}\n\n/** @constructor */\nSk.astnodes.ExceptHandler = function ExceptHandler(/* {expr_ty} */ type, /*\n                                                        {identifier} */ name,\n                                                        /* {asdl_seq *} */\n                                                        body, /* {int} */\n                                                        lineno, /* {int} */\n                                                        col_offset)\n{\n    Sk.asserts.assert(lineno !== null && lineno !== undefined);\n    Sk.asserts.assert(col_offset !== null && col_offset !== undefined);\n    this.type = type;\n    this.name = name;\n    this.body = body;\n    this.lineno = lineno;\n    this.col_offset = col_offset;\n    return this;\n}\n\n/** @constructor */\nSk.astnodes.arguments_ = function arguments_(/* {asdl_seq *} */ args, /*\n                                                  {arg_ty} */ vararg, /*\n                                                  {asdl_seq *} */ kwonlyargs,\n                                                  /* {asdl_seq *} */\n                                                  kw_defaults, /* {arg_ty} */\n                                                  kwarg, /* {asdl_seq *} */\n                                                  defaults)\n{\n    this.args = args;\n    this.vararg = vararg;\n    this.kwonlyargs = kwonlyargs;\n    this.kw_defaults = kw_defaults;\n    this.kwarg = kwarg;\n    this.defaults = defaults;\n    return this;\n}\n\n/** @constructor */\nSk.astnodes.arg = function arg(/* {identifier} */ arg, /* {expr_ty} */\n                                    annotation)\n{\n    this.arg = arg;\n    this.annotation = annotation;\n    return this;\n}\n\n/** @constructor */\nSk.astnodes.keyword = function keyword(/* {identifier} */ arg, /* {expr_ty} */\n                                            value)\n{\n    this.arg = arg;\n    this.value = value;\n    return this;\n}\n\n/** @constructor */\nSk.astnodes.alias = function alias(/* {identifier} */ name, /* {identifier} */\n                                        asname)\n{\n    this.name = name;\n    this.asname = asname;\n    return this;\n}\n\n/** @constructor */\nSk.astnodes.withitem = function withitem(/* {expr_ty} */ context_expr, /*\n                                              {expr_ty} */ optional_vars)\n{\n    this.context_expr = context_expr;\n    this.optional_vars = optional_vars;\n    return this;\n}\n\n\nSk.astnodes.Module.prototype._astname = \"Module\";\nSk.astnodes.Module.prototype._fields = [\n    \"body\", function(n) { return n.body; },\n    \"docstring\", function(n) { return n.docstring; }\n];\nSk.astnodes.Interactive.prototype._astname = \"Interactive\";\nSk.astnodes.Interactive.prototype._fields = [\n    \"body\", function(n) { return n.body; }\n];\nSk.astnodes.Expression.prototype._astname = \"Expression\";\nSk.astnodes.Expression.prototype._fields = [\n    \"body\", function(n) { return n.body; }\n];\nSk.astnodes.Suite.prototype._astname = \"Suite\";\nSk.astnodes.Suite.prototype._fields = [\n    \"body\", function(n) { return n.body; }\n];\nSk.astnodes.FunctionDef.prototype._astname = \"FunctionDef\";\nSk.astnodes.FunctionDef.prototype._fields = [\n    \"name\", function(n) { return n.name; },\n    \"args\", function(n) { return n.args; },\n    \"body\", function(n) { return n.body; },\n    \"decorator_list\", function(n) { return n.decorator_list; },\n    \"returns\", function(n) { return n.returns; },\n    \"docstring\", function(n) { return n.docstring; }\n];\nSk.astnodes.AsyncFunctionDef.prototype._astname = \"AsyncFunctionDef\";\nSk.astnodes.AsyncFunctionDef.prototype._fields = [\n    \"name\", function(n) { return n.name; },\n    \"args\", function(n) { return n.args; },\n    \"body\", function(n) { return n.body; },\n    \"decorator_list\", function(n) { return n.decorator_list; },\n    \"returns\", function(n) { return n.returns; },\n    \"docstring\", function(n) { return n.docstring; }\n];\nSk.astnodes.ClassDef.prototype._astname = \"ClassDef\";\nSk.astnodes.ClassDef.prototype._fields = [\n    \"name\", function(n) { return n.name; },\n    \"bases\", function(n) { return n.bases; },\n    \"keywords\", function(n) { return n.keywords; },\n    \"body\", function(n) { return n.body; },\n    \"decorator_list\", function(n) { return n.decorator_list; },\n    \"docstring\", function(n) { return n.docstring; }\n];\nSk.astnodes.Return.prototype._astname = \"Return\";\nSk.astnodes.Return.prototype._fields = [\n    \"value\", function(n) { return n.value; }\n];\nSk.astnodes.Delete.prototype._astname = \"Delete\";\nSk.astnodes.Delete.prototype._fields = [\n    \"targets\", function(n) { return n.targets; }\n];\nSk.astnodes.Assign.prototype._astname = \"Assign\";\nSk.astnodes.Assign.prototype._fields = [\n    \"targets\", function(n) { return n.targets; },\n    \"value\", function(n) { return n.value; }\n];\nSk.astnodes.AugAssign.prototype._astname = \"AugAssign\";\nSk.astnodes.AugAssign.prototype._fields = [\n    \"target\", function(n) { return n.target; },\n    \"op\", function(n) { return n.op; },\n    \"value\", function(n) { return n.value; }\n];\nSk.astnodes.AnnAssign.prototype._astname = \"AnnAssign\";\nSk.astnodes.AnnAssign.prototype._fields = [\n    \"target\", function(n) { return n.target; },\n    \"annotation\", function(n) { return n.annotation; },\n    \"value\", function(n) { return n.value; },\n    \"simple\", function(n) { return n.simple; }\n];\nSk.astnodes.For.prototype._astname = \"For\";\nSk.astnodes.For.prototype._fields = [\n    \"target\", function(n) { return n.target; },\n    \"iter\", function(n) { return n.iter; },\n    \"body\", function(n) { return n.body; },\n    \"orelse\", function(n) { return n.orelse; }\n];\nSk.astnodes.AsyncFor.prototype._astname = \"AsyncFor\";\nSk.astnodes.AsyncFor.prototype._fields = [\n    \"target\", function(n) { return n.target; },\n    \"iter\", function(n) { return n.iter; },\n    \"body\", function(n) { return n.body; },\n    \"orelse\", function(n) { return n.orelse; }\n];\nSk.astnodes.While.prototype._astname = \"While\";\nSk.astnodes.While.prototype._fields = [\n    \"test\", function(n) { return n.test; },\n    \"body\", function(n) { return n.body; },\n    \"orelse\", function(n) { return n.orelse; }\n];\nSk.astnodes.If.prototype._astname = \"If\";\nSk.astnodes.If.prototype._fields = [\n    \"test\", function(n) { return n.test; },\n    \"body\", function(n) { return n.body; },\n    \"orelse\", function(n) { return n.orelse; }\n];\nSk.astnodes.With.prototype._astname = \"With\";\nSk.astnodes.With.prototype._fields = [\n    \"items\", function(n) { return n.items; },\n    \"body\", function(n) { return n.body; }\n];\nSk.astnodes.AsyncWith.prototype._astname = \"AsyncWith\";\nSk.astnodes.AsyncWith.prototype._fields = [\n    \"items\", function(n) { return n.items; },\n    \"body\", function(n) { return n.body; }\n];\nSk.astnodes.Raise.prototype._astname = \"Raise\";\nSk.astnodes.Raise.prototype._fields = [\n    \"exc\", function(n) { return n.exc; },\n    \"cause\", function(n) { return n.cause; },\n    \"inst\", function(n) { return n.inst; },\n    \"tback\", function(n) { return n.tback; }\n];\nSk.astnodes.Try.prototype._astname = \"Try\";\nSk.astnodes.Try.prototype._fields = [\n    \"body\", function(n) { return n.body; },\n    \"handlers\", function(n) { return n.handlers; },\n    \"orelse\", function(n) { return n.orelse; },\n    \"finalbody\", function(n) { return n.finalbody; }\n];\nSk.astnodes.Assert.prototype._astname = \"Assert\";\nSk.astnodes.Assert.prototype._fields = [\n    \"test\", function(n) { return n.test; },\n    \"msg\", function(n) { return n.msg; }\n];\nSk.astnodes.Import.prototype._astname = \"Import\";\nSk.astnodes.Import.prototype._fields = [\n    \"names\", function(n) { return n.names; }\n];\nSk.astnodes.ImportFrom.prototype._astname = \"ImportFrom\";\nSk.astnodes.ImportFrom.prototype._fields = [\n    \"module\", function(n) { return n.module; },\n    \"names\", function(n) { return n.names; },\n    \"level\", function(n) { return n.level; }\n];\nSk.astnodes.Global.prototype._astname = \"Global\";\nSk.astnodes.Global.prototype._fields = [\n    \"names\", function(n) { return n.names; }\n];\nSk.astnodes.Nonlocal.prototype._astname = \"Nonlocal\";\nSk.astnodes.Nonlocal.prototype._fields = [\n    \"names\", function(n) { return n.names; }\n];\nSk.astnodes.Expr.prototype._astname = \"Expr\";\nSk.astnodes.Expr.prototype._fields = [\n    \"value\", function(n) { return n.value; }\n];\nSk.astnodes.Pass.prototype._astname = \"Pass\";\nSk.astnodes.Pass.prototype._fields = [\n];\nSk.astnodes.Break.prototype._astname = \"Break\";\nSk.astnodes.Break.prototype._fields = [\n];\nSk.astnodes.Continue.prototype._astname = \"Continue\";\nSk.astnodes.Continue.prototype._fields = [\n];\nSk.astnodes.Print.prototype._astname = \"Print\";\nSk.astnodes.Print.prototype._fields = [\n    \"dest\", function(n) { return n.dest; },\n    \"values\", function(n) { return n.values; },\n    \"nl\", function(n) { return n.nl; }\n];\nSk.astnodes.Debugger.prototype._astname = \"Debugger\";\nSk.astnodes.Debugger.prototype._fields = [\n];\nSk.astnodes.BoolOp.prototype._astname = \"BoolOp\";\nSk.astnodes.BoolOp.prototype._fields = [\n    \"op\", function(n) { return n.op; },\n    \"values\", function(n) { return n.values; }\n];\nSk.astnodes.BinOp.prototype._astname = \"BinOp\";\nSk.astnodes.BinOp.prototype._fields = [\n    \"left\", function(n) { return n.left; },\n    \"op\", function(n) { return n.op; },\n    \"right\", function(n) { return n.right; }\n];\nSk.astnodes.UnaryOp.prototype._astname = \"UnaryOp\";\nSk.astnodes.UnaryOp.prototype._fields = [\n    \"op\", function(n) { return n.op; },\n    \"operand\", function(n) { return n.operand; }\n];\nSk.astnodes.Lambda.prototype._astname = \"Lambda\";\nSk.astnodes.Lambda.prototype._fields = [\n    \"args\", function(n) { return n.args; },\n    \"body\", function(n) { return n.body; }\n];\nSk.astnodes.IfExp.prototype._astname = \"IfExp\";\nSk.astnodes.IfExp.prototype._fields = [\n    \"test\", function(n) { return n.test; },\n    \"body\", function(n) { return n.body; },\n    \"orelse\", function(n) { return n.orelse; }\n];\nSk.astnodes.Dict.prototype._astname = \"Dict\";\nSk.astnodes.Dict.prototype._fields = [\n    \"keys\", function(n) { return n.keys; },\n    \"values\", function(n) { return n.values; }\n];\nSk.astnodes.Set.prototype._astname = \"Set\";\nSk.astnodes.Set.prototype._fields = [\n    \"elts\", function(n) { return n.elts; }\n];\nSk.astnodes.ListComp.prototype._astname = \"ListComp\";\nSk.astnodes.ListComp.prototype._fields = [\n    \"elt\", function(n) { return n.elt; },\n    \"generators\", function(n) { return n.generators; }\n];\nSk.astnodes.SetComp.prototype._astname = \"SetComp\";\nSk.astnodes.SetComp.prototype._fields = [\n    \"elt\", function(n) { return n.elt; },\n    \"generators\", function(n) { return n.generators; }\n];\nSk.astnodes.DictComp.prototype._astname = \"DictComp\";\nSk.astnodes.DictComp.prototype._fields = [\n    \"key\", function(n) { return n.key; },\n    \"value\", function(n) { return n.value; },\n    \"generators\", function(n) { return n.generators; }\n];\nSk.astnodes.GeneratorExp.prototype._astname = \"GeneratorExp\";\nSk.astnodes.GeneratorExp.prototype._fields = [\n    \"elt\", function(n) { return n.elt; },\n    \"generators\", function(n) { return n.generators; }\n];\nSk.astnodes.Await.prototype._astname = \"Await\";\nSk.astnodes.Await.prototype._fields = [\n    \"value\", function(n) { return n.value; }\n];\nSk.astnodes.Yield.prototype._astname = \"Yield\";\nSk.astnodes.Yield.prototype._fields = [\n    \"value\", function(n) { return n.value; }\n];\nSk.astnodes.YieldFrom.prototype._astname = \"YieldFrom\";\nSk.astnodes.YieldFrom.prototype._fields = [\n    \"value\", function(n) { return n.value; }\n];\nSk.astnodes.Compare.prototype._astname = \"Compare\";\nSk.astnodes.Compare.prototype._fields = [\n    \"left\", function(n) { return n.left; },\n    \"ops\", function(n) { return n.ops; },\n    \"comparators\", function(n) { return n.comparators; }\n];\nSk.astnodes.Call.prototype._astname = \"Call\";\nSk.astnodes.Call.prototype._fields = [\n    \"func\", function(n) { return n.func; },\n    \"args\", function(n) { return n.args; },\n    \"keywords\", function(n) { return n.keywords; }\n];\nSk.astnodes.Num.prototype._astname = \"Num\";\nSk.astnodes.Num.prototype._fields = [\n    \"n\", function(n) { return n.n; }\n];\nSk.astnodes.Str.prototype._astname = \"Str\";\nSk.astnodes.Str.prototype._fields = [\n    \"s\", function(n) { return n.s; }\n];\nSk.astnodes.FormattedValue.prototype._astname = \"FormattedValue\";\nSk.astnodes.FormattedValue.prototype._fields = [\n    \"value\", function(n) { return n.value; },\n    \"conversion\", function(n) { return n.conversion; },\n    \"format_spec\", function(n) { return n.format_spec; }\n];\nSk.astnodes.JoinedStr.prototype._astname = \"JoinedStr\";\nSk.astnodes.JoinedStr.prototype._fields = [\n    \"values\", function(n) { return n.values; }\n];\nSk.astnodes.Bytes.prototype._astname = \"Bytes\";\nSk.astnodes.Bytes.prototype._fields = [\n    \"s\", function(n) { return n.s; }\n];\nSk.astnodes.NameConstant.prototype._astname = \"NameConstant\";\nSk.astnodes.NameConstant.prototype._fields = [\n    \"value\", function(n) { return n.value; }\n];\nSk.astnodes.Ellipsis.prototype._astname = \"Ellipsis\";\nSk.astnodes.Ellipsis.prototype._fields = [\n];\nSk.astnodes.Constant.prototype._astname = \"Constant\";\nSk.astnodes.Constant.prototype._fields = [\n    \"value\", function(n) { return n.value; }\n];\nSk.astnodes.Attribute.prototype._astname = \"Attribute\";\nSk.astnodes.Attribute.prototype._fields = [\n    \"value\", function(n) { return n.value; },\n    \"attr\", function(n) { return n.attr; },\n    \"ctx\", function(n) { return n.ctx; }\n];\nSk.astnodes.Subscript.prototype._astname = \"Subscript\";\nSk.astnodes.Subscript.prototype._fields = [\n    \"value\", function(n) { return n.value; },\n    \"slice\", function(n) { return n.slice; },\n    \"ctx\", function(n) { return n.ctx; }\n];\nSk.astnodes.Starred.prototype._astname = \"Starred\";\nSk.astnodes.Starred.prototype._fields = [\n    \"value\", function(n) { return n.value; },\n    \"ctx\", function(n) { return n.ctx; }\n];\nSk.astnodes.Name.prototype._astname = \"Name\";\nSk.astnodes.Name.prototype._fields = [\n    \"id\", function(n) { return n.id; },\n    \"ctx\", function(n) { return n.ctx; }\n];\nSk.astnodes.List.prototype._astname = \"List\";\nSk.astnodes.List.prototype._fields = [\n    \"elts\", function(n) { return n.elts; },\n    \"ctx\", function(n) { return n.ctx; }\n];\nSk.astnodes.Tuple.prototype._astname = \"Tuple\";\nSk.astnodes.Tuple.prototype._fields = [\n    \"elts\", function(n) { return n.elts; },\n    \"ctx\", function(n) { return n.ctx; }\n];\nSk.astnodes.Load.prototype._astname = \"Load\";\nSk.astnodes.Load.prototype._isenum = true;\nSk.astnodes.Store.prototype._astname = \"Store\";\nSk.astnodes.Store.prototype._isenum = true;\nSk.astnodes.Del.prototype._astname = \"Del\";\nSk.astnodes.Del.prototype._isenum = true;\nSk.astnodes.AugLoad.prototype._astname = \"AugLoad\";\nSk.astnodes.AugLoad.prototype._isenum = true;\nSk.astnodes.AugStore.prototype._astname = \"AugStore\";\nSk.astnodes.AugStore.prototype._isenum = true;\nSk.astnodes.Param.prototype._astname = \"Param\";\nSk.astnodes.Param.prototype._isenum = true;\nSk.astnodes.Slice.prototype._astname = \"Slice\";\nSk.astnodes.Slice.prototype._fields = [\n    \"lower\", function(n) { return n.lower; },\n    \"upper\", function(n) { return n.upper; },\n    \"step\", function(n) { return n.step; }\n];\nSk.astnodes.ExtSlice.prototype._astname = \"ExtSlice\";\nSk.astnodes.ExtSlice.prototype._fields = [\n    \"dims\", function(n) { return n.dims; }\n];\nSk.astnodes.Index.prototype._astname = \"Index\";\nSk.astnodes.Index.prototype._fields = [\n    \"value\", function(n) { return n.value; }\n];\nSk.astnodes.And.prototype._astname = \"And\";\nSk.astnodes.And.prototype._isenum = true;\nSk.astnodes.Or.prototype._astname = \"Or\";\nSk.astnodes.Or.prototype._isenum = true;\nSk.astnodes.Add.prototype._astname = \"Add\";\nSk.astnodes.Add.prototype._isenum = true;\nSk.astnodes.Sub.prototype._astname = \"Sub\";\nSk.astnodes.Sub.prototype._isenum = true;\nSk.astnodes.Mult.prototype._astname = \"Mult\";\nSk.astnodes.Mult.prototype._isenum = true;\nSk.astnodes.MatMult.prototype._astname = \"MatMult\";\nSk.astnodes.MatMult.prototype._isenum = true;\nSk.astnodes.Div.prototype._astname = \"Div\";\nSk.astnodes.Div.prototype._isenum = true;\nSk.astnodes.Mod.prototype._astname = \"Mod\";\nSk.astnodes.Mod.prototype._isenum = true;\nSk.astnodes.Pow.prototype._astname = \"Pow\";\nSk.astnodes.Pow.prototype._isenum = true;\nSk.astnodes.LShift.prototype._astname = \"LShift\";\nSk.astnodes.LShift.prototype._isenum = true;\nSk.astnodes.RShift.prototype._astname = \"RShift\";\nSk.astnodes.RShift.prototype._isenum = true;\nSk.astnodes.BitOr.prototype._astname = \"BitOr\";\nSk.astnodes.BitOr.prototype._isenum = true;\nSk.astnodes.BitXor.prototype._astname = \"BitXor\";\nSk.astnodes.BitXor.prototype._isenum = true;\nSk.astnodes.BitAnd.prototype._astname = \"BitAnd\";\nSk.astnodes.BitAnd.prototype._isenum = true;\nSk.astnodes.FloorDiv.prototype._astname = \"FloorDiv\";\nSk.astnodes.FloorDiv.prototype._isenum = true;\nSk.astnodes.Invert.prototype._astname = \"Invert\";\nSk.astnodes.Invert.prototype._isenum = true;\nSk.astnodes.Not.prototype._astname = \"Not\";\nSk.astnodes.Not.prototype._isenum = true;\nSk.astnodes.UAdd.prototype._astname = \"UAdd\";\nSk.astnodes.UAdd.prototype._isenum = true;\nSk.astnodes.USub.prototype._astname = \"USub\";\nSk.astnodes.USub.prototype._isenum = true;\nSk.astnodes.Eq.prototype._astname = \"Eq\";\nSk.astnodes.Eq.prototype._isenum = true;\nSk.astnodes.NotEq.prototype._astname = \"NotEq\";\nSk.astnodes.NotEq.prototype._isenum = true;\nSk.astnodes.Lt.prototype._astname = \"Lt\";\nSk.astnodes.Lt.prototype._isenum = true;\nSk.astnodes.LtE.prototype._astname = \"LtE\";\nSk.astnodes.LtE.prototype._isenum = true;\nSk.astnodes.Gt.prototype._astname = \"Gt\";\nSk.astnodes.Gt.prototype._isenum = true;\nSk.astnodes.GtE.prototype._astname = \"GtE\";\nSk.astnodes.GtE.prototype._isenum = true;\nSk.astnodes.Is.prototype._astname = \"Is\";\nSk.astnodes.Is.prototype._isenum = true;\nSk.astnodes.IsNot.prototype._astname = \"IsNot\";\nSk.astnodes.IsNot.prototype._isenum = true;\nSk.astnodes.In.prototype._astname = \"In\";\nSk.astnodes.In.prototype._isenum = true;\nSk.astnodes.NotIn.prototype._astname = \"NotIn\";\nSk.astnodes.NotIn.prototype._isenum = true;\nSk.astnodes.comprehension.prototype._astname = \"comprehension\";\nSk.astnodes.comprehension.prototype._fields = [\n    \"target\", function(n) { return n.target; },\n    \"iter\", function(n) { return n.iter; },\n    \"ifs\", function(n) { return n.ifs; },\n    \"is_async\", function(n) { return n.is_async; }\n];\nSk.astnodes.ExceptHandler.prototype._astname = \"ExceptHandler\";\nSk.astnodes.ExceptHandler.prototype._fields = [\n    \"type\", function(n) { return n.type; },\n    \"name\", function(n) { return n.name; },\n    \"body\", function(n) { return n.body; }\n];\nSk.astnodes.arguments_.prototype._astname = \"arguments\";\nSk.astnodes.arguments_.prototype._fields = [\n    \"args\", function(n) { return n.args; },\n    \"vararg\", function(n) { return n.vararg; },\n    \"kwonlyargs\", function(n) { return n.kwonlyargs; },\n    \"kw_defaults\", function(n) { return n.kw_defaults; },\n    \"kwarg\", function(n) { return n.kwarg; },\n    \"defaults\", function(n) { return n.defaults; }\n];\nSk.astnodes.arg.prototype._astname = \"arg\";\nSk.astnodes.arg.prototype._fields = [\n    \"arg\", function(n) { return n.arg; },\n    \"annotation\", function(n) { return n.annotation; }\n];\nSk.astnodes.keyword.prototype._astname = \"keyword\";\nSk.astnodes.keyword.prototype._fields = [\n    \"arg\", function(n) { return n.arg; },\n    \"value\", function(n) { return n.value; }\n];\nSk.astnodes.alias.prototype._astname = \"alias\";\nSk.astnodes.alias.prototype._fields = [\n    \"name\", function(n) { return n.name; },\n    \"asname\", function(n) { return n.asname; }\n];\nSk.astnodes.withitem.prototype._astname = \"withitem\";\nSk.astnodes.withitem.prototype._fields = [\n    \"context_expr\", function(n) { return n.context_expr; },\n    \"optional_vars\", function(n) { return n.optional_vars; }\n];\n\nSk.exportSymbol(\"Sk.astnodes\", Sk.astnodes);\n","//\n// This is pretty much a straight port of ast.c from CPython 3.7.3\n// (with a few leftovers from 2.6.5).\n//\n// The previous version was easier to work with and more JS-ish, but having a\n// somewhat different ast structure than cpython makes testing more difficult.\n//\n// This way, we can use a dump from the ast module on any arbitrary python\n// code and know that we're the same up to ast level, at least.\n//\n\nvar SYM = Sk.ParseTables.sym;\nvar TOK = Sk.token.tokens;\nvar COMP_GENEXP = 0;\nvar COMP_LISTCOMP = 1;\nvar COMP_SETCOMP = 2;\nvar NULL = null;\nvar _slice_kind = { \n    Slice_kind: 1,\n    ExtSlice_kind: 2, \n    Index_kind: 3\n};\n\nvar _expr_kind = {\n    BoolOp_kind: 1, NamedExpr_kind: 2, BinOp_kind: 3, UnaryOp_kind: 4,\n    Lambda_kind: 5, IfExp_kind: 6, Dict_kind: 7, Set_kind: 8,\n    ListComp_kind: 9, SetComp_kind: 10, DictComp_kind: 11,\n    GeneratorExp_kind: 12, Await_kind: 13, Yield_kind: 14,\n    YieldFrom_kind: 15, Compare_kind: 16, Call_kind: 17,\n    FormattedValue_kind: 18, JoinedStr_kind: 19, Constant_kind: 20,\n    Attribute_kind: 21, Subscript_kind: 22, Starred_kind: 23,\n    Name_kind: 24, List_kind: 25, Tuple_kind: 26 };\n\n/** @constructor */\nfunction Compiling (encoding, filename, c_flags) {\n    this.c_encoding = encoding;\n    this.c_filename = filename;\n    this.c_flags = c_flags || 0;\n}\n\n/**\n * @return {number}\n */\nfunction NCH (n) {\n    Sk.asserts.assert(n !== undefined, \"node must be defined\");\n    if (n.children === null) {\n        return 0;\n    }\n    return n.children.length;\n}\n\nfunction CHILD (n, i) {\n    Sk.asserts.assert(n !== undefined, \"node must be defined\");\n    Sk.asserts.assert(i !== undefined, \"index of child must be specified\");\n    return n.children[i];\n}\n\nfunction REQ (n, type) {\n    Sk.asserts.assert(n.type === type, \"node wasn't expected type\");\n}\n\nfunction TYPE(n) {\n    return n.type;\n}\n\nfunction LINENO(n) {\n    return n.lineno;\n}\n\nfunction STR(ch) {\n    return ch.value;\n}\n\nfunction ast_error(c, n, msg) {\n    throw new Sk.builtin.SyntaxError(msg, c.c_filename, n.lineno);\n}\n\nfunction strobj (s) {\n    Sk.asserts.assert(typeof s === \"string\", \"expecting string, got \" + (typeof s));\n    return new Sk.builtin.str(s);\n}\n\n/** @return {number} */\nfunction numStmts (n) {\n    var ch;\n    var i;\n    var cnt;\n    switch (n.type) {\n        case SYM.single_input:\n            if (CHILD(n, 0).type === TOK.T_NEWLINE) {\n                return 0;\n            }\n            else {\n                return numStmts(CHILD(n, 0));\n            }\n        case SYM.file_input:\n            cnt = 0;\n            for (i = 0; i < NCH(n); ++i) {\n                ch = CHILD(n, i);\n                if (ch.type === SYM.stmt) {\n                    cnt += numStmts(ch);\n                }\n            }\n            return cnt;\n        case SYM.stmt:\n            return numStmts(CHILD(n, 0));\n        case SYM.compound_stmt:\n            return 1;\n        case SYM.simple_stmt:\n            return Math.floor(NCH(n) / 2); // div 2 is to remove count of ;s\n        case SYM.suite:\n            if (NCH(n) === 1) {\n                return numStmts(CHILD(n, 0));\n            }\n            else {\n                cnt = 0;\n                for (i = 2; i < NCH(n) - 1; ++i) {\n                    cnt += numStmts(CHILD(n, i));\n                }\n                return cnt;\n            }\n            break;\n        default:\n            Sk.asserts.fail(\"Non-statement found\");\n    }\n    return 0;\n}\n\nfunction forbiddenCheck (c, n, x, lineno) {\n    if (x instanceof Sk.builtin.str) {\n        x = x.v;\n    }\n    if (x === \"None\") {\n        throw new Sk.builtin.SyntaxError(\"assignment to None\", c.c_filename, lineno);\n    }\n    if (x === \"True\" || x === \"False\") {\n        throw new Sk.builtin.SyntaxError(\"assignment to True or False is forbidden\", c.c_filename, lineno);\n    }\n}\n\n/**\n * Set the context ctx for e, recursively traversing e.\n *\n * Only sets context for expr kinds that can appear in assignment context as\n * per the asdl file.\n */\nfunction setContext (c, e, ctx, n) {\n    var i;\n    var exprName;\n    var s;\n    Sk.asserts.assert(ctx !== Sk.astnodes.AugStore && ctx !== Sk.astnodes.AugLoad, \"context not AugStore or AugLoad\");\n    s = null;\n    exprName = null;\n\n    switch (e.constructor) {\n        case Sk.astnodes.Attribute:\n        case Sk.astnodes.Name:\n            if (ctx === Sk.astnodes.Store) {\n                forbiddenCheck(c, n, e.attr, n.lineno);\n            }\n            e.ctx = ctx;\n            break;\n        case Sk.astnodes.Subscript:\n            e.ctx = ctx;\n            break;\n        case Sk.astnodes.List:\n            e.ctx = ctx;\n            s = e.elts;\n            break;\n        case Sk.astnodes.Tuple:\n            if (e.elts.length === 0) {\n                throw new Sk.builtin.SyntaxError(\"can't assign to ()\", c.c_filename, n.lineno);\n            }\n            e.ctx = ctx;\n            s = e.elts;\n            break;\n        case Sk.astnodes.Lambda:\n            exprName = \"lambda\";\n            break;\n        case Sk.astnodes.Call:\n            exprName = \"function call\";\n            break;\n        case Sk.astnodes.BoolOp:\n        case Sk.astnodes.BinOp:\n        case Sk.astnodes.UnaryOp:\n            exprName = \"operator\";\n            break;\n        case Sk.astnodes.GeneratorExp:\n            exprName = \"generator expression\";\n            break;\n        case Sk.astnodes.Yield:\n            exprName = \"yield expression\";\n            break;\n        case Sk.astnodes.ListComp:\n            exprName = \"list comprehension\";\n            break;\n        case Sk.astnodes.SetComp:\n            exprName = \"set comprehension\";\n            break;\n        case Sk.astnodes.DictComp:\n            exprName = \"dict comprehension\";\n            break;\n        case Sk.astnodes.Dict:\n        case Sk.astnodes.Set:\n        case Sk.astnodes.Num:\n        case Sk.astnodes.Str:\n            exprName = \"literal\";\n            break;\n        case Sk.astnodes.NameConstant:\n            exprName = \"True, False or None\";\n            break;\n        case Sk.astnodes.Compare:\n            exprName = \"comparison\";\n            break;\n        case Sk.astnodes.Repr:\n            exprName = \"repr\";\n            break;\n        case Sk.astnodes.IfExp:\n            exprName = \"conditional expression\";\n            break;\n        default:\n            Sk.asserts.fail(\"unhandled expression in assignment\");\n    }\n    if (exprName) {\n        throw new Sk.builtin.SyntaxError(\"can't \" + (ctx === Sk.astnodes.Store ? \"assign to\" : \"delete\") + \" \" + exprName, c.c_filename, n.lineno);\n    }\n\n    if (s) {\n        for (i = 0; i < s.length; ++i) {\n            setContext(c, s[i], ctx, n);\n        }\n    }\n}\n\nvar operatorMap = {};\n(function () {\n    operatorMap[TOK.T_VBAR] = Sk.astnodes.BitOr;\n    operatorMap[TOK.T_CIRCUMFLEX] = Sk.astnodes.BitXor;\n    operatorMap[TOK.T_AMPER] = Sk.astnodes.BitAnd;\n    operatorMap[TOK.T_LEFTSHIFT] = Sk.astnodes.LShift;\n    operatorMap[TOK.T_RIGHTSHIFT] = Sk.astnodes.RShift;\n    operatorMap[TOK.T_PLUS] = Sk.astnodes.Add;\n    operatorMap[TOK.T_MINUS] = Sk.astnodes.Sub;\n    operatorMap[TOK.T_STAR] = Sk.astnodes.Mult;\n    operatorMap[TOK.T_SLASH] = Sk.astnodes.Div;\n    operatorMap[TOK.T_DOUBLESLASH] = Sk.astnodes.FloorDiv;\n    operatorMap[TOK.T_PERCENT] = Sk.astnodes.Mod;\n}());\n\nfunction getOperator (n) {\n    Sk.asserts.assert(operatorMap[n.type] !== undefined, \"Operator missing from operatorMap\");\n    return operatorMap[n.type];\n}\n\nfunction new_identifier(n, c) {\n    if (n.value) {\n        return Sk.builtin.str(n.value);\n    }\n\n    return Sk.builtin.str(n);\n}\n\nfunction astForCompOp (c, n) {\n    /* comp_op: '<'|'>'|'=='|'>='|'<='|'!='|'in'|'not' 'in'|'is'\n     |'is' 'not'\n     */\n    REQ(n, SYM.comp_op);\n    if (NCH(n) === 1) {\n        n = CHILD(n, 0);\n        switch (n.type) {\n            case TOK.T_LESS:\n                return Sk.astnodes.Lt;\n            case TOK.T_GREATER:\n                return Sk.astnodes.Gt;\n            case TOK.T_EQEQUAL:\n                return Sk.astnodes.Eq;\n            case TOK.T_LESSEQUAL:\n                return Sk.astnodes.LtE;\n            case TOK.T_GREATEREQUAL:\n                return Sk.astnodes.GtE;\n            case TOK.T_NOTEQUAL:\n                return Sk.astnodes.NotEq;\n            case TOK.T_NAME:\n                if (n.value === \"in\") {\n                    return Sk.astnodes.In;\n                }\n                if (n.value === \"is\") {\n                    return Sk.astnodes.Is;\n                }\n        }\n    }\n    else if (NCH(n) === 2) {\n        if (CHILD(n, 0).type === TOK.T_NAME) {\n            if (CHILD(n, 1).value === \"in\") {\n                return Sk.astnodes.NotIn;\n            }\n            if (CHILD(n, 0).value === \"is\") {\n                return Sk.astnodes.IsNot;\n            }\n        }\n    }\n    Sk.asserts.fail(\"invalid comp_op\");\n}\n\nfunction copy_location(e, n)\n{\n    if (e) {\n        e.lineno = LINENO(n);\n        e.col_offset = n.col_offset;\n        e.end_lineno = n.end_lineno;\n        e.end_col_offset = n.end_col_offset;\n    }\n    return e;\n}\n\nfunction seq_for_testlist (c, n) {\n    /* testlist: test (',' test)* [',']\n       testlist_star_expr: test|star_expr (',' test|star_expr)* [',']\n    */\n    var i;\n    var seq = [];\n    Sk.asserts.assert(n.type === SYM.testlist ||\n        n.type === SYM.testlist_star_expr ||\n        n.type === SYM.listmaker ||\n        n.type === SYM.testlist_comp ||\n        n.type === SYM.testlist_safe ||\n        n.type === SYM.testlist1, \"node type must be listlike\");\n    for (i = 0; i < NCH(n); i += 2) {\n        Sk.asserts.assert(CHILD(n, i).type === SYM.test || CHILD(n, i).type === SYM.old_test || CHILD(n, i).type === SYM.star_expr);\n        seq[i / 2] = ast_for_expr(c, CHILD(n, i));\n    }\n    return seq;\n}\n\nfunction astForSuite (c, n) {\n    /* suite: simple_stmt | NEWLINE INDENT stmt+ DEDENT */\n    var j;\n    var num;\n    var i;\n    var end;\n    var ch;\n    var pos;\n    var seq;\n    REQ(n, SYM.suite);\n    seq = [];\n    pos = 0;\n    if (CHILD(n, 0).type === SYM.simple_stmt) {\n        n = CHILD(n, 0);\n        /* simple_stmt always ends with an NEWLINE and may have a trailing\n         * SEMI. */\n        end = NCH(n) - 1;\n        if (CHILD(n, end - 1).type === TOK.T_SEMI) {\n            end -= 1;\n        }\n        for (i = 0; i < end; i += 2) // by 2 to skip ;\n        {\n            seq[pos++] = astForStmt(c, CHILD(n, i));\n        }\n    }\n    else {\n        for (i = 2; i < NCH(n) - 1; ++i) {\n            ch = CHILD(n, i);\n            REQ(ch, SYM.stmt);\n            num = numStmts(ch);\n            if (num === 1) {\n                // small_stmt or compound_stmt w/ only 1 child\n                seq[pos++] = astForStmt(c, ch);\n            }\n            else {\n                ch = CHILD(ch, 0);\n                REQ(ch, SYM.simple_stmt);\n                for (j = 0; j < NCH(ch); j += 2) {\n                    if (NCH(CHILD(ch, j)) === 0) {\n                        Sk.asserts.assert(j + 1 === NCH(ch));\n                        break;\n                    }\n                    seq[pos++] = astForStmt(c, CHILD(ch, j));\n                }\n            }\n        }\n    }\n    Sk.asserts.assert(pos === numStmts(n));\n    return seq;\n}\n\nfunction astForExceptClause (c, exc, body) {\n    /* except_clause: 'except' [test [(',' | 'as') test]] */\n    var e;\n    REQ(exc, SYM.except_clause);\n    REQ(body, SYM.suite);\n    if (NCH(exc) === 1) {\n        return new Sk.astnodes.ExceptHandler(null, null, astForSuite(c, body), exc.lineno, exc.col_offset);\n    }\n    else if (NCH(exc) === 2) {\n        return new Sk.astnodes.ExceptHandler(ast_for_expr(c, CHILD(exc, 1)), null, astForSuite(c, body), exc.lineno, exc.col_offset);\n    }\n    else if (NCH(exc) === 4) {\n        var expression = ast_for_expr(c, CHILD(exc, 1));\n        e = ast_for_expr(c, CHILD(exc, 3));\n        setContext(c, e, Sk.astnodes.Store, CHILD(exc, 3));\n        return new Sk.astnodes.ExceptHandler(ast_for_expr(c, CHILD(exc, 1)), e, astForSuite(c, body), exc.lineno, exc.col_offset);\n    }\n    Sk.asserts.fail(\"wrong number of children for except clause\");\n}\n\nfunction astForTryStmt (c, n) {\n    var exceptSt;\n    var i;\n    var handlers = [];\n    var nc = NCH(n);\n    var nexcept = (nc - 3) / 3;\n    var body, orelse = [],\n        finally_ = null;\n\n    REQ(n, SYM.try_stmt);\n    body = astForSuite(c, CHILD(n, 2));\n    if (CHILD(n, nc - 3).type === TOK.T_NAME) {\n        if (CHILD(n, nc - 3).value === \"finally\") {\n            if (nc >= 9 && CHILD(n, nc - 6).type === TOK.T_NAME) {\n                /* we can assume it's an \"else\",\n                 because nc >= 9 for try-else-finally and\n                 it would otherwise have a type of except_clause */\n                orelse = astForSuite(c, CHILD(n, nc - 4));\n                nexcept--;\n            }\n\n            finally_ = astForSuite(c, CHILD(n, nc - 1));\n            nexcept--;\n        }\n        else {\n            /* we can assume it's an \"else\",\n             otherwise it would have a type of except_clause */\n            orelse = astForSuite(c, CHILD(n, nc - 1));\n            nexcept--;\n        }\n    }\n    else if (CHILD(n, nc - 3).type !== SYM.except_clause) {\n        throw new Sk.builtin.SyntaxError(\"malformed 'try' statement\", c.c_filename, n.lineno);\n    }\n\n    if (nexcept > 0) {\n        /* process except statements to create a try ... except */\n        for (i = 0; i < nexcept; i++) {\n            handlers[i] = astForExceptClause(c, CHILD(n, 3 + i * 3), CHILD(n, 5 + i * 3));\n        }\n    }\n\n    Sk.asserts.assert(!!finally_ || handlers.length != 0);\n    return new Sk.astnodes.Try(body, handlers, orelse, finally_, n.lineno, n.col_offset);\n}\n\nfunction astForDottedName (c, n) {\n    var i;\n    var e;\n    var id;\n    var col_offset;\n    var lineno;\n    REQ(n, SYM.dotted_name);\n    lineno = n.lineno;\n    col_offset = n.col_offset;\n    id = strobj(CHILD(n, 0).value);\n    e = new Sk.astnodes.Name(id, Sk.astnodes.Load, lineno, col_offset);\n    for (i = 2; i < NCH(n); i += 2) {\n        id = strobj(CHILD(n, i).value);\n        e = new Sk.astnodes.Attribute(e, id, Sk.astnodes.Load, lineno, col_offset);\n    }\n    return e;\n}\n\nfunction astForDecorator (c, n) {\n    /* decorator: '@' dotted_name [ '(' [arglist] ')' ] NEWLINE */\n    var nameExpr;\n    REQ(n, SYM.decorator);\n    REQ(CHILD(n, 0), TOK.T_AT);\n    REQ(CHILD(n, NCH(n) - 1), TOK.T_NEWLINE);\n    nameExpr = astForDottedName(c, CHILD(n, 1));\n    if (NCH(n) === 3) // no args\n    {\n        return nameExpr;\n    }\n    else if (NCH(n) === 5) // call with no args\n    {\n        return new Sk.astnodes.Call(nameExpr, [], [], null, null, n.lineno, n.col_offset);\n    }\n    else {\n        return ast_for_call(c, CHILD(n, 3), nameExpr);\n    }\n}\n\nfunction astForDecorators (c, n) {\n    var i;\n    var decoratorSeq;\n    REQ(n, SYM.decorators);\n    decoratorSeq = [];\n    for (i = 0; i < NCH(n); ++i) {\n        decoratorSeq[i] = astForDecorator(c, CHILD(n, i));\n    }\n    return decoratorSeq;\n}\n\nfunction ast_for_decorated (c, n) {\n    /* decorated: decorators (classdef | funcdef | async_funcdef) */\n    var thing = null;\n    var decorator_seq = null;\n\n    REQ(n, SYM.decorated);\n\n    decorator_seq = astForDecorators(c, CHILD(n, 0));\n    Sk.asserts.assert(TYPE(CHILD(n, 1)) == SYM.funcdef ||\n            TYPE(CHILD(n, 1)) == SYM.async_funcdef ||\n            TYPE(CHILD(n, 1)) == SYM.classdef);\n\n    if (TYPE(CHILD(n, 1)) == SYM.funcdef) {\n        thing = ast_for_funcdef(c, CHILD(n, 1), decorator_seq);\n    } else if (TYPE(CHILD(n, 1)) == SYM.classdef) {\n        thing = astForClassdef(c, CHILD(n, 1), decorator_seq);\n    } else if (TYPE(CHILD(n, 1)) == SYM.async_funcdef) {\n        thing = ast_for_async_funcdef(c, CHILD(n, 1), decorator_seq);\n    }\n    /* we count the decorators in when talking about the class' or\n        * function's line number */\n    if (thing) {\n        thing.lineno = LINENO(n);\n        thing.col_offset = n.col_offset;\n    }\n    return thing;\n}\n\n/* with_item: test ['as' expr] */\nfunction ast_for_with_item (c, n) {\n    var context_expr, optional_vars;\n    REQ(n, SYM.with_item);\n    context_expr = ast_for_expr(c, CHILD(n, 0));\n    if (NCH(n) == 3) {\n        optional_vars = ast_for_expr(c, CHILD(n, 2));\n        setContext(c, optional_vars, Sk.astnodes.Store, n);\n    }\n\n    return new Sk.astnodes.withitem(context_expr, optional_vars);\n}\n\n/* with_stmt: 'with' with_item (',' with_item)* ':' suite */\nfunction ast_for_with_stmt(c, n0, is_async) {\n    const n = is_async ? CHILD(n0, 1) : n0;\n    var i\n    var items = [], body;\n\n    REQ(n, SYM.with_stmt);\n\n    for (i = 1; i < NCH(n) - 2; i += 2) {\n        var item = ast_for_with_item(c, CHILD(n, i));\n        items[(i - 1) / 2] = item;\n    }\n\n    body = astForSuite(c, CHILD(n, NCH(n) - 1));\n\n    if (is_async) {\n        return new Sk.astnodes.AsyncWith(items, body, LINENO(n0), n0.col_offset);\n    } else {\n        return new Sk.astnodes.With(items, body, LINENO(n), n.col_offset);\n    }\n}\n\nfunction astForExecStmt (c, n) {\n    var expr1, globals = null, locals = null;\n    var nchildren = NCH(n);\n    Sk.asserts.assert(nchildren === 2 || nchildren === 4 || nchildren === 6);\n\n    /* exec_stmt: 'exec' expr ['in' test [',' test]] */\n    REQ(n, SYM.exec_stmt);\n    expr1 = ast_for_expr(c, CHILD(n, 1));\n    if (nchildren >= 4) {\n        globals = ast_for_expr(c, CHILD(n, 3));\n    }\n    if (nchildren === 6) {\n        locals = ast_for_expr(c, CHILD(n, 5));\n    }\n    return new Sk.astnodes.Exec(expr1, globals, locals, n.lineno, n.col_offset);\n}\n\nfunction astForIfStmt (c, n) {\n    /* if_stmt: 'if' test ':' suite ('elif' test ':' suite)*\n     ['else' ':' suite]\n     */\n    var off;\n    var i;\n    var orelse;\n    var hasElse;\n    var nElif;\n    var decider;\n    var s;\n    REQ(n, SYM.if_stmt);\n    if (NCH(n) === 4) {\n        return new Sk.astnodes.If(\n            ast_for_expr(c, CHILD(n, 1)),\n            astForSuite(c, CHILD(n, 3)),\n            [], n.lineno, n.col_offset);\n    }\n\n    s = CHILD(n, 4).value;\n    decider = s.charAt(2); // elSe or elIf\n    if (decider === \"s\") {\n        return new Sk.astnodes.If(\n            ast_for_expr(c, CHILD(n, 1)),\n            astForSuite(c, CHILD(n, 3)),\n            astForSuite(c, CHILD(n, 6)),\n            n.lineno, n.col_offset);\n    }\n    else if (decider === \"i\") {\n        nElif = NCH(n) - 4;\n        hasElse = false;\n        orelse = [];\n\n        /* must reference the child nElif+1 since 'else' token is third, not\n         * fourth child from the end. */\n        if (CHILD(n, nElif + 1).type === TOK.T_NAME &&\n            CHILD(n, nElif + 1).value.charAt(2) === \"s\") {\n            hasElse = true;\n            nElif -= 3;\n        }\n        nElif /= 4;\n\n        if (hasElse) {\n            orelse = [\n                new Sk.astnodes.If(\n                    ast_for_expr(c, CHILD(n, NCH(n) - 6)),\n                    astForSuite(c, CHILD(n, NCH(n) - 4)),\n                    astForSuite(c, CHILD(n, NCH(n) - 1)),\n                    CHILD(n, NCH(n) - 6).lineno,\n                    CHILD(n, NCH(n) - 6).col_offset)];\n            nElif--;\n        }\n\n        for (i = 0; i < nElif; ++i) {\n            off = 5 + (nElif - i - 1) * 4;\n            orelse = [\n                new Sk.astnodes.If(\n                    ast_for_expr(c, CHILD(n, off)),\n                    astForSuite(c, CHILD(n, off + 2)),\n                    orelse,\n                    CHILD(n, off).lineno,\n                    CHILD(n, off).col_offset)];\n        }\n        return new Sk.astnodes.If(\n            ast_for_expr(c, CHILD(n, 1)),\n            astForSuite(c, CHILD(n, 3)),\n            orelse, n.lineno, n.col_offset);\n    }\n\n    Sk.asserts.fail(\"unexpected token in 'if' statement\");\n}\n\nfunction ast_for_exprlist (c, n, context) {\n    var e;\n    var i;\n    var seq;\n    REQ(n, SYM.exprlist);\n    seq = [];\n    for (i = 0; i < NCH(n); i += 2) {\n        e = ast_for_expr(c, CHILD(n, i));\n        seq[i / 2] = e;\n        if (context) {\n            setContext(c, e, context, CHILD(n, i));\n        }\n    }\n    return seq;\n}\n\nfunction astForDelStmt (c, n) {\n    /* del_stmt: 'del' exprlist */\n    REQ(n, SYM.del_stmt);\n    return new Sk.astnodes.Delete(ast_for_exprlist(c, CHILD(n, 1), Sk.astnodes.Del), n.lineno, n.col_offset);\n}\n\nfunction astForGlobalStmt (c, n) {\n    /* global_stmt: 'global' NAME (',' NAME)* */\n    var i;\n    var s = [];\n    REQ(n, SYM.global_stmt);\n    for (i = 1; i < NCH(n); i += 2) {\n        s[(i - 1) / 2] = strobj(CHILD(n, i).value);\n    }\n    return new Sk.astnodes.Global(s, n.lineno, n.col_offset);\n}\n\nfunction astForAssertStmt (c, n) {\n    /* assert_stmt: 'assert' test [',' test] */\n    REQ(n, SYM.assert_stmt);\n    if (NCH(n) === 2) {\n        return new Sk.astnodes.Assert(ast_for_expr(c, CHILD(n, 1)), null, n.lineno, n.col_offset);\n    }\n    else if (NCH(n) === 4) {\n        return new Sk.astnodes.Assert(ast_for_expr(c, CHILD(n, 1)), ast_for_expr(c, CHILD(n, 3)), n.lineno, n.col_offset);\n    }\n    Sk.asserts.fail(\"improper number of parts to assert stmt\");\n}\n\nfunction aliasForImportName (c, n) {\n    /*\n     import_as_name: NAME ['as' NAME]\n     dotted_as_name: dotted_name ['as' NAME]\n     dotted_name: NAME ('.' NAME)*\n     */\n\n    var i;\n    var a;\n    var name;\n    var str;\n    loop: while (true) {\n        switch (n.type) {\n            case SYM.import_as_name:\n                str = null;\n                name = strobj(CHILD(n, 0).value);\n                if (NCH(n) === 3) {\n                    str = CHILD(n, 2).value;\n                }\n                return new Sk.astnodes.alias(name, str == null ? null : strobj(str));\n            case SYM.dotted_as_name:\n                if (NCH(n) === 1) {\n                    n = CHILD(n, 0);\n                    continue loop;\n                }\n                else {\n                    a = aliasForImportName(c, CHILD(n, 0));\n                    Sk.asserts.assert(!a.asname);\n                    a.asname = strobj(CHILD(n, 2).value);\n                    return a;\n                }\n                break;\n            case SYM.dotted_name:\n                if (NCH(n) === 1) {\n                    return new Sk.astnodes.alias(strobj(CHILD(n, 0).value), null);\n                }\n                else {\n                    // create a string of the form a.b.c\n                    str = \"\";\n                    for (i = 0; i < NCH(n); i += 2) {\n                        str += CHILD(n, i).value + \".\";\n                    }\n                    return new Sk.astnodes.alias(strobj(str.substr(0, str.length - 1)), null);\n                }\n                break;\n            case TOK.T_STAR:\n                return new Sk.astnodes.alias(strobj(\"*\"), null);\n            default:\n                throw new Sk.builtin.SyntaxError(\"unexpected import name\", c.c_filename, n.lineno);\n        }\n        break;\n    }\n}\n\nfunction astForImportStmt (c, n) {\n    /*\n     import_stmt: import_name | import_from\n     import_name: 'import' dotted_as_names\n     import_from: 'from' ('.'* dotted_name | '.') 'import'\n     ('*' | '(' import_as_names ')' | import_as_names)\n     */\n    var modname;\n    var idx;\n    var nchildren;\n    var ndots;\n    var mod;\n    var i;\n    var aliases;\n    var col_offset;\n    var lineno;\n    REQ(n, SYM.import_stmt);\n    lineno = n.lineno;\n    col_offset = n.col_offset;\n    n = CHILD(n, 0);\n    if (n.type === SYM.import_name) {\n        n = CHILD(n, 1);\n        REQ(n, SYM.dotted_as_names);\n        aliases = [];\n        for (i = 0; i < NCH(n); i += 2) {\n            aliases[i / 2] = aliasForImportName(c, CHILD(n, i));\n        }\n        return new Sk.astnodes.Import(aliases, lineno, col_offset);\n    }\n    else if (n.type === SYM.import_from) {\n        mod = null;\n        ndots = 0;\n\n        for (idx = 1; idx < NCH(n); ++idx) {\n            if (CHILD(n, idx).type === SYM.dotted_name) {\n                mod = aliasForImportName(c, CHILD(n, idx));\n                idx++;\n                break;\n            }\n            else if (CHILD(n, idx).type !== TOK.T_DOT) {\n                break;\n            }\n            ndots++;\n        }\n        ++idx; // skip the import keyword\n        switch (CHILD(n, idx).type) {\n            case TOK.T_STAR:\n                // from ... import\n                n = CHILD(n, idx);\n                nchildren = 1;\n                break;\n            case TOK.T_LPAR:\n                // from ... import (x, y, z)\n                n = CHILD(n, idx + 1);\n                nchildren = NCH(n);\n                break;\n            case SYM.import_as_names:\n                // from ... import x, y, z\n                n = CHILD(n, idx);\n                nchildren = NCH(n);\n                if (nchildren % 2 === 0) {\n                    throw new Sk.builtin.SyntaxError(\"trailing comma not allowed without surrounding parentheses\", c.c_filename, n.lineno);\n                }\n                break;\n            default:\n                throw new Sk.builtin.SyntaxError(\"Unexpected node-type in from-import\", c.c_filename, n.lineno);\n        }\n        aliases = [];\n        if (n.type === TOK.T_STAR) {\n            aliases[0] = aliasForImportName(c, n);\n        }\n        else {\n            for (i = 0; i < NCH(n); i += 2) {\n                aliases[i / 2] = aliasForImportName(c, CHILD(n, i));\n            }\n        }\n        modname = mod ? mod.name.v : \"\";\n        return new Sk.astnodes.ImportFrom(strobj(modname), aliases, ndots, lineno, col_offset);\n    }\n    throw new Sk.builtin.SyntaxError(\"unknown import statement\", c.c_filename, n.lineno);\n}\n\nfunction ast_for_testlistComp(c, n) {\n    /* testlist_comp: test ( comp_for | (',' test)* [','] ) */\n    /* argument: test [comp_for] */\n    Sk.asserts.assert(n.type === SYM.testlist_comp || n.type === SYM.argument);\n    if (NCH(n) > 1 && CHILD(n, 1).type === SYM.comp_for) {\n        return ast_for_gen_expr(c, n);\n    }\n    return ast_for_testlist(c, n);\n}\nfunction ast_for_genexp(c, n)\n{\n    Sk.asserts.assert(TYPE(n) == SYM.testlist_comp || TYPE(n) == SYM.argument);\n    return ast_for_itercomp(c, n, COMP_GENEXP);\n}\n\nfunction  ast_for_listcomp(c, n) {\n    Sk.asserts.assert(TYPE(n) == (SYM.testlist_comp));\n    return ast_for_itercomp(c, n, COMP_LISTCOMP);\n}\n\nfunction astForFactor (c, n) {\n    /* some random peephole thing that cpy does */\n    var expression;\n    var pnum;\n    var patom;\n    var ppower;\n    var pfactor;\n    if (CHILD(n, 0).type === TOK.T_MINUS && NCH(n) === 2) {\n        pfactor = CHILD(n, 1);\n        if (pfactor.type === SYM.factor && NCH(pfactor) === 1) {\n            ppower = CHILD(pfactor, 0);\n            if (ppower.type === SYM.power && NCH(ppower) === 1) {\n                patom = CHILD(ppower, 0);\n                if (patom.type === SYM.atom) {\n                    pnum = CHILD(patom, 0);\n                    if (pnum.type === TOK.T_NUMBER) {\n                        pnum.value = \"-\" + pnum.value;\n                        return ast_for_atom(c, patom);\n                    }\n                }\n            }\n        }\n    }\n\n    expression = ast_for_expr(c, CHILD(n, 1));\n    switch (CHILD(n, 0).type) {\n        case TOK.T_PLUS:\n            return new Sk.astnodes.UnaryOp(Sk.astnodes.UAdd, expression, n.lineno, n.col_offset);\n        case TOK.T_MINUS:\n            return new Sk.astnodes.UnaryOp(Sk.astnodes.USub, expression, n.lineno, n.col_offset);\n        case TOK.T_TILDE:\n            return new Sk.astnodes.UnaryOp(Sk.astnodes.Invert, expression, n.lineno, n.col_offset);\n    }\n\n    Sk.asserts.fail(\"unhandled factor\");\n}\n\nfunction astForForStmt (c, n) {\n    /* for_stmt: 'for' exprlist 'in' testlist ':' suite ['else' ':' suite] */\n    var target;\n    var _target;\n    var nodeTarget;\n    var seq = [];\n    REQ(n, SYM.for_stmt);\n    if (NCH(n) === 9) {\n        seq = astForSuite(c, CHILD(n, 8));\n    }\n    nodeTarget = CHILD(n, 1);\n    _target = ast_for_exprlist(c, nodeTarget, Sk.astnodes.Store);\n    if (NCH(nodeTarget) === 1) {\n        target = _target[0];\n    }\n    else {\n        target = new Sk.astnodes.Tuple(_target, Sk.astnodes.Store, n.lineno, n.col_offset);\n    }\n\n    return new Sk.astnodes.For(target,\n        ast_for_testlist(c, CHILD(n, 3)),\n        astForSuite(c, CHILD(n, 5)),\n        seq, n.lineno, n.col_offset);\n}\n\nfunction ast_for_call(c, n, func, allowgen)\n{\n    /*\n      arglist: argument (',' argument)*  [',']\n      argument: ( test [comp_for] | '*' test | test '=' test | '**' test )\n    */\n\n    var i, nargs, nkeywords;\n    var ndoublestars;\n    var args;\n    var keywords;\n\n    REQ(n, SYM.arglist);\n\n    nargs = 0;\n    nkeywords = 0;\n    for (i = 0; i < NCH(n); i++) {\n        var ch = CHILD(n, i);\n        if (TYPE(ch) == SYM.argument) {\n            if (NCH(ch) == 1) {\n                nargs++;\n            } else if (TYPE(CHILD(ch, 1)) == SYM.comp_for) {\n                nargs++;\n                if (!allowgen) {\n                    ast_error(c, ch, \"invalid syntax\");\n                }\n                if (NCH(n) > 1) {\n                    ast_error(c, ch, \"Generator expression must be parenthesized\");\n                }\n            } else if (TYPE(CHILD(ch, 0)) == TOK.T_STAR) {\n                nargs++;\n            } else {\n                /* TYPE(CHILD(ch, 0)) == DOUBLESTAR or keyword argument */\n                nkeywords++;\n            }\n        }\n    }\n\n    args = []\n    keywords = []\n\n    nargs = 0;  /* positional arguments + iterable argument unpackings */\n    nkeywords = 0;  /* keyword arguments + keyword argument unpackings */\n    ndoublestars = 0;  /* just keyword argument unpackings */\n    for (i = 0; i < NCH(n); i++) {\n        ch = CHILD(n, i);\n        if (TYPE(ch) == SYM.argument) {\n            var e;\n            var chch = CHILD(ch, 0);\n            if (NCH(ch) == 1) {\n                /* a positional argument */\n                if (nkeywords) {\n                    if (ndoublestars) {\n                        ast_error(c, chch,\n                                \"positional argument follows \" +\n                                \"keyword argument unpacking\");\n                    } else {\n                        ast_error(c, chch,\n                                \"positional argument follows \" +\n                                \"keyword argument\");\n                    }\n                }\n                e = ast_for_expr(c, chch);\n                if (!e) {\n                    return NULL;\n                }\n                args[nargs++] = e;\n            } else if (TYPE(chch) == TOK.T_STAR) {\n                /* an iterable argument unpacking */\n                var starred;\n                if (ndoublestars) {\n                    ast_error(c, chch,\n                            \"iterable argument unpacking follows \" +\n                            \"keyword argument unpacking\");\n                    return NULL;\n                }\n                e = ast_for_expr(c, CHILD(ch, 1));\n                if (!e) {\n                    return NULL;\n                }\n                starred = new Sk.astnodes.Starred(e, Sk.astnodes.Load, LINENO(chch),\n                        chch.col_offset);\n                args[nargs++] = starred;\n            } else if (TYPE(chch) == TOK.T_DOUBLESTAR) {\n                /* a keyword argument unpacking */\n                var kw;\n                i++;\n                e = ast_for_expr(c, CHILD(ch, 1));\n                if (!e) {\n                    return NULL;\n                }\n                kw = new Sk.astnodes.keyword(NULL, e);\n                keywords[nkeywords++] = kw;\n                ndoublestars++;\n            } else if (TYPE(CHILD(ch, 1)) == SYM.comp_for) {\n                /* the lone generator expression */\n                e = ast_for_genexp(c, ch);\n                if (!e) {\n                    return NULL;\n                }\n                args[nargs++] = e;\n            } else {\n                /* a keyword argument */\n                var kw;\n                var key, tmp;\n                var k;\n\n                /* chch is test, but must be an identifier? */\n                e = ast_for_expr(c, chch);\n                if (!e) {\n                    return NULL;\n                }\n                /* f(lambda x: x[0] = 3) ends up getting parsed with\n                 * LHS test = lambda x: x[0], and RHS test = 3.\n                 * SF bug 132313 points out that complaining about a keyword\n                 * then is very confusing.\n                 */\n                if (e.constructor === Sk.astnodes.Lambda) {\n                    ast_error(c, chch,\n                            \"lambda cannot contain assignment\");\n                    return NULL;\n                }\n                else if (e.constructor !== Sk.astnodes.Name) {\n                    ast_error(c, chch,\n                            \"keyword can't be an expression\");\n                    return NULL;\n                }\n                else if (forbiddenCheck(c, e.id, ch, 1)) {\n                    return NULL;\n                }\n                key = e.id;\n                for (k = 0; k < nkeywords; k++) {\n                    tmp = keywords[k].arg;\n                    if (tmp && tmp === key) {\n                        ast_error(c, chch,\n                                \"keyword argument repeated\");\n                        return NULL;\n                    }\n                }\n                e = ast_for_expr(c, CHILD(ch, 2));\n                if (!e)\n                    return NULL;\n                kw = new Sk.astnodes.keyword(key, e);\n                keywords[nkeywords++] = kw;\n            }\n        }\n    }\n\n    return new Sk.astnodes.Call(func, args, keywords, func.lineno, func.col_offset);\n}\n\nfunction ast_for_trailer(c, n, left_expr) {\n    /* trailer: '(' [arglist] ')' | '[' subscriptlist ']' | '.' NAME\n       subscriptlist: subscript (',' subscript)* [',']\n       subscript: '.' '.' '.' | test | [test] ':' [test] [sliceop]\n     */\n    REQ(n, SYM.trailer);\n    if (TYPE(CHILD(n, 0)) == TOK.T_LPAR) {\n        if (NCH(n) == 2)\n            return new Sk.astnodes.Call(left_expr, NULL, NULL, LINENO(n),\n                        n.col_offset);\n        else\n            return ast_for_call(c, CHILD(n, 1), left_expr, true);\n    }\n    else if (TYPE(CHILD(n, 0)) == TOK.T_DOT) {\n        var attr_id = new_identifier(CHILD(n, 1));\n        if (!attr_id)\n            return NULL;\n        return new Sk.astnodes.Attribute(left_expr, attr_id, Sk.astnodes.Load,\n                         LINENO(n), n.col_offset);\n    }\n    else {\n        REQ(CHILD(n, 0), TOK.T_LSQB);\n        REQ(CHILD(n, 2), TOK.T_RSQB);\n        n = CHILD(n, 1);\n        if (NCH(n) == 1) {\n            var slc = astForSlice(c, CHILD(n, 0));\n            if (!slc) {\n                return NULL;\n            }\n            return new Sk.astnodes.Subscript(left_expr, slc, Sk.astnodes.Load, LINENO(n), n.col_offset);\n        }\n        else {\n            /* The grammar is ambiguous here. The ambiguity is resolved\n               by treating the sequence as a tuple literal if there are\n               no slice features.\n            */\n            var j;\n            var slc;\n            var e;\n            var simple = 1;\n            var slices = [], elts;\n\n            for (j = 0; j < NCH(n); j += 2) {\n                slc = astForSlice(c, CHILD(n, j));\n                if (!slc) {\n                    return NULL;\n                }\n                if (slc.kind != _slice_kind.Index_kind) {\n                    simple = 0;\n                }\n                slices[j / 2] = slc;\n            }\n            if (!simple) {\n                return new Sk.astnodes.Subscript(left_expr, new Sk.astnodes.ExtSlice(slices),\n                                Sk.astnodes.Load, LINENO(n), n.col_offset);\n            }\n            /* extract Index values and put them in a Tuple */\n            elts = [];\n            for (j = 0; j < slices.length; ++j) {\n                // @meredydd any idea how we reach this?\n                slc = slices[j];\n                Sk.asserts.assert(slc.kind == _slice_kind.Index_kind  && slc.v.Index.value);\n                elts[j] = slc.v.Index.value;\n            }\n            e = new Sk.astnodes.Tuple(elts, Sk.astnodes.Load, LINENO(n), n.col_offset);\n\n            return new Sk.astnodes.Subscript(left_expr, new Sk.astnodes.Index(e),\n                             Sk.astnodes.Load, LINENO(n), n.col_offset);\n        }\n    }\n}\n\nfunction ast_for_flow_stmt(c, n)\n{\n    /*\n      flow_stmt: break_stmt | continue_stmt | return_stmt | raise_stmt\n                 | yield_stmt\n      break_stmt: 'break'\n      continue_stmt: 'continue'\n      return_stmt: 'return' [testlist]\n      yield_stmt: yield_expr\n      yield_expr: 'yield' testlist | 'yield' 'from' test\n      raise_stmt: 'raise' [test [',' test [',' test]]]\n    */\n    var ch;\n\n    REQ(n, SYM.flow_stmt);\n    ch = CHILD(n, 0);\n    switch (TYPE(ch)) {\n        case SYM.break_stmt:\n            return new Sk.astnodes.Break(LINENO(n), n.col_offset,\n                         n.end_lineno, n.end_col_offset);\n        case SYM.continue_stmt:\n            return new Sk.astnodes.Continue(LINENO(n), n.col_offset,\n                            n.end_lineno, n.end_col_offset);\n        case SYM.yield_stmt: { /* will reduce to yield_expr */\n            var exp = ast_for_expr(c, CHILD(ch, 0));\n            if (!exp) {\n                return null;\n            }\n            return new Sk.astnodes.Expr(exp, LINENO(n), n.col_offset,\n                        n.end_lineno, n.end_col_offset);\n        }\n        case SYM.return_stmt:\n            if (NCH(ch) == 1)\n                return new Sk.astnodes.Return(null, LINENO(n), n.col_offset,\n                              n.end_lineno, n.end_col_offset);\n            else {\n                var expression = ast_for_testlist(c, CHILD(ch, 1));\n                if (!expression) {\n                    return null;\n                }\n                return new Sk.astnodes.Return(expression, LINENO(n), n.col_offset,\n                              n.end_lineno, n.end_col_offset);\n            }\n        case SYM.raise_stmt:\n            // This is tricky and Skulpt-specific, because we need to handle\n            // both Python 3-style and Python 2-style 'raise' statements\n            if (NCH(ch) == 1)\n                return new Sk.astnodes.Raise(null, null, null, null, LINENO(n), n.col_offset,\n                             n.end_lineno, n.end_col_offset);\n            else if (NCH(ch) >= 2) {\n                var cause = null;\n                var expression = ast_for_expr(c, CHILD(ch, 1));\n                var inst = null, tback = null;\n\n                // raise [expression] from [cause]\n                if (NCH(ch) == 4 && CHILD(ch, 2).value == 'from') {\n                    if (!Sk.__future__.python3) {\n                        ast_error(c, CHILD(ch, 2), \"raise ... from ... is not available in Python 2\");\n                    }\n                    cause = ast_for_expr(c, CHILD(ch, 3));\n                } else if (NCH(ch) >= 4 && CHILD(ch, 2).value == ',') {\n                    if (Sk.__future__.python3) {\n                        ast_error(c, n, \"Old raise syntax is not available in Python 3\")\n                    }\n                    // raise [exception_type], [instantiation value] [, [traceback]]\n                    // NB traceback isn't implemented in Skulpt yet\n                    inst = ast_for_expr(c, CHILD(ch, 3));\n\n                    if (NCH(ch) == 6) {\n                        tback = ast_for_expr(c, CHILD(ch, 5));\n                    }\n                }\n                return new Sk.astnodes.Raise(expression, cause, inst, tback, LINENO(n), n.col_offset,\n                             n.end_lineno, n.end_col_offset);\n            }\n            /* fall through */\n        default:\n            Sk.asserts.fail(\"unexpected flow_stmt: \", TYPE(ch));\n            return null;\n    }\n}\n\nfunction astForArg(c, n)\n{\n    var name;\n    var annotation = null;\n    var ch;\n\n    Sk.asserts.assert(n.type === SYM.tfpdef || n.type === SYM.vfpdef);\n    ch = CHILD(n, 0);\n    forbiddenCheck(c, ch, ch.value, ch.lineno);\n    name = strobj(ch.value);\n\n    if (NCH(n) == 3 && CHILD(n, 1).type === TOK.T_COLON) {\n        annotation = ast_for_expr(c, CHILD(n, 2));\n    }\n\n    return new Sk.astnodes.arg(name, annotation, n.lineno, n.col_offset);\n}\n\n/* returns -1 if failed to handle keyword only arguments\n   returns new position to keep processing if successful\n               (',' tfpdef ['=' test])*\n                     ^^^\n   start pointing here\n */\nfunction handleKeywordonlyArgs(c, n, start, kwonlyargs, kwdefaults)\n{\n    var argname;\n    var ch;\n    var expression;\n    var annotation;\n    var arg;\n    var i = start;\n    var j = 0; /* index for kwdefaults and kwonlyargs */\n\n    if (!kwonlyargs) {\n        ast_error(c, CHILD(n, start), \"named arguments must follow bare *\");\n    }\n    Sk.asserts.assert(kwdefaults);\n    while (i < NCH(n)) {\n        ch = CHILD(n, i);\n        switch (ch.type) {\n            case SYM.vfpdef:\n            case SYM.tfpdef:\n                if (i + 1 < NCH(n) && CHILD(n, i + 1).type == TOK.T_EQUAL) {\n                    kwdefaults[j] = ast_for_expr(c, CHILD(n, i + 2));\n                    i += 2; /* '=' and test */\n                }\n                else { /* setting NULL if no default value exists */\n                    kwdefaults[j] = null;\n                }\n                if (NCH(ch) == 3) {\n                    /* ch is NAME ':' test */\n                    annotation = ast_for_expr(c, CHILD(ch, 2));\n                }\n                else {\n                    annotation = null;\n                }\n                ch = CHILD(ch, 0);\n                forbiddenCheck(c, ch, ch.value, ch.lineno);\n                argname = strobj(ch.value);\n                kwonlyargs[j++] = new Sk.astnodes.arg(argname, annotation, ch.lineno, ch.col_offset);\n                i += 2; /* the name and the comma */\n                break;\n            case TOK.T_DOUBLESTAR:\n                return i;\n            default:\n                ast_error(c, ch, \"unexpected node\");\n        }\n    }\n    return i;\n}\n\nfunction astForArguments (c, n) {\n    var k;\n    var j;\n    var i;\n    var foundDefault;\n    var posargs = [];\n    var posdefaults = [];\n    var kwonlyargs = [];\n    var kwdefaults = [];\n    var vararg = null;\n    var kwarg = null;\n    var ch = null;\n\n    /* This function handles both typedargslist (function definition)\n       and varargslist (lambda definition).\n\n       parameters: '(' [typedargslist] ')'\n       typedargslist: (tfpdef ['=' test] (',' tfpdef ['=' test])* [',' [\n               '*' [tfpdef] (',' tfpdef ['=' test])* [',' ['**' tfpdef [',']]]\n             | '**' tfpdef [',']]]\n         | '*' [tfpdef] (',' tfpdef ['=' test])* [',' ['**' tfpdef [',']]]\n         | '**' tfpdef [','])\n       tfpdef: NAME [':' test]\n       varargslist: (vfpdef ['=' test] (',' vfpdef ['=' test])* [',' [\n               '*' [vfpdef] (',' vfpdef ['=' test])* [',' ['**' vfpdef [',']]]\n             | '**' vfpdef [',']]]\n         | '*' [vfpdef] (',' vfpdef ['=' test])* [',' ['**' vfpdef [',']]]\n         | '**' vfpdef [',']\n       )\n       vfpdef: NAME\n\n    */\n    if (n.type === SYM.parameters) {\n        if (NCH(n) === 2) // () as arglist\n        {\n            return new Sk.astnodes.arguments_([], null, [], [], null, []);\n        }\n        n = CHILD(n, 1);\n    }\n    Sk.asserts.assert(n.type === SYM.varargslist ||\n                        n.type === SYM.typedargslist);\n\n\n    // Skulpt note: the \"counting numbers of args\" section\n    // from ast.c is omitted because JS arrays autoexpand\n\n    /* tfpdef: NAME [':' test]\n       vfpdef: NAME\n    */\n    i = 0;\n    j = 0;  /* index for defaults */\n    k = 0;  /* index for args */\n    while (i < NCH(n)) {\n        ch = CHILD(n, i);\n        switch (ch.type) {\n            case SYM.tfpdef:\n            case SYM.vfpdef:\n                /* XXX Need to worry about checking if TYPE(CHILD(n, i+1)) is\n                   anything other than EQUAL or a comma? */\n                /* XXX Should NCH(n) check be made a separate check? */\n                if (i + 1 < NCH(n) && CHILD(n, i + 1).type == TOK.T_EQUAL) {\n                    posdefaults[j++] = ast_for_expr(c, CHILD(n, i + 2));\n                    i += 2;\n                    foundDefault = 1;\n                }\n                else if (foundDefault) {\n                    throw new Sk.builtin.SyntaxError(\"non-default argument follows default argument\", c.c_filename, n.lineno);\n                }\n                posargs[k++] = astForArg(c, ch);\n                i += 2; /* the name and the comma */\n                break;\n            case TOK.T_STAR:\n                if (i+1 >= NCH(n) ||\n                    (i+2 == NCH(n) && CHILD(n, i+1).type == TOK.T_COMMA)) {\n                    throw new Sk.builtin.SyntaxError(\"named arguments must follow bare *\", c.c_filename, n.lineno);\n                }\n                ch = CHILD(n, i+1);  /* tfpdef or COMMA */\n                if (ch.type == TOK.T_COMMA) {\n                    i += 2; /* now follows keyword only arguments */\n                    i = handleKeywordonlyArgs(c, n, i,\n                                                  kwonlyargs, kwdefaults);\n                }\n                else {\n                    vararg = astForArg(c, ch);\n\n                    i += 3;\n                    if (i < NCH(n) && (CHILD(n, i).type == SYM.tfpdef\n                                    || CHILD(n, i).type == SYM.vfpdef)) {\n                        i = handleKeywordonlyArgs(c, n, i,\n                                                      kwonlyargs, kwdefaults);\n                    }\n                }\n                break;\n            case TOK.T_DOUBLESTAR:\n                ch = CHILD(n, i+1);  /* tfpdef */\n                Sk.asserts.assert(ch.type == SYM.tfpdef || ch.type == SYM.vfpdef);\n                kwarg = astForArg(c, ch);\n                i += 3;\n                break;\n            default:\n                Sk.asserts.fail(\"unexpected node in varargslist\");\n                return;\n        }\n    }\n    return new Sk.astnodes.arguments_(posargs, vararg, kwonlyargs, kwdefaults, kwarg, posdefaults);\n}\n\nfunction ast_for_async_funcdef(c, n, decorator_seq)\n{\n    /* async_funcdef: 'async' funcdef */\n    REQ(n, SYM.async_funcdef);\n    REQ(CHILD(n, 0), TOK.T_NAME);\n    Sk.asserts.assert(STR(CHILD(n, 0) === \"async\"));\n    REQ(CHILD(n, 1), SYM.funcdef);\n\n    return ast_for_funcdef_impl(c, n, decorator_seq,\n                                true /* is_async */);\n}\n\nfunction ast_for_funcdef(c, n, decorator_seq) {\n    /* funcdef: 'def' NAME parameters ['->' test] ':' suite */\n    return ast_for_funcdef_impl(c, n, decorator_seq,\n        false /* is_async */);\n}\n\nfunction ast_for_funcdef_impl(c, n0, decorator_seq, is_async) {\n    /* funcdef: 'def' NAME parameters ['->' test] ':' [TYPE_COMMENT] suite */\n    var n = is_async ? CHILD(n0, 1) : n0;\n    var name;\n    var args;\n    var body;\n    var returns = NULL;\n    var name_i = 1;\n    var end_lineno, end_col_offset;\n    var tc;\n    var type_comment = NULL;\n\n    if (is_async && c.c_feature_version < 5) {\n        ast_error(c, n,\n                  \"Async functions are only supported in Python 3.5 and greater\");\n        return NULL;\n    }\n\n    REQ(n, SYM.funcdef);\n\n    name = new_identifier(CHILD(n, name_i));\n\n    if (forbiddenCheck(c, name, CHILD(n, name_i), 0)) {\n        return NULL;\n    }\n    args = astForArguments(c, CHILD(n, name_i + 1));\n    if (!args) {\n        return NULL;\n    }\n    if (TYPE(CHILD(n, name_i+2)) == TOK.T_RARROW) {\n        returns = ast_for_expr(c, CHILD(n, name_i + 3));\n        if (!returns) {\n            return NULL\n        }\n        name_i += 2;\n    }\n\n    if (TYPE(CHILD(n, name_i + 3)) == TOK.T_TYPE_COMMENT) {\n        type_comment = TOK.T_NEW_TYPE_COMMENT(CHILD(n, name_i + 3));\n        if (!type_comment)\n            return NULL;\n        name_i += 1;\n    }\n\n    body = astForSuite(c, CHILD(n, name_i + 3));\n    if (!body) {\n        return NULL;\n    }\n    // get_last_end_pos(body, &end_lineno, &end_col_offset);\n\n    if (NCH(CHILD(n, name_i + 3)) > 1) {\n        /* Check if the suite has a type comment in it. */\n        tc = CHILD(CHILD(n, name_i + 3), 1);\n\n        if (TYPE(tc) == TOK.T_TYPE_COMMENT) {\n            if (type_comment != NULL) {\n                ast_error(c, n, \"Cannot have two type comments on def\");\n                return NULL;\n            }\n            type_comment = TOK.T_NEW_TYPE_COMMENT(tc);\n            if (!type_comment)\n                return NULL;\n        }\n    }\n\n    if (is_async)\n        return new Sk.astnodes.AsyncFunctionDef(name, args, body, decorator_seq, returns, type_comment,\n                                LINENO(n0), n0.col_offset, end_lineno, end_col_offset);\n    else\n        return new Sk.astnodes.FunctionDef(name, args, body, decorator_seq, returns, type_comment,\n                           LINENO(n), n.col_offset, end_lineno, end_col_offset);\n}\n\nfunction astForClassBases (c, n) {\n    /* testlist: test (',' test)* [','] */\n    Sk.asserts.assert(NCH(n) > 0);\n    REQ(n, SYM.testlist);\n    if (NCH(n) === 1) {\n        return [ ast_for_expr(c, CHILD(n, 0)) ];\n    }\n    return seq_for_testlist(c, n);\n}\n\nfunction astForClassdef (c, n, decoratorSeq) {\n    /* classdef: 'class' NAME ['(' arglist ')'] ':' suite */\n    var classname;\n    var call;\n    var s;\n\n    REQ(n, SYM.classdef);\n\n    if (NCH(n) == 4) { /* class NAME ':' suite */\n        s = astForSuite(c, CHILD(n, 3));\n        classname = new_identifier(CHILD(n, 1).value);\n        forbiddenCheck(c, CHILD(n,3), classname, n.lineno);\n\n        return new Sk.astnodes.ClassDef(classname, [], [], s, decoratorSeq,\n                                    /*TODO docstring*/null, LINENO(n), n.col_offset);\n    }\n\n    if (TYPE(CHILD(n, 3)) === TOK.T_RPAR) { /* class NAME '(' ')' ':' suite */\n        s = astForSuite(c, CHILD(n, 5));\n        classname = new_identifier(CHILD(n, 1).value);\n        forbiddenCheck(c, CHILD(n, 3), classname, CHILD(n, 3).lineno);\n        return new Sk.astnodes.ClassDef(classname, [], [], s, decoratorSeq,\n                                    /*TODO docstring*/null, LINENO(n), n.col_offset);\n    }\n\n    /* class NAME '(' arglist ')' ':' suite */\n    /* build up a fake Call node so we can extract its pieces */\n    {\n        var dummy_name;\n        var dummy;\n        dummy_name = new_identifier(CHILD(n, 1));\n        dummy = new Sk.astnodes.Name(dummy_name, Sk.astnodes.Load, LINENO(n), n.col_offset);\n        call = ast_for_call(c, CHILD(n, 3), dummy, false);\n    }\n    s = astForSuite(c, CHILD(n, 6));\n    classname = new_identifier(CHILD(n, 1).value);\n    forbiddenCheck(c, CHILD(n,1), classname, CHILD(n,1).lineno);\n\n    return new Sk.astnodes.ClassDef(classname, call.args, call.keywords, s,\n                               decoratorSeq, /*TODO docstring*/null, LINENO(n), n.col_offset);\n}\n\nfunction astForLambdef (c, n) {\n    /* lambdef: 'lambda' [varargslist] ':' test */\n    var args;\n    var expression;\n    if (NCH(n) === 3) {\n        args = new Sk.astnodes.arguments_([], null, null, []);\n        expression = ast_for_expr(c, CHILD(n, 2));\n    }\n    else {\n        args = astForArguments(c, CHILD(n, 1));\n        expression = ast_for_expr(c, CHILD(n, 3));\n    }\n    return new Sk.astnodes.Lambda(args, expression, n.lineno, n.col_offset);\n}\n\nfunction astForComprehension(c, n) {\n    /* testlist_comp: test ( comp_for | (',' test)* [','] )\n       argument: test [comp_for] | test '=' test       # Really [keyword '='] test */\n\n    var j;\n    var ifs;\n    var nifs;\n    var ge;\n    var expression;\n    var t;\n    var forch;\n    var i;\n    var ch;\n    var genexps;\n    var nfors;\n    var elt;\n    var comps;\n    var comp;\n\n    function countCompFors(c, n) {\n        var nfors = 0;\n        count_comp_for: while (true) {\n            nfors++;\n            REQ(n, SYM.comp_for);\n            if (NCH(n) === 5) {\n                n = CHILD(n, 4);\n            } else {\n                return nfors;\n            }\n            count_comp_iter: while (true) {\n                REQ(n, SYM.comp_iter);\n                n = CHILD(n, 0);\n                if (n.type === SYM.comp_for) {\n                    continue count_comp_for;\n                } else if (n.type === SYM.comp_if) {\n                    if (NCH(n) === 3) {\n                        n = CHILD(n, 2);\n                        continue count_comp_iter;\n                    } else {\n                        return nfors;\n                    }\n                }\n                break;\n            }\n            break;\n        }\n        Sk.asserts.fail(\"logic error in countCompFors\");\n    }\n\n    function countCompIfs(c, n) {\n        var nifs = 0;\n        while (true) {\n            REQ(n, SYM.comp_iter);\n            if (CHILD(n, 0).type === SYM.comp_for) {\n                return nifs;\n            }\n            n = CHILD(n, 0);\n            REQ(n, SYM.comp_if);\n            nifs++;\n            if (NCH(n) === 2) {\n                return nifs;\n            }\n            n = CHILD(n, 2);\n        }\n    }\n\n    nfors = countCompFors(c, n);\n    comps = [];\n    for (i = 0; i < nfors; ++i) {\n        REQ(n, SYM.comp_for);\n        forch = CHILD(n, 1);\n        t = ast_for_exprlist(c, forch, Sk.astnodes.Store);\n        expression = ast_for_expr(c, CHILD(n, 3));\n        if (NCH(forch) === 1) {\n            comp = new Sk.astnodes.comprehension(t[0], expression, []);\n        } else {\n            comp = new Sk.astnodes.comprehension(new Sk.astnodes.Tuple(t, Sk.astnodes.Store, n.lineno, n.col_offset), expression, []);\n        }\n        if (NCH(n) === 5) {\n            n = CHILD(n, 4);\n            nifs = countCompIfs(c, n);\n            ifs = [];\n            for (j = 0; j < nifs; ++j) {\n                REQ(n, SYM.comp_iter);\n                n = CHILD(n, 0);\n                REQ(n, SYM.comp_if);\n                expression = ast_for_expr(c, CHILD(n, 1));\n                ifs[j] = expression;\n                if (NCH(n) === 3) {\n                    n = CHILD(n, 2);\n                }\n            }\n            if (n.type === SYM.comp_iter) {\n                n = CHILD(n, 0);\n            }\n            comp.ifs = ifs;\n        }\n        comps[i] = comp;\n    }\n    return comps;\n}\n\nfunction astForIterComp(c, n, type) {\n    var elt, comps;\n    Sk.asserts.assert(NCH(n) > 1);\n    elt = ast_for_expr(c, CHILD(n, 0));\n    comps = astForComprehension(c, CHILD(n, 1));\n    if (type === COMP_GENEXP) {\n        return new Sk.astnodes.GeneratorExp(elt, comps, n.lineno, n.col_offset);\n    } else if (type === COMP_SETCOMP) {\n        return new Sk.astnodes.SetComp(elt, comps, n.lineno, n.col_offset);\n    }\n}\n\n/*\n   Count the number of 'for' loops in a comprehension.\n   Helper for ast_for_comprehension().\n*/\nfunction count_comp_fors(c, n) {\n    var n_fors = 0;\n    var is_async;\n    count_comp_for: while (true) {\n        // @meredydd needs new grammar\n        // REQ(n, SYM.comp_for);\n        // if (NCH(n) === 2) {\n        //     REQ(CHILD(n, 0), TOK.T_ASYNC);\n        //     n = CHILD(n, 1);\n        // } else if (NCH(n) === 1) {\n        //     n = CHILD(n, 0);\n        // } else {\n        //     Sk.asserts.fail(\"logic error in count_comp_fors\");\n        // }\n        // if (NCH(n) == (5)) {\n        //     n = CHILD(n, 4);\n        // } else {\n        //     return n_fors;\n        // }\n        is_async = 0;\n        n_fors++;\n        REQ(n, SYM.comp_for);\n        if (TYPE(CHILD(n, 0)) == TOK.T_ASYNC) {\n            is_async = 1;\n        }\n        if (NCH(n) == (5 + is_async)) {\n            n = CHILD(n, 4 + is_async);\n        }\n        else {\n            return n_fors;\n        }\n        count_comp_iter: while (true) {\n            REQ(n, SYM.comp_iter);\n            n = CHILD(n, 0);\n            if (TYPE(n) === SYM.comp_for) {\n                continue count_comp_for;\n            } else if (TYPE(n) === SYM.comp_if) {\n                if (NCH(n) === 3) {\n                    n = CHILD(n, 2);\n                    continue count_comp_iter;\n                } else {\n                    return n_fors;\n                }\n            }\n            break;\n        }\n        break;\n    }\n}\n\nfunction count_comp_ifs(c, n)\n{\n    var n_ifs = 0;\n\n    while (true) {\n        REQ(n, SYM.comp_iter);\n        if (TYPE(CHILD(n, 0)) == SYM.comp_for)\n            return n_ifs;\n        n = CHILD(n, 0);\n        REQ(n, SYM.comp_if);\n        n_ifs++;\n        if (NCH(n) == 2) {\n            return n_ifs;\n        }\n        n = CHILD(n, 2);\n    }\n}\n\nfunction ast_for_comprehension(c, n) {\n    var i, n_fors;\n    var comps = [];\n    n_fors = count_comp_fors(c, n);\n\n    for (i = 0; i < n_fors; i++) {\n        var comp;\n        var t;\n        var expression, first;\n        var for_ch;\n        var is_async = 0;\n\n        if (TYPE(CHILD(n, 0)) == TOK.T_ASYNC) {\n            is_async = 1;\n        }\n\n        for_ch = CHILD(n, 1 + is_async);\n        t = ast_for_exprlist(c, for_ch, Sk.astnodes. Store);\n        if (!t) {\n            return null;\n        }\n\n        expression = ast_for_expr(c, CHILD(n, 3 + is_async));\n\n        if (!expression) {\n            return null;\n        }\n\n        // again new grammar needed\n        // REQ(n, SYM.comp_for);\n\n        // if (NCH(n) == 2) {\n        //     is_async = 1;\n        //     REQ(CHILD(n, 0), TOK.T_ASYNC);\n        //     sync_n = CHILD(n, 1);\n        // }\n        // else {\n        //     sync_n = CHILD(n, 0);\n        // }\n        // REQ(sync_n, SYM.sync_comp_for);\n\n        // /* Async comprehensions only allowed in Python 3.6 and greater */\n        // /* @meredydd see below for the joys of the future! */\n        // if (is_async && c.c_feature_version < 6) {\n        //     ast_error(c, n,\n        //               \"Async comprehensions are only supported in Python 3.6 and greater\");\n        //     return null;\n        // }\n\n        // for_ch = CHILD(sync_n, 1);\n        // t = ast_for_exprlist(c, for_ch, Sk.astnodes.Store);\n\n        // expression = ast_for_expr(c, CHILD(sync_n, 3));\n\n        /* Check the # of children rather than the length of t, since\n           (x for x, in ...) has 1 element in t, but still requires a Tuple. */\n        first = t[0];\n        if (NCH(for_ch) == 1)\n            comp = new Sk.astnodes.comprehension(first, expression, null, is_async);\n        else\n            comp = new Sk.astnodes.comprehension(new Sk.astnodes.Tuple(t, Sk.astnodes.Store, first.lineno, first.col_offset,\n                                       for_ch.end_lineno, for_ch.end_col_offset),\n                                 expression, null, is_async);\n\n        if (NCH(n) == (5 + is_async)) {\n            var j, n_ifs;\n            var ifs = [];\n\n            n = CHILD(n, 4 + is_async);\n            n_ifs = count_comp_ifs(c, n);\n            if (n_ifs == -1) {\n                return null;\n            }\n\n            for (j = 0; j < n_ifs; j++) {\n                REQ(n, SYM.comp_iter);\n                n = CHILD(n, 0);\n                REQ(n, SYM.comp_if);\n\n                expression = ast_for_expr(c, CHILD(n, 1));\n                if (!expression) {\n                    return null;\n                }\n\n                ifs[j] = expression;\n                if (NCH(n) == 3) {\n                    n = CHILD(n, 2);\n                }\n            }\n            /* on exit, must guarantee that n is a comp_for */\n            if (TYPE(n) == SYM.comp_iter) {\n                n = CHILD(n, 0);\n            }\n            comp.ifs = ifs;\n        }\n        // if (NCH(sync_n) == 5) {\n        //     var j, n_ifs;\n        //     var ifs = [];\n\n        //     n = CHILD(sync_n, 4);\n        //     n_ifs = count_comp_ifs(c, n);\n\n        //     for (j = 0; j < n_ifs; j++) {\n        //         REQ(n, comp_iter);\n        //         n = CHILD(n, 0);\n        //         REQ(n, comp_if);\n\n        //         expression = ast_for_expr(c, CHILD(n, 1));\n        //         if (!expression) {\n        //             return null;\n        //         }\n\n        //         ifs[j] = expression;\n        //         if (NCH(n) == 3) {\n        //             n = CHILD(n, 2);\n        //         }\n        //     }\n        //     /* on exit, must guarantee that n is a comp_for */\n        //     if (TYPE(n) == SYM.comp_iter) {\n        //         n = CHILD(n, 0);\n        //     }\n        //     comp.ifs = ifs;\n        // }\n        comps[i] = comp;\n    }\n    return comps;\n}\n\nfunction ast_for_itercomp(c, n, type) {\n    /* testlist_comp: (test|star_expr)\n     *                ( comp_for | (',' (test|star_expr))* [','] ) */\n    var elt;\n    var comps;\n    var ch;\n\n    Sk.asserts.assert(NCH(n) > 1);\n\n    ch = CHILD(n, 0);\n    elt = ast_for_expr(c, ch);\n\n    if (elt.constructor === Sk.astnodes.Starred) {\n        ast_error(c, ch, \"iterable unpacking cannot be used in comprehension\");\n        return NULL;\n    }\n\n    comps = ast_for_comprehension(c, CHILD(n, 1));\n\n    if (type == COMP_GENEXP) {\n        return new Sk.astnodes.GeneratorExp(elt, comps, LINENO(n), n.col_offset,\n                            n.end_lineno, n.end_col_offset);\n    } else if (type == COMP_LISTCOMP) {\n        return new Sk.astnodes.ListComp(elt, comps, LINENO(n), n.col_offset,\n                        n.end_lineno, n.end_col_offset);\n    } else if (type == COMP_SETCOMP) {\n        return new Sk.astnodes.SetComp(elt, comps, LINENO(n), n.col_offset,\n                       n.end_lineno, n.end_col_offset);\n    } else {\n        /* Should never happen */\n        return null;\n    }\n}\n\n/* Fills in the key, value pair corresponding to the dict element.  In case\n * of an unpacking, key is NULL.  *i is advanced by the number of ast\n * elements.  Iff successful, nonzero is returned.\n */\nfunction ast_for_dictelement(c, n, i)\n{\n    var expression;\n    if (TYPE(CHILD(n, i)) == TOK.T_DOUBLESTAR) {\n        Sk.asserts.assert(NCH(n) - i >= 2);\n\n        expression = ast_for_expr(c, CHILD(n, i + 1));\n\n        return { key: null, value: expression, i: i + 2 }\n    } else {\n        Sk.asserts.assert(NCH(n) - i >= 3);\n\n        expression = ast_for_expr(c, CHILD(n, i));\n        if (!expression)\n            return 0;\n        var key = expression;\n\n        REQ(CHILD(n, i + 1), TOK.T_COLON);\n\n        expression = ast_for_expr(c, CHILD(n, i + 2));\n        if (!expression) {\n            return false;\n        }\n\n        var value = expression;\n\n        return { key: key, value: value, i: i + 3 };\n    }\n}\n\nfunction ast_for_dictcomp(c, n) {\n    var key, value;\n    var comps = [];\n    Sk.asserts.assert(NCH(n) > 3);\n    REQ(CHILD(n, 1), TOK.T_COLON);\n    key = ast_for_expr(c, CHILD(n, 0));\n    value = ast_for_expr(c, CHILD(n, 2));\n    comps = astForComprehension(c, CHILD(n, 3));\n    return new Sk.astnodes.DictComp(key, value, comps, n.lineno, n.col_offset);\n}\n\nfunction ast_for_dictdisplay(c, n)\n{\n    var i;\n    var j;\n    var keys = [], values = [];\n\n    j = 0;\n    for (i = 0; i < NCH(n); i++) {\n        var res = ast_for_dictelement(c, n, i);\n        i = res.i\n        keys[j] = res.key;\n        values[j] = res.value;\n        j++;\n    }\n\n    return new Sk.astnodes.Dict(keys, values, LINENO(n), n.col_offset,\n                n.end_lineno, n.end_col_offset);\n}\n\nfunction ast_for_gen_expr(c, n) {\n    Sk.asserts.assert(n.type === SYM.testlist_comp || n.type === SYM.argument);\n    return astForIterComp(c, n, COMP_GENEXP);\n}\n\nfunction ast_for_setcomp(c, n) {\n    Sk.asserts.assert(n.type === SYM.dictorsetmaker);\n    return astForIterComp(c, n, COMP_SETCOMP);\n}\n\nfunction astForWhileStmt (c, n) {\n    /* while_stmt: 'while' test ':' suite ['else' ':' suite] */\n    REQ(n, SYM.while_stmt);\n    if (NCH(n) === 4) {\n        return new Sk.astnodes.While(ast_for_expr(c, CHILD(n, 1)), astForSuite(c, CHILD(n, 3)), [], n.lineno, n.col_offset);\n    }\n    else if (NCH(n) === 7) {\n        return new Sk.astnodes.While(ast_for_expr(c, CHILD(n, 1)), astForSuite(c, CHILD(n, 3)), astForSuite(c, CHILD(n, 6)), n.lineno, n.col_offset);\n    }\n    Sk.asserts.fail(\"wrong number of tokens for 'while' stmt\");\n}\n\nfunction astForAugassign (c, n) {\n    REQ(n, SYM.augassign);\n    n = CHILD(n, 0);\n    switch (n.value.charAt(0)) {\n        case \"+\":\n            return Sk.astnodes.Add;\n        case \"-\":\n            return Sk.astnodes.Sub;\n        case \"/\":\n            if (n.value.charAt(1) === \"/\") {\n                return Sk.astnodes.FloorDiv;\n            }\n            return Sk.astnodes.Div;\n        case \"%\":\n            return Sk.astnodes.Mod;\n        case \"<\":\n            return Sk.astnodes.LShift;\n        case \">\":\n            return Sk.astnodes.RShift;\n        case \"&\":\n            return Sk.astnodes.BitAnd;\n        case \"^\":\n            return Sk.astnodes.BitXor;\n        case \"|\":\n            return Sk.astnodes.BitOr;\n        case \"*\":\n            if (n.value.charAt(1) === \"*\") {\n                return Sk.astnodes.Pow;\n            }\n            return Sk.astnodes.Mult;\n        default:\n            Sk.asserts.fail(\"invalid augassign\");\n    }\n}\n\nfunction astForBinop (c, n) {\n    /* Must account for a sequence of expressions.\n     How should A op B op C by represented?\n     BinOp(BinOp(A, op, B), op, C).\n     */\n    var tmp;\n    var newoperator;\n    var nextOper;\n    var i;\n    var result = new Sk.astnodes.BinOp(\n        ast_for_expr(c, CHILD(n, 0)),\n        getOperator(CHILD(n, 1)),\n        ast_for_expr(c, CHILD(n, 2)),\n        n.lineno, n.col_offset);\n    var nops = (NCH(n) - 1) / 2;\n    for (i = 1; i < nops; ++i) {\n        nextOper = CHILD(n, i * 2 + 1);\n        newoperator = getOperator(nextOper);\n        tmp = ast_for_expr(c, CHILD(n, i * 2 + 2));\n        result = new Sk.astnodes.BinOp(result, newoperator, tmp, nextOper.lineno, nextOper.col_offset);\n    }\n    return result;\n}\n\nfunction ast_for_testlist (c, n) {\n    /* testlist_comp: test (',' comp_for | (',' test)* [',']) */\n    /* testlist: test (',' test)* [','] */\n    Sk.asserts.assert(NCH(n) > 0);\n    if (n.type === SYM.testlist_comp) {\n        if (NCH(n) > 1) {\n            Sk.asserts.assert(CHILD(n, 1).type !== SYM.comp_for);\n        }\n    }\n    else {\n        Sk.asserts.assert(n.type === SYM.testlist || n.type === SYM.testlist_star_expr);\n    }\n\n    if (NCH(n) === 1) {\n        return ast_for_expr(c, CHILD(n, 0));\n    }\n    else {\n        return new Sk.astnodes.Tuple(seq_for_testlist(c, n), Sk.astnodes.Load, n.lineno, n.col_offset/*, c.c_arena */);\n    }\n}\n\nfunction ast_for_exprStmt (c, n) {\n    var expression;\n    var value;\n    var e;\n    var i;\n    var targets;\n    var expr2;\n    var varName;\n    var expr1;\n    var ch;\n    REQ(n, SYM.expr_stmt);\n    /* expr_stmt: testlist_star_expr (annassign | augassign (yield_expr|testlist) |\n                            ('=' (yield_expr|testlist_star_expr))*)\n       annassign: ':' test ['=' test]\n       testlist_star_expr: (test|star_expr) (',' test|star_expr)* [',']\n       augassign: '+=' | '-=' | '*=' | '@=' | '/=' | '%=' | '&=' | '|=' | '^='\n                | '<<=' | '>>=' | '**=' | '//='\n       test: ... here starts the operator precedence dance\n     */\n    if (NCH(n) === 1) {\n        return new Sk.astnodes.Expr(ast_for_testlist(c, CHILD(n, 0)), n.lineno, n.col_offset);\n    }\n    else if (CHILD(n, 1).type === SYM.augassign) {\n        ch = CHILD(n, 0);\n        expr1 = ast_for_testlist(c, ch);\n        setContext(c, expr1, Sk.astnodes.Store, ch);\n        switch (expr1.constructor) {\n            case Sk.astnodes.Name:\n                varName = expr1.id;\n                forbiddenCheck(c, ch, varName, n.lineno);\n                break;\n            case Sk.astnodes.Attribute:\n            case Sk.astnodes.Subscript:\n                break;\n            case Sk.astnodes.GeneratorExp:\n                throw new Sk.builtin.SyntaxError(\"augmented assignment to generator expression not possible\", c.c_filename, n.lineno);\n            case Sk.astnodes.Yield:\n                throw new Sk.builtin.SyntaxError(\"augmented assignment to yield expression not possible\", c.c_filename, n.lineno);\n            default:\n                throw new Sk.builtin.SyntaxError(\"illegal expression for augmented assignment\", c.c_filename, n.lineno);\n        }\n\n        ch = CHILD(n, 2);\n        if (ch.type === SYM.testlist) {\n            expr2 = ast_for_testlist(c, ch);\n        }\n        else {\n            expr2 = ast_for_expr(c, ch);\n        }\n\n        return new Sk.astnodes.AugAssign(expr1, astForAugassign(c, CHILD(n, 1)), expr2, n.lineno, n.col_offset);\n    }\n    else if (CHILD(n, 1).type === SYM.annassign) {\n        // TODO translate the relevant section from ast.c\n        throw new Sk.builtin.SyntaxError(\"Skulpt does not yet support type assignments\", c.c_filename, n.lineno);\n    }\n    else {\n        // normal assignment\n        REQ(CHILD(n, 1), TOK.T_EQUAL);\n        targets = [];\n        for (i = 0; i < NCH(n) - 2; i += 2) {\n            ch = CHILD(n, i);\n            if (ch.type === SYM.yield_expr) {\n                throw new Sk.builtin.SyntaxError(\"assignment to yield expression not possible\", c.c_filename, n.lineno);\n            }\n            e = ast_for_testlist(c, ch);\n            setContext(c, e, Sk.astnodes.Store, CHILD(n, i));\n            targets[i / 2] = e;\n        }\n        value = CHILD(n, NCH(n) - 1);\n        if (value.type === SYM.testlist_star_expr) {\n            expression = ast_for_testlist(c, value);\n        }\n        else {\n            expression = ast_for_expr(c, value);\n        }\n        return new Sk.astnodes.Assign(targets, expression, n.lineno, n.col_offset);\n    }\n}\n\nfunction astForIfexpr (c, n) {\n    /* test: or_test 'if' or_test 'else' test */\n    Sk.asserts.assert(NCH(n) === 5);\n    return new Sk.astnodes.IfExp(\n        ast_for_expr(c, CHILD(n, 2)),\n        ast_for_expr(c, CHILD(n, 0)),\n        ast_for_expr(c, CHILD(n, 4)),\n        n.lineno, n.col_offset);\n}\n\n/**\n * s is a python-style string literal, including quote characters and u/r/b\n * prefixes. Returns decoded string object.\n */\nfunction parsestr (c, s) {\n    var encodeUtf8 = function (s) {\n        return unescape(encodeURIComponent(s));\n    };\n    var decodeUtf8 = function (s) {\n        return decodeURIComponent(escape(s));\n    };\n    var decodeEscape = function (s, quote) {\n        var d3;\n        var d2;\n        var d1;\n        var d0;\n        var c;\n        var i;\n        var len = s.length;\n        var ret = \"\";\n        for (i = 0; i < len; ++i) {\n            c = s.charAt(i);\n            if (c === \"\\\\\") {\n                ++i;\n                c = s.charAt(i);\n                if (c === \"n\") {\n                    ret += \"\\n\";\n                }\n                else if (c === \"\\\\\") {\n                    ret += \"\\\\\";\n                }\n                else if (c === \"t\") {\n                    ret += \"\\t\";\n                }\n                else if (c === \"r\") {\n                    ret += \"\\r\";\n                }\n                else if (c === \"b\") {\n                    ret += \"\\b\";\n                }\n                else if (c === \"f\") {\n                    ret += \"\\f\";\n                }\n                else if (c === \"v\") {\n                    ret += \"\\v\";\n                }\n                else if (c === \"0\") {\n                    ret += \"\\0\";\n                }\n                else if (c === '\"') {\n                    ret += '\"';\n                }\n                else if (c === '\\'') {\n                    ret += '\\'';\n                }\n                else if (c === \"\\n\") /* escaped newline, join lines */ {\n                }\n                else if (c === \"x\") {\n                    d0 = s.charAt(++i);\n                    d1 = s.charAt(++i);\n                    ret += String.fromCharCode(parseInt(d0 + d1, 16));\n                }\n                else if (c === \"u\" || c === \"U\") {\n                    d0 = s.charAt(++i);\n                    d1 = s.charAt(++i);\n                    d2 = s.charAt(++i);\n                    d3 = s.charAt(++i);\n                    ret += String.fromCharCode(parseInt(d0 + d1, 16), parseInt(d2 + d3, 16));\n                }\n                else {\n                    // Leave it alone\n                    ret += \"\\\\\" + c;\n                    // Sk.asserts.fail(\"unhandled escape: '\" + c.charCodeAt(0) + \"'\");\n                }\n            }\n            else {\n                ret += c;\n            }\n        }\n        return ret;\n    };\n\n    //print(\"parsestr\", s);\n\n    var quote = s.charAt(0);\n    var rawmode = false;\n    var unicode = false;\n\n    // treats every sequence as unicodes even if they are not treated with uU prefix\n    // kinda hacking though working for most purposes\n    if((c.c_flags & Sk.Parser.CO_FUTURE_UNICODE_LITERALS || Sk.__future__.unicode_literals === true)) {\n        unicode = true;\n    }\n\n    if (quote === \"u\" || quote === \"U\") {\n        s = s.substr(1);\n        quote = s.charAt(0);\n        unicode = true;\n    }\n    else if (quote === \"r\" || quote === \"R\") {\n        s = s.substr(1);\n        quote = s.charAt(0);\n        rawmode = true;\n    }\n    Sk.asserts.assert(quote !== \"b\" && quote !== \"B\", \"todo; haven't done b'' strings yet\");\n\n    Sk.asserts.assert(quote === \"'\" || quote === '\"' && s.charAt(s.length - 1) === quote);\n    s = s.substr(1, s.length - 2);\n    if (unicode) {\n        s = encodeUtf8(s);\n    }\n\n    if (s.length >= 4 && s.charAt(0) === quote && s.charAt(1) === quote) {\n        Sk.asserts.assert(s.charAt(s.length - 1) === quote && s.charAt(s.length - 2) === quote);\n        s = s.substr(2, s.length - 4);\n    }\n\n    if (rawmode || s.indexOf(\"\\\\\") === -1) {\n        return strobj(decodeUtf8(s));\n    }\n    return strobj(decodeEscape(s, quote));\n}\n\nfunction parsestrplus (c, n) {\n    var i;\n    var ret;\n    REQ(CHILD(n, 0), TOK.T_STRING);\n    ret = new Sk.builtin.str(\"\");\n    for (i = 0; i < NCH(n); ++i) {\n        try {\n            ret = ret.sq$concat(parsestr(c, CHILD(n, i).value));\n        } catch (x) {\n            throw new Sk.builtin.SyntaxError(\"invalid string (possibly contains a unicode character)\", c.c_filename, CHILD(n, i).lineno);\n        }\n    }\n    return ret;\n}\n\nfunction parsenumber (c, s, lineno) {\n    var neg;\n    var val;\n    var tmp;\n    var end = s.charAt(s.length - 1);\n\n    // call internal complex type constructor for complex strings\n    if (end === \"j\" || end === \"J\") {\n        return Sk.builtin.complex.complex_subtype_from_string(s);\n    }\n\n    // Handle longs\n    if (end === \"l\" || end === \"L\") {\n        return Sk.longFromStr(s.substr(0, s.length - 1), 0);\n    }\n\n    // todo; we don't currently distinguish between int and float so\n    // str is wrong for these.\n    if (s.indexOf(\".\") !== -1) {\n        return new Sk.builtin.float_(parseFloat(s));\n    }\n\n    // Handle integers of various bases\n    tmp = s;\n    neg = false;\n    if (s.charAt(0) === \"-\") {\n        tmp = s.substr(1);\n        neg = true;\n    }\n\n    if (tmp.charAt(0) === \"0\" && (tmp.charAt(1) === \"x\" || tmp.charAt(1) === \"X\")) {\n        // Hex\n        tmp = tmp.substring(2);\n        val = parseInt(tmp, 16);\n    } else if ((s.indexOf(\"e\") !== -1) || (s.indexOf(\"E\") !== -1)) {\n        // Float with exponent (needed to make sure e/E wasn't hex first)\n        return new Sk.builtin.float_(parseFloat(s));\n    } else if (tmp.charAt(0) === \"0\" && (tmp.charAt(1) === \"b\" || tmp.charAt(1) === \"B\")) {\n        // Binary\n        tmp = tmp.substring(2);\n        val = parseInt(tmp, 2);\n    } else if (tmp.charAt(0) === \"0\") {\n        if (tmp === \"0\") {\n            // Zero\n            val = 0;\n        } else {\n            // Octal\n            tmp = tmp.substring(1);\n            if ((tmp.charAt(0) === \"o\") || (tmp.charAt(0) === \"O\")) {\n                tmp = tmp.substring(1);\n            }\n            val = parseInt(tmp, 8);\n        }\n    }\n    else {\n        // Decimal\n        val = parseInt(tmp, 10);\n    }\n\n    // Convert to long\n    if (val > Sk.builtin.int_.threshold$ &&\n        Math.floor(val) === val &&\n        (s.indexOf(\"e\") === -1 && s.indexOf(\"E\") === -1)) {\n        return Sk.longFromStr(s, 0);\n    }\n\n    // Small enough, return parsed number\n    if (neg) {\n        return new Sk.builtin.int_(-val);\n    } else {\n        return new Sk.builtin.int_(val);\n    }\n}\n\nfunction astForSlice (c, n) {\n    var n2;\n    var step;\n    var upper;\n    var lower;\n    var ch;\n    REQ(n, SYM.subscript);\n\n    /*\n     subscript: '.' '.' '.' | test | [test] ':' [test] [sliceop]\n     sliceop: ':' [test]\n     */\n    ch = CHILD(n, 0);\n    lower = null;\n    upper = null;\n    step = null;\n    if (ch.type === TOK.T_DOT) {\n        return new Sk.astnodes.Ellipsis();\n    }\n    if (NCH(n) === 1 && ch.type === SYM.test) {\n        return new Sk.astnodes.Index(ast_for_expr(c, ch));\n    }\n    if (ch.type === SYM.test) {\n        lower = ast_for_expr(c, ch);\n    }\n    if (ch.type === TOK.T_COLON) {\n        if (NCH(n) > 1) {\n            n2 = CHILD(n, 1);\n            if (n2.type === SYM.test) {\n                upper = ast_for_expr(c, n2);\n            }\n        }\n    }\n    else if (NCH(n) > 2) {\n        n2 = CHILD(n, 2);\n        if (n2.type === SYM.test) {\n            upper = ast_for_expr(c, n2);\n        }\n    }\n\n    ch = CHILD(n, NCH(n) - 1);\n    if (ch.type === SYM.sliceop) {\n        if (NCH(ch) === 1) {\n            ch = CHILD(ch, 0);\n            step = new Sk.astnodes.NameConstant(Sk.builtin.none.none$, Sk.astnodes.Load, ch.lineno, ch.col_offset);\n        }\n        else {\n            ch = CHILD(ch, 1);\n            if (ch.type === SYM.test) {\n                step = ast_for_expr(c, ch);\n            }\n        }\n    }\n    return new Sk.astnodes.Slice(lower, upper, step);\n}\n\nfunction ast_for_atom(c, n)\n{\n    /* atom: '(' [yield_expr|testlist_comp] ')' | '[' [testlist_comp] ']'\n       | '{' [dictmaker|testlist_comp] '}' | NAME | NUMBER | STRING+\n       | '...' | 'None' | 'True' | 'False'\n    */\n    var ch = CHILD(n, 0);\n\n    switch (TYPE(ch)) {\n        case TOK.T_NAME: {\n            var name;\n            var s = STR(ch);\n            if (s.length >= 4 && s.length <= 5) {\n                if (s === \"None\") {\n                    return new Sk.astnodes.NameConstant(Sk.builtin.none.none$, n.lineno, n.col_offset);\n                }\n\n                if (s === \"True\") {\n                    return new Sk.astnodes.NameConstant(Sk.builtin.bool.true$, n.lineno, n.col_offset);\n                }\n\n                if (s === \"False\") {\n                    return new Sk.astnodes.NameConstant(Sk.builtin.bool.false$, n.lineno, n.col_offset);\n                }\n            }\n            name = new_identifier(s, c);\n            /* All names start in Load context, but may later be changed. */\n            return new Sk.astnodes.Name(name, Sk.astnodes.Load, LINENO(n), n.col_offset,\n                        n.end_lineno, n.end_col_offset);\n        }\n        case TOK.T_STRING: {\n            var str = parsestrplus(c, n);\n            // if (!str) {\n            //     const char *errtype = NULL;\n            //     if (PyErr_ExceptionMatches(PyExc_UnicodeError))\n            //         errtype = \"unicode error\";\n            //     else if (PyErr_ExceptionMatches(PyExc_ValueError))\n            //         errtype = \"value error\";\n            //     if (errtype) {\n            //         PyObject *type, *value, *tback, *errstr;\n            //         PyErr_Fetch(&type, &value, &tback);\n            //         errstr = PyObject_Str(value);\n            //         if (errstr) {\n            //             ast_error(c, n, \"(%s) %U\", errtype, errstr);\n            //             Py_DECREF(errstr);\n            //         }\n            //         else {\n            //             PyErr_Clear();\n            //             ast_error(c, n, \"(%s) unknown error\", errtype);\n            //         }\n            //         Py_DECREF(type);\n            //         Py_XDECREF(value);\n            //         Py_XDECREF(tback);\n            //     }\n            //     return NULL;\n            // }\n            return new Sk.astnodes.Str(str, LINENO(n), n.col_offset, c.end_lineno, n.end_col_offset);\n        }\n        case TOK.T_NUMBER:\n            return new Sk.astnodes.Num(parsenumber(c, ch.value, n.lineno), n.lineno, n.col_offset);\n        case TOK.T_ELLIPSIS: /* Ellipsis */\n            return new Sk.astnodes.Ellipsis(LINENO(n), n.col_offset,\n                            n.end_lineno, n.end_col_offset);\n        case TOK.T_LPAR: /* some parenthesized expressions */\n            ch = CHILD(n, 1);\n\n            if (TYPE(ch) == TOK.T_RPAR)\n                return new Sk.astnodes.Tuple([], Sk.astnodes.Load, LINENO(n), n.col_offset,\n                            n.end_lineno, n.end_col_offset);\n\n            if (TYPE(ch) == SYM.yield_expr) {\n                return ast_for_expr(c, ch);\n            }\n\n            /* testlist_comp: test ( comp_for | (',' test)* [','] ) */\n            if (NCH(ch) == 1) {\n                return ast_for_testlist(c, ch);\n            }\n\n            if (TYPE(CHILD(ch, 1)) == SYM.comp_for) {\n                return copy_location(ast_for_genexp(c, ch), n);\n            }\n            else {\n                return copy_location(ast_for_testlist(c, ch), n);\n            }\n        case TOK.T_LSQB: /* list (or list comprehension) */\n            ch = CHILD(n, 1);\n\n            if (TYPE(ch) == TOK.T_RSQB)\n                return new Sk.astnodes.List([], Sk.astnodes.Load, LINENO(n), n.col_offset,\n                            n.end_lineno, n.end_col_offset);\n\n            REQ(ch, SYM.testlist_comp);\n            if (NCH(ch) == 1 || TYPE(CHILD(ch, 1)) == TOK.T_COMMA) {\n                var elts = seq_for_testlist(c, ch);\n                if (!elts) {\n                    return null;\n                }\n                return new Sk.astnodes.List(elts, Sk.astnodes.Load, LINENO(n), n.col_offset,\n                            n.end_lineno, n.end_col_offset);\n            }\n            else {\n                return copy_location(ast_for_listcomp(c, ch), n);\n            }\n        case TOK.T_LBRACE: {\n            /* dictorsetmaker: ( ((test ':' test | '**' test)\n            *                    (comp_for | (',' (test ':' test | '**' test))* [','])) |\n            *                   ((test | '*' test)\n            *                    (comp_for | (',' (test | '*' test))* [','])) ) */\n            var res;\n            ch = CHILD(n, 1);\n            if (TYPE(ch) == TOK.T_RBRACE) {\n                /* It's an empty dict. */\n                return new Sk.astnodes.Dict(null, null, LINENO(n), n.col_offset,\n                    n.end_lineno, n.end_col_offset);\n            }\n            else {\n                var is_dict = (TYPE(CHILD(ch, 0)) == TOK.T_DOUBLESTAR);\n                if (NCH(ch) == 1 ||\n                        (NCH(ch) > 1 &&\n                        TYPE(CHILD(ch, 1)) == TOK.T_COMMA)) {\n                    /* It's a set display. */\n                    res = ast_for_setdisplay(c, ch);\n                }\n                else if (NCH(ch) > 1 &&\n                        TYPE(CHILD(ch, 1)) == SYM.comp_for) {\n                    /* It's a set comprehension. */\n                    res = ast_for_setcomp(c, ch);\n                }\n                else if (NCH(ch) > 3 - is_dict &&\n                        TYPE(CHILD(ch, 3 - is_dict)) == SYM.comp_for) {\n                    /* It's a dictionary comprehension. */\n                    if (is_dict) {\n                        ast_error(c, n,\n                                \"dict unpacking cannot be used in dict comprehension\");\n                        return null;\n                    }\n                    res = ast_for_dictcomp(c, ch);\n                }\n                else {\n                    /* It's a dictionary display. */\n                    res = ast_for_dictdisplay(c, ch);\n                }\n                return copy_location(res, n);\n            }\n        }\n        default:\n            Sk.assert.fail(\"unhandled atom \" + TYPE(ch));\n            return null;\n    }\n}\n\nfunction ast_for_setdisplay(c, n) {\n    var i;\n    var elts = [];\n\n    Sk.asserts.assert(TYPE(n) === SYM.dictorsetmaker);\n\n    for (i = 0; i < NCH(n); i += 2) {\n        var expression;\n        expression = ast_for_expr(c, CHILD(n, i));\n        elts[i / 2] = expression;\n    }\n\n    return new Sk.astnodes.Set(elts, LINENO(n), n.col_offset);\n}\n\n\nfunction astForAtom(c, n) {\n    /* atom: '(' [yield_expr|testlist_comp] ')' | '[' [testlist_comp] ']'\n       | '{' [dictmaker|testlist_comp] '}' | NAME | NUMBER | STRING+\n       | '...' | 'None' | 'True' | 'False'\n    */\n    var i;\n    var values;\n    var keys;\n    var size;\n    var ch = CHILD(n, 0);\n    var elts;\n    switch (ch.type) {\n        case TOK.T_NAME:\n            var s = ch.value;\n            // All names start in Load context, but may be changed later\n            if (s.length >= 4 && s.length <= 5) {\n                if (s === \"None\") {\n                    return new Sk.astnodes.NameConstant(Sk.builtin.none.none$, n.lineno, n.col_offset /* c.c_arena*/);\n                }\n\n                if (s === \"True\") {\n                    return new Sk.astnodes.NameConstant(Sk.builtin.bool.true$, n.lineno, n.col_offset /* c.c_arena*/);\n                }\n\n                if (s === \"False\") {\n                    return new Sk.astnodes.NameConstant(Sk.builtin.bool.false$, n.lineno, n.col_offset /* c.c_arena*/);\n                }\n\n            }\n            var name = new_identifier(s, c)\n\n            /* All names start in Load context, but may later be changed. */\n            return new Sk.astnodes.Name(name, Sk.astnodes.Load, n.lineno, n.col_offset);\n        case TOK.T_STRING:\n            return new Sk.astnodes.Str(parsestrplus(c, n), n.lineno, n.col_offset);\n        case TOK.T_NUMBER:\n            return new Sk.astnodes.Num(parsenumber(c, ch.value, n.lineno), n.lineno, n.col_offset);\n        case TOK.T_LPAR: // various uses for parens\n            ch = CHILD(n, 1);\n            if (ch.type === TOK.T_RPAR) {\n                return new Sk.astnodes.Tuple([], Sk.astnodes.Load, n.lineno, n.col_offset);\n            }\n            if (ch.type === SYM.yield_expr) {\n                return ast_for_expr(c, ch);\n            }\n            //            if (NCH(ch) > 1 && CHILD(ch, 1).type === SYM.comp_for) {\n            //                return astForComprehension(c, ch);\n            //            }\n            return ast_for_testlistComp(c, ch);\n        case TOK.T_LSQB: // list or listcomp\n            ch = CHILD(n, 1);\n            if (ch.type === TOK.T_RSQB) {\n                return new Sk.astnodes.List([], Sk.astnodes.Load, n.lineno, n.col_offset);\n            }\n            REQ(ch, SYM.listmaker);\n            if (NCH(ch) === 1 || CHILD(ch, 1).type === TOK.T_COMMA) {\n                return new Sk.astnodes.List(seq_for_testlist(c, ch), Sk.astnodes.Load, n.lineno, n.col_offset);\n            }\n            return ast_for_listcomp(c, ch);\n\n        case TOK.T_LBRACE:\n            /* dictorsetmaker:\n             *     (test ':' test (comp_for : (',' test ':' test)* [','])) |\n             *     (test (comp_for | (',' test)* [',']))\n             */\n            keys = [];\n            values = [];\n            ch = CHILD(n, 1);\n            if (n.type === TOK.T_RBRACE) {\n                //it's an empty dict\n                return new Sk.astnodes.Dict([], null, n.lineno, n.col_offset);\n            }\n            else if (NCH(ch) === 1 || (NCH(ch) !== 0 && CHILD(ch, 1).type === TOK.T_COMMA)) {\n                //it's a simple set\n                elts = [];\n                size = Math.floor((NCH(ch) + 1) / 2);\n                for (i = 0; i < NCH(ch); i += 2) {\n                    var expression = ast_for_expr(c, CHILD(ch, i));\n                    elts[i / 2] = expression;\n                }\n                return new Sk.astnodes.Set(elts, n.lineno, n.col_offset);\n            }\n            else if (NCH(ch) !== 0 && CHILD(ch, 1).type == SYM.comp_for) {\n                //it's a set comprehension\n                return ast_for_setcomp(c, ch);\n            }\n            else if (NCH(ch) > 3 && CHILD(ch, 3).type === SYM.comp_for) {\n                //it's a dict compr. I think.\n                return ast_for_dictcomp(c, ch);\n            }\n            else {\n                size = Math.floor((NCH(ch) + 1) / 4); // + 1 for no trailing comma case\n                for (i = 0; i < NCH(ch); i += 4) {\n                    keys[i / 4] = ast_for_expr(c, CHILD(ch, i));\n                    values[i / 4] = ast_for_expr(c, CHILD(ch, i + 2));\n                }\n                return new Sk.astnodes.Dict(keys, values, n.lineno, n.col_offset);\n            }\n        case TOK.T_BACKQUOTE:\n            //throw new Sk.builtin.SyntaxError(\"backquote not supported, use repr()\", c.c_filename, n.lineno);\n            return new Sk.astnodes.Repr(ast_for_testlist(c, CHILD(n, 1)), n.lineno, n.col_offset);\n        default:\n            Sk.asserts.fail(\"unhandled atom\", ch.type);\n\n    }\n}\n\nfunction astForAtomExpr(c, n) {\n    var i, nch, start = 0;\n    var e, tmp;\n\n    REQ(n, SYM.atom_expr);\n    nch = NCH(n);\n\n    if (CHILD(n, 0).type === TOK.T_AWAIT) {\n        start = 1;\n        Sk.asserts.assert(nch > 1);\n    }\n\n    e = ast_for_atom(c, CHILD(n, start));\n    if (!e) {\n        return null;\n    }\n\n    if (nch === 1) {\n        return e;\n    }\n\n    if (start && nch === 2) {\n        return new Sk.astnodes.Await(e, n.lineno, n.col_offset /*, c->c_arena*/);\n    }\n\n    for (i = start + 1; i < nch; i++) {\n        var ch = CHILD(n, i);\n        if (ch.type !== SYM.trailer) {\n            break;\n        }\n        tmp = ast_for_trailer(c, ch, e);\n        if (!tmp) {\n            return null;\n        }\n\n        tmp.lineno = e.lineno;\n        tmp.col_offset = e.col_offset;\n        e = tmp;\n    }\n\n    if (start) {\n        /* there was an AWAIT */\n        return new Sk.astnodes.Await(e, n.line, n.col_offset /*, c->c_arena*/);\n    }\n    else {\n        return e;\n    }\n}\n\nfunction astForPower (c, n) {\n    /* power: atom trailer* ('**' factor)*\n     */\n    var f;\n    var tmp;\n    var ch;\n    var i;\n    var e;\n    REQ(n, SYM.power);\n    e = astForAtomExpr(c, CHILD(n, 0));\n    if (NCH(n) === 1) {\n        return e;\n    }\n    if (CHILD(n, NCH(n) - 1).type === SYM.factor) {\n        f = ast_for_expr(c, CHILD(n, NCH(n) - 1));\n        e = new Sk.astnodes.BinOp(e, Sk.astnodes.Pow, f, n.lineno, n.col_offset);\n    }\n    return e;\n}\n\nfunction astForStarred(c, n) {\n    REQ(n, SYM.star_expr);\n\n    /* The Load context is changed later */\n    return new Sk.astnodes.Starred(ast_for_expr(c, CHILD(n ,1)), Sk.astnodes.Load, n.lineno, n.col_offset /*, c.c_arena */)\n}\n\nfunction ast_for_expr (c, n) {\n    /*\n     handle the full range of simple expressions\n     test: or_test ['if' or_test 'else' test] | lambdef\n     test_nocond: or_test | lambdef_nocond\n     or_test: and_test ('or' and_test)*\n     and_test: not_test ('and' not_test)*\n     not_test: 'not' not_test | comparison\n     comparison: expr (comp_op expr)*\n     expr: xor_expr ('|' xor_expr)*\n     xor_expr: and_expr ('^' and_expr)*\n     and_expr: shift_expr ('&' shift_expr)*\n     shift_expr: arith_expr (('<<'|'>>') arith_expr)*\n     arith_expr: term (('+'|'-') term)*\n     term: factor (('*'|'/'|'%'|'//') factor)*\n     factor: ('+'|'-'|'~') factor | power\n     power: atom_expr ['**' factor]\n     atom_expr: [AWAIT] atom trailer*\n     yield_expr: 'yield' [yield_arg]\n    */\n\n    var exp;\n    var cmps;\n    var ops;\n    var i;\n    var seq;\n    LOOP: while (true) {\n        switch (n.type) {\n            case SYM.test:\n            case SYM.test_nocond:\n                if (CHILD(n, 0).type === SYM.lambdef || CHILD(n, 0).type === SYM.lambdef_nocond) {\n                    return astForLambdef(c, CHILD(n, 0));\n                }\n                else if (NCH(n) > 1) {\n                    return astForIfexpr(c, n);\n                }\n                // fallthrough\n            case SYM.or_test:\n            case SYM.and_test:\n                if (NCH(n) === 1) {\n                    n = CHILD(n, 0);\n                    continue LOOP;\n                }\n                seq = [];\n                for (i = 0; i < NCH(n); i += 2) {\n                    seq[i / 2] = ast_for_expr(c, CHILD(n, i));\n                }\n                if (CHILD(n, 1).value === \"and\") {\n                    return new Sk.astnodes.BoolOp(Sk.astnodes.And, seq, n.lineno, n.col_offset /*, c.c_arena*/);\n                }\n                Sk.asserts.assert(CHILD(n, 1).value === \"or\");\n                return new Sk.astnodes.BoolOp(Sk.astnodes.Or, seq, n.lineno, n.col_offset);\n            case SYM.not_test:\n                if (NCH(n) === 1) {\n                    n = CHILD(n, 0);\n                    continue LOOP;\n                }\n                else {\n                    return new Sk.astnodes.UnaryOp(Sk.astnodes.Not, ast_for_expr(c, CHILD(n, 1)), n.lineno, n.col_offset);\n                }\n                break;\n            case SYM.comparison:\n                if (NCH(n) === 1) {\n                    n = CHILD(n, 0);\n                    continue LOOP;\n                }\n                else {\n                    ops = [];\n                    cmps = [];\n                    for (i = 1; i < NCH(n); i += 2) {\n                        ops[(i - 1) / 2] = astForCompOp(c, CHILD(n, i));\n                        cmps[(i - 1) / 2] = ast_for_expr(c, CHILD(n, i + 1));\n                    }\n                    return new Sk.astnodes.Compare(ast_for_expr(c, CHILD(n, 0)), ops, cmps, n.lineno, n.col_offset);\n                }\n                break;\n            case SYM.star_expr:\n                return astForStarred(c, n);\n            /* The next fize cases all handle BinOps  The main body of code\n               is the same in each case, but the switch turned inside out to\n               reuse the code for each type of operator\n             */\n            case SYM.expr:\n            case SYM.xor_expr:\n            case SYM.and_expr:\n            case SYM.shift_expr:\n            case SYM.arith_expr:\n            case SYM.term:\n                if (NCH(n) === 1) {\n                    n = CHILD(n, 0);\n                    continue LOOP;\n                }\n                return astForBinop(c, n);\n            case SYM.yield_expr:\n                var an;\n                var en\n                var is_from = false;\n                exp = null;\n                if (NCH(n) > 1) {\n                    an = CHILD(n, 1); /* yield_arg */\n                }\n\n                if (an) {\n                    en = CHILD(an, NCH(an) - 1);\n                    if (NCH(an) == 2) {\n                        is_from = true;\n                        exp = ast_for_expr(c, en);\n                    } else {\n                        exp = ast_for_testlist(c, en);\n                    }\n                }\n\n                if (is_from) {\n                    return new Sk.astnodes.YieldFrom(exp, n.lineno, n.col_offset);\n                }\n\n                return new Sk.astnodes.Yield(exp, n.lineno, n.col_offset);\n            case SYM.factor:\n                if (NCH(n) === 1) {\n                    n = CHILD(n, 0);\n                    continue LOOP;\n                }\n                return astForFactor(c, n);\n            case SYM.power:\n                return astForPower(c, n);\n            default:\n                Sk.asserts.fail(\"unhandled expr\", \"n.type: %d\", n.type);\n        }\n        break;\n    }\n}\n\nfunction astForNonLocalStmt(c, n) {\n    ast_error(c, n, \"Not implemented: nonlocal\");\n}\n\nfunction astForAsyncStmt(c, n) {\n    ast_error(c, n, \"Not implemented: async\");\n}\n\n// This is only used for Python 2 support.\nfunction astForPrintStmt (c, n) {\n\n    if (Sk.__future__.print_function) {\n        ast_error(c, n, \"Missing parentheses in call to 'print'\");\n    }\n\n    /* print_stmt: 'print' ( [ test (',' test)* [','] ]\n     | '>>' test [ (',' test)+ [','] ] )\n     */\n    var nl;\n    var i, j;\n    var seq;\n    var start = 1;\n    var dest = null;\n    REQ(n, SYM.print_stmt);\n    if (NCH(n) >= 2 && CHILD(n, 1).type === TOK.T_RIGHTSHIFT) {\n        dest = ast_for_expr(c, CHILD(n, 2));\n        start = 4;\n    }\n    seq = [];\n    for (i = start, j = 0; i < NCH(n); i += 2, ++j) {\n        seq[j] = ast_for_expr(c, CHILD(n, i));\n    }\n    nl = (CHILD(n, NCH(n) - 1)).type === TOK.T_COMMA ? false : true;\n    return new Sk.astnodes.Print(dest, seq, nl, n.lineno, n.col_offset);\n}\n\nfunction astForStmt (c, n) {\n    var ch;\n    if (n.type === SYM.stmt) {\n        Sk.asserts.assert(NCH(n) === 1);\n        n = CHILD(n, 0);\n    }\n    if (n.type === SYM.simple_stmt) {\n        Sk.asserts.assert(numStmts(n) === 1);\n        n = CHILD(n, 0);\n    }\n    if (n.type === SYM.small_stmt) {\n        n = CHILD(n, 0);\n        /* small_stmt: expr_stmt | del_stmt | pass_stmt | flow_stmt\n                   | import_stmt | global_stmt | nonlocal_stmt | assert_stmt\n                   | debugger_stmt (skulpt special)\n        */\n        switch (n.type) {\n            case SYM.expr_stmt:\n                return ast_for_exprStmt(c, n);\n            case SYM.del_stmt:\n                return astForDelStmt(c, n);\n            case SYM.pass_stmt:\n                return new Sk.astnodes.Pass(n.lineno, n.col_offset);\n            case SYM.flow_stmt:\n                return ast_for_flow_stmt(c, n);\n            case SYM.import_stmt:\n                return astForImportStmt(c, n);\n            case SYM.global_stmt:\n                return astForGlobalStmt(c, n);\n            case SYM.nonlocal_stmt:\n                return astForNonLocalStmt(c, n);\n            case SYM.assert_stmt:\n                return astForAssertStmt(c, n);\n            case SYM.print_stmt:\n                return astForPrintStmt(c, n);\n            case SYM.debugger_stmt:\n                return new Sk.astnodes.Debugger(n.lineno, n.col_offset);\n            default:\n                Sk.asserts.fail(\"unhandled small_stmt\");\n        }\n    }\n    else {\n        /* compound_stmt: if_stmt | while_stmt | for_stmt | try_stmt\n                        | funcdef | classdef | decorated | async_stmt\n        */\n        ch = CHILD(n, 0);\n        REQ(n, SYM.compound_stmt);\n        switch (ch.type) {\n            case SYM.if_stmt:\n                return astForIfStmt(c, ch);\n            case SYM.while_stmt:\n                return astForWhileStmt(c, ch);\n            case SYM.for_stmt:\n                return astForForStmt(c, ch);\n            case SYM.try_stmt:\n                return astForTryStmt(c, ch);\n            case SYM.with_stmt:\n                return ast_for_with_stmt(c, ch);\n            case SYM.funcdef:\n                return ast_for_funcdef(c, ch, []);\n            case SYM.classdef:\n                return astForClassdef(c, ch, []);\n            case SYM.decorated:\n                return ast_for_decorated(c, ch);\n            case SYM.async_stmt:\n                return astForAsyncStmt(c, ch);\n            default:\n                Sk.asserts.assert(\"unhandled compound_stmt\");\n        }\n    }\n};\n\nSk.astFromParse = function (n, filename, c_flags) {\n    var j;\n    var num;\n    var ch;\n    var i;\n    var c = new Compiling(\"utf-8\", filename, c_flags);\n    var stmts = [];\n    var k = 0;\n    switch (n.type) {\n        case SYM.file_input:\n            for (i = 0; i < NCH(n) - 1; ++i) {\n                ch = CHILD(n, i);\n                if (n.type === TOK.T_NEWLINE) {\n                    continue;\n                }\n                REQ(ch, SYM.stmt);\n                num = numStmts(ch);\n                if (num === 1) {\n                    stmts[k++] = astForStmt(c, ch);\n                }\n                else {\n                    ch = CHILD(ch, 0);\n                    REQ(ch, SYM.simple_stmt);\n                    for (j = 0; j < num; ++j) {\n                        stmts[k++] = astForStmt(c, CHILD(ch, j * 2));\n                    }\n                }\n            }\n            return new Sk.astnodes.Module(stmts);\n        case SYM.eval_input:\n            Sk.asserts.fail(\"todo;\");\n        case SYM.single_input:\n            Sk.asserts.fail(\"todo;\");\n        default:\n            Sk.asserts.fail(\"todo;\");\n    }\n};\n\nSk.astDump = function (node) {\n    var spaces = function (n) // todo; blurgh\n    {\n        var i;\n        var ret = \"\";\n        for (i = 0; i < n; ++i) {\n            ret += \" \";\n        }\n        return ret;\n    };\n\n    var _format = function (node, indent) {\n        var ret;\n        var elemsstr;\n        var x;\n        var elems;\n        var fieldstr;\n        var field;\n        var attrs;\n        var fieldlen;\n        var b;\n        var a;\n        var i;\n        var fields;\n        var namelen;\n        if (node === null) {\n            return indent + \"None\";\n        }\n        else if (node.prototype && node.prototype._astname !== undefined && node.prototype._isenum) {\n            return indent + node.prototype._astname + \"()\";\n        }\n        else if (node._astname !== undefined) {\n            namelen = spaces(node._astname.length + 1);\n            fields = [];\n            for (i = 0; i < node._fields.length; i += 2) // iter_fields\n            {\n                a = node._fields[i]; // field name\n                b = node._fields[i + 1](node); // field getter func\n                fieldlen = spaces(a.length + 1);\n                fields.push([a, _format(b, indent + namelen + fieldlen)]);\n            }\n            attrs = [];\n            for (i = 0; i < fields.length; ++i) {\n                field = fields[i];\n                attrs.push(field[0] + \"=\" + field[1].replace(/^\\s+/, \"\"));\n            }\n            fieldstr = attrs.join(\",\\n\" + indent + namelen);\n            return indent + node._astname + \"(\" + fieldstr + \")\";\n        }\n        else if (Sk.isArrayLike(node)) {\n            //Sk.debugout(\"arr\", node.length);\n            elems = [];\n            for (i = 0; i < node.length; ++i) {\n                x = node[i];\n                elems.push(_format(x, indent + \" \"));\n            }\n            elemsstr = elems.join(\",\\n\");\n            return indent + \"[\" + elemsstr.replace(/^\\s+/, \"\") + \"]\";\n        }\n        else {\n            if (node === true) {\n                ret = \"True\";\n            }\n            else if (node === false) {\n                ret = \"False\";\n            }\n            else if (node instanceof Sk.builtin.lng) {\n                ret = node.tp$str().v;\n            }\n            else if (node instanceof Sk.builtin.str) {\n                ret = node[\"$r\"]().v;\n            }\n            else {\n                ret = \"\" + node;\n            }\n            return indent + ret;\n        }\n    };\n\n    return _format(node, \"\");\n};\n\nSk.exportSymbol(\"Sk.astFromParse\", Sk.astFromParse);\nSk.exportSymbol(\"Sk.astDump\", Sk.astDump);\n","/* Flags for def-use information */\n\nvar DEF_GLOBAL = 1;\n/* global stmt */\nvar DEF_LOCAL = 2;\n/* assignment in code block */\nvar DEF_PARAM = 2 << 1;\n/* formal parameter */\nvar USE = 2 << 2;\n/* name is used */\nvar DEF_STAR = 2 << 3;\n/* parameter is star arg */\nvar DEF_DOUBLESTAR = 2 << 4;\n/* parameter is star-star arg */\nvar DEF_INTUPLE = 2 << 5;\n/* name defined in tuple in parameters */\nvar DEF_FREE = 2 << 6;\n/* name used but not defined in nested block */\nvar DEF_FREE_GLOBAL = 2 << 7;\n/* free variable is actually implicit global */\nvar DEF_FREE_CLASS = 2 << 8;\n/* free variable from class's method */\nvar DEF_IMPORT = 2 << 9;\n/* assignment occurred via import */\n\nvar DEF_BOUND = (DEF_LOCAL | DEF_PARAM | DEF_IMPORT);\n\n/* GLOBAL_EXPLICIT and GLOBAL_IMPLICIT are used internally by the symbol\n table.  GLOBAL is returned from PyST_GetScope() for either of them.\n It is stored in ste_symbols at bits 12-14.\n */\nvar SCOPE_OFF = 11;\nvar SCOPE_MASK = 7;\n\nvar LOCAL = 1;\nvar GLOBAL_EXPLICIT = 2;\nvar GLOBAL_IMPLICIT = 3;\nvar FREE = 4;\nvar CELL = 5;\n\n/* The following three names are used for the ste_unoptimized bit field */\nvar OPT_IMPORT_STAR = 1;\nvar OPT_EXEC = 2;\nvar OPT_BARE_EXEC = 4;\nvar OPT_TOPLEVEL = 8;\n/* top-level names, including eval and exec */\n\nvar GENERATOR = 2;\nvar GENERATOR_EXPRESSION = 2;\n\nvar ModuleBlock = \"module\";\nvar FunctionBlock = \"function\";\nvar ClassBlock = \"class\";\n\nvar SYMTAB_CONSTS = {\n    DEF_GLOBAL: DEF_GLOBAL,\n    DEF_LOCAL: DEF_LOCAL,\n    DEF_PARAM: DEF_PARAM,\n    USE: USE,\n    DEF_STAR: DEF_STAR,\n    DEF_DOUBLESTAR: DEF_DOUBLESTAR,\n    DEF_INTUPLE: DEF_INTUPLE,\n    DEF_FREE: DEF_FREE,\n    DEF_FREE_GLOBAL: DEF_FREE_GLOBAL,\n    DEF_FREE_CLASS: DEF_FREE_CLASS,\n    DEF_IMPORT: DEF_IMPORT,\n    DEF_BOUND: DEF_BOUND,\n    SCOPE_OFF: SCOPE_OFF,\n    SCOPE_MASK: SCOPE_MASK,\n    LOCAL: LOCAL,\n    GLOBAL_EXPLICIT: GLOBAL_EXPLICIT,\n    GLOBAL_IMPLICIT: GLOBAL_IMPLICIT,\n    FREE: FREE,\n    CELL: CELL,\n    OPT_IMPORT_STAR: OPT_IMPORT_STAR,\n    OPT_EXEC: OPT_EXEC,\n    OPT_BARE_EXEC: OPT_BARE_EXEC,\n    OPT_TOPLEVEL: OPT_TOPLEVEL,\n    GENERATOR: GENERATOR,\n    GENERATOR_EXPRESSION: GENERATOR_EXPRESSION,\n    ModuleBlock: ModuleBlock,\n    FunctionBlock: FunctionBlock,\n    ClassBlock: ClassBlock\n};\n\nSk.exportSymbol(\"Sk.SYMTAB_CONSTS\", SYMTAB_CONSTS);\n\n/**\n * @constructor\n * @param {string} name\n * @param {number} flags\n * @param {Array.<SymbolTableScope>} namespaces\n */\nfunction Symbol_ (name, flags, namespaces) {\n    this.__name = name;\n    this.__flags = flags;\n    this.__scope = (flags >> SCOPE_OFF) & SCOPE_MASK;\n    this.__namespaces = namespaces || [];\n}\nSymbol_.prototype.get_name = function () {\n    return this.__name;\n};\nSymbol_.prototype.is_referenced = function () {\n    return !!(this.__flags & USE);\n};\nSymbol_.prototype.is_parameter = function () {\n    return !!(this.__flags & DEF_PARAM);\n};\nSymbol_.prototype.is_global = function () {\n    return this.__scope === GLOBAL_IMPLICIT || this.__scope == GLOBAL_EXPLICIT;\n};\nSymbol_.prototype.is_declared_global = function () {\n    return this.__scope == GLOBAL_EXPLICIT;\n};\nSymbol_.prototype.is_local = function () {\n    return !!(this.__flags & DEF_BOUND);\n};\nSymbol_.prototype.is_free = function () {\n    return this.__scope == FREE;\n};\nSymbol_.prototype.is_imported = function () {\n    return !!(this.__flags & DEF_IMPORT);\n};\nSymbol_.prototype.is_assigned = function () {\n    return !!(this.__flags & DEF_LOCAL);\n};\nSymbol_.prototype.is_namespace = function () {\n    return this.__namespaces && this.__namespaces.length > 0;\n};\nSymbol_.prototype.get_namespaces = function () {\n    return this.__namespaces;\n};\n\nvar astScopeCounter = 0;\n\n/**\n * @constructor\n * @param {SymbolTable} table\n * @param {string} name\n * @param {string} type\n * @param {number} lineno\n */\nfunction SymbolTableScope (table, name, type, ast, lineno) {\n    this.symFlags = {};\n    this.name = name;\n    this.varnames = [];\n    this.children = [];\n    this.blockType = type;\n\n    this.isNested = false;\n    this.hasFree = false;\n    this.childHasFree = false;  // true if child block has free vars including free refs to globals\n    this.generator = false;\n    this.varargs = false;\n    this.varkeywords = false;\n    this.returnsValue = false;\n\n    this.lineno = lineno;\n\n    this.table = table;\n\n    if (table.cur && (table.cur.nested || table.cur.blockType === FunctionBlock)) {\n        this.isNested = true;\n    }\n\n    ast.scopeId = astScopeCounter++;\n    table.stss[ast.scopeId] = this;\n\n    // cache of Symbols for returning to other parts of code\n    this.symbols = {};\n}\nSymbolTableScope.prototype.get_type = function () {\n    return this.blockType;\n};\nSymbolTableScope.prototype.get_name = function () {\n    return this.name;\n};\nSymbolTableScope.prototype.get_lineno = function () {\n    return this.lineno;\n};\nSymbolTableScope.prototype.is_nested = function () {\n    return this.isNested;\n};\nSymbolTableScope.prototype.has_children = function () {\n    return this.children.length > 0;\n};\nSymbolTableScope.prototype.get_identifiers = function () {\n    return this._identsMatching(function () {\n        return true;\n    });\n};\nSymbolTableScope.prototype.lookup = function (name) {\n    var namespaces;\n    var flags;\n    var sym;\n    if (!this.symbols.hasOwnProperty(name)) {\n        flags = this.symFlags[name];\n        namespaces = this.__check_children(name);\n        sym = this.symbols[name] = new Symbol_(name, flags, namespaces);\n    }\n    else {\n        sym = this.symbols[name];\n    }\n    return sym;\n};\nSymbolTableScope.prototype.__check_children = function (name) {\n    //print(\"  check_children:\", name);\n    var child;\n    var i;\n    var ret = [];\n    for (i = 0; i < this.children.length; ++i) {\n        child = this.children[i];\n        if (child.name === name) {\n            ret.push(child);\n        }\n    }\n    return ret;\n};\n\nSymbolTableScope.prototype._identsMatching = function (f) {\n    var k;\n    var ret = [];\n    for (k in this.symFlags) {\n        if (this.symFlags.hasOwnProperty(k)) {\n            if (f(this.symFlags[k])) {\n                ret.push(k);\n            }\n        }\n    }\n    ret.sort();\n    return ret;\n};\nSymbolTableScope.prototype.get_parameters = function () {\n    Sk.asserts.assert(this.get_type() == \"function\", \"get_parameters only valid for function scopes\");\n    if (!this._funcParams) {\n        this._funcParams = this._identsMatching(function (x) {\n            return x & DEF_PARAM;\n        });\n    }\n    return this._funcParams;\n};\nSymbolTableScope.prototype.get_locals = function () {\n    Sk.asserts.assert(this.get_type() == \"function\", \"get_locals only valid for function scopes\");\n    if (!this._funcLocals) {\n        this._funcLocals = this._identsMatching(function (x) {\n            return x & DEF_BOUND;\n        });\n    }\n    return this._funcLocals;\n};\nSymbolTableScope.prototype.get_globals = function () {\n    Sk.asserts.assert(this.get_type() == \"function\", \"get_globals only valid for function scopes\");\n    if (!this._funcGlobals) {\n        this._funcGlobals = this._identsMatching(function (x) {\n            var masked = (x >> SCOPE_OFF) & SCOPE_MASK;\n            return masked == GLOBAL_IMPLICIT || masked == GLOBAL_EXPLICIT;\n        });\n    }\n    return this._funcGlobals;\n};\nSymbolTableScope.prototype.get_frees = function () {\n    Sk.asserts.assert(this.get_type() == \"function\", \"get_frees only valid for function scopes\");\n    if (!this._funcFrees) {\n        this._funcFrees = this._identsMatching(function (x) {\n            var masked = (x >> SCOPE_OFF) & SCOPE_MASK;\n            return masked == FREE;\n        });\n    }\n    return this._funcFrees;\n};\nSymbolTableScope.prototype.get_methods = function () {\n    var i;\n    var all;\n    Sk.asserts.assert(this.get_type() == \"class\", \"get_methods only valid for class scopes\");\n    if (!this._classMethods) {\n        // todo; uniq?\n        all = [];\n        for (i = 0; i < this.children.length; ++i) {\n            all.push(this.children[i].name);\n        }\n        all.sort();\n        this._classMethods = all;\n    }\n    return this._classMethods;\n};\nSymbolTableScope.prototype.getScope = function (name) {\n    //print(\"getScope\");\n    //for (var k in this.symFlags) print(k);\n    var v = this.symFlags[name];\n    if (v === undefined) {\n        return 0;\n    }\n    return (v >> SCOPE_OFF) & SCOPE_MASK;\n};\n\n/**\n * @constructor\n * @param {string} filename\n */\nfunction SymbolTable (filename) {\n    this.filename = filename;\n    this.cur = null;\n    this.top = null;\n    this.stack = [];\n    this.global = null; // points at top level module symFlags\n    this.curClass = null; // current class or null\n    this.tmpname = 0;\n\n    // mapping from ast nodes to their scope if they have one. we add an\n    // id to the ast node when a scope is created for it, and store it in\n    // here for the compiler to lookup later.\n    this.stss = {};\n}\nSymbolTable.prototype.getStsForAst = function (ast) {\n    var v;\n    Sk.asserts.assert(ast.scopeId !== undefined, \"ast wasn't added to st?\");\n    v = this.stss[ast.scopeId];\n    Sk.asserts.assert(v !== undefined, \"unknown sym tab entry\");\n    return v;\n};\n\nSymbolTable.prototype.SEQStmt = function (nodes) {\n    var val;\n    var i;\n    var len;\n    if (nodes !== null) {\n        Sk.asserts.assert(Sk.isArrayLike(nodes), \"SEQ: nodes isn't array? got \" + nodes.toString());\n        len = nodes.length;\n        for (i = 0; i < len; ++i) {\n            val = nodes[i];\n            if (val) {\n                this.visitStmt(val);\n            }\n        }\n    }\n};\n\nSymbolTable.prototype.SEQExpr = function (nodes) {\n    var val;\n    var i;\n    var len;\n    if (nodes !== null) {\n        Sk.asserts.assert(Sk.isArrayLike(nodes), \"SEQ: nodes isn't array? got \" + nodes.toString());\n        len = nodes.length;\n        for (i = 0; i < len; ++i) {\n            val = nodes[i];\n            if (val) {\n                this.visitExpr(val);\n            }\n        }\n    }\n};\n\nSymbolTable.prototype.enterBlock = function (name, blockType, ast, lineno) {\n    var prev;\n    name = Sk.fixReservedNames(name);\n    //print(\"enterBlock:\", name);\n    prev = null;\n    if (this.cur) {\n        prev = this.cur;\n        this.stack.push(this.cur);\n    }\n    this.cur = new SymbolTableScope(this, name, blockType, ast, lineno);\n    if (name === \"top\") {\n        this.global = this.cur.symFlags;\n    }\n    if (prev) {\n        //print(\"    adding\", this.cur.name, \"to\", prev.name);\n        prev.children.push(this.cur);\n    }\n};\n\nSymbolTable.prototype.exitBlock = function () {\n    //print(\"exitBlock\");\n    this.cur = null;\n    if (this.stack.length > 0) {\n        this.cur = this.stack.pop();\n    }\n};\n\nSymbolTable.prototype.visitParams = function (args, toplevel) {\n    var arg;\n    var i;\n    for (i = 0; i < args.length; ++i) {\n        arg = args[i];\n        if (arg.constructor === Sk.astnodes.arg) {\n            // TODO arguments are more complicated in Python 3...\n            this.addDef(arg.arg, DEF_PARAM, arg.lineno);\n        }\n        else {\n            // Tuple isn't supported\n            throw new Sk.builtin.SyntaxError(\"invalid expression in parameter list\", this.filename);\n        }\n    }\n};\n\nSymbolTable.prototype.visitArguments = function (a, lineno) {\n    if (a.args) {\n        this.visitParams(a.args, true);\n    }\n    if (a.kwonlyargs) {\n        this.visitParams(a.kwonlyargs, true);\n    }\n    if (a.vararg) {\n        this.addDef(a.vararg.arg, DEF_PARAM, lineno);\n        this.cur.varargs = true;\n    }\n    if (a.kwarg) {\n        this.addDef(a.kwarg.arg, DEF_PARAM, lineno);\n        this.cur.varkeywords = true;\n    }\n};\n\nSymbolTable.prototype.newTmpname = function (lineno) {\n    this.addDef(new Sk.builtin.str(\"_[\" + (++this.tmpname) + \"]\"), DEF_LOCAL, lineno);\n};\n\nSymbolTable.prototype.addDef = function (name, flag, lineno) {\n    var fromGlobal;\n    var val;\n    var mangled = Sk.mangleName(this.curClass, new Sk.builtin.str(name)).v;\n    mangled = Sk.fixReservedNames(mangled);\n    val = this.cur.symFlags[mangled];\n    if (val !== undefined) {\n        if ((flag & DEF_PARAM) && (val & DEF_PARAM)) {\n            throw new Sk.builtin.SyntaxError(\"duplicate argument '\" + name.v + \"' in function definition\", this.filename, lineno);\n        }\n        val |= flag;\n    }\n    else {\n        val = flag;\n    }\n    this.cur.symFlags[mangled] = val;\n    if (flag & DEF_PARAM) {\n        this.cur.varnames.push(mangled);\n    }\n    else if (flag & DEF_GLOBAL) {\n        val = flag;\n        fromGlobal = this.global[mangled];\n        if (fromGlobal !== undefined) {\n            val |= fromGlobal;\n        }\n        this.global[mangled] = val;\n    }\n};\n\nSymbolTable.prototype.visitSlice = function (s) {\n    var i;\n    switch (s.constructor) {\n        case Sk.astnodes.Slice:\n            if (s.lower) {\n                this.visitExpr(s.lower);\n            }\n            if (s.upper) {\n                this.visitExpr(s.upper);\n            }\n            if (s.step) {\n                this.visitExpr(s.step);\n            }\n            break;\n        case Sk.astnodes.ExtSlice:\n            for (i = 0; i < s.dims.length; ++i) {\n                this.visitSlice(s.dims[i]);\n            }\n            break;\n        case Sk.astnodes.Index:\n            this.visitExpr(s.value);\n            break;\n        case Sk.astnodes.Ellipsis:\n            break;\n    }\n};\n\nSymbolTable.prototype.visitStmt = function (s) {\n    var cur;\n    var name;\n    var i;\n    var nameslen;\n    var tmp;\n    Sk.asserts.assert(s !== undefined, \"visitStmt called with undefined\");\n    switch (s.constructor) {\n        case Sk.astnodes.FunctionDef:\n            this.addDef(s.name, DEF_LOCAL, s.lineno);\n            if (s.args.defaults) {\n                this.SEQExpr(s.args.defaults);\n            }\n            if (s.decorator_list) {\n                this.SEQExpr(s.decorator_list);\n            }\n            this.enterBlock(s.name.v, FunctionBlock, s, s.lineno);\n            this.visitArguments(s.args, s.lineno);\n            this.SEQStmt(s.body);\n            this.exitBlock();\n            break;\n        case Sk.astnodes.ClassDef:\n            this.addDef(s.name, DEF_LOCAL, s.lineno);\n            this.SEQExpr(s.bases);\n            if (s.decorator_list) {\n                this.SEQExpr(s.decorator_list);\n            }\n            this.enterBlock(s.name.v, ClassBlock, s, s.lineno);\n            tmp = this.curClass;\n            this.curClass = s.name;\n            this.SEQStmt(s.body);\n            this.exitBlock();\n            break;\n        case Sk.astnodes.Return:\n            if (s.value) {\n                this.visitExpr(s.value);\n                this.cur.returnsValue = true;\n                if (this.cur.generator) {\n                    throw new Sk.builtin.SyntaxError(\"'return' with argument inside generator\", this.filename);\n                }\n            }\n            break;\n        case Sk.astnodes.Delete:\n            this.SEQExpr(s.targets);\n            break;\n        case Sk.astnodes.Assign:\n            this.SEQExpr(s.targets);\n            this.visitExpr(s.value);\n            break;\n        case Sk.astnodes.AugAssign:\n            this.visitExpr(s.target);\n            this.visitExpr(s.value);\n            break;\n        case Sk.astnodes.Print:\n            if (s.dest) {\n                this.visitExpr(s.dest);\n            }\n            this.SEQExpr(s.values);\n            break;\n        case Sk.astnodes.For:\n            this.visitExpr(s.target);\n            this.visitExpr(s.iter);\n            this.SEQStmt(s.body);\n            if (s.orelse) {\n                this.SEQStmt(s.orelse);\n            }\n            break;\n        case Sk.astnodes.While:\n            this.visitExpr(s.test);\n            this.SEQStmt(s.body);\n            if (s.orelse) {\n                this.SEQStmt(s.orelse);\n            }\n            break;\n        case Sk.astnodes.If:\n            this.visitExpr(s.test);\n            this.SEQStmt(s.body);\n            if (s.orelse) {\n                this.SEQStmt(s.orelse);\n            }\n            break;\n        case Sk.astnodes.Raise:\n            if (s.exc) {\n                this.visitExpr(s.exc);\n                // Our hacked AST supports both Python 2 (inst, tback)\n                // and Python 3 (cause) versions of the Raise statement\n                if (s.inst) {\n                    this.visitExpr(s.inst);\n                    if (s.tback) {\n                        this.visitExpr(s.tback);\n                    }\n                }\n                if (s.cause) {\n                    this.visitExpr(s.cause);\n                }\n            }\n            break;\n        case Sk.astnodes.Assert:\n            this.visitExpr(s.test);\n            if (s.msg) {\n                this.visitExpr(s.msg);\n            }\n            break;\n        case Sk.astnodes.Import:\n        case Sk.astnodes.ImportFrom:\n            this.visitAlias(s.names, s.lineno);\n            break;\n        case Sk.astnodes.Global:\n            nameslen = s.names.length;\n            for (i = 0; i < nameslen; ++i) {\n                name = Sk.mangleName(this.curClass, s.names[i]).v;\n                name = Sk.fixReservedNames(name);\n                cur = this.cur.symFlags[name];\n                if (cur & (DEF_LOCAL | USE)) {\n                    if (cur & DEF_LOCAL) {\n                        throw new Sk.builtin.SyntaxError(\"name '\" + name + \"' is assigned to before global declaration\", this.filename, s.lineno);\n                    }\n                    else {\n                        throw new Sk.builtin.SyntaxError(\"name '\" + name + \"' is used prior to global declaration\", this.filename, s.lineno);\n                    }\n                }\n                this.addDef(new Sk.builtin.str(name), DEF_GLOBAL, s.lineno);\n            }\n            break;\n        case Sk.astnodes.Expr:\n            this.visitExpr(s.value);\n            break;\n        case Sk.astnodes.Pass:\n        case Sk.astnodes.Break:\n        case Sk.astnodes.Continue:\n        case Sk.astnodes.Debugger:\n            // nothing\n            break;\n        case Sk.astnodes.With:\n            VISIT_SEQ(this.visit_withitem.bind(this), s.items);\n            VISIT_SEQ(this.visitStmt.bind(this), s.body);\n            break;\n\n        case Sk.astnodes.Try:\n            this.SEQStmt(s.body);\n            this.visitExcepthandlers(s.handlers)\n            this.SEQStmt(s.orelse);\n            this.SEQStmt(s.finalbody);\n            break;\n\n        default:\n            Sk.asserts.fail(\"Unhandled type \" + s.constructor.name + \" in visitStmt\");\n    }\n};\n\nSymbolTable.prototype.visit_withitem = function(item) {\n    this.visitExpr(item.context_expr);\n    if (item.optional_vars) {\n        this.visitExpr(item.optional_vars);\n    }\n}\n\n\nfunction VISIT_SEQ(visitFunc, seq) {\n    var i;\n    for (i = 0; i < seq.length; i++) {\n        var elt = seq[i];\n        visitFunc(elt)\n    }\n}\n\nSymbolTable.prototype.visitExpr = function (e) {\n    var i;\n    Sk.asserts.assert(e !== undefined, \"visitExpr called with undefined\");\n    // console.log(\"  e: \", e.constructor.name);\n    switch (e.constructor) {\n        case Sk.astnodes.BoolOp:\n            this.SEQExpr(e.values);\n            break;\n        case Sk.astnodes.BinOp:\n            this.visitExpr(e.left);\n            this.visitExpr(e.right);\n            break;\n        case Sk.astnodes.UnaryOp:\n            this.visitExpr(e.operand);\n            break;\n        case Sk.astnodes.Lambda:\n            this.addDef(new Sk.builtin.str(\"lambda\"), DEF_LOCAL, e.lineno);\n            if (e.args.defaults) {\n                this.SEQExpr(e.args.defaults);\n            }\n            this.enterBlock(\"lambda\", FunctionBlock, e, e.lineno);\n            this.visitArguments(e.args, e.lineno);\n            this.visitExpr(e.body);\n            this.exitBlock();\n            break;\n        case Sk.astnodes.IfExp:\n            this.visitExpr(e.test);\n            this.visitExpr(e.body);\n            this.visitExpr(e.orelse);\n            break;\n        case Sk.astnodes.Dict:\n            this.SEQExpr(e.keys);\n            this.SEQExpr(e.values);\n            break;\n        case Sk.astnodes.DictComp:\n        case Sk.astnodes.SetComp:\n            this.visitComprehension(e.generators, 0);\n            break;\n        case Sk.astnodes.ListComp:\n            this.newTmpname(e.lineno);\n            this.visitExpr(e.elt);\n            this.visitComprehension(e.generators, 0);\n            break;\n        case Sk.astnodes.GeneratorExp:\n            this.visitGenexp(e);\n            break;\n        case Sk.astnodes.Yield:\n            if (e.value) {\n                this.visitExpr(e.value);\n            }\n            this.cur.generator = true;\n            if (this.cur.returnsValue) {\n                throw new Sk.builtin.SyntaxError(\"'return' with argument inside generator\", this.filename);\n            }\n            break;\n        case Sk.astnodes.Compare:\n            this.visitExpr(e.left);\n            this.SEQExpr(e.comparators);\n            break;\n        case Sk.astnodes.Call:\n            this.visitExpr(e.func);\n            if (e.args) {\n                for (let a of e.args) {\n                    if (a.constructor === Sk.astnodes.Starred) {\n                        this.visitExpr(a.value);\n                    } else {\n                        this.visitExpr(a);\n                    }\n                }\n            }\n            if (e.keywords) {\n                for (let k of e.keywords) {\n                    this.visitExpr(k.value);\n                }\n            }\n            break;\n        case Sk.astnodes.Num:\n        case Sk.astnodes.Str:\n            break;\n        case Sk.astnodes.Attribute:\n            this.visitExpr(e.value);\n            break;\n        case Sk.astnodes.Subscript:\n            this.visitExpr(e.value);\n            this.visitSlice(e.slice);\n            break;\n        case Sk.astnodes.Name:\n            this.addDef(e.id, e.ctx === Sk.astnodes.Load ? USE : DEF_LOCAL, e.lineno);\n            break;\n        case Sk.astnodes.NameConstant:\n            break;\n        case Sk.astnodes.List:\n        case Sk.astnodes.Tuple:\n        case Sk.astnodes.Set:\n            this.SEQExpr(e.elts);\n            break;\n        case Sk.astnodes.Starred:\n            this.visitExpr(e.value);\n            break;\n        default:\n            Sk.asserts.fail(\"Unhandled type \" + e.constructor.name + \" in visitExpr\");\n    }\n};\n\nSymbolTable.prototype.visitComprehension = function (lcs, startAt) {\n    var lc;\n    var i;\n    var len = lcs.length;\n    for (i = startAt; i < len; ++i) {\n        lc = lcs[i];\n        this.visitExpr(lc.target);\n        this.visitExpr(lc.iter);\n        this.SEQExpr(lc.ifs);\n    }\n};\n\nSymbolTable.prototype.visitAlias = function (names, lineno) {\n    /* Compute store_name, the name actually bound by the import\n     operation.  It is diferent than a->name when a->name is a\n     dotted package name (e.g. spam.eggs)\n     */\n    var dot;\n    var storename;\n    var name;\n    var a;\n    var i;\n    for (i = 0; i < names.length; ++i) {\n        a = names[i];\n        name = a.asname === null ? a.name.v : a.asname.v;\n        storename = name;\n        dot = name.indexOf(\".\");\n        if (dot !== -1) {\n            storename = name.substr(0, dot);\n        }\n        if (name !== \"*\") {\n            this.addDef(new Sk.builtin.str(storename), DEF_IMPORT, lineno);\n        }\n        else {\n            if (this.cur.blockType !== ModuleBlock) {\n                throw new Sk.builtin.SyntaxError(\"import * only allowed at module level\", this.filename);\n            }\n        }\n    }\n};\n\nSymbolTable.prototype.visitGenexp = function (e) {\n    var outermost = e.generators[0];\n    // outermost is evaled in current scope\n    this.visitExpr(outermost.iter);\n    this.enterBlock(\"genexpr\", FunctionBlock, e, e.lineno);\n    this.cur.generator = true;\n    this.addDef(new Sk.builtin.str(\".0\"), DEF_PARAM, e.lineno);\n    this.visitExpr(outermost.target);\n    this.SEQExpr(outermost.ifs);\n    this.visitComprehension(e.generators, 1);\n    this.visitExpr(e.elt);\n    this.exitBlock();\n};\n\nSymbolTable.prototype.visitExcepthandlers = function (handlers) {\n    var i, eh;\n    for (i = 0; eh = handlers[i]; ++i) {\n        if (eh.type) {\n            this.visitExpr(eh.type);\n        }\n        if (eh.name) {\n            this.visitExpr(eh.name);\n        }\n        this.SEQStmt(eh.body);\n    }\n};\n\nfunction _dictUpdate (a, b) {\n    var kb;\n    for (kb in b) {\n        a[kb] = b[kb];\n    }\n}\n\nSymbolTable.prototype.analyzeBlock = function (ste, bound, free, global) {\n    var c;\n    var i;\n    var childlen;\n    var allfree;\n    var flags;\n    var name;\n    var local = {};\n    var scope = {};\n    var newglobal = {};\n    var newbound = {};\n    var newfree = {};\n\n    if (ste.blockType == ClassBlock) {\n        _dictUpdate(newglobal, global);\n        if (bound) {\n            _dictUpdate(newbound, bound);\n        }\n    }\n\n    for (name in ste.symFlags) {\n        flags = ste.symFlags[name];\n        this.analyzeName(ste, scope, name, flags, bound, local, free, global);\n    }\n\n    if (ste.blockType !== ClassBlock) {\n        if (ste.blockType === FunctionBlock) {\n            _dictUpdate(newbound, local);\n        }\n        if (bound) {\n            _dictUpdate(newbound, bound);\n        }\n        _dictUpdate(newglobal, global);\n    }\n\n    allfree = {};\n    childlen = ste.children.length;\n    for (i = 0; i < childlen; ++i) {\n        c = ste.children[i];\n        this.analyzeChildBlock(c, newbound, newfree, newglobal, allfree);\n        if (c.hasFree || c.childHasFree) {\n            ste.childHasFree = true;\n        }\n    }\n\n    _dictUpdate(newfree, allfree);\n    if (ste.blockType === FunctionBlock) {\n        this.analyzeCells(scope, newfree);\n    }\n    this.updateSymbols(ste.symFlags, scope, bound, newfree, ste.blockType === ClassBlock);\n\n    _dictUpdate(free, newfree);\n};\n\nSymbolTable.prototype.analyzeChildBlock = function (entry, bound, free, global, childFree) {\n    var tempGlobal;\n    var tempFree;\n    var tempBound = {};\n    _dictUpdate(tempBound, bound);\n    tempFree = {};\n    _dictUpdate(tempFree, free);\n    tempGlobal = {};\n    _dictUpdate(tempGlobal, global);\n\n    this.analyzeBlock(entry, tempBound, tempFree, tempGlobal);\n    _dictUpdate(childFree, tempFree);\n};\n\nSymbolTable.prototype.analyzeCells = function (scope, free) {\n    var flags;\n    var name;\n    for (name in scope) {\n        flags = scope[name];\n        if (flags !== LOCAL) {\n            continue;\n        }\n        if (free[name] === undefined) {\n            continue;\n        }\n        scope[name] = CELL;\n        delete free[name];\n    }\n};\n\n/**\n * store scope info back into the st symbols dict. symbols is modified,\n * others are not.\n */\nSymbolTable.prototype.updateSymbols = function (symbols, scope, bound, free, classflag) {\n    var i;\n    var o;\n    var pos;\n    var freeValue;\n    var w;\n    var flags;\n    var name;\n    for (name in symbols) {\n        flags = symbols[name];\n        w = scope[name];\n        flags |= w << SCOPE_OFF;\n        symbols[name] = flags;\n    }\n\n    freeValue = FREE << SCOPE_OFF;\n    pos = 0;\n    for (name in free) {\n        o = symbols[name];\n        if (o !== undefined) {\n            // it could be a free variable in a method of the class that has\n            // the same name as a local or global in the class scope\n            if (classflag && (o & (DEF_BOUND | DEF_GLOBAL))) {\n                i = o | DEF_FREE_CLASS;\n                symbols[name] = i;\n            }\n            // else it's not free, probably a cell\n            continue;\n        }\n        if (bound[name] === undefined) {\n            continue;\n        }\n        symbols[name] = freeValue;\n    }\n};\n\nSymbolTable.prototype.analyzeName = function (ste, dict, name, flags, bound, local, free, global) {\n    if (flags & DEF_GLOBAL) {\n        if (flags & DEF_PARAM) {\n            throw new Sk.builtin.SyntaxError(\"name '\" + name + \"' is local and global\", this.filename, ste.lineno);\n        }\n        dict[name] = GLOBAL_EXPLICIT;\n        global[name] = null;\n        if (bound && bound[name] !== undefined) {\n            delete bound[name];\n        }\n        return;\n    }\n    if (flags & DEF_BOUND) {\n        dict[name] = LOCAL;\n        local[name] = null;\n        delete global[name];\n        return;\n    }\n\n    if (bound && bound[name] !== undefined) {\n        dict[name] = FREE;\n        ste.hasFree = true;\n        free[name] = null;\n    }\n    else if (global && global[name] !== undefined) {\n        dict[name] = GLOBAL_IMPLICIT;\n    }\n    else {\n        if (ste.isNested) {\n            ste.hasFree = true;\n        }\n        dict[name] = GLOBAL_IMPLICIT;\n    }\n};\n\nSymbolTable.prototype.analyze = function () {\n    var free = {};\n    var global = {};\n    this.analyzeBlock(this.top, null, free, global);\n};\n\n/**\n * @param {Object} ast\n * @param {string} filename\n */\nSk.symboltable = function (ast, filename) {\n    var i;\n    var ret = new SymbolTable(filename);\n\n    ret.enterBlock(\"top\", ModuleBlock, ast, 0);\n    ret.top = ret.cur;\n\n    //print(Sk.astDump(ast));\n    for (i = 0; i < ast.body.length; ++i) {\n        ret.visitStmt(ast.body[i]);\n    }\n\n    ret.exitBlock();\n\n    ret.analyze();\n\n    return ret;\n};\n\nSk.dumpSymtab = function (st) {\n    var pyBoolStr = function (b) {\n        return b ? \"True\" : \"False\";\n    }\n    var pyList = function (l) {\n        var i;\n        var ret = [];\n        for (i = 0; i < l.length; ++i) {\n            ret.push(new Sk.builtin.str(l[i])[\"$r\"]().v);\n        }\n        return \"[\" + ret.join(\", \") + \"]\";\n    };\n    var getIdents = function (obj, indent) {\n        var ns;\n        var j;\n        var sub;\n        var nsslen;\n        var nss;\n        var info;\n        var i;\n        var objidentslen;\n        var objidents;\n        var ret;\n        if (indent === undefined) {\n            indent = \"\";\n        }\n        ret = \"\";\n        ret += indent + \"Sym_type: \" + obj.get_type() + \"\\n\";\n        ret += indent + \"Sym_name: \" + obj.get_name() + \"\\n\";\n        ret += indent + \"Sym_lineno: \" + obj.get_lineno() + \"\\n\";\n        ret += indent + \"Sym_nested: \" + pyBoolStr(obj.is_nested()) + \"\\n\";\n        ret += indent + \"Sym_haschildren: \" + pyBoolStr(obj.has_children()) + \"\\n\";\n        if (obj.get_type() === \"class\") {\n            ret += indent + \"Class_methods: \" + pyList(obj.get_methods()) + \"\\n\";\n        }\n        else if (obj.get_type() === \"function\") {\n            ret += indent + \"Func_params: \" + pyList(obj.get_parameters()) + \"\\n\";\n            ret += indent + \"Func_locals: \" + pyList(obj.get_locals()) + \"\\n\";\n            ret += indent + \"Func_globals: \" + pyList(obj.get_globals()) + \"\\n\";\n            ret += indent + \"Func_frees: \" + pyList(obj.get_frees()) + \"\\n\";\n        }\n        ret += indent + \"-- Identifiers --\\n\";\n        objidents = obj.get_identifiers();\n        objidentslen = objidents.length;\n        for (i = 0; i < objidentslen; ++i) {\n            info = obj.lookup(objidents[i]);\n            ret += indent + \"name: \" + info.get_name() + \"\\n\";\n            ret += indent + \"  is_referenced: \" + pyBoolStr(info.is_referenced()) + \"\\n\";\n            ret += indent + \"  is_imported: \" + pyBoolStr(info.is_imported()) + \"\\n\";\n            ret += indent + \"  is_parameter: \" + pyBoolStr(info.is_parameter()) + \"\\n\";\n            ret += indent + \"  is_global: \" + pyBoolStr(info.is_global()) + \"\\n\";\n            ret += indent + \"  is_declared_global: \" + pyBoolStr(info.is_declared_global()) + \"\\n\";\n            ret += indent + \"  is_local: \" + pyBoolStr(info.is_local()) + \"\\n\";\n            ret += indent + \"  is_free: \" + pyBoolStr(info.is_free()) + \"\\n\";\n            ret += indent + \"  is_assigned: \" + pyBoolStr(info.is_assigned()) + \"\\n\";\n            ret += indent + \"  is_namespace: \" + pyBoolStr(info.is_namespace()) + \"\\n\";\n            nss = info.get_namespaces();\n            nsslen = nss.length;\n            ret += indent + \"  namespaces: [\\n\";\n            sub = [];\n            for (j = 0; j < nsslen; ++j) {\n                ns = nss[j];\n                sub.push(getIdents(ns, indent + \"    \"));\n            }\n            ret += sub.join(\"\\n\");\n            ret += indent + \"  ]\\n\";\n        }\n        return ret;\n    };\n    return getIdents(st.top, \"\");\n};\n\nSk.exportSymbol(\"Sk.symboltable\", Sk.symboltable);\nSk.exportSymbol(\"Sk.dumpSymtab\", Sk.dumpSymtab);\n","/** @param {...*} x */\nvar out;\n\nSk.gensymcount = 0;\n\n/**\n * @constructor\n * @param {string} filename\n * @param {SymbolTable} st\n * @param {number} flags\n * @param {boolean=} canSuspend whether compiled code can suspend\n * @param {string=} sourceCodeForAnnotation used to add original source to listing if desired\n */\nfunction Compiler (filename, st, flags, canSuspend, sourceCodeForAnnotation) {\n    this.filename = filename;\n    this.st = st;\n    this.flags = flags;\n    this.canSuspend = canSuspend;\n    this.interactive = false;\n    this.nestlevel = 0;\n\n    this.u = null;\n    this.stack = [];\n\n    this.result = [];\n\n    // this.gensymcount = 0;\n\n    this.allUnits = [];\n\n    this.source = sourceCodeForAnnotation ? sourceCodeForAnnotation.split(\"\\n\") : false;\n}\n\n/**\n * @constructor\n *\n * Stuff that changes on entry/exit of code blocks. must be saved and restored\n * when returning to a block.\n *\n * Corresponds to the body of a module, class, or function.\n */\n\nfunction CompilerUnit () {\n    this.ste = null;\n    this.name = null;\n    this.canSuspend = false;\n    this.doesSuspend = false;\n\n    this.private_ = null;\n    this.firstlineno = 0;\n    this.lineno = 0;\n    this.linenoSet = false;\n    this.localnames = [];\n\n    this.localtemps = [];\n    this.tempsToSave = [];\n\n    this.blocknum = 0;\n    this.blocks = [];\n    this.curblock = 0;\n\n    this.consts = {};\n\n    this.scopename = null;\n\n    this.prefixCode = \"\";\n    this.varDeclsCode = \"\";\n    this.switchCode = \"\";\n    this.suffixCode = \"\";\n\n    // stack of where to go on a break\n    this.breakBlocks = [];\n    // stack of where to go on a continue\n    this.continueBlocks = [];\n    this.exceptBlocks = [];\n    // state of where to go on a return\n    this.finallyBlocks = [];\n}\n\nCompilerUnit.prototype.activateScope = function () {\n    var self = this;\n\n    out = function () {\n        var i;\n        var b = self.blocks[self.curblock];\n        if (b._next === null) {\n            for (i = 0; i < arguments.length; ++i) {\n                b.push(arguments[i]);\n            }\n        }\n        // TODO: Warn about unreachable code after an unconditional jump?\n    };\n};\n\nCompiler.prototype.getSourceLine = function (lineno) {\n    Sk.asserts.assert(this.source);\n    return this.source[lineno - 1];\n};\n\nCompiler.prototype.annotateSource = function (ast) {\n    var i;\n    var col_offset;\n    var lineno;\n    if (this.source) {\n        lineno = ast.lineno;\n        col_offset = ast.col_offset;\n        out(\"\\n//\\n// line \", lineno, \":\\n// \", this.getSourceLine(lineno), \"\\n// \");\n        for (i = 0; i < col_offset; ++i) {\n            out(\" \");\n        }\n        out(\"^\\n//\\n\");\n\n        Sk.asserts.assert(ast.lineno !== undefined && ast.col_offset !== undefined);\n        out(\"$currLineNo = \", lineno, \";\\n$currColNo = \", col_offset, \";\\n\\n\");\n    }\n};\n\nCompiler.prototype.gensym = function (hint) {\n    hint = hint || \"\";\n    hint = \"$\" + hint;\n    hint += Sk.gensymcount++;\n    return hint;\n};\n\nCompiler.prototype.niceName = function (roughName) {\n    return this.gensym(roughName.replace(\"<\", \"\").replace(\">\", \"\").replace(\" \", \"_\"));\n};\n\nvar reservedWords_ = {\n    \"abstract\": true,\n    \"as\": true,\n    \"boolean\": true,\n    \"break\": true,\n    \"byte\": true,\n    \"case\": true,\n    \"catch\": true,\n    \"char\": true,\n    \"class\": true,\n    \"continue\": true,\n    \"const\": true,\n    \"debugger\": true,\n    \"default\": true,\n    \"delete\": true,\n    \"do\": true,\n    \"double\": true,\n    \"else\": true,\n    \"enum\": true,\n    \"export\": true,\n    \"extends\": true,\n    \"false\": true,\n    \"final\": true,\n    \"finally\": true,\n    \"float\": true,\n    \"for\": true,\n    \"function\": true,\n    \"goto\": true,\n    \"if\": true,\n    \"implements\": true,\n    \"import\": true,\n    \"in\": true,\n    \"instanceof\": true,\n    \"int\": true,\n    \"interface\": true,\n    \"is\": true,\n    \"long\": true,\n    \"namespace\": true,\n    \"native\": true,\n    \"new\": true,\n    \"null\": true,\n    \"package\": true,\n    \"private\": true,\n    \"protected\": true,\n    \"public\": true,\n    \"return\": true,\n    \"short\": true,\n    \"static\": true,\n    \"super\": false,\n    \"switch\": true,\n    \"synchronized\": true,\n    \"this\": true,\n    \"throw\": true,\n    \"throws\": true,\n    \"transient\": true,\n    \"true\": true,\n    \"try\": true,\n    \"typeof\": true,\n    \"use\": true,\n    \"var\": true,\n    \"void\": true,\n    \"volatile\": true,\n    \"while\": true,\n    \"with\": true\n};\n\n/**\n * Fix reserved words\n *\n * @param {string} name\n */\nfunction fixReservedWords(name) {\n    if (reservedWords_[name] !== true) {\n        return name;\n    }\n    return name + \"_$rw$\";\n}\n\nvar reservedNames_ = {\n    \"__defineGetter__\": true,\n    \"__defineSetter__\": true,\n    \"apply\": true,\n    \"call\": true,\n    \"eval\": true,\n    \"hasOwnProperty\": true,\n    \"isPrototypeOf\": true,\n    \"__lookupGetter__\": true,\n    \"__lookupSetter__\": true,\n    \"__noSuchMethod__\": true,\n    \"propertyIsEnumerable\": true,\n    \"toSource\": true,\n    \"toLocaleString\": true,\n    \"toString\": true,\n    \"unwatch\": true,\n    \"valueOf\": true,\n    \"watch\": true,\n    \"length\": true,\n    \"name\": true,\n};\n\nfunction fixReservedNames (name) {\n    if (reservedNames_[name]) {\n        return name + \"_$rn$\";\n    }\n    return name;\n}\n\nfunction unfixReserved(name) {\n    return name.replace(/_\\$r[wn]\\$$/, \"\");\n}\n\nfunction mangleName (priv, ident) {\n    var name = ident.v;\n    var strpriv = null;\n\n\n    if (priv === null || name === null || name.charAt(0) !== \"_\" || name.charAt(1) !== \"_\") {\n        return ident;\n    }\n    // don't mangle __id__\n    if (name.charAt(name.length - 1) === \"_\" && name.charAt(name.length - 2) === \"_\") {\n        return ident;\n    }\n    // don't mangle classes that are all _ (obscure much?)\n    strpriv = priv.v;\n    strpriv.replace(/_/g, \"\");\n    if (strpriv === \"\") {\n        return ident;\n    }\n\n    strpriv = priv.v;\n    strpriv.replace(/^_*/, \"\");\n    strpriv = new Sk.builtin.str(\"_\" + strpriv + name);\n    return strpriv;\n}\n\n/**\n * @param {...*} rest\n */\nCompiler.prototype.makeConstant = function (rest) {\n    var i;\n    var v;\n    var val = \"\";\n    var cval;\n\n    // Construct constant value\n    for (i = 0; i < arguments.length; ++i) {\n        val += arguments[i];\n    }\n\n    // Check if we've already defined this exact constant\n    for (var constant in this.u.consts) {\n        if (this.u.consts.hasOwnProperty(constant)) {\n            cval = this.u.consts[constant];\n            if (cval == val) {\n                // We have, just use it\n                return constant;\n            }\n        }\n    }\n\n    // We have not, build new one\n    v = this.u.scopename + \".\" + this.gensym(\"const\");\n    this.u.consts[v] = val;\n    return v;\n}\n\n/**\n * @param {string} hint basename for gensym\n * @param {...*} rest\n */\nCompiler.prototype._gr = function (hint, rest) {\n    var i;\n    var v = this.gensym(hint);\n    this.u.localtemps.push(v);\n    out(\"var \", v, \"=\");\n    for (i = 1; i < arguments.length; ++i) {\n        out(arguments[i]);\n    }\n    out(\";\");\n    return v;\n};\n\n/**\n * Function to test if an interrupt should occur if the program has been running for too long.\n * This function is executed at every test/branch operation.\n */\nCompiler.prototype.outputInterruptTest = function () { // Added by RNL\n    var output = \"\";\n    if (Sk.execLimit !== null || Sk.yieldLimit !== null && this.u.canSuspend) {\n            output += \"var $dateNow = Date.now();\";\n        if (Sk.execLimit !== null) {\n            output += \"if ($dateNow - Sk.execStart > Sk.execLimit) {throw new Sk.builtin.TimeLimitError(Sk.timeoutMsg())}\";\n        }\n        if (Sk.yieldLimit !== null && this.u.canSuspend) {\n            output += \"if ($dateNow - Sk.lastYield > Sk.yieldLimit) {\";\n            output += \"var $susp = $saveSuspension({data: {type: 'Sk.yield'}, resume: function() {}}, '\"+this.filename+\"',$currLineNo,$currColNo);\";\n            output += \"$susp.$blk = $blk;\";\n            output += \"$susp.optional = true;\";\n            output += \"return $susp;\";\n            output += \"}\";\n            this.u.doesSuspend = true;\n        }\n    }\n    return output;\n};\n\nCompiler.prototype._jumpfalse = function (test, block) {\n    var cond = this._gr(\"jfalse\", \"(\", test, \"===false||!Sk.misceval.isTrue(\", test, \"))\");\n    out(\"if(\", cond, \"){/*test failed */$blk=\", block, \";continue;}\");\n};\n\nCompiler.prototype._jumpundef = function (test, block) {\n    out(\"if(\", test, \"===undefined){$blk=\", block, \";continue;}\");\n};\n\nCompiler.prototype._jumpnotundef = function (test, block) {\n    out(\"if(\", test, \"!==undefined){$blk=\", block, \";continue;}\");\n};\n\nCompiler.prototype._jumptrue = function (test, block) {\n    var cond = this._gr(\"jtrue\", \"(\", test, \"===true||Sk.misceval.isTrue(\", test, \"))\");\n    out(\"if(\", cond, \"){/*test passed */$blk=\", block, \";continue;}\");\n};\n\nCompiler.prototype._jump = function (block) {\n    if (this.u.blocks[this.u.curblock]._next === null) {\n        out(\"$blk=\", block, \";\");\n        this.u.blocks[this.u.curblock]._next = block;\n    }\n};\n\n/**\n * @param {Object=} e Object with keys 'lineno' and 'col_offset'\n */\nCompiler.prototype._checkSuspension = function(e) {\n    var retblk;\n    if (this.u.canSuspend) {\n\n        retblk = this.newBlock(\"function return or resume suspension\");\n        this._jump(retblk);\n        this.setBlock(retblk);\n\n        e = e || {lineno: \"$currLineNo\", col_offset: \"$currColNo\"};\n\n        out (\"if ($ret && $ret.$isSuspension) { return $saveSuspension($ret,'\"+this.filename+\"',\"+e.lineno+\",\"+e.col_offset+\"); }\");\n\n        this.u.doesSuspend = true;\n        this.u.tempsToSave = this.u.tempsToSave.concat(this.u.localtemps);\n\n    } else {\n        out (\"if ($ret && $ret.$isSuspension) { $ret = Sk.misceval.retryOptionalSuspensionOrThrow($ret); }\");\n    }\n};\nCompiler.prototype.cunpackstarstoarray = function(elts, permitEndOnly) {\n    if (!elts || elts.length == 0) {\n        return \"[]\";\n    }\n    let arr = this._gr(\"unpack\", \"[]\");\n    let hasStars = false;\n    for (let elt of elts) {\n        if (permitEndOnly && hasStars) {\n            throw new Sk.builtin.SyntaxError(\"Extended argument unpacking is not permitted in Python 2\");\n        }\n        if (elt.constructor !== Sk.astnodes.Starred) {\n            out(arr,\".push(\",this.vexpr(elt),\");\");\n        } else {\n            out(\"$ret = Sk.misceval.iterFor(Sk.abstr.iter(\",this.vexpr(elt.value),\"), function(e) { \",arr,\".push(e); });\");\n            this._checkSuspension();\n            hasStars = true;\n        }\n    }\n    return arr;\n}\n\nCompiler.prototype.ctuplelistorset = function(e, data, tuporlist) {\n    var i;\n    var items;\n    var item;\n    var allconsts;\n    Sk.asserts.assert(tuporlist === \"tuple\" || tuporlist === \"list\" || tuporlist === \"set\");\n\n    let hasStars = false;\n    for (let elt of e.elts) {\n        if (elt.constructor === Sk.astnodes.Starred) { hasStars = true; break; }\n    }\n\n    if (e.ctx === Sk.astnodes.Store) {\n        if (hasStars) {\n            // TODO support this in Python 3 mode\n            throw new Sk.builtin.SyntaxError(\"Tuple unpacking with stars is not supported\");\n        }\n        items = this._gr(\"items\", \"Sk.abstr.sequenceUnpack(\" + data + \",\" + e.elts.length + \")\");\n        for (i = 0; i < e.elts.length; ++i) {\n            this.vexpr(e.elts[i], items + \"[\" + i + \"]\");\n        }\n    }\n    else if (e.ctx === Sk.astnodes.Load || tuporlist === \"set\") { //because set's can't be assigned to.\n\n        if (hasStars) {\n            if (!Sk.__future__.python3) {\n                throw new Sk.builtin.SyntaxError(\"List packing with stars is not supported in Python 2\");\n            }\n            return this._gr(\"load\" + tuporlist, \"new Sk.builtins['\", tuporlist, \"'](\", this.cunpackstarstoarray(e.elts), \")\");\n        }\n        else if (tuporlist === \"tuple\") {\n            allconsts = true;\n            items = [];\n            for (i = 0; i < e.elts.length; ++i) {\n                item = this.vexpr(e.elts[i]);\n\n                // The following is an ugly check to see if item was\n                // turned into a constant.  As vexpr returns a string,\n                // this requires seeing if \"$const\" is contained\n                // within it.  A better solution would require a\n                // change to vexpr, which would be more invasive.\n                if (allconsts && (item.indexOf('$const') == -1)) {\n                    allconsts = false;\n                }\n                items.push(item);\n            }\n\n            if (allconsts) {\n                return this.makeConstant(\"new Sk.builtin.tuple([\" + items + \"])\");\n            } else {\n                for (i = 0; i < items.length; ++i) {\n                    items[i] = this._gr(\"elem\", items[i]);\n                }\n                return this._gr(\"load\" + tuporlist, \"new Sk.builtins['\", tuporlist, \"']([\", items, \"])\");\n            }\n        } else {\n            items = [];\n            for (i = 0; i < e.elts.length; ++i) {\n                items.push(this._gr(\"elem\", this.vexpr(e.elts[i])));\n            }\n            return this._gr(\"load\" + tuporlist, \"new Sk.builtins['\", tuporlist, \"']([\", items, \"])\");\n        }\n    }\n};\n\nCompiler.prototype.cdict = function (e) {\n    var v;\n    var i;\n    var items;\n    items = [];\n    if (e.keys !== null) {\n        Sk.asserts.assert(e.values.length === e.keys.length);\n        for (i = 0; i < e.values.length; ++i) {\n            v = this.vexpr(e.values[i]); // \"backwards\" to match order in cpy\n            items.push(this.vexpr(e.keys[i]));\n            items.push(v);\n        }\n    }\n    return this._gr(\"loaddict\", \"new Sk.builtins['dict']([\", items, \"])\");\n};\n\nCompiler.prototype.clistcomp = function(e) {\n    Sk.asserts.assert(e instanceof Sk.astnodes.ListComp);\n    var tmp = this._gr(\"_compr\", \"new Sk.builtins['list']([])\"); // note: _ is impt. for hack in name mangling (same as cpy)\n    return this.ccompgen(\"list\", tmp, e.generators, 0, e.elt, null, e);\n};\n\nCompiler.prototype.cdictcomp = function(e) {\n    Sk.asserts.assert(e instanceof Sk.astnodes.DictComp);\n    var tmp = this._gr(\"_dcompr\", \"new Sk.builtins.dict([])\");\n    return this.ccompgen(\"dict\", tmp, e.generators, 0, e.value, e.key, e);\n};\n\nCompiler.prototype.csetcomp = function(e) {\n    Sk.asserts.assert(e instanceof Sk.astnodes.SetComp);\n    var tmp = this._gr(\"_setcompr\", \"new Sk.builtins.set([])\");\n    return this.ccompgen(\"set\", tmp, e.generators, 0, e.elt, null, e);\n};\n\nCompiler.prototype.ccompgen = function (type, tmpname, generators, genIndex, value, key, e) {\n    var start = this.newBlock(type + \" comp start\");\n    var skip = this.newBlock(type + \" comp skip\");\n    var anchor = this.newBlock(type + \" comp anchor\");\n\n    var l = generators[genIndex];\n    var toiter = this.vexpr(l.iter);\n    var iter = this._gr(\"iter\", \"Sk.abstr.iter(\", toiter, \")\");\n    var lvalue;\n    var lkey;\n    var ifres;\n    var i;\n    var target;\n    var nexti;\n    var n;\n\n    this._jump(start);\n    this.setBlock(start);\n\n    // load targets\n    out(\"$ret = Sk.abstr.iternext(\", iter, \", true);\");\n\n    this._checkSuspension(e);\n\n    nexti = this._gr(\"next\", \"$ret\");\n    this._jumpundef(nexti, anchor); // todo; this should be handled by StopIteration\n    target = this.vexpr(l.target, nexti);\n\n    n = l.ifs ? l.ifs.length : 0;\n    for (i = 0; i < n; ++i) {\n        ifres = this.vexpr(l.ifs[i]);\n        this._jumpfalse(ifres, start);\n    }\n\n    if (++genIndex < generators.length) {\n        this.ccompgen(type, tmpname, generators, genIndex, value, key, e);\n    }\n\n    if (genIndex >= generators.length) {\n        lvalue = this.vexpr(value);\n        if (type === \"dict\") {\n            lkey = this.vexpr(key);\n            out(tmpname, \".mp$ass_subscript(\", lkey, \",\", lvalue, \");\");\n        }\n        else if (type === \"list\") {\n            out(tmpname, \".v.push(\", lvalue, \");\"); // todo;\n        }\n        else if (type === \"set\") {\n            out(tmpname, \".v.mp$ass_subscript(\", lvalue, \", true);\");\n        }\n        this._jump(skip);\n        this.setBlock(skip);\n    }\n\n    this._jump(start);\n\n    this.setBlock(anchor);\n\n    return tmpname;\n};\n\nCompiler.prototype.cyield = function(e)\n{\n    if (this.u.ste.blockType !== Sk.SYMTAB_CONSTS.FunctionBlock) {\n        throw new SyntaxError(\"'yield' outside function\");\n    }\n    var val = \"null\",\n        nextBlock;\n    if (e.value) {\n        val = this.vexpr(e.value);\n    }\n    nextBlock = this.newBlock(\"after yield\");\n    // return a pair: resume target block and yielded value\n    out(\"return [/*resume*/\", nextBlock, \",/*ret*/\", val, \"];\");\n    this.setBlock(nextBlock);\n    return \"$gen.gi$sentvalue\"; // will either be null if none sent, or the value from gen.send(value)\n};\n\nCompiler.prototype.ccompare = function (e) {\n    var res;\n    var rhs;\n    var i;\n    var fres;\n    var done;\n    var n;\n    var cur;\n    Sk.asserts.assert(e.ops.length === e.comparators.length);\n    cur = this.vexpr(e.left);\n    n = e.ops.length;\n    done = this.newBlock(\"done\");\n    fres = this._gr(\"compareres\", \"null\");\n\n    for (i = 0; i < n; ++i) {\n        rhs = this.vexpr(e.comparators[i]);\n        out(\"$ret = Sk.builtin.bool(Sk.misceval.richCompareBool(\", cur, \",\", rhs, \",'\", e.ops[i].prototype._astname, \"', true));\");\n        this._checkSuspension(e);\n        out(fres, \"=$ret;\");\n        this._jumpfalse(\"$ret\", done);\n        cur = rhs;\n    }\n    this._jump(done);\n    this.setBlock(done);\n    return fres;\n};\n\nCompiler.prototype.ccall = function (e) {\n    var func = this.vexpr(e.func);\n    var kwarray = null;\n    // Okay, here's the deal. We have some set of positional args\n    // and we need to unpack them. We have some set of keyword args\n    // and we need to unpack those too. Then we make a call.\n    // The existing Sk.misceval.call() and .apply() signatures do not\n    // help us here; we do it by hand.\n    // This is less than optimal (yep, that's the @rixner bat-sign),\n    // but should be correct.\n\n    let positionalArgs = this.cunpackstarstoarray(e.args, !Sk.__future__.python3);\n    let keywordArgs = \"undefined\";\n\n    if (e.keywords && e.keywords.length > 0) {\n        let hasStars = false;\n        kwarray = [];\n        for (let kw of e.keywords) {\n            if (hasStars && !Sk.__future__.python3) {\n                throw new SyntaxError(\"Advanced unpacking of function arguments is not supported in Python 2\");\n            }\n            if (kw.arg) {\n                kwarray.push(\"'\" + kw.arg.v + \"'\");\n                kwarray.push(this.vexpr(kw.value));\n            } else {\n                hasStars = true;\n            }\n        }\n        keywordArgs = \"[\" + kwarray.join(\",\") + \"]\";\n        if (hasStars) {\n            keywordArgs = this._gr(\"keywordArgs\", keywordArgs);\n            for (let kw of e.keywords) {\n                if (!kw.arg) {\n                    out(\"$ret = Sk.abstr.mappingUnpackIntoKeywordArray(\",keywordArgs,\",\",this.vexpr(kw.value),\",\",func,\");\");\n                    this._checkSuspension();\n                }\n            }\n        }\n    }\n\n    if (Sk.__future__.super_args && e.func.id && e.func.id.v === \"super\" && positionalArgs === \"[]\") {\n        // make sure there is a self variable\n        // note that it's part of the js API spec: https://developer.mozilla.org/en/docs/Web/API/Window/self\n        // so we should probably add self to the mangling\n        // TODO: feel free to ignore the above\n        out(\"if (typeof self === \\\"undefined\\\" || self.toString().indexOf(\\\"Window\\\") > 0) { throw new Sk.builtin.RuntimeError(\\\"super(): no arguments\\\") };\")\n        positionalArgs = \"[$gbl.__class__,self]\";\n    }\n    if (keywordArgs !== \"undefined\") {\n        out(\"$ret = Sk.misceval.applyOrSuspend(\",func,\",undefined,undefined,\",keywordArgs,\",\",positionalArgs,\");\");\n    } else if (positionalArgs != \"[]\") {\n        out (\"$ret = Sk.misceval.callsimOrSuspendArray(\", func, \", \", positionalArgs, \");\");\n    } else {\n        out (\"$ret = Sk.misceval.callsimOrSuspendArray(\", func, \");\");\n    }\n\n    this._checkSuspension(e);\n\n    return this._gr(\"call\", \"$ret\");\n};\n\nCompiler.prototype.cslice = function (s) {\n    var step;\n    var high;\n    var low;\n    Sk.asserts.assert(s instanceof Sk.astnodes.Slice);\n    if (Sk.__future__.python3) {\n        low = s.lower ? this.vexpr(s.lower) : \"Sk.builtin.none.none$\";\n        high = s.upper ? this.vexpr(s.upper) : \"Sk.builtin.none.none$\";\n        step = s.step ? this.vexpr(s.step) : \"Sk.builtin.none.none$\";\n    } else {\n        // This implements Python 2's idea of slice literals, which is...idiosyncratic.\n        // The rules for when you get None, and when you get an arbitrary integer (0 or maxint)\n        // seem pretty arbitrary. Python 3's are much saner.\n        low = s.lower ? this.vexpr(s.lower) : s.step ? \"Sk.builtin.none.none$\" : \"new Sk.builtin.int_(0)\"; // todo;ideally, these numbers would be constants\n        high = s.upper ? this.vexpr(s.upper) : s.step ? \"Sk.builtin.none.none$\" : \"new Sk.builtin.int_(2147483647)\";\n        step = s.step ? this.vexpr(s.step) : \"Sk.builtin.none.none$\";\n    }\n    return this._gr(\"slice\", \"new Sk.builtins['slice'](\", low, \",\", high, \",\", step, \")\");\n};\n\nCompiler.prototype.eslice = function (dims) {\n    var i;\n    var dimSubs, subs;\n    Sk.asserts.assert(dims instanceof Array);\n    dimSubs = [];\n    for (i = 0; i < dims.length; i++) {\n        dimSubs.push(this.vslicesub(dims[i]));\n    }\n    return this._gr(\"extslice\", \"new Sk.builtins['tuple']([\", dimSubs, \"])\");\n};\n\nCompiler.prototype.vslicesub = function (s) {\n    var subs;\n    switch (s.constructor) {\n        case Sk.astnodes.Index:\n            subs = this.vexpr(s.value);\n            break;\n        case Sk.astnodes.Slice:\n            subs = this.cslice(s);\n            break;\n        case Sk.astnodes.Ellipsis:\n            Sk.asserts.fail(\"todo compile.js Ellipsis;\");\n            break;\n        case Sk.astnodes.ExtSlice:\n            subs = this.eslice(s.dims);\n            break;\n        default:\n            Sk.asserts.fail(\"invalid subscript kind\");\n    }\n    return subs;\n};\n\nCompiler.prototype.vslice = function (s, ctx, obj, dataToStore) {\n    var subs = this.vslicesub(s);\n    return this.chandlesubscr(ctx, obj, subs, dataToStore);\n};\n\nCompiler.prototype.chandlesubscr = function (ctx, obj, subs, data) {\n    if (ctx === Sk.astnodes.Load || ctx === Sk.astnodes.AugLoad) {\n        out(\"$ret = Sk.abstr.objectGetItem(\", obj, \",\", subs, \", true);\");\n        this._checkSuspension();\n        return this._gr(\"lsubscr\", \"$ret\");\n    }\n    else if (ctx === Sk.astnodes.Store || ctx === Sk.astnodes.AugStore) {\n        out(\"$ret = Sk.abstr.objectSetItem(\", obj, \",\", subs, \",\", data, \", true);\");\n        this._checkSuspension();\n    }\n    else if (ctx === Sk.astnodes.Del) {\n        out(\"Sk.abstr.objectDelItem(\", obj, \",\", subs, \");\");\n    }\n    else {\n        Sk.asserts.fail(\"handlesubscr fail\");\n    }\n};\n\nCompiler.prototype.cboolop = function (e) {\n    var expres;\n    var i;\n    var retval;\n    var n;\n    var s;\n    var end;\n    var ifFailed;\n    var jtype;\n    Sk.asserts.assert(e instanceof Sk.astnodes.BoolOp);\n    if (e.op === Sk.astnodes.And) {\n        jtype = this._jumpfalse;\n    }\n    else {\n        jtype = this._jumptrue;\n    }\n    end = this.newBlock(\"end of boolop\");\n    s = e.values;\n    n = s.length;\n    for (i = 0; i < n; ++i) {\n        expres = this.vexpr(s[i]);\n        if (i === 0) {\n            retval = this._gr(\"boolopsucc\", expres);\n        }\n        out(retval, \"=\", expres, \";\");\n        jtype.call(this, expres, end);\n    }\n    this._jump(end);\n    this.setBlock(end);\n    return retval;\n};\n\n\n/**\n *\n * compiles an expression. to 'return' something, it'll gensym a var and store\n * into that var so that the calling code doesn't have avoid just pasting the\n * returned name.\n *\n * @param {Object} e\n * @param {string=} data data to store in a store operation\n * @param {Object=} augvar var to load/store to for augmented assignments like '+='.\n *                  (already vexpr'ed, so we can evaluate it once and reuse for both load and store ops)\n * @param {Object=} augsubs precomputed subscript for augmented assignments like '+='.\n *                  (already vexpr'ed, so we can evaluate it once and reuse for both load and store ops)\n */\nCompiler.prototype.vexpr = function (e, data, augvar, augsubs) {\n    var mangled, mname;\n    var val;\n    var result;\n    var nStr; // used for preserving signs for floats (zeros)\n    if (e.lineno > this.u.lineno) {\n        this.u.lineno = e.lineno;\n        this.u.linenoSet = false;\n    }\n    //this.annotateSource(e);\n    switch (e.constructor) {\n        case Sk.astnodes.BoolOp:\n            return this.cboolop(e);\n        case Sk.astnodes.BinOp:\n            return this._gr(\"binop\", \"Sk.abstr.numberBinOp(\", this.vexpr(e.left), \",\", this.vexpr(e.right), \",'\", e.op.prototype._astname, \"')\");\n        case Sk.astnodes.UnaryOp:\n            return this._gr(\"unaryop\", \"Sk.abstr.numberUnaryOp(\", this.vexpr(e.operand), \",'\", e.op.prototype._astname, \"')\");\n        case Sk.astnodes.Lambda:\n            return this.clambda(e);\n        case Sk.astnodes.IfExp:\n            return this.cifexp(e);\n        case Sk.astnodes.Dict:\n            return this.cdict(e);\n        case Sk.astnodes.ListComp:\n            return this.clistcomp(e);\n        case Sk.astnodes.DictComp:\n            return this.cdictcomp(e);\n        case Sk.astnodes.SetComp:\n            return this.csetcomp(e);\n        case Sk.astnodes.GeneratorExp:\n            return this.cgenexp(e);\n        case Sk.astnodes.Yield:\n            return this.cyield(e);\n        case Sk.astnodes.Compare:\n            return this.ccompare(e);\n        case Sk.astnodes.Call:\n            result = this.ccall(e);\n            // After the function call, we've returned to this line\n            this.annotateSource(e);\n            return result;\n        case Sk.astnodes.Num:\n            if (typeof e.n === \"number\") {\n                return e.n;\n            }\n            else if (e.n instanceof Sk.builtin.int_) {\n                return this.makeConstant(\"new Sk.builtin.int_(\" + e.n.v + \")\");\n            } else if (e.n instanceof Sk.builtin.float_) {\n                // Preserve sign of zero for floats\n                nStr = e.n.v === 0 && 1/e.n.v === -Infinity ? \"-0\" : e.n.v;\n                return this.makeConstant(\"new Sk.builtin.float_(\" + nStr + \")\");\n            }\n            else if (e.n instanceof Sk.builtin.lng) {\n                // long uses the tp$str() method which delegates to nmber.str$ which preserves the sign\n                return this.makeConstant(\"Sk.longFromStr('\" + e.n.tp$str().v + \"')\");\n            }\n            else if (e.n instanceof Sk.builtin.complex) {\n                // preserve sign of zero here too\n                var real_val = e.n.real.v === 0 && 1/e.n.real.v === -Infinity ? \"-0\" : e.n.real.v;\n                var imag_val = e.n.imag.v === 0 && 1/e.n.imag.v === -Infinity ? \"-0\" : e.n.imag.v;\n                return this.makeConstant(\"new Sk.builtin.complex(new Sk.builtin.float_(\" + real_val + \"), new Sk.builtin.float_(\" + imag_val + \"))\");\n            }\n            Sk.asserts.fail(\"unhandled Num type\");\n        case Sk.astnodes.Str:\n            return this.makeConstant(\"new Sk.builtin.str(\", e.s[\"$r\"]().v, \")\");\n        case Sk.astnodes.Attribute:\n            if (e.ctx !== Sk.astnodes.AugLoad && e.ctx !== Sk.astnodes.AugStore) {\n                val = this.vexpr(e.value);\n            }\n            mangled = e.attr[\"$r\"]().v;\n            mangled = mangled.substring(1, mangled.length - 1);\n            mangled = mangleName(this.u.private_, new Sk.builtin.str(mangled)).v;\n            mangled = fixReservedWords(mangled);\n            mangled = fixReservedNames(mangled);\n            mname = this.makeConstant(\"new Sk.builtin.str('\" + mangled + \"')\");\n            switch (e.ctx) {\n                case Sk.astnodes.AugLoad:\n                    out(\"$ret = Sk.abstr.gattr(\", augvar, \",\", mname, \", true);\");\n                    this._checkSuspension(e);\n                    return this._gr(\"lattr\", \"$ret\");\n                case Sk.astnodes.Load:\n                    out(\"$ret = Sk.abstr.gattr(\", val, \",\", mname, \", true);\");\n                    this._checkSuspension(e);\n                    return this._gr(\"lattr\", \"$ret\");\n                case Sk.astnodes.AugStore:\n                    // To be more correct, we shouldn't sattr() again if the in-place update worked.\n                    // At the time of writing (26/Feb/2015), Sk.abstr.numberInplaceBinOp never returns undefined,\n                    // so this will never *not* execute. But it could, if Sk.abstr.numberInplaceBinOp were fixed.\n                    out(\"$ret = undefined;\");\n                    out(\"if(\", data, \"!==undefined){\");\n                    out(\"$ret = Sk.abstr.sattr(\", augvar, \",\", mname, \",\", data, \", true);\");\n                    out(\"}\");\n                    this._checkSuspension(e);\n                    break;\n                case Sk.astnodes.Store:\n                    out(\"$ret = Sk.abstr.sattr(\", val, \",\", mname, \",\", data, \", true);\");\n                    this._checkSuspension(e);\n                    break;\n                case Sk.astnodes.Del:\n                    Sk.asserts.fail(\"todo Del;\");\n                    break;\n                case Sk.astnodes.Param:\n                default:\n                    Sk.asserts.fail(\"invalid attribute expression\");\n            }\n            break;\n        case Sk.astnodes.Subscript:\n            switch (e.ctx) {\n                case Sk.astnodes.AugLoad:\n                    out(\"$ret = Sk.abstr.objectGetItem(\",augvar,\",\",augsubs,\", true);\");\n                    this._checkSuspension(e)\n                    return this._gr(\"gitem\", \"$ret\");\n                case Sk.astnodes.Load:\n                case Sk.astnodes.Store:\n                case Sk.astnodes.Del:\n                    return this.vslice(e.slice, e.ctx, this.vexpr(e.value), data);\n                case Sk.astnodes.AugStore:\n                    // To be more correct, we shouldn't sattr() again if the in-place update worked.\n                    // At the time of writing (26/Feb/2015), Sk.abstr.numberInplaceBinOp never returns undefined,\n                    // so this will never *not* execute. But it could, if Sk.abstr.numberInplaceBinOp were fixed.\n\n                    out(\"$ret=undefined;\");\n                    out(\"if(\", data, \"!==undefined){\");\n                    out(\"$ret=Sk.abstr.objectSetItem(\",augvar,\",\",augsubs,\",\",data,\", true)\");\n                    out(\"}\");\n                    this._checkSuspension(e);\n                    break;\n                case Sk.astnodes.Param:\n                default:\n                    Sk.asserts.fail(\"invalid subscript expression\");\n            }\n            break;\n        case Sk.astnodes.Name:\n            return this.nameop(e.id, e.ctx, data);\n        case Sk.astnodes.NameConstant:\n            if (e.ctx === Sk.astnodes.Store || e.ctx === Sk.astnodes.AugStore || e.ctx === Sk.astnodes.Del) {\n                throw new Sk.builtin.SyntaxError(\"can not assign to a constant name\");\n            }\n\n            switch (e.value) {\n                case Sk.builtin.none.none$:\n                    return \"Sk.builtin.none.none$\";\n                case Sk.builtin.bool.true$:\n                    return \"Sk.builtin.bool.true$\";\n                case Sk.builtin.bool.false$:\n                    return \"Sk.builtin.bool.false$\";\n                default:\n                    Sk.asserts.fail(\"invalid named constant\")\n            }\n            break;\n        case Sk.astnodes.List:\n            return this.ctuplelistorset(e, data, 'list');\n        case Sk.astnodes.Tuple:\n            return this.ctuplelistorset(e, data, 'tuple');\n        case Sk.astnodes.Set:\n            return this.ctuplelistorset(e, data, 'set');\n        case Sk.astnodes.Starred:\n            break;\n        default:\n            Sk.asserts.fail(\"unhandled case \" + e.constructor.name + \" vexpr\");\n    }\n};\n\n/**\n * @param {Array.<Object>} exprs\n * @param {Array.<string>=} data\n */\nCompiler.prototype.vseqexpr = function (exprs, data) {\n    var i;\n    var ret;\n    Sk.asserts.assert(data === undefined || exprs.length === data.length);\n    ret = [];\n\n    // if (exprs.length === 1 && exprs[0].constructor === Sk.astnodes.Starred) {\n    //     exprs = exprs[0].value;\n    // }\n\n    for (i = 0; i < exprs.length; ++i) {\n        ret.push(this.vexpr(exprs[i], data === undefined ? undefined : data[i]));\n    }\n    return ret;\n};\n\nCompiler.prototype.caugassign = function (s) {\n    var to;\n    var augsub;\n    var res;\n    var val;\n    var aug;\n    var auge;\n    var e;\n    Sk.asserts.assert(s instanceof Sk.astnodes.AugAssign);\n    e = s.target;\n    switch (e.constructor) {\n        case Sk.astnodes.Attribute:\n            to = this.vexpr(e.value);\n            auge = new Sk.astnodes.Attribute(e.value, e.attr, Sk.astnodes.AugLoad, e.lineno, e.col_offset);\n            aug = this.vexpr(auge, undefined, to);\n            val = this.vexpr(s.value);\n            res = this._gr(\"inplbinopattr\", \"Sk.abstr.numberInplaceBinOp(\", aug, \",\", val, \",'\", s.op.prototype._astname, \"')\");\n            auge.ctx = Sk.astnodes.AugStore;\n            return this.vexpr(auge, res, to);\n        case Sk.astnodes.Subscript:\n            // Only compile the subscript value once\n            to = this.vexpr(e.value);\n            augsub = this.vslicesub(e.slice);\n            auge = new Sk.astnodes.Subscript(e.value, augsub, Sk.astnodes.AugLoad, e.lineno, e.col_offset);\n            aug = this.vexpr(auge, undefined, to, augsub);\n            val = this.vexpr(s.value);\n            res = this._gr(\"inplbinopsubscr\", \"Sk.abstr.numberInplaceBinOp(\", aug, \",\", val, \",'\", s.op.prototype._astname, \"')\");\n            auge.ctx = Sk.astnodes.AugStore;\n            return this.vexpr(auge, res, to, augsub);\n        case Sk.astnodes.Name:\n            to = this.nameop(e.id, Sk.astnodes.Load);\n            val = this.vexpr(s.value);\n            res = this._gr(\"inplbinop\", \"Sk.abstr.numberInplaceBinOp(\", to, \",\", val, \",'\", s.op.prototype._astname, \"')\");\n            return this.nameop(e.id, Sk.astnodes.Store, res);\n        default:\n            Sk.asserts.fail(\"unhandled case in augassign\");\n    }\n};\n\n/**\n * optimize some constant exprs. returns 0 if always false, 1 if always true or -1 otherwise.\n */\nCompiler.prototype.exprConstant = function (e) {\n    switch (e.constructor) {\n        case Sk.astnodes.Num:\n            return Sk.misceval.isTrue(e.n) ? 1 : 0;\n        case Sk.astnodes.Str:\n            return Sk.misceval.isTrue(e.s) ? 1 : 0;\n        case Sk.astnodes.Name:\n        // todo; do __debug__ test here if opt\n        default:\n            return -1;\n    }\n};\n\nCompiler.prototype.newBlock = function (name) {\n    var ret = this.u.blocknum++;\n    this.u.blocks[ret] = [];\n    this.u.blocks[ret]._name = name || \"<unnamed>\";\n    this.u.blocks[ret]._next = null;\n    return ret;\n};\nCompiler.prototype.setBlock = function (n) {\n    Sk.asserts.assert(n >= 0 && n < this.u.blocknum);\n    this.u.curblock = n;\n};\n\nCompiler.prototype.pushBreakBlock = function (n) {\n    Sk.asserts.assert(n >= 0 && n < this.u.blocknum);\n    this.u.breakBlocks.push(n);\n};\nCompiler.prototype.popBreakBlock = function () {\n    this.u.breakBlocks.pop();\n};\n\nCompiler.prototype.pushContinueBlock = function (n) {\n    Sk.asserts.assert(n >= 0 && n < this.u.blocknum);\n    this.u.continueBlocks.push(n);\n};\nCompiler.prototype.popContinueBlock = function () {\n    this.u.continueBlocks.pop();\n};\n\nCompiler.prototype.pushExceptBlock = function (n) {\n    Sk.asserts.assert(n >= 0 && n < this.u.blocknum);\n    this.u.exceptBlocks.push(n);\n};\nCompiler.prototype.popExceptBlock = function () {\n    this.u.exceptBlocks.pop();\n};\n\nCompiler.prototype.pushFinallyBlock = function (n) {\n    Sk.asserts.assert(n >= 0 && n < this.u.blocknum);\n    Sk.asserts.assert(this.u.breakBlocks.length === this.u.continueBlocks.length);\n    this.u.finallyBlocks.push({blk: n, breakDepth: this.u.breakBlocks.length});\n};\nCompiler.prototype.popFinallyBlock = function () {\n    this.u.finallyBlocks.pop();\n};\nCompiler.prototype.peekFinallyBlock = function() {\n    return (this.u.finallyBlocks.length > 0) ? this.u.finallyBlocks[this.u.finallyBlocks.length-1] : undefined;\n};\n\nCompiler.prototype.setupExcept = function (eb) {\n    out(\"$exc.push(\", eb, \");\");\n    //this.pushExceptBlock(eb);\n};\n\nCompiler.prototype.endExcept = function () {\n    out(\"$exc.pop();\");\n};\n\nCompiler.prototype.outputLocals = function (unit) {\n    var name;\n    var output;\n    var i;\n    var have = {};\n    //print(\"args\", unit.name.v, JSON.stringify(unit.argnames));\n    for (i = 0; unit.argnames && i < unit.argnames.length; ++i) {\n        have[unit.argnames[i]] = true;\n    }\n    unit.localnames.sort();\n    output = [];\n    for (i = 0; i < unit.localnames.length; ++i) {\n        name = unit.localnames[i];\n        if (have[name] === undefined) {\n            output.push(name);\n            have[name] = true;\n        }\n    }\n    if (output.length > 0) {\n        return \"var \" + output.join(\",\") + \"; /* locals */\";\n    }\n    return \"\";\n};\n\nCompiler.prototype.outputSuspensionHelpers = function (unit) {\n    var i, t;\n    var localSaveCode = [];\n    var localsToSave = unit.localnames.concat(unit.tempsToSave);\n    var seenTemps = {};\n    var hasCell = unit.ste.blockType === Sk.SYMTAB_CONSTS.FunctionBlock && unit.ste.childHasFree;\n    var output = (localsToSave.length > 0 ? (\"var \" + localsToSave.join(\",\") + \";\") : \"\") +\n                 \"var $wakeFromSuspension = function() {\" +\n                    \"var susp = \"+unit.scopename+\".$wakingSuspension; \"+unit.scopename+\".$wakingSuspension = undefined;\" +\n                    \"$blk=susp.$blk; $loc=susp.$loc; $gbl=susp.$gbl; $exc=susp.$exc; $err=susp.$err; $postfinally=susp.$postfinally;\" +\n                    \"$currLineNo=susp.$lineno; $currColNo=susp.$colno; Sk.lastYield=Date.now();\" +\n                    (hasCell?\"$cell=susp.$cell;\":\"\");\n\n    for (i = 0; i < localsToSave.length; i++) {\n        t = localsToSave[i];\n        if (seenTemps[t]===undefined) {\n            output += t + \"=susp.$tmps.\" + t + \";\";\n            seenTemps[t] = true;\n        }\n    }\n\n    output +=  \"try { $ret=susp.child.resume(); } catch(err) { if (!(err instanceof Sk.builtin.BaseException)) { err = new Sk.builtin.ExternalError(err); } err.traceback.push({lineno: $currLineNo, colno: $currColNo, filename: '\"+this.filename+\"'}); if($exc.length>0) { $err=err; $blk=$exc.pop(); } else { throw err; } }\" +\n                \"};\";\n\n    output += \"var $saveSuspension = function($child, $filename, $lineno, $colno) {\" +\n                \"var susp = new Sk.misceval.Suspension(); susp.child=$child;\" +\n                \"susp.resume=function(){\"+unit.scopename+\".$wakingSuspension=susp; return \"+unit.scopename+\"(\"+(unit.ste.generator?\"$gen\":\"\")+\"); };\" +\n                \"susp.data=susp.child.data;susp.$blk=$blk;susp.$loc=$loc;susp.$gbl=$gbl;susp.$exc=$exc;susp.$err=$err;susp.$postfinally=$postfinally;\" +\n                \"susp.$filename=$filename;susp.$lineno=$lineno;susp.$colno=$colno;\" +\n                \"susp.optional=susp.child.optional;\" +\n                (hasCell ? \"susp.$cell=$cell;\" : \"\");\n\n    seenTemps = {};\n    for (i = 0; i < localsToSave.length; i++) {\n        t = localsToSave[i];\n        if (seenTemps[t]===undefined) {\n            localSaveCode.push(\"\\\"\" + t + \"\\\":\" + t);\n            seenTemps[t]=true;\n        }\n    }\n    output +=   \"susp.$tmps={\" + localSaveCode.join(\",\") + \"};\" +\n                \"return susp;\" +\n              \"};\";\n\n    return output;\n}\n\nCompiler.prototype.outputAllUnits = function () {\n    var i;\n    var blocks;\n    var unit;\n    var j;\n    var ret = \"\";\n    var block;\n    var generatedBlocks;\n    for (j = 0; j < this.allUnits.length; ++j) {\n        unit = this.allUnits[j];\n        ret += unit.prefixCode;\n        ret += this.outputLocals(unit);\n        if (unit.doesSuspend) {\n            ret += this.outputSuspensionHelpers(unit);\n        }\n        ret += unit.varDeclsCode;\n        ret += unit.switchCode;\n        blocks = unit.blocks;\n        generatedBlocks = Object.create(null);\n        for (i = 0; i < blocks.length; ++i) {\n            block = i;\n            if (block in generatedBlocks)\n                continue;\n            while (true) {\n                generatedBlocks[block] = true;\n\n                ret += \"case \" + block + \": /* --- \" + blocks[block]._name + \" --- */\";\n                ret += blocks[block].join(\"\");\n\n                if (blocks[block]._next !== null) {\n                    if (!(blocks[block]._next in generatedBlocks)) {\n                        ret += \"/* allowing case fallthrough */\";\n                        block = blocks[block]._next;\n                    }\n                    else {\n                        ret += \"/* jump */ continue;\";\n                        break;\n                    }\n                }\n                else {\n                    ret += \"throw new Sk.builtin.SystemError('internal error: unterminated block');\";\n                    break;\n                }\n            }\n        }\n        ret += unit.suffixCode;\n    }\n    return ret;\n};\n\nCompiler.prototype.cif = function (s) {\n    var test;\n    var next;\n    var end;\n    var constant;\n    Sk.asserts.assert(s instanceof Sk.astnodes.If);\n    constant = this.exprConstant(s.test);\n    if (constant === 0) {\n        if (s.orelse && s.orelse.length > 0) {\n            this.vseqstmt(s.orelse);\n        }\n    }\n    else if (constant === 1) {\n        this.vseqstmt(s.body);\n    }\n    else {\n        end = this.newBlock(\"end of if\");\n        if (s.orelse && s.orelse.length > 0) {\n            next = this.newBlock(\"next branch of if\");\n        }\n\n        test = this.vexpr(s.test);\n\n        if (s.orelse && s.orelse.length > 0) {\n            this._jumpfalse(test, next);\n            this.vseqstmt(s.body);\n            this._jump(end);\n\n            this.setBlock(next);\n            this.vseqstmt(s.orelse);\n        }\n        else {\n            this._jumpfalse(test, end);\n            this.vseqstmt(s.body);\n        }\n        this._jump(end);\n        this.setBlock(end);\n    }\n\n};\n\nCompiler.prototype.cwhile = function (s) {\n    var body;\n    var orelse;\n    var next;\n    var top;\n    var constant = this.exprConstant(s.test);\n    if (constant === 0) {\n        if (s.orelse) {\n            this.vseqstmt(s.orelse);\n        }\n    }\n    else {\n        top = this.newBlock(\"while test\");\n        this._jump(top);\n        this.setBlock(top);\n\n        next = this.newBlock(\"after while\");\n        orelse = s.orelse.length > 0 ? this.newBlock(\"while orelse\") : null;\n        body = this.newBlock(\"while body\");\n\n        this.annotateSource(s);\n        this._jumpfalse(this.vexpr(s.test), orelse ? orelse : next);\n        this._jump(body);\n\n        this.pushBreakBlock(next);\n        this.pushContinueBlock(top);\n\n        this.setBlock(body);\n\n        if ((Sk.debugging || Sk.killableWhile) && this.u.canSuspend) {\n            var suspType = 'Sk.delay';\n            var debugBlock = this.newBlock(\"debug breakpoint for line \"+s.lineno);\n            out(\"if (Sk.breakpoints('\"+this.filename+\"',\"+s.lineno+\",\"+s.col_offset+\")) {\",\n                \"var $susp = $saveSuspension({data: {type: '\"+suspType+\"'}, resume: function() {}}, '\"+this.filename+\"',\"+s.lineno+\",\"+s.col_offset+\");\",\n                \"$susp.$blk = \"+debugBlock+\";\",\n                \"$susp.optional = true;\",\n                \"return $susp;\",\n                \"}\");\n            this._jump(debugBlock);\n            this.setBlock(debugBlock);\n            this.u.doesSuspend = true;\n        }\n\n        this.vseqstmt(s.body);\n\n        this._jump(top);\n\n        this.popContinueBlock();\n        this.popBreakBlock();\n\n        if (s.orelse.length > 0) {\n            this.setBlock(orelse);\n            this.vseqstmt(s.orelse);\n            this._jump(next);\n        }\n\n        this.setBlock(next);\n    }\n};\n\nCompiler.prototype.cfor = function (s) {\n    var target;\n    var nexti;\n    var iter;\n    var toiter;\n    var start = this.newBlock(\"for start\");\n    var cleanup = this.newBlock(\"for cleanup\");\n    var end = this.newBlock(\"for end\");\n\n    this.pushBreakBlock(end);\n    this.pushContinueBlock(start);\n\n    // get the iterator\n    toiter = this.vexpr(s.iter);\n    if (this.u.ste.generator) {\n        // if we're in a generator, we have to store the iterator to a local\n        // so it's preserved (as we cross blocks here and assume it survives)\n        iter = \"$loc.\" + this.gensym(\"iter\");\n        out(iter, \"=Sk.abstr.iter(\", toiter, \");\");\n    }\n    else {\n        iter = this._gr(\"iter\", \"Sk.abstr.iter(\", toiter, \")\");\n        this.u.tempsToSave.push(iter); // Save it across suspensions\n    }\n\n    this._jump(start);\n\n    this.setBlock(start);\n\n    // load targets\n    out (\"$ret = Sk.abstr.iternext(\", iter,(this.u.canSuspend?\", true\":\", false\"),\");\");\n\n    this._checkSuspension(s);\n\n    nexti = this._gr(\"next\", \"$ret\");\n    this._jumpundef(nexti, cleanup); // todo; this should be handled by StopIteration\n    target = this.vexpr(s.target, nexti);\n\n    if ((Sk.debugging || Sk.killableFor) && this.u.canSuspend) {\n        var suspType = 'Sk.delay';\n        var debugBlock = this.newBlock(\"debug breakpoint for line \"+s.lineno);\n        out(\"if (Sk.breakpoints('\"+this.filename+\"',\"+s.lineno+\",\"+s.col_offset+\")) {\",\n            \"var $susp = $saveSuspension({data: {type: '\"+suspType+\"'}, resume: function() {}}, '\"+this.filename+\"',\"+s.lineno+\",\"+s.col_offset+\");\",\n            \"$susp.$blk = \"+debugBlock+\";\",\n            \"$susp.optional = true;\",\n            \"return $susp;\",\n            \"}\");\n        this._jump(debugBlock);\n        this.setBlock(debugBlock);\n        this.u.doesSuspend = true;\n    }\n\n    // execute body\n    this.vseqstmt(s.body);\n\n    // jump to top of loop\n    this._jump(start);\n\n    this.setBlock(cleanup);\n    this.popContinueBlock();\n    this.popBreakBlock();\n\n    this.vseqstmt(s.orelse);\n    this._jump(end);\n\n    this.setBlock(end);\n};\n\nCompiler.prototype.craise = function (s) {\n    if (s.exc) {\n        var exc = this._gr(\"exc\", this.vexpr(s.exc));\n        // This is tricky - we're supporting both the weird-ass semantics\n        // of the Python 2 \"raise (exc), (inst), (tback)\" version,\n        // plus the sensible Python \"raise (exc) from (cause)\".\n        // ast.js takes care of ensuring that you can only use the right one\n        // for the Python version you're using.\n\n        var instantiatedException = this.newBlock(\"exception now instantiated\");\n        var isClass = this._gr(\"isclass\", exc + \" instanceof Sk.builtin.type || \" + exc + \".prototype instanceof Sk.builtin.BaseException\");\n        this._jumpfalse(isClass, instantiatedException);\n        //this._jumpfalse(instantiatedException, isClass);\n\n        // Instantiate exc with inst\n        if (s.inst) {\n            var inst = this._gr(\"inst\", this.vexpr(s.inst));\n            out(\"if(!(\",inst,\" instanceof Sk.builtin.tuple)) {\",\n                inst,\"= new Sk.builtin.tuple([\",inst,\"]);\",\n                \"}\");\n            out(\"$ret = Sk.misceval.callsimOrSuspendArray(\",exc,\",\",inst,\".v);\");\n        } else {\n            out(\"$ret = Sk.misceval.callsimOrSuspend(\",exc,\");\");\n        }\n        this._checkSuspension(s);\n        out(exc,\"=$ret;\");\n\n        this._jump(instantiatedException);\n\n        this.setBlock(instantiatedException);\n\n        // TODO TODO TODO set cause appropriately\n        // (and perhaps traceback for py2 if we care before it gets fully deprecated)\n\n        out(\"throw \",exc,\";\");\n    }\n    else {\n        // re-raise\n        out(\"throw $err;\");\n    }\n};\n\nCompiler.prototype.outputFinallyCascade = function (thisFinally) {\n    var nextFinally;\n\n    // What do we do when we're done executing a 'finally' block?\n    // Normally you just fall off the end. If we're 'return'ing,\n    // 'continue'ing or 'break'ing, $postfinally tells us what to do.\n    //\n    // But we might be in a nested pair of 'finally' blocks. If so, we need\n    // to work out whether to jump to the outer finally block.\n    //\n    // (NB we do NOT deal with re-raising exceptions here. That's handled\n    // elsewhere, because 'with' does special things with exceptions.)\n\n    if (this.u.finallyBlocks.length == 0) {\n        // No nested 'finally' block. Easy.\n        out(\"if($postfinally!==undefined) { if ($postfinally.returning) { return $postfinally.returning; } else { $blk=$postfinally.gotoBlock; $postfinally=undefined; continue; } }\");\n    } else {\n\n        // OK, we're nested. Do we jump straight to the outer 'finally' block?\n        // Depends on how we got here here.\n\n        // Normal execution ($postfinally===undefined)? No, we're done here.\n\n        // Returning ($postfinally.returning)? Yes, we want to execute all the\n        // 'finally' blocks on the way out.\n\n        // Breaking ($postfinally.isBreak)? It depends. Is the outer 'finally'\n        // block inside or outside the loop we're breaking out of? We compare\n        // its breakDepth to ours to find out. If we're at the same breakDepth,\n        // we're both inside the innermost loop, so we both need to execute.\n        // ('continue' is the same thing as 'break' for us)\n\n        nextFinally = this.peekFinallyBlock();\n\n        out(\"if($postfinally!==undefined) {\",\n                \"if ($postfinally.returning\",\n                    (nextFinally.breakDepth == thisFinally.breakDepth) ? \"|| $postfinally.isBreak\" : \"\", \") {\",\n\n                        \"$blk=\",nextFinally.blk,\";continue;\",\n                \"} else {\",\n                    \"$blk=$postfinally.gotoBlock;$postfinally=undefined;continue;\",\n                \"}\",\n            \"}\");\n    }\n};\n\nCompiler.prototype.ctry = function (s) {\n    var check;\n    var next;\n    var handlertype;\n    var handler;\n    var end;\n    var orelse;\n    var unhandled;\n    var i;\n    var n = s.handlers.length;\n\n    var finalBody, finalExceptionHandler, finalExceptionToReRaise;\n    var thisFinally;\n\n    if (s.finalbody) {\n        finalBody = this.newBlock(\"finalbody\");\n        finalExceptionHandler = this.newBlock(\"finalexh\")\n        finalExceptionToReRaise = this._gr(\"finally_reraise\", \"undefined\");\n\n        this.u.tempsToSave.push(finalExceptionToReRaise);\n        this.pushFinallyBlock(finalBody);\n        thisFinally = this.peekFinallyBlock();\n        this.setupExcept(finalExceptionHandler);\n    }\n\n    // Create a block for each except clause\n    var handlers = [];\n    for (i = 0; i < n; ++i) {\n        handlers.push(this.newBlock(\"except_\" + i + \"_\"));\n    }\n\n    unhandled = this.newBlock(\"unhandled\");\n    orelse = this.newBlock(\"orelse\");\n    end = this.newBlock(\"end\");\n\n    if (handlers.length != 0) {\n        this.setupExcept(handlers[0]);\n    }\n    this.vseqstmt(s.body);\n    if (handlers.length != 0) {\n        this.endExcept();\n    }\n    this._jump(orelse);\n\n    for (i = 0; i < n; ++i) {\n        this.setBlock(handlers[i]);\n        handler = s.handlers[i];\n        if (!handler.type && i < n - 1) {\n            throw new SyntaxError(\"default 'except:' must be last\");\n        }\n\n        if (handler.type) {\n            // should jump to next handler if err not isinstance of handler.type\n            handlertype = this.vexpr(handler.type);\n            next = (i == n - 1) ? unhandled : handlers[i + 1];\n\n            // var isinstance = this.nameop(new Sk.builtin.str(\"isinstance\"), Load));\n            // var check = this._gr('call', \"Sk.misceval.callsimArray(\", isinstance, \", [$err, \", handlertype, \"])\");\n\n            check = this._gr(\"instance\", \"Sk.misceval.isTrue(Sk.builtin.isinstance($err, \", handlertype, \"))\");\n            this._jumpfalse(check, next);\n        }\n\n        if (handler.name) {\n            this.vexpr(handler.name, \"$err\");\n        }\n\n        this.vseqstmt(handler.body);\n\n        this._jump(end);\n    }\n\n    // If no except clause catches exception, throw it again\n    this.setBlock(unhandled);\n    out(\"throw $err;\");\n\n    this.setBlock(orelse);\n    this.vseqstmt(s.orelse);\n    this._jump(end);\n\n    this.setBlock(end);\n    // End of the try/catch/else segment\n    if (s.finalbody) {\n        this.endExcept();\n\n        this._jump(finalBody);\n\n        this.setBlock(finalExceptionHandler);\n        // Exception handling also goes to the finally body,\n        // stashing the original exception to re-raise\n        out(finalExceptionToReRaise,\"=$err;\");\n        this._jump(finalBody);\n\n        this.setBlock(finalBody);\n        this.popFinallyBlock();\n        this.vseqstmt(s.finalbody);\n        // If finalbody executes normally, AND we have an exception\n        // to re-raise, we raise it.\n        out(\"if(\",finalExceptionToReRaise,\"!==undefined) { throw \",finalExceptionToReRaise,\";}\");\n\n        this.outputFinallyCascade(thisFinally);\n        // Else, we continue from here.\n    }\n};\n\nCompiler.prototype.cwith = function (s, itemIdx) {\n    var mgr, exit, value, exception;\n    var exceptionHandler = this.newBlock(\"withexh\"), tidyUp = this.newBlock(\"withtidyup\");\n    var carryOn = this.newBlock(\"withcarryon\");\n    var thisFinallyBlock;\n\n    // NB this does not *quite* match the semantics in PEP 343, which\n    // specifies \"exit = type(mgr).__exit__\" rather than getattr()ing,\n    // presumably for performance reasons.\n\n    mgr = this._gr(\"mgr\", this.vexpr(s.items[itemIdx].context_expr));\n\n    // exit = mgr.__exit__\n    out(\"$ret = Sk.abstr.gattr(\",mgr,\",Sk.builtin.str.$exit, true);\");\n    this._checkSuspension(s);\n    exit = this._gr(\"exit\", \"$ret\");\n    this.u.tempsToSave.push(exit);\n\n    // value = mgr.__enter__()\n    out(\"$ret = Sk.abstr.gattr(\",mgr,\",Sk.builtin.str.$enter, true);\");\n    this._checkSuspension(s);\n    out(\"$ret = Sk.misceval.callsimOrSuspendArray($ret);\");\n    this._checkSuspension(s);\n    value = this._gr(\"value\", \"$ret\");\n\n    // try:\n    this.pushFinallyBlock(tidyUp);\n    thisFinallyBlock = this.u.finallyBlocks[this.u.finallyBlocks.length-1];\n    this.setupExcept(exceptionHandler);\n\n    //    VAR = value\n    if (s.items[itemIdx].optional_vars) {\n        this.nameop(s.items[itemIdx].optional_vars.id, Sk.astnodes.Store, value);\n    }\n\n    //    (try body)\n\n    if (itemIdx +1 < s.items.length) {\n        // \"with\" statements with multiple items (context managers) are\n        // treated as nested \"with\" statements\n        this.cwith(s, itemIdx + 1);\n    } else {\n        this.vseqstmt(s.body);\n    }\n\n    this.endExcept();\n    this._jump(tidyUp);\n\n    // except:\n    this.setBlock(exceptionHandler);\n\n    //   if not exit(*sys.exc_info()):\n    //     raise\n    out(\"$ret = Sk.misceval.applyOrSuspend(\",exit,\",undefined,Sk.builtin.getExcInfo($err),undefined,[]);\");\n    this._checkSuspension(s);\n    this._jumptrue(\"$ret\", carryOn);\n    out(\"throw $err;\");\n\n    // finally: (kinda. NB that this is a \"finally\" that doesn't run in the\n    //           exception case!)\n    this.setBlock(tidyUp);\n    this.popFinallyBlock();\n\n    //   exit(None, None, None)\n    out(\"$ret = Sk.misceval.callsimOrSuspendArray(\",exit,\",[Sk.builtin.none.none$,Sk.builtin.none.none$,Sk.builtin.none.none$]);\");\n    this._checkSuspension(s);\n    // Ignore $ret.\n\n    this.outputFinallyCascade(thisFinallyBlock);\n\n    this._jump(carryOn);\n\n    this.setBlock(carryOn);\n};\n\nCompiler.prototype.cassert = function (s) {\n    /* todo; warnings method\n     if (s.test instanceof Tuple && s.test.elts.length > 0)\n     Sk.warn(\"assertion is always true, perhaps remove parentheses?\");\n     */\n\n    var test = this.vexpr(s.test);\n    var end = this.newBlock(\"end\");\n    this._jumptrue(test, end);\n    // todo; exception handling\n    // maybe replace with Sk.asserts.fail?? or just an alert?\n    out(\"throw new Sk.builtin.AssertionError(\", s.msg ? this.vexpr(s.msg) : \"\", \");\");\n    this.setBlock(end);\n};\n\nCompiler.prototype.cimportas = function (name, asname, mod) {\n    var attr;\n    var src = name.v;\n    var dotLoc = src.indexOf(\".\");\n    //print(\"src\", src);\n    //print(\"dotLoc\", dotLoc);\n    var cur = mod;\n    if (dotLoc !== -1) {\n        // if there's dots in the module name, __import__ will have returned\n        // the top-level module. so, we need to extract the actual module by\n        // getattr'ing up through the names, and then storing the leaf under\n        // the name it was to be imported as.\n        src = src.substr(dotLoc + 1);\n        //print(\"src now\", src);\n        while (dotLoc !== -1) {\n            dotLoc = src.indexOf(\".\");\n            attr = dotLoc !== -1 ? src.substr(0, dotLoc) : src;\n            cur = this._gr(\"lattr\", \"Sk.abstr.gattr(\", cur, \", new Sk.builtin.str('\", attr, \"'))\");\n            src = src.substr(dotLoc + 1);\n        }\n    }\n    return this.nameop(asname, Sk.astnodes.Store, cur);\n};\n\nCompiler.prototype.cimport = function (s) {\n    var lastDot;\n    var tmp;\n    var mod;\n    var alias;\n    var i;\n    var n = s.names.length;\n    for (i = 0; i < n; ++i) {\n        alias = s.names[i];\n        out(\"$ret = Sk.builtin.__import__(\", alias.name[\"$r\"]().v, \",$gbl,$loc,[],\",(Sk.__future__.absolute_import?0:-1),\");\");\n\n        this._checkSuspension(s);\n\n        mod = this._gr(\"module\", \"$ret\");\n\n        if (alias.asname) {\n            this.cimportas(alias.name, alias.asname, mod);\n        }\n        else {\n            tmp = alias.name;\n            lastDot = tmp.v.indexOf(\".\");\n            if (lastDot !== -1) {\n                tmp = new Sk.builtin.str(tmp.v.substr(0, lastDot));\n            }\n            this.nameop(tmp, Sk.astnodes.Store, mod);\n        }\n    }\n};\n\nCompiler.prototype.cfromimport = function (s) {\n    var storeName;\n    var got;\n    var alias;\n    var aliasOut;\n    var mod;\n    var i;\n    var n = s.names.length;\n    var names = [];\n    var level = s.level;\n    if (level == 0 && !Sk.__future__.absolute_import) {\n        level = -1;\n    }\n    for (i = 0; i < n; ++i) {\n        names[i] = \"'\" + fixReservedWords(s.names[i].name.v) + \"'\";\n    }\n    out(\"$ret = Sk.builtin.__import__(\", s.module[\"$r\"]().v, \",$gbl,$loc,[\", names, \"],\",level,\");\");\n\n    this._checkSuspension(s);\n\n    //out(\"print('__import__ returned ' + $ret);\");\n    //out(\"for (var x in $ret) { print(x); }\");\n    mod = this._gr(\"module\", \"$ret\");\n    for (i = 0; i < n; ++i) {\n        alias = s.names[i];\n        aliasOut = \"'\" + fixReservedWords(alias.name.v) + \"'\";\n        if (i === 0 && alias.name.v === \"*\") {\n            Sk.asserts.assert(n === 1);\n            out(\"Sk.importStar(\", mod, \",$loc, $gbl);\");\n            return;\n        }\n\n        //out(\"print(\\\"getting Sk.abstr.gattr(\", mod, \",\", alias.name[\"$r\"]().v, \")\\\");\");\n        got = this._gr(\"item\", \"Sk.abstr.gattr(\", mod, \", new Sk.builtin.str(\", aliasOut, \"))\");\n        //out(\"print('got');\");\n        storeName = alias.name;\n        if (alias.asname) {\n            storeName = alias.asname;\n        }\n        this.nameop(storeName, Sk.astnodes.Store, got);\n    }\n};\n\n/**\n * builds a code object (js function) for various constructs. used by def,\n * lambda, generator expressions. it isn't used for class because it seemed\n * different enough.\n *\n * handles:\n * - setting up a new scope\n * - decorators (if any)\n * - defaults setup\n * - setup for cell and free vars\n * - setup and modification for generators\n *\n * @param {Object} n ast node to build for\n * @param {Sk.builtin.str} coname name of code object to build\n * @param {Array} decorator_list ast of decorators if any\n * @param {Sk.astnodes.arguments_} args arguments to function, if any\n * @param {Function} callback called after setup to do actual work of function\n * @param {Sk.builtin.str=} class_for_super\n *\n * @returns the name of the newly created function or generator object.\n *\n */\nCompiler.prototype.buildcodeobj = function (n, coname, decorator_list, args, callback, class_for_super) {\n    var containingHasFree;\n    var frees;\n    var argnamesarr = [];\n    var start;\n    var kw;\n    var maxargs;\n    var minargs;\n    var id;\n    var argname;\n    var offset;\n    var cells;\n    var locals;\n    var i;\n    var funcArgs;\n    var entryBlock;\n    var hasCell;\n    var hasFree;\n    var isGenerator;\n    var scopename;\n    var decos = [];\n    var defaults = [];\n    var kw_defaults = [];\n    var vararg = null;\n    var kwarg = null;\n\n    // decorators and defaults have to be evaluated out here before we enter\n    // the new scope. we output the defaults and attach them to this code\n    // object, but only once we know the name of it (so we do it after we've\n    // exited the scope near the end of this function).\n    if (decorator_list) {\n        decos = this.vseqexpr(decorator_list);\n    }\n    if (args && args.defaults) {\n        defaults = this.vseqexpr(args.defaults);\n    }\n    if (args && args.kw_defaults) {\n        kw_defaults = args.kw_defaults.map(e => e ? this.vexpr(e) : 'undefined');\n    }\n    if (args && args.vararg) {\n        vararg = args.vararg;\n    }\n    if (args && args.kwarg) {\n        kwarg = args.kwarg;\n    }\n    if (!Sk.__future__.python3 && args && args.kwonlyargs && args.kwonlyargs.length != 0) {\n        throw new Sk.builtin.SyntaxError(\"Keyword-only arguments are not supported in Python 2\");\n    }\n\n    //\n    // enter the new scope, and create the first block\n    //\n    scopename = this.enterScope(coname, n, n.lineno, this.canSuspend);\n\n    isGenerator = this.u.ste.generator;\n    hasFree = this.u.ste.hasFree;\n    hasCell = this.u.ste.childHasFree;\n\n    entryBlock = this.newBlock(\"codeobj entry\");\n\n    //\n    // the header of the function, and arguments\n    //\n    this.u.prefixCode = \"var \" + scopename + \"=(function \" + this.niceName(coname.v) + \"$(\";\n\n    funcArgs = [];\n    if (isGenerator) {\n        // TODO make generators deal with arguments properly\n        if (kwarg) {\n            throw new SyntaxError(coname.v + \"(): keyword arguments in generators not supported\");\n        }\n        if (vararg) {\n            throw new SyntaxError(coname.v + \"(): variable number of arguments in generators not supported\");\n        }\n        funcArgs.push(\"$gen\");\n    }\n    else {\n        if (kwarg) {\n            funcArgs.push(\"$kwa\");\n            this.u.tempsToSave.push(\"$kwa\");\n        }\n        for (i = 0; args && i < args.args.length; ++i) {\n            funcArgs.push(this.nameop(args.args[i].arg, Sk.astnodes.Param));\n        }\n        for (i = 0; args && args.kwonlyargs && i < args.kwonlyargs.length; ++i) {\n            funcArgs.push(this.nameop(args.kwonlyargs[i].arg, Sk.astnodes.Param));\n        }\n        if (vararg) {\n            funcArgs.push(this.nameop(args.vararg.arg, Sk.astnodes.Param));\n        }\n    }\n    if (hasFree) {\n        funcArgs.push(\"$free\");\n        this.u.tempsToSave.push(\"$free\");\n    }\n\n    this.u.prefixCode += funcArgs.join(\",\");\n\n    this.u.prefixCode += \"){\";\n\n    if (isGenerator) {\n        this.u.prefixCode += \"\\n// generator\\n\";\n    }\n    if (hasFree) {\n        this.u.prefixCode += \"\\n// has free\\n\";\n    }\n    if (hasCell) {\n        this.u.prefixCode += \"\\n// has cell\\n\";\n    }\n\n    //\n    // set up standard dicts/variables\n    //\n    locals = \"{}\";\n    if (isGenerator) {\n        entryBlock = \"$gen.gi$resumeat\";\n        locals = \"$gen.gi$locals\";\n    }\n    cells = \",$cell={}\";\n    if (hasCell) {\n        if (isGenerator) {\n            cells = \",$cell=$gen.gi$cells\";\n        }\n    }\n\n    // note special usage of 'this' to avoid having to slice globals into\n    // all function invocations in call\n    this.u.varDeclsCode += \"var $blk=\" + entryBlock + \",$exc=[],$loc=\" + locals + cells + \",$gbl=this,$err=undefined,$ret=undefined,$postfinally=undefined,$currLineNo=undefined,$currColNo=undefined;\";\n    if (Sk.execLimit !== null) {\n        this.u.varDeclsCode += \"if (typeof Sk.execStart === 'undefined') {Sk.execStart = Date.now()}\";\n    }\n    if (Sk.yieldLimit !== null && this.u.canSuspend) {\n        this.u.varDeclsCode += \"if (typeof Sk.lastYield === 'undefined') {Sk.lastYield = Date.now()}\";\n    }\n\n    //\n    // If there is a suspension, resume from it. Otherwise, initialise\n    // parameters appropriately.\n    //\n    this.u.varDeclsCode += \"if (\"+scopename+\".$wakingSuspension!==undefined) { $wakeFromSuspension(); } else {\";\n\n    // TODO update generators to do their arg checks in outside generated code,\n    // like functions do\n    //\n    // this could potentially get removed if generators would learn to deal with args, kw, kwargs, varargs\n    // initialize default arguments. we store the values of the defaults to\n    // this code object as .$defaults just below after we exit this scope.\n    //\n    if (isGenerator && defaults.length > 0) {\n        // defaults have to be \"right justified\" so if there's less defaults\n        // than args we offset to make them match up (we don't need another\n        // correlation in the ast)\n        offset = args.args.length - defaults.length;\n        for (i = 0; i < defaults.length; ++i) {\n            argname = this.nameop(args.args[i + offset].arg, Sk.astnodes.Param);\n            this.u.varDeclsCode += \"if(\" + argname + \"===undefined)\" + argname + \"=\" + scopename + \".$defaults[\" + i + \"];\";\n        }\n    }\n\n    //\n    // copy all parameters that are also cells into the cells dict. this is so\n    // they can be accessed correctly by nested scopes.\n    //\n    for (i = 0; args && i < args.args.length; ++i) {\n        id = args.args[i].arg;\n        if (this.isCell(id)) {\n            this.u.varDeclsCode += \"$cell.\" + id.v + \"=\" + id.v + \";\";\n        }\n    }\n    for (i = 0; args && args.kwonlyargs && i < args.kwonlyargs.length; ++i) {\n        id = args.kwonlyargs[i].arg;\n        if (this.isCell(id)) {\n            this.u.varDeclsCode += \"$cell.\" + id.v + \"=\" + id.v + \";\";\n        }\n    }\n    if (vararg && this.isCell(vararg.arg)) {\n        this.u.varDeclsCode += \"$cell.\" + vararg.arg.v + \"=\" + vararg.arg.v + \";\";\n    }\n\n    //\n    // initialize kwarg, if any\n    //\n    if (kwarg) {\n        this.u.localnames.push(kwarg.arg.v);\n        this.u.varDeclsCode += kwarg.arg.v + \"=new Sk.builtins['dict']($kwa);\";\n        if (this.isCell(kwarg.arg)) {\n            this.u.varDeclsCode += \"$cell.\" + kwarg.arg.v + \"=\" + kwarg.arg.v + \";\";\n        }\n    }\n\n    //\n    // close the else{} block from the wakingSuspension check\n    //\n    this.u.varDeclsCode += \"}\";\n\n    // inject __class__ cell when running python3\n    if (Sk.python3 && class_for_super) {\n        this.u.varDeclsCode += \"$gbl.__class__=this.\" + class_for_super.v + \";\";\n    }\n\n    // finally, set up the block switch that the jump code expects\n    //\n    // Old switch code\n    // this.u.switchCode += \"while(true){switch($blk){\";\n    // this.u.suffixCode = \"}break;}});\";\n\n    // New switch code to catch exceptions\n    this.u.switchCode = \"while(true){try{\"\n    this.u.switchCode += this.outputInterruptTest();\n    this.u.switchCode += \"switch($blk){\";\n    this.u.suffixCode = \"} }catch(err){ if (!(err instanceof Sk.builtin.BaseException)) { err = new Sk.builtin.ExternalError(err); } err.traceback.push({lineno: $currLineNo, colno: $currColNo, filename: '\"+this.filename+\"'}); if ($exc.length>0) { $err = err; $blk=$exc.pop(); continue; } else { throw err; }} }});\";\n\n    //\n    // jump back to the handler so it can do the main actual work of the\n    // function\n    //\n    callback.call(this, scopename);\n\n    //\n    // get a list of all the argument names (used to attach to the code\n    // object, and also to allow us to declare only locals that aren't also\n    // parameters).\n    if (args) {\n        for (let arg of args.args) {\n            argnamesarr.push(arg.arg.v);\n        }\n        for (let arg of args.kwonlyargs || []) {\n            argnamesarr.push(arg.arg.v);\n        }\n\n        // store to unit so we know what local variables not to declare\n        this.u.argnames = argnamesarr;\n    }\n\n    //\n    // and exit the code object scope\n    //\n    this.exitScope();\n\n    //\n    // attach the default values we evaluated at the beginning to the code\n    // object so that it can get at them to set any arguments that are left\n    // unset.\n    //\n    if (defaults.length > 0) {\n        out(scopename, \".$defaults=[\", defaults.join(\",\"), \"];\");\n    }\n    if (args && args.kwonlyargs && args.kwonlyargs.length > 0) {\n        out(scopename, \".co_argcount=\", args.args.length, \";\");\n        out(scopename, \".co_kwonlyargcount=\", args.kwonlyargs.length, \";\");\n        out(scopename, \".$kwdefs=[\", kw_defaults.join(\",\"), \"];\");\n    }\n\n    if (decos.length > 0) {\n        out(scopename, \".$decorators=[\", decos.join(\",\"), \"];\");\n    }\n\n    //\n    // attach co_varnames (only the argument names) for keyword argument\n    // binding.\n    //\n    if (argnamesarr.length > 0) {\n        out(scopename, \".co_varnames=['\", argnamesarr.join(\"','\"), \"'];\");\n    } else {\n        out(scopename, \".co_varnames=[];\");\n    }\n\n    //\n    // attach flags\n    //\n    if (kwarg) {\n        out(scopename, \".co_kwargs=1;\");\n    }\n    if (vararg) {\n        out(scopename, \".co_varargs=1;\");\n    }\n\n    //\n    // build either a 'function' or 'generator'. the function is just a simple\n    // constructor call. the generator is more complicated. it needs to make a\n    // new generator every time it's called, so the thing that's returned is\n    // actually a function that makes the generator (and passes arguments to\n    // the function onwards to the generator). this should probably actually\n    // be a function object, rather than a js function like it is now. we also\n    // have to build the argument names to pass to the generator because it\n    // needs to store all locals into itself so that they're maintained across\n    // yields.\n    //\n    // todo; possibly this should be outside?\n    //\n    frees = \"\";\n    if (hasFree) {\n        frees = \",$cell\";\n        // if the scope we're in where we're defining this one has free\n        // vars, they may also be cell vars, so we pass those to the\n        // closure too.\n        containingHasFree = this.u.ste.hasFree;\n        if (containingHasFree) {\n            frees += \",$free\";\n        }\n    }\n    if (isGenerator)\n    // Keyword and variable arguments are not currently supported in generators.\n    // The call to pyCheckArgs assumes they can't be true.\n    {\n        if (args && args.args.length > 0) {\n            return this._gr(\"gener\", \"new Sk.builtins['function']((function(){var $origargs=Array.prototype.slice.call(arguments);Sk.builtin.pyCheckArgsLen(\\\"\",\n                coname.v, \"\\\",arguments.length,\", args.args.length - defaults.length, \",\", args.args.length,\n                \");return new Sk.builtins['generator'](\", scopename, \",$gbl,$origargs\", frees, \");}))\");\n        }\n        else {\n            return this._gr(\"gener\", \"new Sk.builtins['function']((function(){Sk.builtin.pyCheckArgsLen(\\\"\", coname.v,\n                \"\\\",arguments.length,0,0);return new Sk.builtins['generator'](\", scopename, \",$gbl,[]\", frees, \");}))\");\n        }\n    }\n    else {\n        var res;\n        if (decos.length > 0) {\n            out(\"$ret = Sk.misceval.callsimOrSuspendArray(\", scopename, \".$decorators[0], [new Sk.builtins['function'](\", scopename, \",$gbl\", frees, \")]);\");\n            this._checkSuspension();\n            return this._gr(\"funcobj\", \"$ret\");\n        }\n\n        return this._gr(\"funcobj\", \"new Sk.builtins['function'](\", scopename, \",$gbl\", frees, \")\");\n    }\n};\n\nCompiler.prototype.cfunction = function (s, class_for_super) {\n    var funcorgen;\n    Sk.asserts.assert(s instanceof Sk.astnodes.FunctionDef);\n    funcorgen = this.buildcodeobj(s, s.name, s.decorator_list, s.args, function (scopename) {\n        this.vseqstmt(s.body);\n        out(\"return Sk.builtin.none.none$;\"); // if we fall off the bottom, we want the ret to be None\n    }, class_for_super);\n    this.nameop(s.name, Sk.astnodes.Store, funcorgen);\n};\n\nCompiler.prototype.clambda = function (e) {\n    var func;\n    Sk.asserts.assert(e instanceof Sk.astnodes.Lambda);\n    func = this.buildcodeobj(e, new Sk.builtin.str(\"<lambda>\"), null, e.args, function (scopename) {\n        var val = this.vexpr(e.body);\n        out(\"return \", val, \";\");\n    });\n    return func;\n};\n\nCompiler.prototype.cifexp = function (e) {\n    var next = this.newBlock(\"next of ifexp\");\n    var end = this.newBlock(\"end of ifexp\");\n    var ret = this._gr(\"res\", \"null\");\n\n    var test = this.vexpr(e.test);\n    this._jumpfalse(test, next);\n\n    out(ret, \"=\", this.vexpr(e.body), \";\");\n    this._jump(end);\n\n    this.setBlock(next);\n    out(ret, \"=\", this.vexpr(e.orelse), \";\");\n    this._jump(end);\n\n    this.setBlock(end);\n    return ret;\n};\n\nCompiler.prototype.cgenexpgen = function (generators, genIndex, elt) {\n    var velt;\n    var ifres;\n    var i;\n    var n;\n    var target;\n    var nexti;\n    var toiter;\n    var start = this.newBlock(\"start for \" + genIndex);\n    var skip = this.newBlock(\"skip for \" + genIndex);\n    var ifCleanup = this.newBlock(\"if cleanup for \" + genIndex);\n    var end = this.newBlock(\"end for \" + genIndex);\n\n    var ge = generators[genIndex];\n\n    var iter;\n    if (genIndex === 0) {\n        // the outer most iterator is evaluated in the scope outside so we\n        // have to evaluate it outside and store it into the generator as a\n        // local, which we retrieve here.\n        iter = \"$loc.$iter0\";\n    }\n    else {\n        toiter = this.vexpr(ge.iter);\n        iter = \"$loc.\" + this.gensym(\"iter\");\n        out(iter, \"=\", \"Sk.abstr.iter(\", toiter, \");\");\n    }\n    this._jump(start);\n    this.setBlock(start);\n\n    this.annotateSource(elt);\n\n    // load targets\n    out (\"$ret = Sk.abstr.iternext(\", iter,(this.u.canSuspend?\", true\":\", false\"),\");\");\n\n    this._checkSuspension(elt);\n\n    nexti = this._gr(\"next\", \"$ret\");\n    this._jumpundef(nexti, end); // todo; this should be handled by StopIteration\n    target = this.vexpr(ge.target, nexti);\n\n    n = ge.ifs ? ge.ifs.length : 0;\n    for (i = 0; i < n; ++i) {\n        this.annotateSource(ge.ifs[i]);\n\n        ifres = this.vexpr(ge.ifs[i]);\n        this._jumpfalse(ifres, start);\n    }\n\n    if (++genIndex < generators.length) {\n        this.cgenexpgen(generators, genIndex, elt);\n    }\n\n    if (genIndex >= generators.length) {\n        this.annotateSource(elt);\n\n        velt = this.vexpr(elt);\n        out(\"return [\", skip, \"/*resume*/,\", velt, \"/*ret*/];\");\n        this.setBlock(skip);\n    }\n\n    this._jump(start);\n\n    this.setBlock(end);\n\n    if (genIndex === 1) {\n        out(\"return Sk.builtin.none.none$;\");\n    }\n};\n\nCompiler.prototype.cgenexp = function (e) {\n    var gen = this.buildcodeobj(e, new Sk.builtin.str(\"<genexpr>\"), null, null, function (scopename) {\n        this.cgenexpgen(e.generators, 0, e.elt);\n    });\n\n    // call the generator maker to get the generator. this is kind of dumb,\n    // but the code builder builds a wrapper that makes generators for normal\n    // function generators, so we just do it outside (even just new'ing it\n    // inline would be fine).\n    var gener = this._gr(\"gener\", \"Sk.misceval.callsimArray(\", gen, \");\");\n    // stuff the outermost iterator into the generator after evaluating it\n    // outside of the function. it's retrieved by the fixed name above.\n    out(gener, \".gi$locals.$iter0=Sk.abstr.iter(\", this.vexpr(e.generators[0].iter), \");\");\n    return gener;\n};\n\n\nCompiler.prototype.cclass = function (s) {\n    var wrapped;\n    var entryBlock;\n    var scopename;\n    var bases;\n    var decos;\n    Sk.asserts.assert(s instanceof Sk.astnodes.ClassDef);\n    decos = s.decorator_list;\n\n    // decorators and bases need to be eval'd out here\n    //this.vseqexpr(decos);\n\n    bases = this.vseqexpr(s.bases);\n\n    scopename = this.enterScope(s.name, s, s.lineno);\n    entryBlock = this.newBlock(\"class entry\");\n\n    this.u.prefixCode = \"var \" + scopename + \"=(function $\" + s.name.v + \"$class_outer($globals,$locals,$cell){var $gbl=$globals,$loc=$locals;$free=$globals;\";\n    this.u.switchCode += \"(function $\" + s.name.v + \"$_closure($cell){\";\n    this.u.switchCode += \"var $blk=\" + entryBlock + \",$exc=[],$ret=undefined,$postfinally=undefined,$currLineNo=undefined,$currColNo=undefined;\"\n\n    if (Sk.execLimit !== null) {\n        this.u.switchCode += \"if (typeof Sk.execStart === 'undefined') {Sk.execStart = Date.now()}\";\n    }\n    if (Sk.yieldLimit !== null && this.u.canSuspend) {\n        this.u.switchCode += \"if (typeof Sk.lastYield === 'undefined') {Sk.lastYield = Date.now()}\";\n    }\n\n    this.u.switchCode += \"while(true){try{\";\n    this.u.switchCode += this.outputInterruptTest();\n    this.u.switchCode += \"switch($blk){\";\n    this.u.suffixCode = \"}}catch(err){ if (!(err instanceof Sk.builtin.BaseException)) { err = new Sk.builtin.ExternalError(err); } err.traceback.push({lineno: $currLineNo, colno: $currColNo, filename: '\"+this.filename+\"'}); if ($exc.length>0) { $err = err; $blk=$exc.pop(); continue; } else { throw err; }}}\"\n    this.u.suffixCode += \"}).call(null, $cell);});\";\n\n    this.u.private_ = s.name;\n\n    this.cbody(s.body, s.name);\n    out(\"return;\");\n\n    // build class\n\n    // apply decorators\n\n    this.exitScope();\n\n    // todo; metaclass\n    wrapped = this._gr(\"built\", \"Sk.misceval.buildClass($gbl,\", scopename, \",\", s.name[\"$r\"]().v, \",[\", bases, \"], $cell)\");\n\n    // store our new class under the right name\n    this.nameop(s.name, Sk.astnodes.Store, wrapped);\n};\n\nCompiler.prototype.ccontinue = function (s) {\n    var nextFinally = this.peekFinallyBlock(), gotoBlock;\n    if (this.u.continueBlocks.length == 0) {\n        throw new SyntaxError(\"'continue' outside loop\");\n    }\n    // todo; continue out of exception blocks\n    gotoBlock = this.u.continueBlocks[this.u.continueBlocks.length - 1];\n    Sk.asserts.assert(this.u.breakBlocks.length === this.u.continueBlocks.length);\n    if (nextFinally && nextFinally.breakDepth == this.u.continueBlocks.length) {\n        out(\"$postfinally={isBreak:true,gotoBlock:\",gotoBlock,\"};\");\n    } else {\n        this._jump(gotoBlock);\n    }\n};\n\nCompiler.prototype.cbreak = function (s) {\n    var nextFinally = this.peekFinallyBlock(), gotoBlock;\n\n    if (this.u.breakBlocks.length === 0) {\n        throw new SyntaxError(\"'break' outside loop\");\n    }\n    gotoBlock = this.u.breakBlocks[this.u.breakBlocks.length - 1];\n    if (nextFinally && nextFinally.breakDepth == this.u.breakBlocks.length) {\n        out(\"$postfinally={isBreak:true,gotoBlock:\",gotoBlock,\"};\");\n    } else {\n        this._jump(gotoBlock);\n    }\n};\n\n/**\n * compiles a statement\n * @param {Object} s\n * @param {Sk.builtin.str=} class_for_super\n */\nCompiler.prototype.vstmt = function (s, class_for_super) {\n    var i;\n    var val;\n    var n;\n    var debugBlock;\n    this.u.lineno = s.lineno;\n    this.u.linenoSet = false;\n    this.u.localtemps = [];\n\n    if (Sk.debugging && this.u.canSuspend) {\n        debugBlock = this.newBlock(\"debug breakpoint for line \"+s.lineno);\n        out(\"if (Sk.breakpoints('\"+this.filename+\"',\"+s.lineno+\",\"+s.col_offset+\")) {\",\n            \"var $susp = $saveSuspension({data: {type: 'Sk.debug'}, resume: function() {}}, '\"+this.filename+\"',\"+s.lineno+\",\"+s.col_offset+\");\",\n            \"$susp.$blk = \" + debugBlock + \";\",\n            \"$susp.optional = true;\",\n            \"return $susp;\",\n            \"}\");\n        this._jump(debugBlock);\n        this.setBlock(debugBlock);\n        this.u.doesSuspend = true;\n    }\n\n    this.annotateSource(s);\n\n    switch (s.constructor) {\n        case Sk.astnodes.FunctionDef:\n            this.cfunction(s, class_for_super);\n            break;\n        case Sk.astnodes.ClassDef:\n            this.cclass(s);\n            break;\n        case Sk.astnodes.Return:\n            if (this.u.ste.blockType !== Sk.SYMTAB_CONSTS.FunctionBlock) {\n                throw new SyntaxError(\"'return' outside function\");\n            }\n            val = s.value ? this.vexpr(s.value) : \"Sk.builtin.none.none$\";\n            if (this.u.finallyBlocks.length == 0) {\n                out(\"return \", val, \";\");\n            } else {\n                out(\"$postfinally={returning:\",val,\"};\");\n                this._jump(this.peekFinallyBlock().blk);\n            }\n            break;\n        case Sk.astnodes.Delete:\n            this.vseqexpr(s.targets);\n            break;\n        case Sk.astnodes.Assign:\n            n = s.targets.length;\n            val = this.vexpr(s.value);\n            for (i = 0; i < n; ++i) {\n                this.vexpr(s.targets[i], val);\n            }\n            break;\n        case Sk.astnodes.AugAssign:\n            return this.caugassign(s);\n        case Sk.astnodes.Print:\n            this.cprint(s);\n            break;\n        case Sk.astnodes.For:\n            return this.cfor(s);\n        case Sk.astnodes.While:\n            return this.cwhile(s);\n        case Sk.astnodes.If:\n            return this.cif(s);\n        case Sk.astnodes.Raise:\n            return this.craise(s);\n        case Sk.astnodes.Try:\n            return this.ctry(s);\n        case Sk.astnodes.With:\n            return this.cwith(s, 0);\n        case Sk.astnodes.Assert:\n            return this.cassert(s);\n        case Sk.astnodes.Import:\n            return this.cimport(s);\n        case Sk.astnodes.ImportFrom:\n            return this.cfromimport(s);\n        case Sk.astnodes.Global:\n            break;\n        case Sk.astnodes.Expr:\n            this.vexpr(s.value);\n            break;\n        case Sk.astnodes.Pass:\n            break;\n        case Sk.astnodes.Break:\n            this.cbreak(s);\n            break;\n        case Sk.astnodes.Continue:\n            this.ccontinue(s);\n            break;\n        case Sk.astnodes.Debugger:\n            out(\"debugger;\");\n            break;\n        default:\n            Sk.asserts.fail(\"unhandled case in vstmt: \" + JSON.stringify(s));\n    }\n};\n\nCompiler.prototype.vseqstmt = function (stmts) {\n    var i;\n    for (i = 0; i < stmts.length; ++i) {\n        this.vstmt(stmts[i]);\n    }\n};\n\nvar OP_FAST = 0;\nvar OP_GLOBAL = 1;\nvar OP_DEREF = 2;\nvar OP_NAME = 3;\nvar D_NAMES = 0;\nvar D_FREEVARS = 1;\nvar D_CELLVARS = 2;\n\nCompiler.prototype.isCell = function (name) {\n    var mangled = mangleName(this.u.private_, name).v;\n    var scope = this.u.ste.getScope(mangled);\n    var dict = null;\n    return scope === Sk.SYMTAB_CONSTS.CELL;\n\n};\n\n/**\n * @param {Sk.builtin.str} name\n * @param {Object} ctx\n * @param {string=} dataToStore\n */\nCompiler.prototype.nameop = function (name, ctx, dataToStore) {\n    var v;\n    var mangledNoPre;\n    var dict;\n    var scope;\n    var optype;\n    var op;\n    var mangled;\n    if ((ctx === Sk.astnodes.Store || ctx === Sk.astnodes.AugStore || ctx === Sk.astnodes.Del) && name.v === \"__debug__\") {\n        throw new Sk.builtin.SyntaxError(\"can not assign to __debug__\");\n    }\n    Sk.asserts.assert(name.v !== \"None\");\n\n    if (name.v === \"NotImplemented\") {\n        return \"Sk.builtin.NotImplemented.NotImplemented$\";\n    }\n\n    mangled = mangleName(this.u.private_, name).v;\n    // Have to do this before looking it up in the scope\n    mangled = fixReservedNames(mangled);\n    op = 0;\n    optype = OP_NAME;\n    scope = this.u.ste.getScope(mangled);\n    dict = null;\n    switch (scope) {\n        case Sk.SYMTAB_CONSTS.FREE:\n            dict = \"$free\";\n            optype = OP_DEREF;\n            break;\n        case Sk.SYMTAB_CONSTS.CELL:\n            dict = \"$cell\";\n            optype = OP_DEREF;\n            break;\n        case Sk.SYMTAB_CONSTS.LOCAL:\n            // can't do FAST in generators or at module/class scope\n            if (this.u.ste.blockType === Sk.SYMTAB_CONSTS.FunctionBlock && !this.u.ste.generator) {\n                optype = OP_FAST;\n            }\n            break;\n        case Sk.SYMTAB_CONSTS.GLOBAL_IMPLICIT:\n            if (this.u.ste.blockType === Sk.SYMTAB_CONSTS.FunctionBlock) {\n                optype = OP_GLOBAL;\n            }\n            break;\n        case Sk.SYMTAB_CONSTS.GLOBAL_EXPLICIT:\n            optype = OP_GLOBAL;\n        default:\n            break;\n    }\n\n    // have to do this after looking it up in the scope\n    mangled = fixReservedWords(mangled);\n\n    //print(\"mangled\", mangled);\n    // TODO TODO TODO todo; import * at global scope failing here\n    Sk.asserts.assert(scope || name.v.charAt(1) === \"_\");\n\n    // in generator or at module scope, we need to store to $loc, rather that\n    // to actual JS stack variables.\n    mangledNoPre = mangled;\n    if (this.u.ste.generator || this.u.ste.blockType !== Sk.SYMTAB_CONSTS.FunctionBlock) {\n        mangled = \"$loc.\" + mangled;\n    }\n    else if (optype === OP_FAST || optype === OP_NAME) {\n        this.u.localnames.push(mangled);\n    }\n\n    switch (optype) {\n        case OP_FAST:\n            switch (ctx) {\n                case Sk.astnodes.Load:\n                case Sk.astnodes.Param:\n                    // Need to check that it is bound!\n                    out(\"if (\", mangled, \" === undefined) { throw new Sk.builtin.UnboundLocalError('local variable \\\\\\'\", mangled, \"\\\\\\' referenced before assignment'); }\\n\");\n                    return mangled;\n                case Sk.astnodes.Store:\n                    out(mangled, \"=\", dataToStore, \";\");\n                    break;\n                case Sk.astnodes.Del:\n                    out(\"delete \", mangled, \";\");\n                    break;\n                default:\n                    Sk.asserts.fail(\"unhandled\");\n            }\n            break;\n        case OP_NAME:\n            switch (ctx) {\n                case Sk.astnodes.Load:\n                    // can't be || for loc.x = 0 or null\n                    return this._gr(\"loadname\", mangled, \"!==undefined?\", mangled, \":Sk.misceval.loadname('\", mangledNoPre, \"',$gbl);\");\n                case Sk.astnodes.Store:\n                    out(mangled, \"=\", dataToStore, \";\");\n                    break;\n                case Sk.astnodes.Del:\n                    out(\"delete \", mangled, \";\");\n                    break;\n                case Sk.astnodes.Param:\n                    return mangled;\n                default:\n                    Sk.asserts.fail(\"unhandled\");\n            }\n            break;\n        case OP_GLOBAL:\n            switch (ctx) {\n                case Sk.astnodes.Load:\n                    return this._gr(\"loadgbl\", \"Sk.misceval.loadname('\", mangledNoPre, \"',$gbl)\");\n                case Sk.astnodes.Store:\n                    out(\"$gbl.\", mangledNoPre, \"=\", dataToStore, \";\");\n                    break;\n                case Sk.astnodes.Del:\n                    out(\"delete $gbl.\", mangledNoPre);\n                    break;\n                default:\n                    Sk.asserts.fail(\"unhandled case in name op_global\");\n            }\n            break;\n        case OP_DEREF:\n            switch (ctx) {\n                case Sk.astnodes.Load:\n                    return dict + \".\" + mangledNoPre;\n                case Sk.astnodes.Store:\n                    out(dict, \".\", mangledNoPre, \"=\", dataToStore, \";\");\n                    break;\n                case Sk.astnodes.Param:\n                    return mangledNoPre;\n                default:\n                    Sk.asserts.fail(\"unhandled case in name op_deref\");\n            }\n            break;\n        default:\n            Sk.asserts.fail(\"unhandled case\");\n    }\n};\n\n/**\n * @param {Sk.builtin.str} name\n * @param {Object} key\n * @param {number} lineno\n * @param {boolean=} canSuspend\n */\nCompiler.prototype.enterScope = function (name, key, lineno, canSuspend) {\n    var scopeName;\n    var u = new CompilerUnit();\n    u.ste = this.st.getStsForAst(key);\n    u.name = name;\n    u.firstlineno = lineno;\n    u.canSuspend = canSuspend || false;\n\n    if (this.u && this.u.private_) {\n        u.private_ = this.u.private_;\n    }\n\n    this.stack.push(this.u);\n    this.allUnits.push(u);\n    scopeName = this.gensym(\"scope\");\n    u.scopename = scopeName;\n\n    this.u = u;\n    this.u.activateScope();\n\n    this.nestlevel++;\n\n    return scopeName;\n};\n\nCompiler.prototype.exitScope = function () {\n    var mangled;\n    var prev = this.u;\n    this.nestlevel--;\n    if (this.stack.length - 1 >= 0) {\n        this.u = this.stack.pop();\n    }\n    else {\n        this.u = null;\n    }\n    if (this.u) {\n        this.u.activateScope();\n    }\n\n    if (prev.name.v !== \"<module>\") {// todo; hacky\n        mangled = prev.name[\"$r\"]().v;\n        mangled = mangled.substring(1, mangled.length - 1);\n        mangled = fixReservedWords(mangled);\n        mangled = fixReservedNames(mangled);\n        out(prev.scopename, \".co_name=new Sk.builtins['str']('\", mangled, \"');\");\n    }\n    for (var constant in prev.consts) {\n        if (prev.consts.hasOwnProperty(constant)) {\n            prev.suffixCode += constant + \" = \" + prev.consts[constant] + \";\";\n        }\n    }\n};\n\n/**\n * @param {Array} stmts\n * @param {Sk.builtin.str=} class_for_super\n */\nCompiler.prototype.cbody = function (stmts, class_for_super) {\n    var i;\n    for (i = 0; i < stmts.length; ++i) {\n        this.vstmt(stmts[i], class_for_super);\n    }\n};\n\nCompiler.prototype.cprint = function (s) {\n    var i;\n    var n;\n    var dest;\n    Sk.asserts.assert(s instanceof Sk.astnodes.Print);\n    dest = \"null\";\n    if (s.dest) {\n        dest = this.vexpr(s.dest);\n    }\n\n    n = s.values.length;\n    // todo; dest disabled\n    for (i = 0; i < n; ++i) {\n        out(\"$ret = Sk.misceval.print_(\", /*dest, ',',*/ \"new Sk.builtins['str'](\", this.vexpr(s.values[i]), \").v);\");\n        this._checkSuspension(s);\n    }\n    if (s.nl) {\n        out(\"$ret = Sk.misceval.print_(\", /*dest, ',*/ \"\\\"\\\\n\\\");\");\n        this._checkSuspension(s);\n    }\n\n};\n\nCompiler.prototype.cmod = function (mod) {\n    //print(\"-----\");\n    //print(Sk.astDump(mod));\n    var modf = this.enterScope(new Sk.builtin.str(\"<module>\"), mod, 0, this.canSuspend);\n\n    var entryBlock = this.newBlock(\"module entry\");\n    this.u.prefixCode = \"var \" + modf + \"=(function($forcegbl){\";\n    this.u.varDeclsCode =\n        \"var $gbl = $forcegbl || {}, $blk=\" + entryBlock +\n        \",$exc=[],$loc=$gbl,$cell={},$err=undefined;\" +\n        \"$loc.__file__=new Sk.builtins.str('\" + this.filename +\n        \"');var $ret=undefined,$postfinally=undefined,$currLineNo=undefined,$currColNo=undefined;\";\n\n    if (Sk.execLimit !== null) {\n        this.u.varDeclsCode += \"if (typeof Sk.execStart === 'undefined') {Sk.execStart = Date.now()}\";\n    }\n\n    if (Sk.yieldLimit !== null && this.u.canSuspend) {\n        this.u.varDeclsCode += \"if (typeof Sk.lastYield === 'undefined') {Sk.lastYield = Date.now()}\";\n    }\n\n    this.u.varDeclsCode += \"if (\"+modf+\".$wakingSuspension!==undefined) { $wakeFromSuspension(); }\" +\n        \"if (Sk.retainGlobals) {\" +\n        \"    if (Sk.globals) { $gbl = Sk.globals; Sk.globals = $gbl; $loc = $gbl; }\" +\n        \"    if (Sk.globals) { $gbl = Sk.globals; Sk.globals = $gbl; $loc = $gbl; $loc.__file__=new Sk.builtins.str('\" + this.filename + \"');}\" +\n        \"    else { Sk.globals = $gbl; }\" +\n        \"} else { Sk.globals = $gbl; }\";\n\n    // Add the try block that pops the try/except stack if one exists\n    // Github Issue #38\n    // Google Code Issue: 109 / 114\n\n    // Old code:\n    //this.u.switchCode = \"while(true){switch($blk){\";\n    //this.u.suffixCode = \"}}});\";\n\n    // New Code:\n    this.u.switchCode = \"while(true){try{\";\n    this.u.switchCode += this.outputInterruptTest();\n    this.u.switchCode += \"switch($blk){\";\n    this.u.suffixCode = \"}\"\n    this.u.suffixCode += \"}catch(err){ if (!(err instanceof Sk.builtin.BaseException)) { err = new Sk.builtin.ExternalError(err); } err.traceback.push({lineno: $currLineNo, colno: $currColNo, filename: '\"+this.filename+\"'}); if ($exc.length>0) { $err = err; $blk=$exc.pop(); continue; } else { throw err; }} } });\";\n\n    // Note - this change may need to be adjusted for all the other instances of\n    // switchCode and suffixCode in this file.  Not knowing how to test those\n    // other cases I left them alone.   At least the changes to\n    // setupExcept and endExcept will insure that the generated JavaScript\n    // will be syntactically correct.  The worst that will happen is that when\n    // code in a try block blows up, we will not know to run the except block.\n    // The other problem is that we might catch something that is really an internal\n    // error - it might be nice to add code in the above catch block that looked at\n    // the kind of exception and only popped the stack for exceptions that are\n    // from the original code rather than artifacts of some code generation or\n    // exeution environment error.  We at least err on the side of exceptions\n    // being revealed to the user.  drchuck - Wed Jan 23 19:20:18 EST 2013\n\n    switch (mod.constructor) {\n        case Sk.astnodes.Module:\n            this.cbody(mod.body);\n            out(\"return $loc;\");\n            break;\n        default:\n            Sk.asserts.fail(\"todo; unhandled case in compilerMod\");\n    }\n    this.exitScope();\n\n    this.result.push(this.outputAllUnits());\n    return modf;\n};\n\n/**\n * @param {string} source the code\n * @param {string} filename where it came from\n * @param {string} mode one of 'exec', 'eval', or 'single'\n * @param {boolean=} canSuspend if the generated code supports suspension\n */\nSk.compile = function (source, filename, mode, canSuspend) {\n    //print(\"FILE:\", filename);\n    // __future__ flags can be set from code\n    // (with \"from __future__ import ...\" statements),\n    // so make a temporary object that can be edited.\n    var savedFlags = Sk.__future__;\n    Sk.__future__ = Object.create(Sk.__future__);\n\n    var parse = Sk.parse(filename, source);\n    var ast = Sk.astFromParse(parse.cst, filename, parse.flags);\n    // console.log(JSON.stringify(ast, undefined, 2));\n\n    // compilers flags, later we can add other ones too\n    var flags = {};\n    flags.cf_flags = parse.flags;\n\n    var st = Sk.symboltable(ast, filename);\n    var c = new Compiler(filename, st, flags.cf_flags, canSuspend, source); // todo; CO_xxx\n    var funcname = c.cmod(ast);\n\n    // Restore the global __future__ flags\n    Sk.__future__ = savedFlags;\n\n    var ret = \"$compiledmod = function() {\" + c.result.join(\"\") + \"\\nreturn \" + funcname + \";}();\";\n    return {\n        funcname: \"$compiledmod\",\n        code    : ret\n    };\n};\n\nSk.exportSymbol(\"Sk.compile\", Sk.compile);\n\nSk.resetCompiler = function () {\n    Sk.gensymcount = 0;\n};\n\nSk.exportSymbol(\"Sk.resetCompiler\", Sk.resetCompiler);\n\nSk.fixReservedWords = fixReservedWords;\nSk.exportSymbol(\"Sk.fixReservedWords\", Sk.fixReservedWords);\n\nSk.fixReservedNames = fixReservedNames;\nSk.exportSymbol(\"Sk.fixReservedNames\", Sk.fixReservedNames);\n\nSk.unfixReserved = unfixReserved;\nSk.exportSymbol(\"Sk.unfixReserved\", Sk.unfixReserved);\n\nSk.mangleName = mangleName;\nSk.exportSymbol(\"Sk.mangleName\", Sk.mangleName);\n","/**\n * @namespace Sk\n *\n */\n\n// this is stored into sys specially, rather than created by sys\nSk.sysmodules = new Sk.builtin.dict([]);\nSk.realsyspath = undefined;\n\n/**\n * @param {string} name to look for\n * @param {string} ext extension to use (.py or .js)\n * @param {Object=} searchPath an iterable set of path strings\n */\nSk.importSearchPathForName = function (name, ext, searchPath) {\n    var fn;\n    var j;\n    var fns = [];\n    var nameAsPath = name.replace(/\\./g, \"/\");\n    var it, i;\n\n    var tryPathAndBreakOnSuccess = function(filename, packagePath) {\n        return Sk.misceval.chain(\n            Sk.misceval.tryCatch(function() {\n                return Sk.read(filename);\n            }, function(e) { /* Exceptions signal \"not found\" */ }),\n            function(code) {\n                if (code !== undefined) {\n                    // This will cause the iterFor() to return the specified value\n                    return new Sk.misceval.Break({filename: filename, code: code, packagePath: packagePath});\n                }\n            }\n        );\n    };\n\n    if (searchPath === undefined) {\n        searchPath = Sk.realsyspath;\n    }\n\n    return Sk.misceval.iterFor(searchPath.tp$iter(), function(pathStr) {\n        // For each element of path, try loading the module, and if that\n        // doesn't work, try the corresponding package.\n        return Sk.misceval.chain(\n            tryPathAndBreakOnSuccess(pathStr.v + \"/\" + nameAsPath + ext, false), // module\n            function(r) {\n                return r ? r : tryPathAndBreakOnSuccess(pathStr.v + \"/\" + nameAsPath + \"/__init__\" + ext,\n                                                        pathStr.v + \"/\" + nameAsPath); // package\n            }\n        );\n    });\n};\n\n/**\n * Complete any initialization of Python classes which relies on internal\n * dependencies.\n *\n * This includes making Python classes subclassable and ensuring that the\n * {@link Sk.builtin.object} magic methods are wrapped inside Python functions.\n *\n * @return {undefined}\n */\nSk.doOneTimeInitialization = function (canSuspend) {\n    var proto, name, i, x, func, typesWithFunctionsToWrap, builtin_type, j;\n\n    // can't fill these out when making the type because tuple/dict aren't\n    // defined yet.\n    Sk.builtin.type.basesStr_ = new Sk.builtin.str(\"__bases__\");\n    Sk.builtin.type.mroStr_ = new Sk.builtin.str(\"__mro__\");\n\n    // Register a Python class with an internal dictionary, which allows it to\n    // be subclassed\n    var setUpClass = function (child) {\n        var parent = child.tp$base;\n        var bases = [];\n        var base;\n\n        for (base = parent; base !== undefined; base = base.tp$base) {\n            bases.push(base);\n        }\n\n        child.tp$mro = new Sk.builtin.tuple([child]);\n        if (!child.tp$base){\n            child.tp$base = bases[0];\n        }\n        child[\"$d\"] = new Sk.builtin.dict([]);\n        child[\"$d\"].mp$ass_subscript(Sk.builtin.type.basesStr_, new Sk.builtin.tuple(bases));\n        child[\"$d\"].mp$ass_subscript(Sk.builtin.type.mroStr_, child.tp$mro);\n    };\n\n    for (x in Sk.builtin) {\n        func = Sk.builtin[x];\n        if ((func.prototype instanceof Sk.builtin.object ||\n             func === Sk.builtin.object) && !func.sk$abstract) {\n            setUpClass(func);\n        }\n    }\n\n    // Wrap the inner Javascript code of Sk.builtin.object's Python methods inside\n    // Sk.builtin.func, as that class was undefined when these functions were declared\n    typesWithFunctionsToWrap = [Sk.builtin.object, Sk.builtin.type, Sk.builtin.func, Sk.builtin.method];\n\n    for (i = 0; i < typesWithFunctionsToWrap.length; i++) {\n        builtin_type = typesWithFunctionsToWrap[i];\n        proto = builtin_type.prototype;\n        for (j = 0; j < builtin_type.pythonFunctions.length; j++) {\n            name = builtin_type.pythonFunctions[j];\n\n            if (proto[name] instanceof Sk.builtin.func) {\n                // If functions have already been initialized, do not wrap again.\n                break;\n            }\n\n            proto[name].co_kwargs = null;\n            proto[name] = new Sk.builtin.func(proto[name]);\n        }\n    }\n\n\n    for (var file in Sk.internalPy.files) {\n        var fileWithoutExtension = file.split(\".\")[0].split(\"/\")[1];\n        var mod = Sk.importBuiltinWithBody(fileWithoutExtension, false, Sk.internalPy.files[file], true);\n        mod = Sk.misceval.retryOptionalSuspensionOrThrow(mod);\n        Sk.asserts.assert(mod[\"$d\"][fileWithoutExtension] !== undefined, \"Should have imported name \" + fileWithoutExtension);\n        Sk.builtins[fileWithoutExtension] = mod[\"$d\"][fileWithoutExtension];\n    }\n};\n\n/**\n * currently only pull once from Sk.syspath. User might want to change\n * from js or from py.\n */\nSk.importSetUpPath = function (canSuspend) {\n    var i;\n    var paths;\n    if (!Sk.realsyspath) {\n        paths = [\n            new Sk.builtin.str(\"src/builtin\"),\n            new Sk.builtin.str(\"src/lib\"),\n            new Sk.builtin.str(\".\")\n        ];\n        for (i = 0; i < Sk.syspath.length; ++i) {\n            paths.push(new Sk.builtin.str(Sk.syspath[i]));\n        }\n        Sk.realsyspath = new Sk.builtin.list(paths);\n\n        Sk.doOneTimeInitialization(canSuspend);\n    }\n};\n\n/**\n * @param {string} name name of module to import\n * @param {boolean=} dumpJS whether to output the generated js code\n * @param {string=} modname what to call the module after it's imported if\n * it's to be renamed (i.e. __main__)\n * @param {string=} suppliedPyBody use as the body of the text for the module\n * rather than Sk.read'ing it.\n * @param {Object=} relativeToPackage perform import relative to this package\n * @param {boolean=} returnUndefinedOnTopLevelNotFound return 'undefined' rather than throwing ImportError if the *first* load failed\n * @param {boolean=} canSuspend whether we may return a Suspension object\n */\nSk.importModuleInternal_ = function (name, dumpJS, modname, suppliedPyBody, relativeToPackage, returnUndefinedOnTopLevelNotFound, canSuspend) {\n    //dumpJS = true;\n    var filename;\n    var prev;\n    var parentModName;\n    var parentModule;\n    var modNameSplit;\n    var ret;\n    var module;\n    var topLevelModuleToReturn = null;\n    var relativePackageName = relativeToPackage !== undefined ? relativeToPackage.tp$getattr(Sk.builtin.str.$name) : undefined;\n    var absolutePackagePrefix = relativePackageName !== undefined ? relativePackageName.v + \".\" : \"\";\n    var searchPath = relativeToPackage !== undefined ? relativeToPackage.tp$getattr(Sk.builtin.str.$path) : undefined;\n    Sk.importSetUpPath(canSuspend);\n\n    if (relativeToPackage && !relativePackageName) {\n        if (returnUndefinedOnTopLevelNotFound) {\n            return undefined;\n        } else {\n            throw new Sk.builtin.ValueError(\"Attempted to import relative to invalid package (no name)\");\n        }\n    }\n\n    // if no module name override, supplied, use default name\n    if (modname === undefined) {\n        modname = absolutePackagePrefix + name;\n    }\n\n    modNameSplit = name.split(\".\");\n\n    // if leaf is already in sys.modules, early out\n    try {\n        prev = Sk.sysmodules.mp$subscript(modname);\n        // if we're a dotted module, return the top level, otherwise ourselves\n        if (modNameSplit.length > 1) {\n            return Sk.sysmodules.mp$subscript(absolutePackagePrefix + modNameSplit[0]);\n        } else {\n            return prev;\n        }\n    } catch (x) {\n        // not in sys.modules, continue\n    }\n\n    if (modNameSplit.length > 1) {\n        // if we're a module inside a package (i.e. a.b.c), then we'll need to return the\n        // top-level package ('a'). recurse upwards on our parent, importing\n        // all parent packages. so, here we're importing 'a.b', which will in\n        // turn import 'a', and then return 'a' eventually.\n        parentModName = modNameSplit.slice(0, modNameSplit.length - 1).join(\".\");\n        topLevelModuleToReturn = Sk.importModuleInternal_(parentModName, dumpJS, undefined, undefined, relativeToPackage, returnUndefinedOnTopLevelNotFound, canSuspend);\n    }\n\n    ret = Sk.misceval.chain(topLevelModuleToReturn, function(topLevelModuleToReturn_) {\n        var codeAndPath, co, googClosure;\n        var searchFileName = name;\n        var result;\n\n        topLevelModuleToReturn = topLevelModuleToReturn_;\n\n        // If we're inside a package, look search using its __path__\n        if (modNameSplit.length > 1) {\n            if (!topLevelModuleToReturn) {\n                return undefined;\n            }\n            parentModule = Sk.sysmodules.mp$subscript(absolutePackagePrefix + parentModName);\n            searchFileName = modNameSplit[modNameSplit.length-1];\n            searchPath = parentModule.tp$getattr(Sk.builtin.str.$path);\n        }\n\n        // otherwise:\n        // - create module object\n        // - add module object to sys.modules\n        // - compile source to (function(){...});\n        // - run module and set the module locals returned to the module __dict__\n        module = new Sk.builtin.module();\n\n        if (suppliedPyBody) {\n            filename = name + \".py\";\n            co = Sk.compile(suppliedPyBody, filename, \"exec\", canSuspend);\n        } else {\n            co = Sk.misceval.chain(undefined, function() {\n                // If an onBeforeImport method is supplied, call it and if\n                // the result is false or a string, prevent the import.\n                // This allows for a user to conditionally prevent the usage\n                // of certain libraries.\n                if (Sk.onBeforeImport && typeof Sk.onBeforeImport === \"function\") {\n                    return Sk.onBeforeImport(name);\n                }\n\n                return;\n            }, function(result) {\n                if (result === false) {\n                    throw new Sk.builtin.ImportError(\"Importing \" + name + \" is not allowed\");\n                } else if (typeof result === \"string\") {\n                    throw new Sk.builtin.ImportError(result);\n                }\n\n                // Try loading as a builtin (i.e. already in JS) module, then try .py files\n                return Sk.importSearchPathForName(searchFileName, \".js\", searchPath);\n            }, function(codeAndPath) {\n                if (codeAndPath) {\n                    return {\n                        funcname: \"$builtinmodule\", code: codeAndPath.code,\n                        filename: codeAndPath.filename, packagePath: codeAndPath.packagePath\n                    };\n                } else {\n                    return Sk.misceval.chain(Sk.importSearchPathForName(searchFileName, \".py\", searchPath), function(codeAndPath_) {\n                        codeAndPath = codeAndPath_; // We'll want it in a moment\n                        if (codeAndPath) {\n                            return Sk.compile(codeAndPath.code, codeAndPath.filename, \"exec\", canSuspend);\n                        }\n                    }, function(co) {\n                        if (co) {\n                            co.packagePath = codeAndPath.packagePath;\n                            return co;\n                        }\n                    });\n                }\n            });\n\n        }\n        return co;\n\n    }, function(co) {\n\n        var finalcode;\n        var withLineNumbers;\n        var modscope;\n\n        if (!co) {\n            return undefined;\n        }\n\n        // Now we know this module exists, we can add it to the cache\n        Sk.sysmodules.mp$ass_subscript(modname, module);\n\n        module.$js = co.code; // todo; only in DEBUG?\n        finalcode = co.code;\n\n        if (filename == null) {\n            filename = co.filename;\n        }\n\n        if (Sk.dateSet == null || !Sk.dateSet) {\n            finalcode = \"Sk.execStart = Sk.lastYield = new Date();\\n\" + co.code;\n            Sk.dateSet = true;\n        }\n\n        // if (!COMPILED)\n        // {\n        if (dumpJS) {\n            withLineNumbers = function (code) {\n                var j;\n                var pad;\n                var width;\n                var i;\n                var beaut = Sk.js_beautify(code);\n                var lines = beaut.split(\"\\n\");\n                for (i = 1; i <= lines.length; ++i) {\n                    width = (\"\" + i).length;\n                    pad = \"\";\n                    for (j = width; j < 5; ++j) {\n                        pad += \" \";\n                    }\n                    lines[i - 1] = \"/* \" + pad + i + \" */ \" + lines[i - 1];\n                }\n                return lines.join(\"\\n\");\n            };\n            finalcode = withLineNumbers(finalcode);\n            Sk.debugout(finalcode);\n        }\n        // }\n\n        finalcode += \"\\n\" + co.funcname + \";\";\n\n        modscope = Sk.global[\"eval\"](finalcode);\n\n        module[\"$d\"] = {\n            \"__name__\": new Sk.builtin.str(modname),\n            \"__doc__\": Sk.builtin.none.none$,\n            \"__package__\": co.packagePath ? new Sk.builtin.str(modname) :\n            parentModName ? new Sk.builtin.str(absolutePackagePrefix + parentModName) :\n            relativePackageName ? relativePackageName : Sk.builtin.none.none$\n        };\n        if (co.packagePath) {\n            module[\"$d\"][\"__path__\"] = new Sk.builtin.tuple([new Sk.builtin.str(co.packagePath)]);\n        }\n\n        return modscope(module[\"$d\"]);\n\n    }, function (modlocs) {\n        var i;\n\n        if (modlocs === undefined) {\n            if (returnUndefinedOnTopLevelNotFound && !topLevelModuleToReturn) {\n                return undefined;\n            } else {\n                throw new Sk.builtin.ImportError(\"No module named \" + name);\n            }\n        }\n\n        // Some builtin modules replace their globals entirely.\n        // For their benefit, we copy over any of the standard\n        // dunder-values they didn't supply.\n        if (modlocs !== module[\"$d\"]) {\n            for (i in module[\"$d\"]) {\n                if (!modlocs[i]) {\n                    modlocs[i] = module[\"$d\"][i];\n                }\n            }\n            module[\"$d\"] = modlocs;\n        }\n\n        // If an onAfterImport method is defined on the global Sk\n        // then call it now after a library has been successfully imported\n        // and compiled.\n        if (Sk.onAfterImport && typeof Sk.onAfterImport === \"function\") {\n            try {\n                Sk.onAfterImport(name);\n            } catch (e) {\n            }\n        }\n\n        if (topLevelModuleToReturn) {\n            // if we were a dotted name, then we want to return the top-most\n            // package. we store ourselves into our parent as an attribute\n            parentModule.tp$setattr(new Sk.builtin.str(modNameSplit[modNameSplit.length - 1]), module);\n            //print(\"import returning parent module, modname\", modname, \"__name__\", toReturn.tp$getattr(\"__name__\").v);\n            return topLevelModuleToReturn;\n        }\n\n        if (relativeToPackage) {\n            relativeToPackage.tp$setattr(new Sk.builtin.str(name), module);\n        }\n\n        //print(\"name\", name, \"modname\", modname, \"returning leaf\");\n        // otherwise we return the actual module that we just imported\n        return module;\n    });\n\n    return canSuspend ? ret : Sk.misceval.retryOptionalSuspensionOrThrow(ret);\n};\n\n/**\n * @param {string} name the module name\n * @param {boolean=} dumpJS print out the js code after compilation for debugging\n * @param {boolean=} canSuspend can this function suspend and return a Suspension object?\n */\nSk.importModule = function (name, dumpJS, canSuspend) {\n    return Sk.importModuleInternal_(name, dumpJS, undefined, undefined, undefined, false, canSuspend);\n};\n\nSk.importMain = function (name, dumpJS, canSuspend) {\n    Sk.dateSet = false;\n    Sk.filesLoaded = false;\n    // Added to reset imports\n    Sk.sysmodules = new Sk.builtin.dict([]);\n    Sk.realsyspath = undefined;\n\n    Sk.resetCompiler();\n\n    return Sk.importModuleInternal_(name, dumpJS, \"__main__\", undefined, undefined, false, canSuspend);\n};\n\n/**\n * **Run Python Code in Skulpt**\n *\n * When you want to hand Skulpt a string corresponding to a Python program this is the function.\n *\n * @param name {string}  File name to use for messages related to this run\n * @param dumpJS {boolean} print out the compiled javascript\n * @param body {string} Python Code\n * @param canSuspend {boolean}  Use Suspensions for async execution\n *\n */\nSk.importMainWithBody = function (name, dumpJS, body, canSuspend) {\n    Sk.dateSet = false;\n    Sk.filesLoaded = false;\n    // Added to reset imports\n    Sk.sysmodules = new Sk.builtin.dict([]);\n    Sk.realsyspath = undefined;\n\n    Sk.resetCompiler();\n\n    return Sk.importModuleInternal_(name, dumpJS, \"__main__\", body, undefined, false, canSuspend);\n};\n\n/**\n * Imports internal python files into the `__builtin__` module. Used during startup\n * to compile and import all *.py files from the src/ directory.\n *\n * @param name {string}  File name to use for messages related to this run\n * @param dumpJS {boolean} print out the compiled javascript\n * @param body {string} Python Code\n * @param canSuspend {boolean}  Use Suspensions for async execution\n *\n */\nSk.importBuiltinWithBody = function (name, dumpJS, body, canSuspend) {\n    return Sk.importModuleInternal_(name, dumpJS, \"__builtin__.\"+name, body, undefined, false, canSuspend);\n};\n\nSk.builtin.__import__ = function (name, globals, locals, fromlist, level) {\n    //print(\"Importing: \", JSON.stringify(name), JSON.stringify(fromlist), level);\n    //if (name == \"\") { debugger; }\n\n    // Save the Sk.globals variable importModuleInternal_ may replace it when it compiles\n    // a Python language module.\n    var saveSk = Sk.globals;\n\n    // This might be a relative import, so first we get hold of the module object\n    // representing this module's package (so we can search its __path__).\n    // module.__package__ contains its name, so we use that to look it up in sys.modules.\n\n    var relativeToPackage;\n    var relativeToPackageName;\n    var relativeToPackageNames;\n\n    if (level === undefined) {\n        level = Sk.__future__.absolute_import ? 0 : -1;\n    }\n\n    if (level !== 0 && globals[\"__package__\"] && globals[\"__package__\"] !== Sk.builtin.none.none$) {\n        relativeToPackageName = globals[\"__package__\"].v;\n        if (relativeToPackageName && level > 0) {\n            // Trim <level> packages off the end\n            relativeToPackageNames = relativeToPackageName.split(\".\");\n            if (level-1 >= relativeToPackageNames.length) {\n                throw new Sk.builtin.ValueError(\"Attempted relative import beyond toplevel package\");\n            }\n            relativeToPackageNames.length -= level-1;\n            relativeToPackageName = relativeToPackageNames.join(\".\");\n        }\n        try {\n            relativeToPackage = Sk.sysmodules.mp$subscript(relativeToPackageName);\n        } catch(e) {\n            relativeToPackageName = undefined;\n        }\n    }\n\n    if (level > 0 && relativeToPackage === undefined) {\n        throw new Sk.builtin.ValueError(\"Attempted relative import in non-package\");\n    }\n\n    var dottedName = name.split(\".\");\n    var firstDottedName = dottedName[0];\n\n    return Sk.misceval.chain(undefined, function() {\n        // Attempt local load first (and just fall through to global\n        // case if level == -1 and we fail to load the top-level package)\n        if (level !== 0 && relativeToPackage !== undefined) {\n            if (name === \"\") {\n                // \"from .. import ...\"\n                return relativeToPackage;\n            } else {\n                return Sk.importModuleInternal_(name, undefined, relativeToPackageName + \".\" + name, undefined, relativeToPackage, level==-1, true);\n            }\n        }\n    }, function(ret) {\n        if (ret === undefined) {\n            // Either it was always a global import, or it was an\n            // either-way import that just fell through.\n            relativeToPackage = undefined;\n            relativeToPackageName = undefined;\n            return Sk.importModuleInternal_(name, undefined, undefined, undefined, undefined, false, true);\n        } else {\n            return ret;\n        }\n    }, function(ret) {\n        // We might also have to load modules named by the fromlist.\n        // If there is no fromlist, we have reached the end of the lookup, return\n        if (!fromlist || fromlist.length === 0) {\n            return ret;\n        } else {\n            // try to load from-names as modules from the file system\n            // if they are not present on the module itself\n            var i;\n            var fromName;\n            var leafModule;\n            var importChain;\n\n            leafModule = Sk.sysmodules.mp$subscript(\n                (relativeToPackageName || \"\") +\n                    ((relativeToPackageName && name) ? \".\" : \"\") +\n                    name);\n\n            for (i = 0; i < fromlist.length; i++) {\n                fromName = fromlist[i];\n\n                // \"ret\" is the module we're importing from\n                // Only import from file system if we have not found the fromName in the current module\n                if (fromName != \"*\" && leafModule.tp$getattr(new Sk.builtin.str(fromName)) === undefined) {\n                    importChain = Sk.misceval.chain(importChain,\n                                                    Sk.importModuleInternal_.bind(null, fromName, undefined, undefined, undefined, leafModule, true, true)\n                    );\n                }\n            }\n\n            return Sk.misceval.chain(importChain, function() {\n                // if there's a fromlist we want to return the leaf module\n                // (ret), not the toplevel namespace\n                Sk.asserts.assert(leafModule);\n                return leafModule;\n            });\n        }\n\n    }, function(ret) {\n        if (saveSk !== Sk.globals) {\n            Sk.globals = saveSk;\n        }\n        return ret;\n    });\n};\n\nSk.importStar = function (module, loc, global) {\n    var i;\n    var props = Object[\"getOwnPropertyNames\"](module[\"$d\"]);\n    for (i in props) {\n        if (props[i].charAt(0) != \"_\") {\n            loc[props[i]] = module[\"$d\"][props[i]];\n        }\n    }\n};\n\nSk.exportSymbol(\"Sk.importMain\", Sk.importMain);\nSk.exportSymbol(\"Sk.importMainWithBody\", Sk.importMainWithBody);\nSk.exportSymbol(\"Sk.importBuiltinWithBody\", Sk.importBuiltinWithBody);\nSk.exportSymbol(\"Sk.builtin.__import__\", Sk.builtin.__import__);\nSk.exportSymbol(\"Sk.importStar\", Sk.importStar);\n","/**\n * @constructor\n * @param {Sk.builtin.list=} list\n * @param {number=} length optional\n * @extends Sk.builtin.object\n */\nSk.builtin.timSort = function (list, length) {\n    this.list = new Sk.builtin.list(list.v);\n    // When we get into galloping mode, we stay there until both runs win less\n    // often than MIN_GALLOP consecutive times.  See listsort.txt for more info.\n    this.MIN_GALLOP = 7;\n    if (length) {\n        this.listlength = length;\n    } else {\n        this.listlength = list.sq$length();\n    }\n};\n\nSk.builtin.timSort.prototype.lt = function (a, b) {\n    return Sk.misceval.richCompareBool(a, b, \"Lt\");\n};\n\nSk.builtin.timSort.prototype.le = function (a, b) {\n    return !this.lt(b, a);\n};\n\nSk.builtin.timSort.prototype.setitem = function (item, value) {\n    this.list.v[item] = value;\n};\n\n/*\n # binarysort is the best method for sorting small arrays: it does\n # few compares, but can do data movement quadratic in the number of\n # elements.\n # \"a\" is a contiguous slice of a list, and is sorted via binary insertion.\n # This sort is stable.\n # On entry, the first \"sorted\" elements are already sorted.\n # Even in case of error, the output slice will be some permutation of\n # the input (nothing is lost or duplicated)\n */\nSk.builtin.timSort.prototype.binary_sort = function (a, sorted) {\n    var pivot;\n    var p;\n    var r;\n    var l;\n    var start;\n    for (start = a.base + sorted; start < a.base + a.len; start++) {\n        l = a.base;\n        r = start;\n        pivot = a.getitem(r);\n        // Invariants:\n        // pivot >= all in [base, l).\n        // pivot  < all in [r, start).\n        // The second is vacuously true at the start.\n        while (l < r) {\n            p = l + ((r - l) >> 1);\n            if (this.lt(pivot, a.getitem(p))) {\n                r = p;\n            } else {\n                l = p + 1;\n            }\n        }\n        Sk.asserts.assert(l === r);\n        // The invariants still hold, so pivot >= all in [base, l) and\n        // pivot < all in [l, start), so pivot belongs at l.  Note\n        // that if there are elements equal to pivot, l points to the\n        // first slot after them -- that's why this sort is stable.\n        // Slide over to make room.\n        for (p = start; p > l; p--) {\n            a.setitem(p, a.getitem(p - 1));\n        }\n        a.setitem(l, pivot);\n    }\n};\n\nSk.builtin.timSort.prototype.count_run = function (a) {\n    /*\n     # Compute the length of the run in the slice \"a\".\n     # \"A run\" is the longest ascending sequence, with\n     #\n     #     a[0] <= a[1] <= a[2] <= ...\n     #\n     # or the longest descending sequence, with\n     #\n     #     a[0] > a[1] > a[2] > ...\n     #\n     # Return (run, descending) where descending is False in the former case,\n     # or True in the latter.\n     # For its intended use in a stable mergesort, the strictness of the defn of\n     # \"descending\" is needed so that the caller can safely reverse a descending\n     # sequence without violating stability (strict > ensures there are no equal\n     # elements to get out of order).\n     */\n    var n;\n    var p;\n    var descending;\n    if (a.len <= 1) {\n        n = a.len;\n        descending = false;\n    } else {\n        n = 2;\n        if (this.lt(a.getitem(a.base + 1), a.getitem(a.base))) {\n            descending = true;\n            for (p = a.base + 2; p < a.base + a.len; p++) {\n                if (this.lt(a.getitem(p), a.getitem(p - 1))) {\n                    n++;\n                } else {\n                    break;\n                }\n            }\n        } else {\n            descending = false;\n            for (p = a.base + 2; p < a.base + a.len; p++) {\n                if (this.lt(a.getitem(p), a.getitem(p - 1))) {\n                    break;\n                } else {\n                    n++;\n                }\n            }\n        }\n    }\n    return {\"run\": new Sk.builtin.listSlice(a.list, a.base, n), \"descending\": descending};\n};\n\nSk.builtin.timSort.prototype.sort = function () {\n    /*\n     # ____________________________________________________________\n     # Entry point.\n     */\n\n    var minrun;\n    var cr;\n    var sorted;\n    var remaining = new Sk.builtin.listSlice(this.list, 0, this.listlength);\n    if (remaining.len < 2) {\n        return;\n    }\n\n    // March over the array once, left to right, finding natural runs,\n    // and extending short natural runs to minrun elements.\n    this.merge_init();\n    minrun = this.merge_compute_minrun(remaining.len);\n    while (remaining.len > 0) {\n        // Identify next run.\n        cr = this.count_run(remaining);\n        if (cr.descending) {\n            cr.run.reverse();\n        }\n        // If short, extend to min(minrun, nremaining).\n        if (cr.run.len < minrun) {\n            sorted = cr.run.len;\n            if (minrun < remaining.len) {\n                cr.run.len = minrun;\n            } else {\n                cr.run.len = remaining.len;\n            }\n            this.binary_sort(cr.run, sorted);\n        }\n        // Advance remaining past this run.\n        remaining.advance(cr.run.len);\n        // Push run onto pending-runs stack, and maybe merge.\n        this.pending.push(cr.run);\n        this.merge_collapse();\n    }\n    Sk.asserts.assert(remaining.base == this.listlength);\n\n    this.merge_force_collapse();\n    Sk.asserts.assert(this.pending.length == 1);\n    Sk.asserts.assert(this.pending[0].base === 0);\n    Sk.asserts.assert(this.pending[0].len == this.listlength);\n};\n\n/*\n # Locate the proper position of key in a sorted vector; if the vector\n # contains an element equal to key, return the position immediately to the\n # left of the leftmost equal element -- or to the right of the rightmost\n # equal element if the flag \"rightmost\" is set.\n #\n # \"hint\" is an index at which to begin the search, 0 <= hint < a.len.\n # The closer hint is to the final result, the faster this runs.\n #\n # The return value is the index 0 <= k <= a.len such that\n #\n #     a[k-1] < key <= a[k]      (if rightmost is False)\n #     a[k-1] <= key < a[k]      (if rightmost is True)\n #\n # as long as the indices are in bound.  IOW, key belongs at index k;\n # or, IOW, the first k elements of a should precede key, and the last\n # n-k should follow key.\n */\nSk.builtin.timSort.prototype.gallop = function (key, a, hint, rightmost) {\n    var lower;\n    var self;\n    var p;\n    var lastofs;\n    var ofs;\n    var maxofs;\n    var hintminofs;\n    var hintminlastofs;\n    var m;\n    Sk.asserts.assert(0 <= hint && hint < a.len);\n    self = this;\n    if (rightmost) {\n        lower = function (a, b) {\n            return self.le(a, b);\n        }; // search for the largest k for which a[k] <= key\n    } else {\n        lower = function (a, b) {\n            return self.lt(a, b);\n        }; // search for the largest k for which a[k] < key\n    }\n    p = a.base + hint;\n    lastofs = 0;\n    ofs = 1;\n    if (lower(a.getitem(p), key)) {\n        // a[hint] < key -- gallop right, until\n        // a[hint + lastofs] < key <= a[hint + ofs]\n\n        maxofs = a.len - hint; // a[a.len-1] is highest\n        while (ofs < maxofs) {\n            if (lower(a.getitem(p + ofs), key)) {\n                lastofs = ofs;\n                try {\n                    ofs = (ofs << 1) + 1;\n                } catch (err) {\n                    ofs = maxofs;\n                }\n            } else {\n                // key <= a[hint + ofs]\n                break;\n            }\n        }\n        if (ofs > maxofs) {\n            ofs = maxofs;\n        }\n        // Translate back to offsets relative to a.\n        lastofs += hint;\n        ofs += hint;\n    } else {\n        // key <= a[hint] -- gallop left, until\n        // a[hint - ofs] < key <= a[hint - lastofs]\n        maxofs = hint + 1;   // a[0] is lowest\n        while (ofs < maxofs) {\n            if (lower(a.getitem(p - ofs), key)) {\n                break;\n            } else {\n                // key <= a[hint - ofs]\n                lastofs = ofs;\n                try {\n                    ofs = (ofs << 1) + 1;\n                } catch (err) {\n                    ofs = maxofs;\n                }\n            }\n        }\n        if (ofs > maxofs) {\n            ofs = maxofs;\n        }\n        // Translate back to positive offsets relative to a.\n        hintminofs = hint - ofs;\n        hintminlastofs = hint - lastofs;\n        lastofs = hintminofs;\n        ofs = hintminlastofs;\n    }\n    Sk.asserts.assert(-1 <= lastofs < ofs <= a.len);\n\n    // Now a[lastofs] < key <= a[ofs], so key belongs somewhere to the\n    // right of lastofs but no farther right than ofs.  Do a binary\n    // search, with invariant a[lastofs-1] < key <= a[ofs].\n\n    lastofs += 1;\n    while (lastofs < ofs) {\n        m = lastofs + ((ofs - lastofs) >> 1);\n        if (lower(a.getitem(a.base + m), key)) {\n            lastofs = m + 1;   // a[m] < key\n        } else {\n            ofs = m;         // key <= a[m]\n        }\n    }\n    Sk.asserts.assert(lastofs == ofs);         // so a[ofs-1] < key <= a[ofs]\n    return ofs;\n};\n\n// ____________________________________________________________\n\nSk.builtin.timSort.prototype.merge_init = function () {\n    // This controls when we get *into* galloping mode.  It's initialized\n    // to MIN_GALLOP.  merge_lo and merge_hi tend to nudge it higher for\n    // random data, and lower for highly structured data.\n    this.min_gallop = this.MIN_GALLOP;\n\n    // A stack of n pending runs yet to be merged.  Run #i starts at\n    // address pending[i].base and extends for pending[i].len elements.\n    // It's always true (so long as the indices are in bounds) that\n    //\n    //     pending[i].base + pending[i].len == pending[i+1].base\n    //\n    // so we could cut the storage for this, but it's a minor amount,\n    // and keeping all the info explicit simplifies the code.\n    this.pending = [];\n};\n\n// Merge the slice \"a\" with the slice \"b\" in a stable way, in-place.\n// a.len <= b.len.  See listsort.txt for more info.\n// a.len and b.len must be > 0, and a.base + a.len == b.base.\n// Must also have that b.list[b.base] < a.list[a.base], that\n// a.list[a.base+a.len-1] belongs at the end of the merge, and should have\n\nSk.builtin.timSort.prototype.merge_lo = function (a, b) {\n    var min_gallop;\n    var dest;\n    var acount, bcount;\n    var p;\n    Sk.asserts.assert(a.len > 0 && b.len > 0 && a.base + a.len == b.base);\n    min_gallop = this.min_gallop;\n    dest = a.base;\n    a = a.copyitems();\n\n    // Invariant: elements in \"a\" are waiting to be reinserted into the list\n    // at \"dest\".  They should be merged with the elements of \"b\".\n    // b.base == dest + a.len.\n    // We use a finally block to ensure that the elements remaining in\n    // the copy \"a\" are reinserted back into this.list in all cases.\n    try {\n        this.setitem(dest, b.popleft());\n\n        dest++;\n        if (a.len == 1 || b.len === 0) {\n            return;\n        }\n\n        while (true) {\n            acount = 0;   // number of times A won in a row\n            bcount = 0;   // number of times B won in a row\n\n            // Do the straightforward thing until (if ever) one run\n            // appears to win consistently.\n            while (true) {\n                if (this.lt(b.getitem(b.base), a.getitem(a.base))) {\n                    this.setitem(dest, b.popleft());\n                    dest++;\n                    if (b.len === 0) {\n                        return;\n                    }\n                    bcount++;\n                    acount = 0;\n                    if (bcount >= min_gallop) {\n                        break;\n                    }\n                } else {\n                    this.setitem(dest, a.popleft());\n                    dest++;\n                    if (a.len == 1) {\n                        return;\n                    }\n                    acount++;\n                    bcount = 0;\n                    if (acount >= min_gallop) {\n                        break;\n                    }\n                }\n            }\n\n            // One run is winning so consistently that galloping may\n            // be a huge win.  So try that, and continue galloping until\n            // (if ever) neither run appears to be winning consistently\n            // anymore.\n            min_gallop += 1;\n\n            while (true) {\n                min_gallop -= min_gallop > 1;\n                this.min_gallop = min_gallop;\n                acount = this.gallop(b.getitem(b.base), a, 0, true);\n                for (p = a.base; p < a.base + acount; p++) {\n                    this.setitem(dest, a.getitem(p));\n                    dest++;\n                }\n\n                a.advance(acount);\n\n                if (a.len <= 1) {\n                    return;\n                }\n\n                this.setitem(dest, b.popleft());\n                dest++;\n\n                // a.len==0 is impossible now if the comparison\n                // function is consistent, but we can't assume\n                // that it is.\n                if (b.len === 0) {\n                    return;\n                }\n\n                bcount = this.gallop(a.getitem(a.base), b, 0, false);\n\n                for (p = b.base; p < b.base + bcount; p++) {\n                    this.setitem(dest, b.getitem(p));\n                    dest++;\n                }\n\n                b.advance(bcount);\n                if (b.len === 0) {\n                    return;\n                }\n                this.setitem(dest, a.popleft());\n                dest++;\n\n                if (a.len == 1) {\n                    return;\n                }\n\n                if (acount < this.MIN_GALLOP && bcount < this.MIN_GALLOP) {\n                    break;\n                }\n\n                min_gallop++;  // penalize it for leaving galloping mode\n                this.min_gallop = min_gallop;\n            }\n        }\n    } finally {\n        // The last element of a belongs at the end of the merge, so we copy\n        // the remaining elements of b before the remaining elements of a.\n        Sk.asserts.assert(a.len >= 0 && b.len >= 0);\n        for (p = b.base; p < b.base + b.len; p++) {\n            this.setitem(dest, b.getitem(p));\n            dest++;\n        }\n        for (p = a.base; p < a.base + a.len; p++) {\n            this.setitem(dest, a.getitem(p));\n            dest++;\n        }\n    }\n};\n\nSk.builtin.timSort.prototype.merge_hi = function (a, b) {\n    var min_gallop;\n    var dest;\n    var acount, bcount, nexta, nextb;\n    var k;\n    var p;\n    Sk.asserts.assert(a.len > 0 && b.len > 0 && a.base + a.len == b.base);\n    min_gallop = this.min_gallop;\n    dest = b.base + b.len;\n    b = b.copyitems();\n\n    // Invariant: elements in \"a\" are waiting to be reinserted into the list\n    // at \"dest\".  They should be merged with the elements of \"b\".\n    // b.base == dest + a.len.\n    // We use a finally block to ensure that the elements remaining in\n    // the copy \"a\" are reinserted back into this.list in all cases.\n    try {\n        dest--;\n        this.setitem(dest, a.popright());\n\n        if (a.len === 0 || b.len == 1) {\n            return;\n        }\n\n        while (true) {\n            acount = 0;   // number of times A won in a row\n            bcount = 0;   // number of times B won in a row\n\n            // Do the straightforward thing until (if ever) one run\n            // appears to win consistently.\n            while (true) {\n                nexta = a.getitem(a.base + a.len - 1);\n                nextb = b.getitem(b.base + b.len - 1);\n                if (this.lt(nextb, nexta)) {\n                    dest--;\n                    this.setitem(dest, nexta);\n                    a.len--;\n                    if (a.len === 0) {\n                        return;\n                    }\n                    acount++;\n                    bcount = 0;\n                    if (acount >= min_gallop) {\n                        break;\n                    }\n                } else {\n                    dest--;\n                    this.setitem(dest, nextb);\n                    b.len--;\n                    if (b.len == 1) {\n                        return;\n                    }\n                    bcount++;\n                    acount = 0;\n                    if (bcount >= min_gallop) {\n                        break;\n                    }\n                }\n            }\n\n            // One run is winning so consistently that galloping may\n            // be a huge win.  So try that, and continue galloping until\n            // (if ever) neither run appears to be winning consistently\n            // anymore.\n            min_gallop += 1;\n\n            while (true) {\n                min_gallop -= min_gallop > 1;\n                this.min_gallop = min_gallop;\n                nextb = b.getitem(b.base + b.len - 1);\n                k = this.gallop(nextb, a, a.len - 1, true);\n                acount = a.len - k;\n                for (p = a.base + a.len - 1; p > a.base + k - 1; p--) {\n                    dest--;\n                    this.setitem(dest, a.getitem(p));\n                }\n                a.len -= acount;\n                if (a.len === 0) {\n                    return;\n                }\n\n                dest--;\n                this.setitem(dest, b.popright());\n                if (b.len == 1) {\n                    return;\n                }\n\n                nexta = a.getitem(a.base + a.len - 1);\n                k = this.gallop(nexta, b, b.len - 1, false);\n                bcount = b.len - k;\n                for (p = b.base + b.len - 1; p > b.base + k - 1; p--) {\n                    dest--;\n                    this.setitem(dest, b.getitem(p));\n                }\n\n                b.len -= bcount;\n\n                // b.len==0 is impossible now if the comparison\n                // function is consistent, but we can't assume\n                // that it is.\n                if (b.len <= 1) {\n                    return;\n                }\n                dest--;\n                this.setitem(dest, a.popright());\n                if (a.len === 0) {\n                    return;\n                }\n\n                if (acount < this.MIN_GALLOP && bcount < this.MIN_GALLOP) {\n                    break;\n                }\n\n                min_gallop++;  // penalize it for leaving galloping mode\n                this.min_gallop = min_gallop;\n            }\n        }\n    } finally {\n        // The last element of a belongs at the end of the merge, so we copy\n        // the remaining elements of b before the remaining elements of a.\n        Sk.asserts.assert(a.len >= 0 && b.len >= 0);\n        for (p = a.base + a.len - 1; p > a.base - 1; p--) {\n            dest--;\n            this.setitem(dest, a.getitem(p));\n        }\n        for (p = b.base + b.len - 1; p > b.base - 1; p--) {\n            dest--;\n            this.setitem(dest, b.getitem(p));\n        }\n    }\n};\n\n// Merge the two runs at stack indices i and i+1.\n\nSk.builtin.timSort.prototype.merge_at = function (i) {\n    var a;\n    var b;\n    var k;\n    if (i < 0) {\n        i = this.pending.length + i;\n    }\n\n    a = this.pending[i];\n    b = this.pending[i + 1];\n    Sk.asserts.assert(a.len > 0 && b.len > 0);\n    Sk.asserts.assert(a.base + a.len == b.base);\n\n    // Record the length of the combined runs and remove the run b\n    this.pending[i] = new Sk.builtin.listSlice(this.list, a.base, a.len + b.len);\n    this.pending.splice(i + 1, 1);\n\n    // Where does b start in a?  Elements in a before that can be\n    // ignored (already in place).\n    k = this.gallop(b.getitem(b.base), a, 0, true);\n    a.advance(k);\n    if (a.len === 0) {\n        return;\n    }\n\n    // Where does a end in b?  Elements in b after that can be\n    // ignored (already in place).\n    b.len = this.gallop(a.getitem(a.base + a.len - 1), b, b.len - 1, false);\n    if (b.len === 0) {\n        return;\n    }\n\n    // Merge what remains of the runs.  The direction is chosen to\n    // minimize the temporary storage needed.\n    if (a.len <= b.len) {\n        this.merge_lo(a, b);\n    } else {\n        this.merge_hi(a, b);\n    }\n};\n\n// Examine the stack of runs waiting to be merged, merging adjacent runs\n// until the stack invariants are re-established:\n//\n// 1. len[-3] > len[-2] + len[-1]\n// 2. len[-2] > len[-1]\n//\n// See listsort.txt for more info.\nSk.builtin.timSort.prototype.merge_collapse = function () {\n    var p = this.pending;\n    while (p.length > 1) {\n        if (p.length >= 3 && p[p.length - 3].len <= p[p.length - 2].len + p[p.length - 1].len) {\n            if (p[p.length - 3].len < p[p.length - 1].len) {\n                this.merge_at(-3);\n            } else {\n                this.merge_at(-2);\n            }\n        } else if (p[p.length - 2].len <= p[p.length - 1].len) {\n            this.merge_at(-2);\n        } else {\n            break;\n        }\n    }\n};\n\n// Regardless of invariants, merge all runs on the stack until only one\n// remains.  This is used at the end of the mergesort.\n\nSk.builtin.timSort.prototype.merge_force_collapse = function () {\n    var p = this.pending;\n    while (p.length > 1) {\n        if (p.length >= 3 && p[p.length - 3].len < p[p.length - 1].len) {\n            this.merge_at(-3);\n        } else {\n            this.merge_at(-2);\n        }\n    }\n};\n// Compute a good value for the minimum run length; natural runs shorter\n// than this are boosted artificially via binary insertion.\n//\n// If n < 64, return n (it's too small to bother with fancy stuff).\n// Else if n is an exact power of 2, return 32.\n// Else return an int k, 32 <= k <= 64, such that n/k is close to, but\n// strictly less than, an exact power of 2.\n//\n// See listsort.txt for more info.\n\nSk.builtin.timSort.prototype.merge_compute_minrun = function (n) {\n    var r = 0;    // becomes 1 if any 1 bits are shifted off\n    while (n >= 64) {\n        r = r | n & 1;\n        n >>= 1;\n    }\n    return n + r;\n};\n\n//ListSlice\n/**\n * @constructor\n * @param {Sk.builtin.list=} list\n * @param {number=} base\n * @param {number=} len\n * @extends Sk.builtin.object\n */\nSk.builtin.listSlice = function (list, base, len) {\n    this.list = list;\n    this.base = base;\n    this.len = len;\n};\n\nSk.builtin.listSlice.prototype.copyitems = function () {\n    //Make a copy of the slice of the original list\n    var start = this.base;\n    var stop = this.base + this.len;\n    Sk.asserts.assert(0 <= start <= stop);\n    return new Sk.builtin.listSlice(new Sk.builtin.list(this.list.v.slice(start, stop)), 0, this.len);\n};\n\nSk.builtin.listSlice.prototype.advance = function (n) {\n    this.base += n;\n    this.len -= n;\n    Sk.asserts.assert(this.base <= this.list.sq$length());\n};\n\nSk.builtin.listSlice.prototype.getitem = function (item) {\n    return this.list.v[item];\n};\n\nSk.builtin.listSlice.prototype.setitem = function (item, value) {\n    this.list.v[item] = value;\n};\n\nSk.builtin.listSlice.prototype.popleft = function () {\n    var result = this.list.v[this.base];\n    this.base++;\n    this.len--;\n    return result;\n};\n\nSk.builtin.listSlice.prototype.popright = function () {\n    this.len--;\n    return this.list.v[this.base + this.len];\n};\n\nSk.builtin.listSlice.prototype.reverse = function () {\n    // Reverse the slice in-place.\n    var list_hi;\n    var list_lo;\n    var list = this.list;\n    var lo = this.base;\n    var hi = lo + this.len - 1;\n    while (lo < hi) {\n        list_hi = list.v[hi];\n        list_lo = list.v[lo];\n        list.v[lo] = list_hi;\n        list.v[hi] = list_lo;\n        lo++;\n        hi--;\n    }\n};\n\nSk.exportSymbol(\"Sk.builtin.listSlice\", Sk.builtin.listSlice);\nSk.exportSymbol(\"Sk.builtin.timSort\", Sk.builtin.timSort);\n","Sk.builtin.sorted = function sorted (iterable, cmp, key, reverse) {\n    var arr;\n    var next;\n    var iter;\n    var compare_func;\n    var list;\n    var rev;\n\n    if (reverse === undefined) {\n        rev = false;\n    } else if (reverse instanceof Sk.builtin.float_) {\n        throw new Sk.builtin.TypeError(\"an integer is required, got float\");\n    } else if (reverse instanceof Sk.builtin.int_ || reverse.prototype instanceof Sk.builtin.int_) {\n        rev = Sk.misceval.isTrue(reverse);\n    } else {\n        throw new Sk.builtin.TypeError(\"an integer is required\");\n    }\n\n    if (key !== undefined && !(key instanceof Sk.builtin.none)) {\n        if (cmp instanceof Sk.builtin.none || cmp === undefined) {\n            compare_func = function (a, b) {\n                return Sk.misceval.richCompareBool(a[0], b[0], \"Lt\") ? new Sk.builtin.int_(-1) : new Sk.builtin.int_(0);\n            };\n        } else {\n            compare_func = function (a, b) {\n                return Sk.misceval.callsimArray(cmp, [a[0], b[0]]);\n            };\n        }\n        iter = iterable.tp$iter();\n        next = iter.tp$iternext();\n        arr = [];\n        while (next !== undefined) {\n            arr.push([Sk.misceval.callsimArray(key, [next]), next]);\n            next = iter.tp$iternext();\n        }\n        list = new Sk.builtin.list(arr);\n    } else {\n        if (!(cmp instanceof Sk.builtin.none) && cmp !== undefined) {\n            compare_func = cmp;\n        }\n        list = new Sk.builtin.list(iterable);\n    }\n\n    if (compare_func !== undefined) {\n        list.list_sort_(list, compare_func);\n    } else {\n        list.list_sort_(list);\n    }\n\n    if (rev) {\n        list.list_reverse_(list);\n    }\n\n    if (key !== undefined && !(key instanceof Sk.builtin.none)) {\n        iter = list.tp$iter();\n        next = iter.tp$iternext();\n        arr = [];\n        while (next !== undefined) {\n            arr.push(next[1]);\n            next = iter.tp$iternext();\n        }\n        list = new Sk.builtin.list(arr);\n    }\n\n    return list;\n};\n\n/* NOTE: See constants used for kwargs in constants.js */\n","Sk.builtin.type_is_subtype_base_chain = function type_is_subtype_base_chain(a, b) {\n    do {\n        if (a == b) {\n            return true;\n        }\n        a = a.tp$base;\n    } while (a !== undefined);\n\n    return (b == Sk.builtin.object);\n};\n\nSk.builtin.PyType_IsSubtype = function PyType_IsSubtype(a, b) {\n    var mro = a.tp$mro;\n    if (mro) {\n        /* Deal with multiple inheritance without recursion\n           by walking the MRO tuple */\n        Sk.asserts.assert(mro instanceof Sk.builtin.tuple);\n        for (var i = 0; i < mro.v.length; i++) {\n            if (mro.v[i] == b) {\n                return true;\n            }\n        }\n        return false;\n    } else {\n        /* a is not completely initilized yet; follow tp_base */\n        return Sk.builtin.type_is_subtype_base_chain(a, b);\n    }\n};\n\n/**\n * @constructor\n * Sk.builtin.super_\n */\nSk.builtin.super_ = function super_ (a_type, self) {\n    Sk.builtin.pyCheckArgsLen(\"super\", arguments.length, 1);\n\n    if (!(this instanceof Sk.builtin.super_)) {\n        return new Sk.builtin.super_(a_type, self);\n    }\n\n    Sk.misceval.callsimArray(Sk.builtin.super_.__init__, [this, a_type, self]);\n\n    return this;\n};\n\nSk.builtin.super_.__init__ = new Sk.builtin.func(function(self, a_type, other_self) {\n    self.obj = other_self;\n    self.type = a_type;\n\n    if (!a_type.tp$mro) {\n        throw new Sk.builtin.TypeError(\"must be type, not \" + a_type.ob$type.tp$name);\n    }\n\n    self.obj_type = a_type.tp$mro.v[1];\n\n    if (!other_self) {\n        throw new Sk.builtin.NotImplementedError(\"unbound super not supported because \" +\n                \"skulpts implementation of type descriptors aren't brilliant yet, see this \" +\n                \"question for more information https://stackoverflow.com/a/30190341/117242\");\n    }\n\n    if (!Sk.builtin.PyType_IsSubtype(self.obj.ob$type, self.type)) {\n        throw new Sk.builtin.TypeError(\"super(type, obj): obj must be an instance of subtype of type\");\n    }\n\n    return Sk.builtin.none.none$;\n});\n\nSk.abstr.setUpInheritance(\"super\", Sk.builtin.super_, Sk.builtin.object);\n\n/**\n * Get an attribute\n * @param {Object} pyName Python name of the attribute\n * @param {boolean=} canSuspend Can we return a suspension?\n * @return {undefined}\n */\nSk.builtin.super_.prototype.tp$getattr = function (pyName, canSuspend) {\n    var res;\n    var f;\n    var descr;\n    var tp;\n    var dict;\n    var jsName = pyName.$jsstr();\n\n    tp = this.obj_type;\n    Sk.asserts.assert(tp !== undefined, \"object has no ob$type!\");\n\n    dict = this.obj[\"$d\"] || this.obj.constructor[\"$d\"];\n\n    // todo; assert? force?\n    if (dict) {\n        if (dict.mp$lookup) {\n            res = dict.mp$lookup(pyName);\n        } else if (dict.mp$subscript) {\n            res = Sk.builtin._tryGetSubscript(dict, pyName);\n        } else if (typeof dict === \"object\") {\n            // todo; definitely the wrong place for this. other custom tp$getattr won't work on object -- bnm -- implemented custom __getattr__ in abstract.js\n            res = dict[jsName];\n        }\n        if (res !== undefined) {\n            return res;\n        }\n    }\n\n    descr = Sk.builtin.type.typeLookup(tp, pyName);\n\n    // otherwise, look in the type for a descr\n    if (descr !== undefined && descr !== null) {\n        f = descr.tp$descr_get;\n        // todo - data descriptors (ie those with tp$descr_set too) get a different lookup priority\n\n        if (f) {\n            // non-data descriptor\n            return f.call(descr, this.obj, this.obj_type, canSuspend);\n        }\n    }\n\n    if (descr !== undefined) {\n        return descr;\n    }\n\n    return undefined;\n};\n\nSk.builtin.super_.prototype[\"$r\"] = function super_repr(self) {\n    if (this.obj) {\n        return new Sk.builtin.str(\"<super: <class '\" + (this.type ? this.type.tp$name : \"NULL\") + \"'>, <\" + this.obj.tp$name + \" object>>\");\n    }\n\n    return new Sk.builtin.str(\"<super: <class '\" + (this.type ? this.type.tp$name : \"NULL\") + \"'>, NULL>\");\n};\n\nSk.builtin.super_.__doc__ = new Sk.builtin.str(\n    \"super(type, obj) -> bound super object; requires isinstance(obj, type)\\n\" +\n    \"super(type) -> unbound super object\\n\" +\n    \"super(type, type2) -> bound super object; requires issubclass(type2, type)\\n\" +\n    \"Typical use to call a cooperative superclass method:\\n\" +\n    \"class C(B):\\n\" +\n    \"    def meth(self, arg):\\n\" +\n    \"        super(C, self).meth(arg)\");\n","// Note: the hacky names on int, long, float have to correspond with the\n// uniquization that the compiler does for words that are reserved in\n// Javascript. This is a bit hokey.\nSk.builtins = {\n    \"range\"     : new Sk.builtin.func(Sk.builtin.range),\n    \"round\"     : new Sk.builtin.func(Sk.builtin.round),\n    \"len\"       : new Sk.builtin.func(Sk.builtin.len),\n    \"min\"       : new Sk.builtin.func(Sk.builtin.min),\n    \"max\"       : new Sk.builtin.func(Sk.builtin.max),\n    \"sum\"       : new Sk.builtin.func(Sk.builtin.sum),\n    \"zip\"       : new Sk.builtin.func(Sk.builtin.zip),\n    \"abs\"       : new Sk.builtin.func(Sk.builtin.abs),\n    \"fabs\"      : new Sk.builtin.func(Sk.builtin.fabs),\n    \"ord\"       : new Sk.builtin.func(Sk.builtin.ord),\n    \"chr\"       : new Sk.builtin.func(Sk.builtin.chr),\n    \"hex\"       : new Sk.builtin.func(Sk.builtin.hex),\n    \"oct\"       : new Sk.builtin.func(Sk.builtin.oct),\n    \"bin\"       : new Sk.builtin.func(Sk.builtin.bin),\n    \"dir\"       : new Sk.builtin.func(Sk.builtin.dir),\n    \"repr\"      : new Sk.builtin.func(Sk.builtin.repr),\n    \"open\"      : new Sk.builtin.func(Sk.builtin.open),\n    \"isinstance\": new Sk.builtin.func(Sk.builtin.isinstance),\n    \"hash\"      : new Sk.builtin.func(Sk.builtin.hash),\n    \"getattr\"   : new Sk.builtin.func(Sk.builtin.getattr),\n    \"hasattr\"   : new Sk.builtin.func(Sk.builtin.hasattr),\n    \"id\"        : new Sk.builtin.func(Sk.builtin.id),\n\n    \"map\"       : new Sk.builtin.func(Sk.builtin.map),\n    \"filter\"    : new Sk.builtin.func(Sk.builtin.filter),\n    \"reduce\"    : new Sk.builtin.func(Sk.builtin.reduce),\n    \"sorted\"    : new Sk.builtin.func(Sk.builtin.sorted),\n    \"any\"       : new Sk.builtin.func(Sk.builtin.any),\n    \"all\"       : new Sk.builtin.func(Sk.builtin.all),\n\n    \"AttributeError\"     : Sk.builtin.AttributeError,\n    \"ValueError\"         : Sk.builtin.ValueError,\n    \"Exception\"          : Sk.builtin.Exception,\n    \"ZeroDivisionError\"  : Sk.builtin.ZeroDivisionError,\n    \"AssertionError\"     : Sk.builtin.AssertionError,\n    \"ImportError\"        : Sk.builtin.ImportError,\n    \"IndentationError\"   : Sk.builtin.IndentationError,\n    \"IndexError\"         : Sk.builtin.IndexError,\n    \"KeyError\"           : Sk.builtin.KeyError,\n    \"TypeError\"          : Sk.builtin.TypeError,\n    \"NameError\"          : Sk.builtin.NameError,\n    \"IOError\"            : Sk.builtin.IOError,\n    \"NotImplementedError\": Sk.builtin.NotImplementedError,\n    \"StandardError\"      : Sk.builtin.StandardError,\n    \"SystemExit\"         : Sk.builtin.SystemExit,\n    \"OverflowError\"      : Sk.builtin.OverflowError,\n    \"OperationError\"     : Sk.builtin.OperationError,\n    \"NegativePowerError\" : Sk.builtin.NegativePowerError,\n    \"RuntimeError\"       : Sk.builtin.RuntimeError,\n    \"StopIteration\"      : Sk.builtin.StopIteration,\n\n    \"float_$rw$\": Sk.builtin.float_,\n    \"int_$rw$\"  : Sk.builtin.int_,\n    \"bool\"      : Sk.builtin.bool,\n    \"complex\"   : Sk.builtin.complex,\n    \"enumerate\" : Sk.builtin.enumerate,\n    \"dict\"      : Sk.builtin.dict,\n    \"file\"      : Sk.builtin.file,\n    \"function\"  : Sk.builtin.func,\n    \"generator\" : Sk.builtin.generator,\n    \"list\"      : Sk.builtin.list,\n    \"long_$rw$\" : Sk.builtin.lng,\n    \"method\"    : Sk.builtin.method,\n    \"object\"    : Sk.builtin.object,\n    \"slice\"     : Sk.builtin.slice,\n    \"str\"       : Sk.builtin.str,\n    \"set\"       : Sk.builtin.set,\n    \"tuple\"     : Sk.builtin.tuple,\n    \"type\"      : Sk.builtin.type,\n\n    \"input\"     : new Sk.builtin.func(Sk.builtin.input),\n    \"raw_input\" : new Sk.builtin.func(Sk.builtin.raw_input),\n    \"setattr\"   : new Sk.builtin.func(Sk.builtin.setattr),\n    /*'read': Sk.builtin.read,*/\n    \"jseval\"    : Sk.builtin.jseval,\n    \"jsmillis\"  : Sk.builtin.jsmillis,\n    \"quit\"      : new Sk.builtin.func(Sk.builtin.quit),\n    \"exit\"      : new Sk.builtin.func(Sk.builtin.quit),\n    \"print\"     : Sk.builtin.print,\n    \"divmod\"    : new Sk.builtin.func(Sk.builtin.divmod),\n    \"format\"    : new Sk.builtin.func(Sk.builtin.format),\n    \"globals\"   : new Sk.builtin.func(Sk.builtin.globals),\n    \"issubclass\": new Sk.builtin.func(Sk.builtin.issubclass),\n    \"iter\"      : Sk.builtin.iter,\n\n    // Functions below are not implemented\n    \"bytearray\" : Sk.builtin.bytearray,\n    \"callable\"  : Sk.builtin.callable,\n    \"delattr\"   : Sk.builtin.delattr,\n    \"eval_$rn$\" : Sk.builtin.eval_,\n    \"execfile\"  : Sk.builtin.execfile,\n    \"frozenset\" : Sk.builtin.frozenset,\n    \"help\"      : Sk.builtin.help,\n    \"locals\"    : Sk.builtin.locals,\n    \"memoryview\": Sk.builtin.memoryview,\n    \"next\"      : Sk.builtin.next_,\n    \"pow\"       : Sk.builtin.pow,\n    \"reload\"    : Sk.builtin.reload,\n    \"reversed\"  : Sk.builtin.reversed,\n    \"super\"     : Sk.builtin.super_,\n    \"unichr\"    : Sk.builtin.unichr,\n    \"vars\"      : Sk.builtin.vars,\n    \"xrange\"    : Sk.builtin.xrange,\n    \"apply_$rn$\": Sk.builtin.apply_,\n    \"buffer\"    : Sk.builtin.buffer,\n    \"coerce\"    : Sk.builtin.coerce,\n    \"intern\"    : Sk.builtin.intern\n};\nSk.exportSymbol(\"Sk.builtins\", Sk.builtins);\n","Sk.builtin.str.$emptystr = new Sk.builtin.str(\"\");\n\n/**\n * Python bool True constant.\n * @type {Sk.builtin.bool}\n * @memberOf Sk.builtin.bool\n */\nSk.builtin.bool.true$ = /** @type {Sk.builtin.bool} */ (Object.create(Sk.builtin.bool.prototype, {v: {value: 1, enumerable: true}}));\n\n/**\n * Python bool False constant.\n * @type {Sk.builtin.bool}\n * @memberOf Sk.builtin.bool\n */\nSk.builtin.bool.false$ = /** @type {Sk.builtin.bool} */ (Object.create(Sk.builtin.bool.prototype, {v: {value: 0, enumerable: true}}));\n\n/* Constants used for kwargs */\n\n// Sk.builtin.int_\nSk.builtin.int_.co_varnames = [ \"number\", \"base\" ];\nSk.builtin.int_.$defaults = [ 0, Sk.builtin.none.none$ ];\n\n// Sk.builtin.lng\nSk.builtin.lng.co_varnames = [ \"number\", \"base\" ];\nSk.builtin.lng.$defaults = [ 0, Sk.builtin.none.none$ ];\n\n// Sk.builtin.sorted\nSk.builtin.sorted.co_varnames = [\"list\", \"cmp\", \"key\", \"reverse\"];\nSk.builtin.sorted.$defaults = [Sk.builtin.none.none$, Sk.builtin.none.none$, Sk.builtin.bool.false$];\n\n// Sk.builtin.dict.fromkeys\nSk.builtin.dict.$fromkeys.co_name = new Sk.builtin.str(\"fromkeys\");\nSk.builtin.dict.prototype[\"fromkeys\"] = new Sk.builtin.func(Sk.builtin.dict.$fromkeys);\n\n// String constants\nSk.builtin.str.$empty = new Sk.builtin.str(\"\");\n\nSk.builtin.str.$default_factory = new Sk.builtin.str(\"default_factory\");\nSk.builtin.str.$imag = new Sk.builtin.str(\"imag\");\nSk.builtin.str.$real = new Sk.builtin.str(\"real\");\n\nSk.builtin.str.$abs = new Sk.builtin.str(\"__abs__\");\nSk.builtin.str.$call = new Sk.builtin.str(\"__call__\");\nSk.builtin.str.$cmp = new Sk.builtin.str(\"__cmp__\");\nSk.builtin.str.$complex = new Sk.builtin.str(\"__complex__\");\nSk.builtin.str.$contains = new Sk.builtin.str(\"__contains__\");\nSk.builtin.str.$copy = new Sk.builtin.str(\"__copy__\");\nSk.builtin.str.$dict = new Sk.builtin.str(\"__dict__\");\nSk.builtin.str.$dir = new Sk.builtin.str(\"__dir__\");\nSk.builtin.str.$enter = new Sk.builtin.str(\"__enter__\");\nSk.builtin.str.$eq = new Sk.builtin.str(\"__eq__\");\nSk.builtin.str.$exit = new Sk.builtin.str(\"__exit__\");\nSk.builtin.str.$index = new Sk.builtin.str(\"__index__\");\nSk.builtin.str.$init = new Sk.builtin.str(\"__init__\");\nSk.builtin.str.$int_ = new Sk.builtin.str(\"__int__\");\nSk.builtin.str.$iter = new Sk.builtin.str(\"__iter__\");\nSk.builtin.str.$float_ = new Sk.builtin.str(\"__float__\");\nSk.builtin.str.$format = new Sk.builtin.str(\"__format__\");\nSk.builtin.str.$ge = new Sk.builtin.str(\"__ge__\");\nSk.builtin.str.$getattr = new Sk.builtin.str(\"__getattr__\");\nSk.builtin.str.$getattribute = new Sk.builtin.str(\"__getattribute__\");\nSk.builtin.str.$getitem = new Sk.builtin.str(\"__getitem__\");\nSk.builtin.str.$gt = new Sk.builtin.str(\"__gt__\");\nSk.builtin.str.$le = new Sk.builtin.str(\"__le__\");\nSk.builtin.str.$len = new Sk.builtin.str(\"__len__\");\nSk.builtin.str.$lt = new Sk.builtin.str(\"__lt__\");\nSk.builtin.str.$name = new Sk.builtin.str(\"__name__\");\nSk.builtin.str.$ne = new Sk.builtin.str(\"__ne__\");\nSk.builtin.str.$new = new Sk.builtin.str(\"__new__\");\nSk.builtin.str.$next2 = new Sk.builtin.str(\"next\");\nSk.builtin.str.$next3 = new Sk.builtin.str(\"__next__\");\nSk.builtin.str.$path = new Sk.builtin.str(\"__path__\");\nSk.builtin.str.$repr = new Sk.builtin.str(\"__repr__\");\nSk.builtin.str.$reversed = new Sk.builtin.str(\"__reversed__\");\nSk.builtin.str.$round = new Sk.builtin.str(\"__round__\");\nSk.builtin.str.$setattr = new Sk.builtin.str(\"__setattr__\");\nSk.builtin.str.$setitem = new Sk.builtin.str(\"__setitem__\");\nSk.builtin.str.$str = new Sk.builtin.str(\"__str__\");\nSk.builtin.str.$trunc = new Sk.builtin.str(\"__trunc__\");\nSk.builtin.str.$write = new Sk.builtin.str(\"write\");\n\nSk.misceval.op2method_ = {\n    \"Eq\"   : Sk.builtin.str.$eq,\n    \"NotEq\": Sk.builtin.str.$ne,\n    \"Gt\"   : Sk.builtin.str.$gt,\n    \"GtE\"  : Sk.builtin.str.$ge,\n    \"Lt\"   : Sk.builtin.str.$lt,\n    \"LtE\"  : Sk.builtin.str.$le\n};\n\nvar builtinNames = [\n    \"int_\",\n    \"lng\",\n    \"sorted\",\n    \"range\",\n    \"round\",\n    \"len\",\n    \"min\",\n    \"max\",\n    \"sum\",\n    \"zip\",\n    \"abs\",\n    \"fabs\",\n    \"ord\",\n    \"chr\",\n    \"hex\",\n    \"oct\",\n    \"bin\",\n    \"dir\",\n    \"repr\",\n    \"open\",\n    \"isinstance\",\n    \"hash\",\n    \"getattr\",\n    \"hasattr\",\n    \"id\",\n    \"map\",\n    \"filter\",\n    \"reduce\",\n    \"sorted\",\n    \"any\",\n    \"all\",\n    \"input\",\n    \"raw_input\",\n    \"setattr\",\n    \"quit\",\n    \"quit\",\n    \"divmod\",\n    \"format\",\n    \"globals\",\n    \"issubclass\"\n];\n\nfor (var i = 0; i < builtinNames.length; i++) {\n    Sk.builtin[builtinNames[i]].co_name = new Sk.builtin.str(builtinNames[i]);\n}\n","Sk.internalPy={\"files\":{\"src/classmethod.py\":\"class classmethod(object):\\n    \\\"Emulate PyClassMethod_Type() in Objects/funcobject.c\\\"\\n\\n    def __init__(self, f):\\n        self.f = f\\n\\n    def __get__(self, obj, klass=None):\\n        if klass is None:\\n            klass = type(obj)\\n        def newfunc(*args):\\n            return self.f(klass, *args)\\n        return newfunc\\n\",\"src/property.py\":\"class property(object):\\n    \\\"Emulate PyProperty_Type() in Objects/descrobject.c\\\"\\n\\n    def __init__(self, fget=None, fset=None, fdel=None, doc=None):\\n        self.fget = fget\\n        self.fset = fset\\n        self.fdel = fdel\\n        if doc is None and fget is not None:\\n            if hasattr(fget, '__doc__'):\\n                doc = fget.__doc__\\n            else:\\n                doc = None\\n        self.__doc__ = doc\\n\\n    def __get__(self, obj, objtype=None):\\n        if obj is None:\\n            return self\\n        if self.fget is None:\\n            raise AttributeError(\\\"unreadable attribute\\\")\\n        return self.fget(obj)\\n\\n    def __set__(self, obj, value):\\n        if self.fset is None:\\n            raise AttributeError(\\\"can't set attribute\\\")\\n        self.fset(obj, value)\\n\\n    def __delete__(self, obj):\\n        if self.fdel is None:\\n            raise AttributeError(\\\"can't delete attribute\\\")\\n        self.fdel(obj)\\n\\n    def getter(self, fget):\\n        return type(self)(fget, self.fset, self.fdel, self.__doc__)\\n\\n    def setter(self, fset):\\n        return type(self)(self.fget, fset, self.fdel, self.__doc__)\\n\\n    def deleter(self, fdel):\\n        return type(self)(self.fget, self.fset, fdel, self.__doc__)\\n\",\"src/staticmethod.py\":\"class staticmethod(object):\\n    \\\"Emulate PyStaticMethod_Type() in Objects/funcobject.c\\\"\\n\\n    def __init__(self, f):\\n        self.f = f\\n\\n    def __get__(self, obj, objtype=None):\\n        return self.f\\n\"}}"],"sourceRoot":""}