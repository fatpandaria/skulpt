Sk.builtinFiles={"files":{"src/builtin/sys.js":"var $builtinmodule=function(){var b,a=Math.pow,c={},d=[],e=Sk.getSysArgv();for(b=0;b<e.length;++b)d.push(new Sk.builtin.str(e[b]));return c.argv=new Sk.builtins.list(d),c.copyright=Sk.builtin.str(\"Copyright 2009-2010 Scott Graham.\\nAll Rights Reserved.\\n\"),c.maxint=new Sk.builtin.int_(a(2,53)-1),c.maxsize=new Sk.builtin.int_(a(2,53)-1),c.modules=Sk.sysmodules,c.path=Sk.realsyspath,c.getExecutionLimit=new Sk.builtin.func(function(){return null===Sk.execLimit?Sk.builtin.none.none$:new Sk.builtin.int_(Sk.execLimit)}),c.setExecutionLimit=new Sk.builtin.func(function(a){if(null===Sk.execLimit)throw new Sk.builtin.NotImplementedError(\"Execution limiting is not enabled\");void 0!==a&&(Sk.execLimit=Sk.builtin.asnum$(a))}),c.resetTimeout=new Sk.builtin.func(function(){Sk.execStart=new Date}),c.getYieldLimit=new Sk.builtin.func(function(){return null===Sk.yieldLimit?Sk.builtin.none.none$:new Sk.builtin.int_(Sk.yieldLimit)}),c.setYieldLimit=new Sk.builtin.func(function(a){if(null===Sk.yieldLimit)throw new Sk.builtin.NotImplementedError(\"Yielding is not enabled\");void 0!==a&&(Sk.yieldLimit=Sk.builtin.asnum$(a))}),c.debug=new Sk.builtin.func(function(){return Sk.builtin.none.none$}),c.__stdout__=new Sk.builtin.file(new Sk.builtin.str(\"/dev/stdout\"),new Sk.builtin.str(\"w\")),c.__stdin__=new Sk.builtin.file(new Sk.builtin.str(\"/dev/stdin\"),new Sk.builtin.str(\"r\")),c.stdout=c.__stdout__,c.stdin=c.__stdin__,c};","src/builtin/this.py":"s = \"\"\"Gur Mra bs Clguba, ol Gvz Crgref\n\nOrnhgvshy vf orggre guna htyl.\nRkcyvpvg vf orggre guna vzcyvpvg.\nFvzcyr vf orggre guna pbzcyrk.\nPbzcyrk vf orggre guna pbzcyvpngrq.\nSyng vf orggre guna arfgrq.\nFcnefr vf orggre guna qrafr.\nErnqnovyvgl pbhagf.\nFcrpvny pnfrf nera'g fcrpvny rabhtu gb oernx gur ehyrf.\nNygubhtu cenpgvpnyvgl orngf chevgl.\nReebef fubhyq arire cnff fvyragyl.\nHayrff rkcyvpvgyl fvyraprq.\nVa gur snpr bs nzovthvgl, ershfr gur grzcgngvba gb thrff.\nGurer fubhyq or bar-- naq cersrenoyl bayl bar --boivbhf jnl gb qb vg.\nNygubhtu gung jnl znl abg or boivbhf ng svefg hayrff lbh'er Qhgpu.\nAbj vf orggre guna arire.\nNygubhtu arire vf bsgra orggre guna *evtug* abj.\nVs gur vzcyrzragngvba vf uneq gb rkcynva, vg'f n onq vqrn.\nVs gur vzcyrzragngvba vf rnfl gb rkcynva, vg znl or n tbbq vqrn.\nAnzrfcnprf ner bar ubaxvat terng vqrn -- yrg'f qb zber bs gubfr!\"\"\"\n\nd = {}\nfor c in (65, 97):\n    for i in range(26):\n        d[chr(i+c)] = chr((i+13) % 26 + c)\n\nprint \"\".join([d.get(c, c) for c in s])\n","src/lib/BaseHTTPServer.py":"raise NotImplementedError(\"BaseHTTPServer is not yet implemented in Skulpt\")\n","src/lib/Bastion.py":"raise NotImplementedError(\"Bastion is not yet implemented in Skulpt\")\n","src/lib/CGIHTTPServer.py":"raise NotImplementedError(\"CGIHTTPServer is not yet implemented in Skulpt\")\n","src/lib/ConfigParser.py":"raise NotImplementedError(\"ConfigParser is not yet implemented in Skulpt\")\n","src/lib/Cookie.py":"raise NotImplementedError(\"Cookie is not yet implemented in Skulpt\")\n","src/lib/DocXMLRPCServer.py":"raise NotImplementedError(\"DocXMLRPCServer is not yet implemented in Skulpt\")\n","src/lib/HTMLParser.py":"raise NotImplementedError(\"HTMLParser is not yet implemented in Skulpt\")\n","src/lib/MimeWriter.py":"raise NotImplementedError(\"MimeWriter is not yet implemented in Skulpt\")\n","src/lib/Queue.py":"raise NotImplementedError(\"Queue is not yet implemented in Skulpt\")\n","src/lib/SimpleHTTPServer.py":"raise NotImplementedError(\"SimpleHTTPServer is not yet implemented in Skulpt\")\n","src/lib/SimpleXMLRPCServer.py":"raise NotImplementedError(\"SimpleXMLRPCServer is not yet implemented in Skulpt\")\n","src/lib/SocketServer.py":"raise NotImplementedError(\"SocketServer is not yet implemented in Skulpt\")\n","src/lib/StringIO.py":"r\"\"\"File-like objects that read from or write to a string buffer.\n\nThis implements (nearly) all stdio methods.\n\nf = StringIO()      # ready for writing\nf = StringIO(buf)   # ready for reading\nf.close()           # explicitly release resources held\nflag = f.isatty()   # always false\npos = f.tell()      # get current position\nf.seek(pos)         # set current position\nf.seek(pos, mode)   # mode 0: absolute; 1: relative; 2: relative to EOF\nbuf = f.read()      # read until EOF\nbuf = f.read(n)     # read up to n bytes\nbuf = f.readline()  # read until end of line ('\\n') or EOF\nlist = f.readlines()# list of f.readline() results until EOF\nf.truncate([size])  # truncate file at to at most size (default: current pos)\nf.write(buf)        # write at current position\nf.writelines(list)  # for line in list: f.write(line)\nf.getvalue()        # return whole file's contents as a string\n\nNotes:\n- Using a real file is often faster (but less convenient).\n- There's also a much faster implementation in C, called cStringIO, but\n  it's not subclassable.\n- fileno() is left unimplemented so that code which uses it triggers\n  an exception early.\n- Seeking far beyond EOF and then writing will insert real null\n  bytes that occupy space in the buffer.\n- There's a simple test set (see end of this file).\n\"\"\"\n\n__all__ = [\"StringIO\"]\n\ndef _complain_ifclosed(closed):\n    if closed:\n        raise ValueError(\"I/O operation on closed file\")\n\nclass StringIO:\n    \"\"\"class StringIO([buffer])\n\n    When a StringIO object is created, it can be initialized to an existing\n    string by passing the string to the constructor. If no string is given,\n    the StringIO will start empty.\n\n    The StringIO object can accept either Unicode or 8-bit strings, but\n    mixing the two may take some care. If both are used, 8-bit strings that\n    cannot be interpreted as 7-bit ASCII (that use the 8th bit) will cause\n    a UnicodeError to be raised when getvalue() is called.\n    \"\"\"\n    def __init__(self, buf = ''):\n        # Force self.buf to be a string or unicode\n        if not isinstance(buf, str):\n            buf = str(buf)\n        self.buf = buf\n        self.len = len(buf)\n        self.buflist = []\n        self.pos = 0\n        self.closed = False\n        self.softspace = 0\n\n    def __iter__(self):\n        return self\n\n    def next(self):\n        \"\"\"A file object is its own iterator, for example iter(f) returns f\n        (unless f is closed). When a file is used as an iterator, typically\n        in a for loop (for example, for line in f: print line), the next()\n        method is called repeatedly. This method returns the next input line,\n        or raises StopIteration when EOF is hit.\n        \"\"\"\n        _complain_ifclosed(self.closed)\n        r = self.readline()\n        if not r:\n            raise StopIteration\n        return r\n\n    def close(self):\n        \"\"\"Free the memory buffer.\n        \"\"\"\n        if not self.closed:\n            self.closed = True\n            self.buf = None\n            self.pos = None\n\n    def isatty(self):\n        \"\"\"Returns False because StringIO objects are not connected to a\n        tty-like device.\n        \"\"\"\n        _complain_ifclosed(self.closed)\n        return False\n\n    def seek(self, pos, mode = 0):\n        \"\"\"Set the file's current position.\n\n        The mode argument is optional and defaults to 0 (absolute file\n        positioning); other values are 1 (seek relative to the current\n        position) and 2 (seek relative to the file's end).\n\n        There is no return value.\n        \"\"\"\n        _complain_ifclosed(self.closed)\n        if self.buflist:\n            self.buf += ''.join(self.buflist)\n            self.buflist = []\n        if mode == 1:\n            pos += self.pos\n        elif mode == 2:\n            pos += self.len\n        self.pos = max(0, pos)\n\n    def tell(self):\n        \"\"\"Return the file's current position.\"\"\"\n        _complain_ifclosed(self.closed)\n        return self.pos\n\n    def read(self, n = -1):\n        \"\"\"Read at most size bytes from the file\n        (less if the read hits EOF before obtaining size bytes).\n\n        If the size argument is negative or omitted, read all data until EOF\n        is reached. The bytes are returned as a string object. An empty\n        string is returned when EOF is encountered immediately.\n        \"\"\"\n        _complain_ifclosed(self.closed)\n        if self.buflist:\n            self.buf += ''.join(self.buflist)\n            self.buflist = []\n        if n is None or n < 0:\n            newpos = self.len\n        else:\n            newpos = min(self.pos+n, self.len)\n        r = self.buf[self.pos:newpos]\n        self.pos = newpos\n        return r\n\n    def readline(self, length=None):\n        r\"\"\"Read one entire line from the file.\n\n        A trailing newline character is kept in the string (but may be absent\n        when a file ends with an incomplete line). If the size argument is\n        present and non-negative, it is a maximum byte count (including the\n        trailing newline) and an incomplete line may be returned.\n\n        An empty string is returned only when EOF is encountered immediately.\n\n        Note: Unlike stdio's fgets(), the returned string contains null\n        characters ('\\0') if they occurred in the input.\n        \"\"\"\n        _complain_ifclosed(self.closed)\n        if self.buflist:\n            self.buf += ''.join(self.buflist)\n            self.buflist = []\n        i = self.buf.find('\\n', self.pos)\n        if i < 0:\n            newpos = self.len\n        else:\n            newpos = i+1\n        if length is not None and length >= 0:\n            if self.pos + length < newpos:\n                newpos = self.pos + length\n        r = self.buf[self.pos:newpos]\n        self.pos = newpos\n        return r\n\n    def readlines(self, sizehint = 0):\n        \"\"\"Read until EOF using readline() and return a list containing the\n        lines thus read.\n\n        If the optional sizehint argument is present, instead of reading up\n        to EOF, whole lines totalling approximately sizehint bytes (or more\n        to accommodate a final whole line).\n        \"\"\"\n        total = 0\n        lines = []\n        line = self.readline()\n        while line:\n            lines.append(line)\n            total += len(line)\n            if 0 < sizehint <= total:\n                break\n            line = self.readline()\n        return lines\n\n    def truncate(self, size=None):\n        \"\"\"Truncate the file's size.\n\n        If the optional size argument is present, the file is truncated to\n        (at most) that size. The size defaults to the current position.\n        The current file position is not changed unless the position\n        is beyond the new file size.\n\n        If the specified size exceeds the file's current size, the\n        file remains unchanged.\n        \"\"\"\n        _complain_ifclosed(self.closed)\n        if size is None:\n            size = self.pos\n        elif size < 0:\n            raise IOError(22, \"Negative size not allowed\")\n        elif size < self.pos:\n            self.pos = size\n        self.buf = self.getvalue()[:size]\n        self.len = size\n\n    def write(self, s):\n        \"\"\"Write a string to the file.\n\n        There is no return value.\n        \"\"\"\n        _complain_ifclosed(self.closed)\n        if not s: return\n        # Force s to be a string or unicode\n        if not isinstance(s, str):\n            s = str(s)\n        spos = self.pos\n        slen = self.len\n        if spos == slen:\n            self.buflist.append(s)\n            self.len = self.pos = spos + len(s)\n            return\n        if spos > slen:\n            self.buflist.append('\\0'*(spos - slen))\n            slen = spos\n        newpos = spos + len(s)\n        if spos < slen:\n            if self.buflist:\n                self.buf += ''.join(self.buflist)\n            self.buflist = [self.buf[:spos], s, self.buf[newpos:]]\n            self.buf = ''\n            if newpos > slen:\n                slen = newpos\n        else:\n            self.buflist.append(s)\n            slen = newpos\n        self.len = slen\n        self.pos = newpos\n\n    def writelines(self, iterable):\n        \"\"\"Write a sequence of strings to the file. The sequence can be any\n        iterable object producing strings, typically a list of strings. There\n        is no return value.\n\n        (The name is intended to match readlines(); writelines() does not add\n        line separators.)\n        \"\"\"\n        write = self.write\n        for line in iterable:\n            write(line)\n\n    def flush(self):\n        \"\"\"Flush the internal buffer\n        \"\"\"\n        _complain_ifclosed(self.closed)\n\n    def getvalue(self):\n        \"\"\"\n        Retrieve the entire contents of the \"file\" at any time before\n        the StringIO object's close() method is called.\n\n        The StringIO object can accept either Unicode or 8-bit strings,\n        but mixing the two may take some care. If both are used, 8-bit\n        strings that cannot be interpreted as 7-bit ASCII (that use the\n        8th bit) will cause a UnicodeError to be raised when getvalue()\n        is called.\n        \"\"\"\n        _complain_ifclosed(self.closed)\n        if self.buflist:\n            self.buf += ''.join(self.buflist)\n            self.buflist = []\n        return self.buf\n","src/lib/UserDict.py":"raise NotImplementedError(\"UserDict is not yet implemented in Skulpt\")\n","src/lib/UserList.py":"raise NotImplementedError(\"UserList is not yet implemented in Skulpt\")\n","src/lib/UserString.py":"raise NotImplementedError(\"UserString is not yet implemented in Skulpt\")\n","src/lib/_LWPCookieJar.py":"raise NotImplementedError(\"_LWPCookieJar is not yet implemented in Skulpt\")\n","src/lib/_MozillaCookieJar.py":"raise NotImplementedError(\"_MozillaCookieJar is not yet implemented in Skulpt\")\n","src/lib/__future__.py":"raise NotImplementedError(\"__future__ is not yet implemented in Skulpt\")\n","src/lib/__phello__.foo.py":"raise NotImplementedError(\"__phello__.foo is not yet implemented in Skulpt\")\n","src/lib/_abcoll.py":"raise NotImplementedError(\"_abcoll is not yet implemented in Skulpt\")\n","src/lib/_strptime.py":"raise NotImplementedError(\"_strptime is not yet implemented in Skulpt\")\n","src/lib/_threading_local.py":"raise NotImplementedError(\"_threading_local is not yet implemented in Skulpt\")\n","src/lib/abc.py":"raise NotImplementedError(\"abc is not yet implemented in Skulpt\")\n","src/lib/aifc.py":"raise NotImplementedError(\"aifc is not yet implemented in Skulpt\")\n","src/lib/antigravity.js":"window.open(\"https://xkcd.com/353/\",\"_blank\");","src/lib/anydbm.py":"raise NotImplementedError(\"anydbm is not yet implemented in Skulpt\")\n","src/lib/array.js":"$builtinmodule=function(){var a={},b=[\"c\",\"b\",\"B\",\"u\",\"h\",\"H\",\"i\",\"I\",\"l\",\"L\",\"f\",\"d\"];return a.array=Sk.misceval.buildClass(a,function(a,c){c.__init__=new Sk.builtin.func(function(a,c,d){if(Sk.builtin.pyCheckArgsLen(\"__init__\",arguments.length,2,3),-1==b.indexOf(Sk.ffi.remapToJs(c)))throw new Sk.builtin.ValueError(\"bad typecode (must be c, b, B, u, h, H, i, I, l, L, f or d)\");if(d&&!Sk.builtin.checkIterable(d))throw new Sk.builtin.TypeError(\"iteration over non-sequence\");if(a.$d.mp$ass_subscript(new Sk.builtin.str(\"typecode\"),c),a.$d.mp$ass_subscript(new Sk.builtin.str(\"__module__\"),new Sk.builtin.str(\"array\")),a.typecode=c,void 0===d)a.internalIterable=new Sk.builtin.list;else if(d instanceof Sk.builtin.list)a.internalIterable=d;else for(a.internalIterable=new Sk.builtin.list,iter=Sk.abstr.iter(d),item=iter.tp$iternext();void 0!==item;item=iter.tp$iternext())Sk.misceval.callsimArray(a.internalIterable.append,[a.internalIterable,item])}),c.__repr__=new Sk.builtin.func(function(a){var b=Sk.ffi.remapToJs(a.typecode),c=\"\";return Sk.ffi.remapToJs(a.internalIterable).length&&(\"c\"==Sk.ffi.remapToJs(a.typecode)?c=\", '\"+Sk.ffi.remapToJs(a.internalIterable).join(\"\")+\"'\":c=\", \"+Sk.ffi.remapToJs(Sk.misceval.callsimArray(a.internalIterable.__repr__,[a.internalIterable]))),new Sk.builtin.str(\"array('\"+b+\"'\"+c+\")\")}),c.__str__=c.__repr__,c.__getattribute__=new Sk.builtin.func(function(a,b){return a.tp$getattr(b)}),c.append=new Sk.builtin.func(function(a,b){return Sk.misceval.callsimArray(a.internalIterable.append,[a.internalIterable,b]),Sk.builtin.none.none$}),c.extend=new Sk.builtin.func(function(a,b){if(Sk.builtin.pyCheckArgsLen(\"__init__\",arguments.length,2,2),!Sk.builtin.checkIterable(b))throw new Sk.builtin.TypeError(\"iteration over non-sequence\");for(iter=Sk.abstr.iter(b),item=iter.tp$iternext();void 0!==item;item=iter.tp$iternext())Sk.misceval.callsimArray(a.internalIterable.append,[a.internalIterable,item])})},\"array\",[]),a.__name__=new Sk.builtin.str(\"array\"),a};","src/lib/ast.py":"raise NotImplementedError(\"ast is not yet implemented in Skulpt\")\n","src/lib/asynchat.py":"raise NotImplementedError(\"asynchat is not yet implemented in Skulpt\")\n","src/lib/asyncore.py":"raise NotImplementedError(\"asyncore is not yet implemented in Skulpt\")\n","src/lib/atexit.py":"raise NotImplementedError(\"atexit is not yet implemented in Skulpt\")\n","src/lib/audiodev.py":"raise NotImplementedError(\"audiodev is not yet implemented in Skulpt\")\n","src/lib/base64.py":"raise NotImplementedError(\"base64 is not yet implemented in Skulpt\")\n","src/lib/bdb.py":"raise NotImplementedError(\"bdb is not yet implemented in Skulpt\")\n","src/lib/binhex.py":"raise NotImplementedError(\"binhex is not yet implemented in Skulpt\")\n","src/lib/bisect.py":"\"\"\"Bisection algorithms.\"\"\"\n\ndef insort_right(a, x, lo=0, hi=None):\n    \"\"\"Insert item x in list a, and keep it sorted assuming a is sorted.\n\n    If x is already in a, insert it to the right of the rightmost x.\n\n    Optional args lo (default 0) and hi (default len(a)) bound the\n    slice of a to be searched.\n    \"\"\"\n\n    if lo < 0:\n        raise ValueError('lo must be non-negative')\n    if hi is None:\n        hi = len(a)\n    while lo < hi:\n        mid = (lo+hi)//2\n        if x < a[mid]: hi = mid\n        else: lo = mid+1\n    a.insert(lo, x)\n\ndef bisect_right(a, x, lo=0, hi=None):\n    \"\"\"Return the index where to insert item x in list a, assuming a is sorted.\n\n    The return value i is such that all e in a[:i] have e <= x, and all e in\n    a[i:] have e > x.  So if x already appears in the list, a.insert(x) will\n    insert just after the rightmost x already there.\n\n    Optional args lo (default 0) and hi (default len(a)) bound the\n    slice of a to be searched.\n    \"\"\"\n\n    if lo < 0:\n        raise ValueError('lo must be non-negative')\n    if hi is None:\n        hi = len(a)\n    while lo < hi:\n        mid = (lo+hi)//2\n        if x < a[mid]: hi = mid\n        else: lo = mid+1\n    return lo\n\ndef insort_left(a, x, lo=0, hi=None):\n    \"\"\"Insert item x in list a, and keep it sorted assuming a is sorted.\n\n    If x is already in a, insert it to the left of the leftmost x.\n\n    Optional args lo (default 0) and hi (default len(a)) bound the\n    slice of a to be searched.\n    \"\"\"\n\n    if lo < 0:\n        raise ValueError('lo must be non-negative')\n    if hi is None:\n        hi = len(a)\n    while lo < hi:\n        mid = (lo+hi)//2\n        if a[mid] < x: lo = mid+1\n        else: hi = mid\n    a.insert(lo, x)\n\n\ndef bisect_left(a, x, lo=0, hi=None):\n    \"\"\"Return the index where to insert item x in list a, assuming a is sorted.\n\n    The return value i is such that all e in a[:i] have e < x, and all e in\n    a[i:] have e >= x.  So if x already appears in the list, a.insert(x) will\n    insert just before the leftmost x already there.\n\n    Optional args lo (default 0) and hi (default len(a)) bound the\n    slice of a to be searched.\n    \"\"\"\n\n    if lo < 0:\n        raise ValueError('lo must be non-negative')\n    if hi is None:\n        hi = len(a)\n    while lo < hi:\n        mid = (lo+hi)//2\n        if a[mid] < x: lo = mid+1\n        else: hi = mid\n    return lo\n\n# Overwrite above definitions with a fast C implementation\ntry:\n    from _bisect import *\nexcept ImportError:\n    pass\n\n# Create aliases\nbisect = bisect_right\ninsort = insort_right\n","src/lib/bsddb/__init__.py":"raise NotImplementedError(\"bsddb is not yet implemented in Skulpt\")\n","src/lib/cProfile.py":"raise NotImplementedError(\"cProfile is not yet implemented in Skulpt\")\n","src/lib/calendar.py":"raise NotImplementedError(\"calendar is not yet implemented in Skulpt\")\n","src/lib/cgi.py":"raise NotImplementedError(\"cgi is not yet implemented in Skulpt\")\n","src/lib/cgitb.py":"raise NotImplementedError(\"cgitb is not yet implemented in Skulpt\")\n","src/lib/chunk.py":"raise NotImplementedError(\"chunk is not yet implemented in Skulpt\")\n","src/lib/cmd.py":"raise NotImplementedError(\"cmd is not yet implemented in Skulpt\")\n","src/lib/code.py":"raise NotImplementedError(\"code is not yet implemented in Skulpt\")\n","src/lib/codecs.py":"raise NotImplementedError(\"codecs is not yet implemented in Skulpt\")\n","src/lib/codeop.py":"raise NotImplementedError(\"codeop is not yet implemented in Skulpt\")\n","src/lib/codepku/__init__.py":"from turtle import *\nclass Pen(Turtle):\n\t\n\t# 绘制数码管间隔\n\tdef draw_gap(self):\n\t\tself.penup()\n\t\tself.forward(5)\n\n\t# 绘制单段数码管\n\tdef draw_line(self, draw):\n\t\tself.draw_gap()\n\t\t# 如果draw是True的话，画数码管\n\t\tif draw:\n\t\t\tself.pendown()\n\t\telse:\n\t\t\tself.penup()\n\t\tself.forward(30)\n\t\tself.draw_gap()\n\t\t# 每次画完一段数码管自动向右90度\n\t\tself.right(90)\n\n\t# 根据数字绘制七段数码管\n\tdef draw_digit(self, d):\n\t\t# 画第一段\n\t\tif d in [2, 3, 4, 5, 6, 8, 9]:\n\t\t\tself.draw_line(True)\n\t\telse:\n\t\t\tself.draw_line(False)\n\t\t# 画第二段\n\t\tif d in [0, 1, 3, 4, 5, 6, 7, 8, 9]:\n\t\t\tself.draw_line(True)\n\t\telse:\n\t\t\tself.draw_line(False)\n\t\t# 画第三段\n\t\tif d in [0, 2, 3, 5, 6, 8, 9]:\n\t\t\tself.draw_line(True)\n\t\telse:\n\t\t\tself.draw_line(False)\n\t\t# 画第四段\n\t\tif d in [0, 2, 6, 8]:\n\t\t\tself.draw_line(True)\n\t\telse:\n\t\t\tself.draw_line(False)\n\t\t# 因为第四段和第五段是一个方向，因此需要平衡掉draw_line中的右转\n\t\tself.left(90)\n\t\t# 画第五段\n\t\tif d in [0, 4, 5, 6, 8, 9]:\n\t\t\tself.draw_line(True)\n\t\telse:\n\t\t\tself.draw_line(False)\n\t\t# 画第六段\n\t\tif d in [0, 2, 3, 5, 6, 7, 8, 9]:\n\t\t\tself.draw_line(True)\n\t\telse:\n\t\t\tself.draw_line(False)\n\t\t# 画第七段\n\t\tif d in [0, 1, 2, 3, 4, 7, 8, 9]:\n\t\t\tself.draw_line(True)\n\t\telse:\n\t\t\tself.draw_line(False)\n\t\t# 将画笔移到下个位置以便画出下个数字\n\t\tself.left(180)\n\t\tself.penup()\n\t\tself.forward(20)","src/lib/codepku/codepku.py":"import math, sys\n\nclass codepku:\n    def ellipse(self, x_position, y_position ,x_radius, y_radius, rads=360, steps=60):\n        self.penup()\n        self.goto(x_position, y_position - y_radius)\n        self.pendown()\n        # 弧度\n        heading_radians = math.radians(self.heading())\n        # 弧度π/ 2 等于角度90\n        theta_radians = -math.pi / 2\n        # 2π是一周的弧度\n        extent_radians = 2 * math.pi\n        # 每一步的弧度\n        step_radians = extent_radians / steps\n\n        extent_radians += theta_radians\n        x_center, y_start = self.position()\n        y_center = y_start + y_radius\n\n        cos_heading, sin_heading = math.cos(heading_radians), math.sin(heading_radians)\n\n        # 控制弧度，60为一个圆\n        zcount = 0\n        while True:\n            # print('theta_radians={}, extent_radians={}, zcount={}'.format(theta_radians, extent_radians, zcount))\n            x, y = x_center + math.cos(theta_radians) * x_radius, y_center + math.sin(theta_radians) * y_radius\n            # readjust x & y to set the angle of the ellipse based on the original heading of the turtle\n            x, y = x - x_center, y - y_start\n            x, y = x * cos_heading - y * sin_heading, x * sin_heading + y * cos_heading\n            x, y = x + x_center, y + y_start\n\n            self.setheading(self.towards(x, y))  # turtle faces direction in which ellipse is drawn\n            self.goto(x, y)\n\n            # theta_radians 逼近 extent_radians\n            if theta_radians == extent_radians:\n                break\n            # 控制弧度\n            if zcount * 6 >= rads:\n                break\n\n            theta_radians = min(theta_radians + step_radians, extent_radians)  # don't overshoot our starting point\n\n            zcount += 1\n\n        self.setheading(self.towards(x_center, y_start)) \t # set correct heading for the next thing we draw\n","src/lib/collections.js":"var $builtinmodule=function(){return Sk.misceval.chain(Sk.importModule(\"keyword\",!1,!0),function(a){var b={};b.defaultdict=function(a,c){if(!(this instanceof b.defaultdict))return new b.defaultdict(a,c);if(Sk.abstr.superConstructor(b.defaultdict,this,c),void 0===a)this.default_factory=Sk.builtin.none.none$;else{if(!Sk.builtin.checkCallable(a)&&!(a instanceof Sk.builtin.none))throw new Sk.builtin.TypeError(\"first argument must be callable\");this.default_factory=a}return this.$d?this.$d.default_factory=this.default_factory:this.$d={default_factory:this.default_factory},this},Sk.abstr.setUpInheritance(\"defaultdict\",b.defaultdict,Sk.builtin.dict),b.defaultdict.prototype.$r=function(){var a=Sk.misceval.objectRepr(this.default_factory).v,b=Sk.builtin.dict.prototype.$r.call(this).v;return new Sk.builtin.str(\"defaultdict(\"+a+\", \"+b+\")\")},b.defaultdict.prototype.__copy__=function(a){var c,d,e,f=[];for(d=Sk.abstr.iter(a),e=d.tp$iternext();void 0!==e;e=d.tp$iternext())c=a.mp$subscript(e),f.push(e),f.push(c);return new b.defaultdict(a.$d.default_factory,f)},b.defaultdict.prototype.__missing__=function(a){if(Sk.builtin.pyCheckArgsLen(\"__missing__\",arguments.length,0,1),a)throw new Sk.builtin.KeyError(Sk.misceval.objectRepr(a));else return Sk.misceval.callsimArray(this.default_factory)},b.defaultdict.prototype.mp$subscript=function(a){try{return Sk.builtin.dict.prototype.mp$subscript.call(this,a)}catch(b){return this.default_factory instanceof Sk.builtin.none?this.__missing__(a):(ret=this.__missing__(),this.mp$ass_subscript(a,ret),ret)}},b.Counter=function(a){if(!(this instanceof b.Counter))return new b.Counter(a);if(a instanceof Sk.builtin.dict||void 0===a)Sk.abstr.superConstructor(b.Counter,this,a);else{if(!Sk.builtin.checkIterable(a))throw new Sk.builtin.TypeError(\"'\"+Sk.abstr.typeName(a)+\"' object is not iterable\");Sk.abstr.superConstructor(b.Counter,this);for(var c,d=new Sk.builtin.int_(1),e=a.tp$iter(),f=e.tp$iternext();void 0!==f;f=e.tp$iternext())c=this.mp$subscript(f),c=c.nb$add(d),this.mp$ass_subscript(f,c)}return this},Sk.abstr.setUpInheritance(\"Counter\",b.Counter,Sk.builtin.dict),b.Counter.prototype.$r=function(){var a=0<this.size?Sk.builtin.dict.prototype.$r.call(this).v:\"\";return new Sk.builtin.str(\"Counter(\"+a+\")\")},b.Counter.prototype.mp$subscript=function(a){try{return Sk.builtin.dict.prototype.mp$subscript.call(this,a)}catch(a){return new Sk.builtin.int_(0)}},b.Counter.prototype.elements=new Sk.builtin.func(function(a){Sk.builtin.pyCheckArgsLen(\"elements\",arguments.length,1,1);for(var b=[],c=a.tp$iter(),d=c.tp$iternext();void 0!==d;d=c.tp$iternext())for(var e=0;e<a.mp$subscript(d).v;e++)b.push(d);var f={tp$iter:function(){return f},$obj:this,$index:0,$elem:b,tp$iternext:function(){return f.$index>=f.$elem.length?void 0:f.$elem[f.$index++]}};return f}),b.Counter.prototype.most_common=new Sk.builtin.func(function(a,b){Sk.builtin.pyCheckArgsLen(\"most_common\",arguments.length,1,2);var c=a.mp$length();if(void 0===b)b=c;else{if(!Sk.builtin.checkInt(b))if(b instanceof Sk.builtin.float_)throw new Sk.builtin.TypeError(\"integer argument expected, got float\");else throw new Sk.builtin.TypeError(\"an integer is required\");b=Sk.builtin.asnum$(b),b=b<=c?b:c,b=0<=b?b:0}for(var d=[],e=a.tp$iter(),f=e.tp$iternext();void 0!==f;f=e.tp$iternext())d.push([f,a.mp$subscript(f)]);d=d.sort(function(c,a){return c[1].v<a[1].v?1:c[1].v>a[1].v?-1:0});for(var g=[],h=0;h<b;h++)g.push(new Sk.builtin.tuple(d.shift()));return new Sk.builtin.list(g)}),b.Counter.prototype.update=new Sk.builtin.func(function(a,b){if(Sk.builtin.pyCheckArgsLen(\"update\",arguments.length,1,2),b instanceof Sk.builtin.dict)for(var c,d=b.tp$iter(),e=d.tp$iternext();void 0!==e;e=d.tp$iternext())c=a.mp$subscript(e),a.mp$ass_subscript(e,c.nb$add(b.mp$subscript(e)));else if(void 0!==b){if(!Sk.builtin.checkIterable(b))throw new Sk.builtin.TypeError(\"'\"+Sk.abstr.typeName(b)+\"' object is not iterable\");for(var c,f=new Sk.builtin.int_(1),d=b.tp$iter(),e=d.tp$iternext();void 0!==e;e=d.tp$iternext())c=a.mp$subscript(e),a.mp$ass_subscript(e,c.nb$add(f))}}),b.Counter.prototype.subtract=new Sk.builtin.func(function(a,b){if(Sk.builtin.pyCheckArgsLen(\"subtract\",arguments.length,1,2),b instanceof Sk.builtin.dict)for(var c,d=b.tp$iter(),e=d.tp$iternext();void 0!==e;e=d.tp$iternext())c=a.mp$subscript(e),a.mp$ass_subscript(e,c.nb$subtract(b.mp$subscript(e)));else if(void 0!==b){if(!Sk.builtin.checkIterable(b))throw new Sk.builtin.TypeError(\"'\"+Sk.abstr.typeName(b)+\"' object is not iterable\");for(var c,f=new Sk.builtin.int_(1),d=b.tp$iter(),e=d.tp$iternext();void 0!==e;e=d.tp$iternext())c=a.mp$subscript(e),a.mp$ass_subscript(e,c.nb$subtract(f))}}),b.OrderedDict=function(a){return this instanceof b.OrderedDict?(this.orderedkeys=[],Sk.abstr.superConstructor(b.OrderedDict,this,a),this):new b.OrderedDict(a)},Sk.abstr.setUpInheritance(\"OrderedDict\",b.OrderedDict,Sk.builtin.dict),b.OrderedDict.prototype.$r=function(){var a,b,c,d,e=[];for(b=this.tp$iter(),c=b.tp$iternext();void 0!==c;c=b.tp$iternext())a=this.mp$subscript(c),void 0===a&&(a=null),e.push(\"(\"+Sk.misceval.objectRepr(c).v+\", \"+Sk.misceval.objectRepr(a).v+\")\");return d=e.join(\", \"),0<e.length&&(d=\"[\"+d+\"]\"),new Sk.builtin.str(\"OrderedDict(\"+d+\")\")},b.OrderedDict.prototype.mp$ass_subscript=function(a,b){var c=this.orderedkeys.indexOf(a);return-1==c&&this.orderedkeys.push(a),Sk.builtin.dict.prototype.mp$ass_subscript.call(this,a,b)},b.OrderedDict.prototype.mp$del_subscript=function(a){var b=this.orderedkeys.indexOf(a);return-1!=b&&this.orderedkeys.splice(b,1),Sk.builtin.dict.prototype.mp$del_subscript.call(this,a)},b.OrderedDict.prototype.__iter__=new Sk.builtin.func(function(a){return Sk.builtin.pyCheckArgsLen(\"__iter__\",arguments.length,0,0,!1,!0),b.OrderedDict.prototype.tp$iter.call(a)}),b.OrderedDict.prototype.tp$iter=function(){var a;return a={tp$iter:function(){return a},$obj:this,$index:0,$keys:this.orderedkeys.slice(0),tp$iternext:function(){return a.$index>=a.$keys.length?void 0:a.$keys[a.$index++]}},a},b.OrderedDict.prototype.ob$eq=function(a){var c,d,e,f,g;if(!(a instanceof b.OrderedDict))return Sk.builtin.dict.prototype.ob$eq.call(this,a);if(c=this.mp$length(),d=a.mp$length(),c!==d)return Sk.builtin.bool.false$;for(e=this.tp$iter(),otheriter=a.tp$iter(),f=e.tp$iternext(),otherk=otheriter.tp$iternext();void 0!==f;f=e.tp$iternext(),otherk=otheriter.tp$iternext()){if(!Sk.misceval.isTrue(Sk.misceval.richCompareBool(f,otherk,\"Eq\")))return Sk.builtin.bool.false$;if(g=this.mp$subscript(f),otherv=a.mp$subscript(otherk),!Sk.misceval.isTrue(Sk.misceval.richCompareBool(g,otherv,\"Eq\")))return Sk.builtin.bool.false$}return Sk.builtin.bool.true$},b.OrderedDict.prototype.ob$ne=function(a){var c,d,e,f,g;if(!(a instanceof b.OrderedDict))return Sk.builtin.dict.prototype.ob$ne.call(this,a);if(c=this.size,d=a.size,c!==d)return Sk.builtin.bool.true$;for(e=this.tp$iter(),otheriter=a.tp$iter(),f=e.tp$iternext(),otherk=otheriter.tp$iternext();void 0!==f;f=e.tp$iternext(),otherk=otheriter.tp$iternext()){if(!Sk.misceval.isTrue(Sk.misceval.richCompareBool(f,otherk,\"Eq\")))return Sk.builtin.bool.true$;if(g=this.mp$subscript(f),otherv=a.mp$subscript(otherk),!Sk.misceval.isTrue(Sk.misceval.richCompareBool(g,otherv,\"Eq\")))return Sk.builtin.bool.true$}return Sk.builtin.bool.false$},b.OrderedDict.prototype.pop=new Sk.builtin.func(function(a,b,c){var d;return Sk.builtin.pyCheckArgsLen(\"pop\",arguments.length,2,3),d=a.orderedkeys.indexOf(b),-1!=d&&a.orderedkeys.splice(d,1),Sk.misceval.callsimArray(Sk.builtin.dict.prototype.pop,[a,b,c])}),b.OrderedDict.prototype.popitem=new Sk.builtin.func(function(a,b){var c,d,e;if(Sk.builtin.pyCheckArgsLen(\"popitem\",arguments.length,1,2),0==a.orderedkeys.length)throw e=new Sk.builtin.str(\"dictionary is empty\"),new Sk.builtin.KeyError(e.v);return c=a.orderedkeys[0],(void 0===b||Sk.misceval.isTrue(b))&&(c=a.orderedkeys[a.orderedkeys.length-1]),d=Sk.misceval.callsimArray(a.pop,[a,c]),Sk.builtin.tuple([c,d])}),b.deque=function(){throw new Sk.builtin.NotImplementedError(\"deque is not implemented\")},b.namedtuples={};var c=function(b){for(var a=[],c=0;c<=b.length;c++)if(void 0===a[b[c]])a[b[c]]=1;else return!0;return!1},d=function(a,b){function c(){}c.prototype=b.prototype,a.superClass_=b.prototype,a.prototype=new c,a.prototype.constructor=a};return b.namedtuple=new Sk.builtin.func(function(e,f){if(Sk.ffi.remapToJs(Sk.misceval.callsimArray(a.$d.iskeyword,[e])))throw new Sk.builtin.ValueError(\"Type names and field names cannot be a keyword: \"+e.v);var g=Sk.ffi.remapToJs(e);if(startsw=new RegExp(/^[0-9].*/),startsw2=new RegExp(/^[0-9_].*/),alnum=new RegExp(/^\\w*$/),startsw.test(g)||!alnum.test(g))throw new Sk.builtin.ValueError(\" Bad type name \"+g);var h=Sk.ffi.remapToJs(f);for(\"string\"==typeof h&&(h=h.split(/\\s+/)),i=0;i<h.length;i++)if(Sk.ffi.remapToJs(Sk.misceval.callsimArray(a.$d.iskeyword,[Sk.ffi.remapToPy(h[i])]))||startsw2.test(h[i])||!alnum.test(h[i]))throw new Sk.builtin.ValueError(\"Type names and field names cannot be a keyword: \"+h[i]);if(c(h))throw new Sk.builtin.ValueError(\"Field names must be unique.\");var j=function(){var a;if(arguments.length!==h.length)throw new Sk.builtin.TypeError(\"Number of arguments must match\");return this instanceof b.namedtuples[g]?void(this.__class__=b.namedtuples[g],this.v=Array.prototype.slice.call(arguments)):(a=Object.create(b.namedtuples[g].prototype),a.constructor.apply(a,arguments),a)};return b.namedtuples[g]=j,d(j,Sk.builtin.tuple),j.prototype.tp$name=g,j.prototype.ob$type=Sk.builtin.type.makeIntoTypeObj(g,b.namedtuples[g]),j.prototype.$r=function(){var a,b,c;if(0===this.v.length)return new Sk.builtin.str(g+\"()\");for(c=[],b=0;b<this.v.length;++b)c[b]=h[b]+\"=\"+Sk.misceval.objectRepr(this.v[b]).v;return a=c.join(\", \"),1===this.v.length&&(a+=\",\"),new Sk.builtin.str(g+\"(\"+a+\")\")},j.prototype.tp$getattr=function(a){var b=a.$jsstr(),c=h.indexOf(b);return 0<=c?this.v[c]:void 0},j.prototype.tp$setattr=function(){throw new Sk.builtin.AttributeError(\"can't set attribute\")},j}),b})};","src/lib/colorsys.py":"raise NotImplementedError(\"colorsys is not yet implemented in Skulpt\")\n","src/lib/commands.py":"raise NotImplementedError(\"commands is not yet implemented in Skulpt\")\n","src/lib/compileall.py":"raise NotImplementedError(\"compileall is not yet implemented in Skulpt\")\n","src/lib/compiler/__init__.py":"raise NotImplementedError(\"compiler is not yet implemented in Skulpt\")\n","src/lib/config/__init__.py":"raise NotImplementedError(\"config is not yet implemented in Skulpt\")\n","src/lib/contextlib.py":"raise NotImplementedError(\"contextlib is not yet implemented in Skulpt\")\n","src/lib/cookielib.py":"raise NotImplementedError(\"cookielib is not yet implemented in Skulpt\")\n","src/lib/copy.py":"\"\"\"\nThis file was modified from CPython.\nCopyright (c) 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010,\n2011, 2012, 2013, 2014, 2015 Python Software Foundation; All Rights Reserved\n\"\"\"\nimport types\nclass Error(Exception):\n    pass\nerror = Error \nclass _EmptyClass:\n    pass\n\ndef copy(x):\n    cls = type(x)\n    if callable(x):\n        return x\n    copier = getattr(cls, \"__copy__\", None)\n    if copier:\n        return copier(x)\n    if cls in (type(None), int, float, bool, long, str, tuple, type):\n        return x\n    if (cls == list) or (cls == dict) or (cls == set) or (cls == slice):\n        return cls(x)\n    try:\n        getstate = getattr(x, \"__getstate__\", None)\n        setstate = getattr(x, \"__setstate__\", None)\n        initargs = getattr(x, \"__getinitargs__\", None)\n    except:\n        reductor = False\n    if getstate or setstate or initargs:\n        raise NotImplementedError(\"Skulpt does not yet support copying with user-defined __getstate__, __setstate__ or __getinitargs__()\")\n    reductor = getattr(x, \"__reduce_ex__\", None)\n    if reductor:\n        rv = reductor(4)\n    else:\n        reductor = getattr(x, \"__reduce__\", None)\n        if reductor:\n            rv = reductor()\n        elif str(cls)[1:6] == \"class\":\n            copier = _copy_inst\n            return copier(x)\n        else:\n            raise Error(\"un(shallow)copyable object of type %s\" % cls)\n    if isinstance(rv, str):\n        return x\n    return _reconstruct(x, rv, 0)\n\ndef _copy_inst(x):\n    if hasattr(x, '__copy__'):\n        return x.__copy__()\n    if hasattr(x, '__getinitargs__'):\n        args = x.__getinitargs__()\n        y = x.__class__(*args)\n    else:\n        y = _EmptyClass()\n        y.__class__ = x.__class__\n    if hasattr(x, '__getstate__'):\n        state = x.__getstate__()\n    else:\n        state = x.__dict__\n    if hasattr(y, '__setstate__'):\n        y.__setstate__(state)\n    else:\n        y.__dict__.update(state)\n    return y\n\nd = _deepcopy_dispatch = {}\n\ndef deepcopy(x, memo=None, _nil=[]):\n    \"\"\"Deep copy operation on arbitrary Python objects.\n    See the module's __doc__ string for more info.\n    \"\"\"\n    if memo is None:\n        memo = {}\n    idx = id(x)\n    y = memo.get(idx, _nil)\n    if y is not _nil:\n        return y\n    cls = type(x)\n    try:\n        getstate = getattr(x, \"__getstate__\", None)\n        setstate = getattr(x, \"__setstate__\", None)\n        initargs = getattr(x, \"__getinitargs__\", None)\n    except:\n        reductor = False\n    if getstate or setstate or initargs:\n        raise NotImplementedError(\"Skulpt does not yet support copying with user-defined __getstate__, __setstate__ or __getinitargs__()\")\n    copier = _deepcopy_dispatch.get(cls)\n    if copier:\n        y = copier(x, memo)\n    elif str(cls)[1:6] == \"class\":\n        copier = _deepcopy_dispatch[\"InstanceType\"]\n        y = copier(x, memo)\n    else:\n        try:\n            issc = issubclass(cls, type)\n        except TypeError: # cls is not a class (old Boost; see SF #502085)\n            issc = 0\n        if issc:\n            y = _deepcopy_atomic(x, memo)\n        else:\n            copier = getattr(x, \"__deepcopy__\", None)\n            if copier:\n                y = copier(memo)\n            else:\n                reductor = getattr(x, \"__reduce_ex__\", None)\n                if reductor:\n                    rv = reductor(2)\n                else:\n                    reductor = getattr(x, \"__reduce__\", None)\n                    if reductor:\n                        rv = reductor()\n                    else:\n                        raise Error(\n                            \"un(deep)copyable object of type %s\" % cls)\n                y = _reconstruct(x, rv, 1, memo)\n    memo[idx] = y\n    _keep_alive(x, memo) # Make sure x lives at least as long as d\n    return y\n\ndef _deepcopy_atomic(x, memo):\n    return x\nd[type(None)] = _deepcopy_atomic\n# d[type(Ellipsis)] = _deepcopy_atomic\nd[type(NotImplemented)] = _deepcopy_atomic\nd[int] = _deepcopy_atomic\nd[float] = _deepcopy_atomic\nd[bool] = _deepcopy_atomic\nd[complex] = _deepcopy_atomic\n# d[bytes] = _deepcopy_atomic\nd[str] = _deepcopy_atomic\n# try:\n# d[types.CodeType] = _deepcopy_atomic\n# except AttributeError:\n#   pass\nd[type] = _deepcopy_atomic\n# d[types.BuiltinFunctionType] = _deepcopy_atomic\nd[types.FunctionType] = _deepcopy_atomic\n# d[weakref.ref] = _deepcopy_atomic\n\ndef _deepcopy_list(x, memo):\n    y = []\n    memo[id(x)] = y\n    for a in x:\n        y.append(deepcopy(a, memo))\n    return y\nd[list] = _deepcopy_list\n\ndef _deepcopy_set(x, memo):\n    result = set([])  # make empty set\n    memo[id(x)] = result  # register this set in the memo for loop checking\n    for a in x:   # go through elements of set\n        result.add(deepcopy(a, memo))  # add the copied elements into the new set\n    return result # return the new set\nd[set] = _deepcopy_set\n\ndef _deepcopy_tuple(x, memo):\n    y = [deepcopy(a, memo) for a in x]\n    # We're not going to put the tuple in the memo, but it's still important we\n    # check for it, in case the tuple contains recursive mutable structures.\n    try:\n        return memo[id(x)]\n    except KeyError:\n        pass\n    for k, j in zip(x, y):\n        if k is not j:\n            y = tuple(y)\n            break\n    else:\n        y = x\n    return y\nd[tuple] = _deepcopy_tuple\n\ndef _deepcopy_dict(x, memo):\n    y = {}\n    memo[id(x)] = y\n    for key, value in x.items():\n        y[deepcopy(key, memo)] = deepcopy(value, memo)\n    return y\nd[dict] = _deepcopy_dict\n\n# def _deepcopy_method(x, memo): # Copy instance methods\n#     y = type(x)(x.im_func, deepcopy(x.im_self, memo), x.im_class);\n#     return y\nd[types.MethodType] = _deepcopy_atomic\n\ndef _deepcopy_inst(x, memo):\n    if hasattr(x, '__deepcopy__'):\n         return x.__deepcopy__(memo)\n    if hasattr(x, '__getinitargs__'):\n        args = x.__getinitargs__()\n        args = deepcopy(args, memo)\n        y = x.__class__(*args)\n    else:\n        y = _EmptyClass()\n        y.__class__ = x.__class__\n    memo[id(x)] = y\n    if hasattr(x, '__getstate__'):\n        state = x.__getstate__()\n    else:\n        state = x.__dict__\n    state = deepcopy(state, memo)\n    if hasattr(y, '__setstate__'):\n        y.__setstate__(state)\n    else:\n        y.__dict__.update(state)\n        return y\nd[\"InstanceType\"] = _deepcopy_inst\n\ndef _keep_alive(x, memo):\n    \"\"\"Keeps a reference to the object x in the memo.\n    Because we remember objects by their id, we have\n    to assure that possibly temporary objects are kept\n    alive by referencing them.\n    We store a reference at the id of the memo, which should\n    normally not be used unless someone tries to deepcopy\n    the memo itself...\n    \"\"\"\n    try:\n        memo[id(memo)].append(x)\n    except KeyError:\n        # aha, this is the first one :-)\n        memo[id(memo)]=[x]\n\ndef _reconstruct(x, info, deep, memo=None):\n    if isinstance(info, str):\n        return x\n    assert isinstance(info, tuple)\n    if memo is None:\n        memo = {}\n    n = len(info)\n    assert n in (2, 3, 4, 5)\n    callable, args = info[:2]\n    if n > 2:\n        state = info[2]\n    else:\n        state = None\n    if n > 3:\n        listiter = info[3]\n    else:\n        listiter = None\n    if n > 4:\n        dictiter = info[4]\n    else:\n        dictiter = None\n    if deep:\n        args = deepcopy(args, memo)\n    y = callable(*args)\n    memo[id(x)] = y\n\n    if state is not None:\n        if deep:\n            state = deepcopy(state, memo)\n        if hasattr(y, '__setstate__'):\n            y.__setstate__(state)\n        else:\n            if isinstance(state, tuple) and len(state) == 2:\n                state, slotstate = state\n            else:\n                slotstate = None\n            if state is not None:\n                y.__dict__.update(state)\n            if slotstate is not None:\n                for key, value in slotstate.items():\n                    setattr(y, key, value)\n\n    if listiter is not None:\n        for item in listiter:\n            if deep:\n                item = deepcopy(item, memo)\n            y.append(item)\n    if dictiter is not None:\n        for key, value in dictiter:\n            if deep:\n                key = deepcopy(key, memo)\n                value = deepcopy(value, memo)\n            y[key] = value\n    return y\n\ndel d\n\ndel types\n\n# Helper for instance creation without calling __init__\nclass _EmptyClass:\n    pass","src/lib/copy_reg.py":"raise NotImplementedError(\"copy_reg is not yet implemented in Skulpt\")\n","src/lib/csv.py":"raise NotImplementedError(\"csv is not yet implemented in Skulpt\")\n","src/lib/ctypes/__init__.py":"raise NotImplementedError(\"ctypes is not yet implemented in Skulpt\")\n","src/lib/ctypes/macholib/__init__.py":"raise NotImplementedError(\"macholib is not yet implemented in Skulpt\")\n","src/lib/curses/__init__.py":"raise NotImplementedError(\"curses is not yet implemented in Skulpt\")\n","src/lib/datetime.py":"\"\"\"Concrete date/time and related types -- prototype implemented in Python.\n\nSee http://www.zope.org/Members/fdrake/DateTimeWiki/FrontPage\n\nSee also http://dir.yahoo.com/Reference/calendars/\n\nFor a primer on DST, including many current DST rules, see\nhttp://webexhibits.org/daylightsaving/\n\nFor more about DST than you ever wanted to know, see\nftp://elsie.nci.nih.gov/pub/\n\nSources for time zone and DST data: http://www.twinsun.com/tz/tz-link.htm\n\nThis was originally copied from the sandbox of the CPython CVS repository.\nThanks to Tim Peters for suggesting using it.\n\nThis was then copied from PyPy v5.1.0 into Skulpt by Meredydd Luff, removing\n'from __future__ import division' (and replacing division operators accordingly)\nand pickle support (which requires 'struct', which Skulpt does not currently\n[as of 31/8/2016] have)\n\"\"\"\n\nimport time as _time\nimport math as _math\n\n_SENTINEL = object()\n\ndef _cmp(x, y):\n    return 0 if x == y else 1 if x > y else -1\n\ndef _round(x):\n    return int(_math.floor(x + 0.5) if x >= 0.0 else _math.ceil(x - 0.5))\n\nMINYEAR = 1\nMAXYEAR = 9999\n_MINYEARFMT = 1900\n\n_MAX_DELTA_DAYS = 999999999\n\n# Utility functions, adapted from Python's Demo/classes/Dates.py, which\n# also assumes the current Gregorian calendar indefinitely extended in\n# both directions.  Difference:  Dates.py calls January 1 of year 0 day\n# number 1.  The code here calls January 1 of year 1 day number 1.  This is\n# to match the definition of the \"proleptic Gregorian\" calendar in Dershowitz\n# and Reingold's \"Calendrical Calculations\", where it's the base calendar\n# for all computations.  See the book for algorithms for converting between\n# proleptic Gregorian ordinals and many other calendar systems.\n\n_DAYS_IN_MONTH = [-1, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n\n_DAYS_BEFORE_MONTH = [-1]\ndbm = 0\nfor dim in _DAYS_IN_MONTH[1:]:\n    _DAYS_BEFORE_MONTH.append(dbm)\n    dbm += dim\ndel dbm, dim\n\ndef _is_leap(year):\n    \"year -> 1 if leap year, else 0.\"\n    return year % 4 == 0 and (year % 100 != 0 or year % 400 == 0)\n\ndef _days_before_year(year):\n    \"year -> number of days before January 1st of year.\"\n    y = year - 1\n    return y*365 + y//4 - y//100 + y//400\n\ndef _days_in_month(year, month):\n    \"year, month -> number of days in that month in that year.\"\n    assert 1 <= month <= 12, month\n    if month == 2 and _is_leap(year):\n        return 29\n    return _DAYS_IN_MONTH[month]\n\ndef _days_before_month(year, month):\n    \"year, month -> number of days in year preceding first day of month.\"\n    assert 1 <= month <= 12, 'month must be in 1..12'\n    return _DAYS_BEFORE_MONTH[month] + (month > 2 and _is_leap(year))\n\ndef _ymd2ord(year, month, day):\n    \"year, month, day -> ordinal, considering 01-Jan-0001 as day 1.\"\n    assert 1 <= month <= 12, 'month must be in 1..12'\n    dim = _days_in_month(year, month)\n    assert 1 <= day <= dim, ('day must be in 1..%d' % dim)\n    return (_days_before_year(year) +\n            _days_before_month(year, month) +\n            day)\n\n_DI400Y = _days_before_year(401)    # number of days in 400 years\n_DI100Y = _days_before_year(101)    #    \"    \"   \"   \" 100   \"\n_DI4Y   = _days_before_year(5)      #    \"    \"   \"   \"   4   \"\n\n# A 4-year cycle has an extra leap day over what we'd get from pasting\n# together 4 single years.\nassert _DI4Y == 4 * 365 + 1\n\n# Similarly, a 400-year cycle has an extra leap day over what we'd get from\n# pasting together 4 100-year cycles.\nassert _DI400Y == 4 * _DI100Y + 1\n\n# OTOH, a 100-year cycle has one fewer leap day than we'd get from\n# pasting together 25 4-year cycles.\nassert _DI100Y == 25 * _DI4Y - 1\n\n_US_PER_US = 1\n_US_PER_MS = 1000\n_US_PER_SECOND = 1000000\n_US_PER_MINUTE = 60000000\n_SECONDS_PER_DAY = 24 * 3600\n_US_PER_HOUR = 3600000000\n_US_PER_DAY = 86400000000\n_US_PER_WEEK = 604800000000\n\ndef _ord2ymd(n):\n    \"ordinal -> (year, month, day), considering 01-Jan-0001 as day 1.\"\n\n    # n is a 1-based index, starting at 1-Jan-1.  The pattern of leap years\n    # repeats exactly every 400 years.  The basic strategy is to find the\n    # closest 400-year boundary at or before n, then work with the offset\n    # from that boundary to n.  Life is much clearer if we subtract 1 from\n    # n first -- then the values of n at 400-year boundaries are exactly\n    # those divisible by _DI400Y:\n    #\n    #     D  M   Y            n              n-1\n    #     -- --- ----        ----------     ----------------\n    #     31 Dec -400        -_DI400Y       -_DI400Y -1\n    #      1 Jan -399         -_DI400Y +1   -_DI400Y      400-year boundary\n    #     ...\n    #     30 Dec  000        -1             -2\n    #     31 Dec  000         0             -1\n    #      1 Jan  001         1              0            400-year boundary\n    #      2 Jan  001         2              1\n    #      3 Jan  001         3              2\n    #     ...\n    #     31 Dec  400         _DI400Y        _DI400Y -1\n    #      1 Jan  401         _DI400Y +1     _DI400Y      400-year boundary\n    n -= 1\n    n400, n = divmod(n, _DI400Y)\n    year = n400 * 400 + 1   # ..., -399, 1, 401, ...\n\n    # Now n is the (non-negative) offset, in days, from January 1 of year, to\n    # the desired date.  Now compute how many 100-year cycles precede n.\n    # Note that it's possible for n100 to equal 4!  In that case 4 full\n    # 100-year cycles precede the desired day, which implies the desired\n    # day is December 31 at the end of a 400-year cycle.\n    n100, n = divmod(n, _DI100Y)\n\n    # Now compute how many 4-year cycles precede it.\n    n4, n = divmod(n, _DI4Y)\n\n    # And now how many single years.  Again n1 can be 4, and again meaning\n    # that the desired day is December 31 at the end of the 4-year cycle.\n    n1, n = divmod(n, 365)\n\n    year += n100 * 100 + n4 * 4 + n1\n    if n1 == 4 or n100 == 4:\n        assert n == 0\n        return year-1, 12, 31\n\n    # Now the year is correct, and n is the offset from January 1.  We find\n    # the month via an estimate that's either exact or one too large.\n    leapyear = n1 == 3 and (n4 != 24 or n100 == 3)\n    assert leapyear == _is_leap(year)\n    month = (n + 50) >> 5\n    preceding = _DAYS_BEFORE_MONTH[month] + (month > 2 and leapyear)\n    if preceding > n:  # estimate is too large\n        month -= 1\n        preceding -= _DAYS_IN_MONTH[month] + (month == 2 and leapyear)\n    n -= preceding\n    assert 0 <= n < _days_in_month(year, month)\n\n    # Now the year and month are correct, and n is the offset from the\n    # start of that month:  we're done!\n    return year, month, n+1\n\n# Month and day names.  For localized versions, see the calendar module.\n_MONTHNAMES = [None, \"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\",\n                     \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"]\n_DAYNAMES = [None, \"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\", \"Sun\"]\n\n\ndef _build_struct_time(y, m, d, hh, mm, ss, dstflag):\n    wday = (_ymd2ord(y, m, d) + 6) % 7\n    dnum = _days_before_month(y, m) + d\n    return _time.struct_time((y, m, d, hh, mm, ss, wday, dnum, dstflag))\n\ndef _format_time(hh, mm, ss, us):\n    # Skip trailing microseconds when us==0.\n    result = \"%02d:%02d:%02d\" % (hh, mm, ss)\n    if us:\n        result += \".%06d\" % us\n    return result\n\n# Correctly substitute for %z and %Z escapes in strftime formats.\ndef _wrap_strftime(object, format, timetuple):\n    year = timetuple[0]\n    if year < _MINYEARFMT:\n        raise ValueError(\"year=%d is before %d; the datetime strftime() \"\n                         \"methods require year >= %d\" %\n                         (year, _MINYEARFMT, _MINYEARFMT))\n    # Don't call utcoffset() or tzname() unless actually needed.\n    freplace = None  # the string to use for %f\n    zreplace = None  # the string to use for %z\n    Zreplace = None  # the string to use for %Z\n\n    # Scan format for %z and %Z escapes, replacing as needed.\n    newformat = []\n    push = newformat.append\n    i, n = 0, len(format)\n    while i < n:\n        ch = format[i]\n        i += 1\n        if ch == '%':\n            if i < n:\n                ch = format[i]\n                i += 1\n                if ch == 'f':\n                    if freplace is None:\n                        freplace = '%06d' % getattr(object,\n                                                    'microsecond', 0)\n                    newformat.append(freplace)\n                elif ch == 'z':\n                    if zreplace is None:\n                        zreplace = \"\"\n                        if hasattr(object, \"_utcoffset\"):\n                            offset = object._utcoffset()\n                            if offset is not None:\n                                sign = '+'\n                                if offset < 0:\n                                    offset = -offset\n                                    sign = '-'\n                                h, m = divmod(offset, 60)\n                                zreplace = '%c%02d%02d' % (sign, h, m)\n                    assert '%' not in zreplace\n                    newformat.append(zreplace)\n                elif ch == 'Z':\n                    if Zreplace is None:\n                        Zreplace = \"\"\n                        if hasattr(object, \"tzname\"):\n                            s = object.tzname()\n                            if s is not None:\n                                # strftime is going to have at this: escape %\n                                Zreplace = s.replace('%', '%%')\n                    newformat.append(Zreplace)\n                else:\n                    push('%')\n                    push(ch)\n            else:\n                push('%')\n        else:\n            push(ch)\n    newformat = \"\".join(newformat)\n    return _time.strftime(newformat, timetuple)\n\n# Just raise TypeError if the arg isn't None or a string.\ndef _check_tzname(name):\n    if name is not None and not isinstance(name, str):\n        raise TypeError(\"tzinfo.tzname() must return None or string, \"\n                        \"not '%s'\" % type(name))\n\n# name is the offset-producing method, \"utcoffset\" or \"dst\".\n# offset is what it returned.\n# If offset isn't None or timedelta, raises TypeError.\n# If offset is None, returns None.\n# Else offset is checked for being in range, and a whole # of minutes.\n# If it is, its integer value is returned.  Else ValueError is raised.\ndef _check_utc_offset(name, offset):\n    assert name in (\"utcoffset\", \"dst\")\n    if offset is None:\n        return\n    if not isinstance(offset, timedelta):\n        raise TypeError(\"tzinfo.%s() must return None \"\n                        \"or timedelta, not '%s'\" % (name, type(offset)))\n    days = offset.days\n    if days < -1 or days > 0:\n        offset = 1440  # trigger out-of-range\n    else:\n        seconds = days * 86400 + offset.seconds\n        minutes, seconds = divmod(seconds, 60)\n        if seconds or offset.microseconds:\n            raise ValueError(\"tzinfo.%s() must return a whole number \"\n                             \"of minutes\" % name)\n        offset = minutes\n    if not -1440 < offset < 1440:\n        raise ValueError(\"%s()=%d, must be in -1439..1439\" % (name, offset))\n    return offset\n\ndef _check_int_field(value):\n    if isinstance(value, int):\n        return int(value)\n    if not isinstance(value, float):\n        try:\n            value = value.__int__()\n        except AttributeError:\n            pass\n        else:\n            if isinstance(value, int):\n                return int(value)\n            elif isinstance(value, long):\n                return int(long(value))\n            raise TypeError('__int__ method should return an integer')\n        raise TypeError('an integer is required')\n    raise TypeError('integer argument expected, got float')\n\ndef _check_date_fields(year, month, day):\n    year = _check_int_field(year)\n    month = _check_int_field(month)\n    day = _check_int_field(day)\n    if not MINYEAR <= year <= MAXYEAR:\n        raise ValueError('year must be in %d..%d' % (MINYEAR, MAXYEAR), year)\n    if not 1 <= month <= 12:\n        raise ValueError('month must be in 1..12', month)\n    dim = _days_in_month(year, month)\n    if not 1 <= day <= dim:\n        raise ValueError('day must be in 1..%d' % dim, day)\n    return year, month, day\n\ndef _check_time_fields(hour, minute, second, microsecond):\n    hour = _check_int_field(hour)\n    minute = _check_int_field(minute)\n    second = _check_int_field(second)\n    microsecond = _check_int_field(microsecond)\n    if not 0 <= hour <= 23:\n        raise ValueError('hour must be in 0..23', hour)\n    if not 0 <= minute <= 59:\n        raise ValueError('minute must be in 0..59', minute)\n    if not 0 <= second <= 59:\n        raise ValueError('second must be in 0..59', second)\n    if not 0 <= microsecond <= 999999:\n        raise ValueError('microsecond must be in 0..999999', microsecond)\n    return hour, minute, second, microsecond\n\ndef _check_tzinfo_arg(tz):\n    if tz is not None and not isinstance(tz, tzinfo):\n        raise TypeError(\"tzinfo argument must be None or of a tzinfo subclass\")\n\n\n# Notes on comparison:  In general, datetime module comparison operators raise\n# TypeError when they don't know how to do a comparison themself.  If they\n# returned NotImplemented instead, comparison could (silently) fall back to\n# the default compare-objects-by-comparing-their-memory-addresses strategy,\n# and that's not helpful.  There are two exceptions:\n#\n# 1. For date and datetime, if the other object has a \"timetuple\" attr,\n#    NotImplemented is returned.  This is a hook to allow other kinds of\n#    datetime-like objects a chance to intercept the comparison.\n#\n# 2. Else __eq__ and __ne__ return False and True, respectively.  This is\n#    so opertaions like\n#\n#        x == y\n#        x != y\n#        x in sequence\n#        x not in sequence\n#        dict[x] = y\n#\n#    don't raise annoying TypeErrors just because a datetime object\n#    is part of a heterogeneous collection.  If there's no known way to\n#    compare X to a datetime, saying they're not equal is reasonable.\n\ndef _cmperror(x, y):\n    raise TypeError(\"can't compare '%s' to '%s'\" % (\n                    type(x).__name__, type(y).__name__))\n\ndef _normalize_pair(hi, lo, factor):\n    if not 0 <= lo <= factor-1:\n        inc, lo = divmod(lo, factor)\n        hi += inc\n    return hi, lo\n\ndef _normalize_datetime(y, m, d, hh, mm, ss, us, ignore_overflow=False):\n    # Normalize all the inputs, and store the normalized values.\n    ss, us = _normalize_pair(ss, us, 1000000)\n    mm, ss = _normalize_pair(mm, ss, 60)\n    hh, mm = _normalize_pair(hh, mm, 60)\n    d, hh = _normalize_pair(d, hh, 24)\n    y, m, d = _normalize_date(y, m, d, ignore_overflow)\n    return y, m, d, hh, mm, ss, us\n\ndef _normalize_date(year, month, day, ignore_overflow=False):\n    # That was easy.  Now it gets muddy:  the proper range for day\n    # can't be determined without knowing the correct month and year,\n    # but if day is, e.g., plus or minus a million, the current month\n    # and year values make no sense (and may also be out of bounds\n    # themselves).\n    # Saying 12 months == 1 year should be non-controversial.\n    if not 1 <= month <= 12:\n        year, month = _normalize_pair(year, month-1, 12)\n        month += 1\n        assert 1 <= month <= 12\n\n    # Now only day can be out of bounds (year may also be out of bounds\n    # for a datetime object, but we don't care about that here).\n    # If day is out of bounds, what to do is arguable, but at least the\n    # method here is principled and explainable.\n    dim = _days_in_month(year, month)\n    if not 1 <= day <= dim:\n        # Move day-1 days from the first of the month.  First try to\n        # get off cheap if we're only one day out of range (adjustments\n        # for timezone alone can't be worse than that).\n        if day == 0:    # move back a day\n            month -= 1\n            if month > 0:\n                day = _days_in_month(year, month)\n            else:\n                year, month, day = year-1, 12, 31\n        elif day == dim + 1:    # move forward a day\n            month += 1\n            day = 1\n            if month > 12:\n                month = 1\n                year += 1\n        else:\n            ordinal = _ymd2ord(year, month, 1) + (day - 1)\n            year, month, day = _ord2ymd(ordinal)\n\n    if not ignore_overflow and not MINYEAR <= year <= MAXYEAR:\n        raise OverflowError(\"date value out of range\")\n    return year, month, day\n\ndef _accum(tag, sofar, num, factor, leftover):\n    if isinstance(num, (int, long)):\n        prod = num * factor\n        rsum = sofar + prod\n        return rsum, leftover\n    if isinstance(num, float):\n        fracpart, intpart = _math.modf(num)\n        prod = int(intpart) * factor\n        rsum = sofar + prod\n        if fracpart == 0.0:\n            return rsum, leftover\n        assert isinstance(factor, (int, long))\n        fracpart, intpart = _math.modf(factor * fracpart)\n        rsum += int(intpart)\n        return rsum, leftover + fracpart\n    raise TypeError(\"unsupported type for timedelta %s component: %s\" %\n                    (tag, type(num)))\n\nclass timedelta(object):\n    \"\"\"Represent the difference between two datetime objects.\n\n    Supported operators:\n\n    - add, subtract timedelta\n    - unary plus, minus, abs\n    - compare to timedelta\n    - multiply, divide by int/long\n\n    In addition, datetime supports subtraction of two datetime objects\n    returning a timedelta, and addition or subtraction of a datetime\n    and a timedelta giving a datetime.\n\n    Representation: (days, seconds, microseconds).  Why?  Because I\n    felt like it.\n    \"\"\"\n    __slots__ = '_days', '_seconds', '_microseconds', '_hashcode'\n\n    def __new__(cls, days=_SENTINEL, seconds=_SENTINEL, microseconds=_SENTINEL,\n                milliseconds=_SENTINEL, minutes=_SENTINEL, hours=_SENTINEL, weeks=_SENTINEL):\n        x = 0\n        leftover = 0.0\n        if microseconds is not _SENTINEL:\n            x, leftover = _accum(\"microseconds\", x, microseconds, _US_PER_US, leftover)\n        if milliseconds is not _SENTINEL:\n            x, leftover = _accum(\"milliseconds\", x, milliseconds, _US_PER_MS, leftover)\n        if seconds is not _SENTINEL:\n            x, leftover = _accum(\"seconds\", x, seconds, _US_PER_SECOND, leftover)\n        if minutes is not _SENTINEL:\n            x, leftover = _accum(\"minutes\", x, minutes, _US_PER_MINUTE, leftover)\n        if hours is not _SENTINEL:\n            x, leftover = _accum(\"hours\", x, hours, _US_PER_HOUR, leftover)\n        if days is not _SENTINEL:\n            x, leftover = _accum(\"days\", x, days, _US_PER_DAY, leftover)\n        if weeks is not _SENTINEL:\n            x, leftover = _accum(\"weeks\", x, weeks, _US_PER_WEEK, leftover)\n        if leftover != 0.0:\n            x += _round(leftover)\n        return cls._from_microseconds(x)\n\n    @classmethod\n    def _from_microseconds(cls, us):\n        s, us = divmod(us, _US_PER_SECOND)\n        d, s = divmod(s, _SECONDS_PER_DAY)\n        return cls._create(d, s, us, False)\n\n    @classmethod\n    def _create(cls, d, s, us, normalize):\n        if normalize:\n            s, us = _normalize_pair(s, us, 1000000)\n            d, s = _normalize_pair(d, s, 24*3600)\n\n        if not -_MAX_DELTA_DAYS <= d <= _MAX_DELTA_DAYS:\n            raise OverflowError(\"days=%d; must have magnitude <= %d\" % (d, _MAX_DELTA_DAYS))\n\n        self = object.__new__(cls)\n        self._days = d\n        self._seconds = s\n        self._microseconds = us\n        self._hashcode = -1\n        return self\n\n    def _to_microseconds(self):\n        return ((self._days * _SECONDS_PER_DAY + self._seconds) * _US_PER_SECOND +\n                self._microseconds)\n\n    def __repr__(self):\n        module = \"datetime.\" if self.__class__ is timedelta else \"\"\n        if self._microseconds:\n            return \"%s(%d, %d, %d)\" % (module + self.__class__.__name__,\n                                       self._days,\n                                       self._seconds,\n                                       self._microseconds)\n        if self._seconds:\n            return \"%s(%d, %d)\" % (module + self.__class__.__name__,\n                                   self._days,\n                                   self._seconds)\n        return \"%s(%d)\" % (module + self.__class__.__name__, self._days)\n\n    def __str__(self):\n        mm, ss = divmod(self._seconds, 60)\n        hh, mm = divmod(mm, 60)\n        s = \"%d:%02d:%02d\" % (hh, mm, ss)\n        if self._days:\n            def plural(n):\n                return n, abs(n) != 1 and \"s\" or \"\"\n            s = (\"%d day%s, \" % plural(self._days)) + s\n        if self._microseconds:\n            s = s + \".%06d\" % self._microseconds\n        return s\n\n    def total_seconds(self):\n        \"\"\"Total seconds in the duration.\"\"\"\n        return self._to_microseconds() / 10.0**6\n\n    # Read-only field accessors\n    @property\n    def days(self):\n        \"\"\"days\"\"\"\n        return self._days\n\n    @property\n    def seconds(self):\n        \"\"\"seconds\"\"\"\n        return self._seconds\n\n    @property\n    def microseconds(self):\n        \"\"\"microseconds\"\"\"\n        return self._microseconds\n\n    def __add__(self, other):\n        if isinstance(other, timedelta):\n            # for CPython compatibility, we cannot use\n            # our __class__ here, but need a real timedelta\n            return timedelta._create(self._days + other._days,\n                                     self._seconds + other._seconds,\n                                     self._microseconds + other._microseconds,\n                                     True)\n        return NotImplemented\n\n    def __sub__(self, other):\n        if isinstance(other, timedelta):\n            # for CPython compatibility, we cannot use\n            # our __class__ here, but need a real timedelta\n            return timedelta._create(self._days - other._days,\n                                     self._seconds - other._seconds,\n                                     self._microseconds - other._microseconds,\n                                     True)\n        return NotImplemented\n\n    def __neg__(self):\n        # for CPython compatibility, we cannot use\n        # our __class__ here, but need a real timedelta\n        return timedelta._create(-self._days,\n                                 -self._seconds,\n                                 -self._microseconds,\n                                 True)\n\n    def __pos__(self):\n        # for CPython compatibility, we cannot use\n        # our __class__ here, but need a real timedelta\n        return timedelta._create(self._days,\n                                 self._seconds,\n                                 self._microseconds,\n                                 False)\n\n    def __abs__(self):\n        if self._days < 0:\n            return -self\n        else:\n            return self\n\n    def __mul__(self, other):\n        if not isinstance(other, (int, long)):\n            return NotImplemented\n        usec = self._to_microseconds()\n        return timedelta._from_microseconds(usec * other)\n\n    __rmul__ = __mul__\n\n    def __div__(self, other):\n        if not isinstance(other, (int, long)):\n            return NotImplemented\n        usec = self._to_microseconds()\n        return timedelta._from_microseconds(usec // other)\n\n    __floordiv__ = __div__\n\n    # Comparisons of timedelta objects with other.\n\n    def __eq__(self, other):\n        if isinstance(other, timedelta):\n            return self._cmp(other) == 0\n        else:\n            return False\n\n    def __ne__(self, other):\n        if isinstance(other, timedelta):\n            return self._cmp(other) != 0\n        else:\n            return True\n\n    def __le__(self, other):\n        if isinstance(other, timedelta):\n            return self._cmp(other) <= 0\n        else:\n            _cmperror(self, other)\n\n    def __lt__(self, other):\n        if isinstance(other, timedelta):\n            return self._cmp(other) < 0\n        else:\n            _cmperror(self, other)\n\n    def __ge__(self, other):\n        if isinstance(other, timedelta):\n            return self._cmp(other) >= 0\n        else:\n            _cmperror(self, other)\n\n    def __gt__(self, other):\n        if isinstance(other, timedelta):\n            return self._cmp(other) > 0\n        else:\n            _cmperror(self, other)\n\n    def _cmp(self, other):\n        assert isinstance(other, timedelta)\n        return _cmp(self._getstate(), other._getstate())\n\n    def __hash__(self):\n        if self._hashcode == -1:\n            self._hashcode = hash(self._getstate())\n        return self._hashcode\n\n    def __nonzero__(self):\n        return (self._days != 0 or\n                self._seconds != 0 or\n                self._microseconds != 0)\n\ntimedelta.min = timedelta(-_MAX_DELTA_DAYS)\ntimedelta.max = timedelta(_MAX_DELTA_DAYS, 24*3600-1, 1000000-1)\ntimedelta.resolution = timedelta(microseconds=1)\n\nclass date(object):\n    \"\"\"Concrete date type.\n\n    Constructors:\n\n    __new__()\n    fromtimestamp()\n    today()\n    fromordinal()\n\n    Operators:\n\n    __repr__, __str__\n    __cmp__, __hash__\n    __add__, __radd__, __sub__ (add/radd only with timedelta arg)\n\n    Methods:\n\n    timetuple()\n    toordinal()\n    weekday()\n    isoweekday(), isocalendar(), isoformat()\n    ctime()\n    strftime()\n\n    Properties (readonly):\n    year, month, day\n    \"\"\"\n    __slots__ = '_year', '_month', '_day', '_hashcode'\n\n    def __new__(cls, year, month=None, day=None):\n        \"\"\"Constructor.\n\n        Arguments:\n\n        year, month, day (required, base 1)\n        \"\"\"\n        year, month, day = _check_date_fields(year, month, day)\n        self = object.__new__(cls)\n        self._year = year\n        self._month = month\n        self._day = day\n        self._hashcode = -1\n        return self\n\n    # Additional constructors\n\n    @classmethod\n    def fromtimestamp(cls, t):\n        \"Construct a date from a POSIX timestamp (like time.time()).\"\n        y, m, d, hh, mm, ss, weekday, jday, dst = _time.localtime(t)\n        return cls(y, m, d)\n\n    @classmethod\n    def today(cls):\n        \"Construct a date from time.time().\"\n        t = _time.time()\n        return cls.fromtimestamp(t)\n\n    @classmethod\n    def fromordinal(cls, n):\n        \"\"\"Contruct a date from a proleptic Gregorian ordinal.\n\n        January 1 of year 1 is day 1.  Only the year, month and day are\n        non-zero in the result.\n        \"\"\"\n        y, m, d = _ord2ymd(n)\n        return cls(y, m, d)\n\n    # Conversions to string\n\n    def __repr__(self):\n        \"\"\"Convert to formal string, for repr().\n\n        >>> dt = datetime(2010, 1, 1)\n        >>> repr(dt)\n        'datetime.datetime(2010, 1, 1, 0, 0)'\n\n        >>> dt = datetime(2010, 1, 1, tzinfo=timezone.utc)\n        >>> repr(dt)\n        'datetime.datetime(2010, 1, 1, 0, 0, tzinfo=datetime.timezone.utc)'\n        \"\"\"\n        module = \"datetime.\" if self.__class__ is date else \"\"\n        return \"%s(%d, %d, %d)\" % (module + self.__class__.__name__,\n                                   self._year,\n                                   self._month,\n                                   self._day)\n\n    # XXX These shouldn't depend on time.localtime(), because that\n    # clips the usable dates to [1970 .. 2038).  At least ctime() is\n    # easily done without using strftime() -- that's better too because\n    # strftime(\"%c\", ...) is locale specific.\n\n    def ctime(self):\n        \"Return ctime() style string.\"\n        weekday = self.toordinal() % 7 or 7\n        return \"%s %s %2d 00:00:00 %04d\" % (\n            _DAYNAMES[weekday],\n            _MONTHNAMES[self._month],\n            self._day, self._year)\n\n    def strftime(self, format):\n        \"Format using strftime().\"\n        return _wrap_strftime(self, format, self.timetuple())\n\n    def __format__(self, fmt):\n        if not isinstance(fmt, (str, unicode)):\n            raise ValueError(\"__format__ expects str or unicode, not %s\" %\n                             fmt.__class__.__name__)\n        if len(fmt) != 0:\n            return self.strftime(fmt)\n        return str(self)\n\n    def isoformat(self):\n        \"\"\"Return the date formatted according to ISO.\n\n        This is 'YYYY-MM-DD'.\n\n        References:\n        - http://www.w3.org/TR/NOTE-datetime\n        - http://www.cl.cam.ac.uk/~mgk25/iso-time.html\n        \"\"\"\n        return \"%04d-%02d-%02d\" % (self._year, self._month, self._day)\n\n    __str__ = isoformat\n\n    # Read-only field accessors\n    @property\n    def year(self):\n        \"\"\"year (1-9999)\"\"\"\n        return self._year\n\n    @property\n    def month(self):\n        \"\"\"month (1-12)\"\"\"\n        return self._month\n\n    @property\n    def day(self):\n        \"\"\"day (1-31)\"\"\"\n        return self._day\n\n    # Standard conversions, __cmp__, __hash__ (and helpers)\n\n    def timetuple(self):\n        \"Return local time tuple compatible with time.localtime().\"\n        return _build_struct_time(self._year, self._month, self._day,\n                                  0, 0, 0, -1)\n\n    def toordinal(self):\n        \"\"\"Return proleptic Gregorian ordinal for the year, month and day.\n\n        January 1 of year 1 is day 1.  Only the year, month and day values\n        contribute to the result.\n        \"\"\"\n        return _ymd2ord(self._year, self._month, self._day)\n\n    def replace(self, year=None, month=None, day=None):\n        \"\"\"Return a new date with new values for the specified fields.\"\"\"\n        if year is None:\n            year = self._year\n        if month is None:\n            month = self._month\n        if day is None:\n            day = self._day\n        return date(year, month, day)\n\n    # Comparisons of date objects with other.\n\n    def __eq__(self, other):\n        if isinstance(other, date):\n            return self._cmp(other) == 0\n        elif hasattr(other, \"timetuple\"):\n            return NotImplemented\n        else:\n            return False\n\n    def __ne__(self, other):\n        if isinstance(other, date):\n            return self._cmp(other) != 0\n        elif hasattr(other, \"timetuple\"):\n            return NotImplemented\n        else:\n            return True\n\n    def __le__(self, other):\n        if isinstance(other, date):\n            return self._cmp(other) <= 0\n        elif hasattr(other, \"timetuple\"):\n            return NotImplemented\n        else:\n            _cmperror(self, other)\n\n    def __lt__(self, other):\n        if isinstance(other, date):\n            return self._cmp(other) < 0\n        elif hasattr(other, \"timetuple\"):\n            return NotImplemented\n        else:\n            _cmperror(self, other)\n\n    def __ge__(self, other):\n        if isinstance(other, date):\n            return self._cmp(other) >= 0\n        elif hasattr(other, \"timetuple\"):\n            return NotImplemented\n        else:\n            _cmperror(self, other)\n\n    def __gt__(self, other):\n        if isinstance(other, date):\n            return self._cmp(other) > 0\n        elif hasattr(other, \"timetuple\"):\n            return NotImplemented\n        else:\n            _cmperror(self, other)\n\n    def _cmp(self, other):\n        assert isinstance(other, date)\n        y, m, d = self._year, self._month, self._day\n        y2, m2, d2 = other._year, other._month, other._day\n        return _cmp((y, m, d), (y2, m2, d2))\n\n    def __hash__(self):\n        \"Hash.\"\n        if self._hashcode == -1:\n            self._hashcode = hash(self._getstate())\n        return self._hashcode\n\n    # Computations\n\n    def _add_timedelta(self, other, factor):\n        y, m, d = _normalize_date(\n            self._year,\n            self._month,\n            self._day + other.days * factor)\n        return date(y, m, d)\n\n    def __add__(self, other):\n        \"Add a date to a timedelta.\"\n        if isinstance(other, timedelta):\n            return self._add_timedelta(other, 1)\n        return NotImplemented\n\n    __radd__ = __add__\n\n    def __sub__(self, other):\n        \"\"\"Subtract two dates, or a date and a timedelta.\"\"\"\n        if isinstance(other, date):\n            days1 = self.toordinal()\n            days2 = other.toordinal()\n            return timedelta._create(days1 - days2, 0, 0, False)\n        if isinstance(other, timedelta):\n            return self._add_timedelta(other, -1)\n        return NotImplemented\n\n    def weekday(self):\n        \"Return day of the week, where Monday == 0 ... Sunday == 6.\"\n        return (self.toordinal() + 6) % 7\n\n    # Day-of-the-week and week-of-the-year, according to ISO\n\n    def isoweekday(self):\n        \"Return day of the week, where Monday == 1 ... Sunday == 7.\"\n        # 1-Jan-0001 is a Monday\n        return self.toordinal() % 7 or 7\n\n    def isocalendar(self):\n        \"\"\"Return a 3-tuple containing ISO year, week number, and weekday.\n\n        The first ISO week of the year is the (Mon-Sun) week\n        containing the year's first Thursday; everything else derives\n        from that.\n\n        The first week is 1; Monday is 1 ... Sunday is 7.\n\n        ISO calendar algorithm taken from\n        http://www.phys.uu.nl/~vgent/calendar/isocalendar.htm\n        \"\"\"\n        year = self._year\n        week1monday = _isoweek1monday(year)\n        today = _ymd2ord(self._year, self._month, self._day)\n        # Internally, week and day have origin 0\n        week, day = divmod(today - week1monday, 7)\n        if week < 0:\n            year -= 1\n            week1monday = _isoweek1monday(year)\n            week, day = divmod(today - week1monday, 7)\n        elif week >= 52:\n            if today >= _isoweek1monday(year+1):\n                year += 1\n                week = 0\n        return year, week+1, day+1\n\n_date_class = date  # so functions w/ args named \"date\" can get at the class\n\ndate.min = date(1, 1, 1)\ndate.max = date(9999, 12, 31)\ndate.resolution = timedelta(days=1)\n\nclass tzinfo(object):\n    \"\"\"Abstract base class for time zone info classes.\n\n    Subclasses must override the name(), utcoffset() and dst() methods.\n    \"\"\"\n    __slots__ = ()\n\n    def tzname(self, dt):\n        \"datetime -> string name of time zone.\"\n        raise NotImplementedError(\"tzinfo subclass must override tzname()\")\n\n    def utcoffset(self, dt):\n        \"datetime -> minutes east of UTC (negative for west of UTC)\"\n        raise NotImplementedError(\"tzinfo subclass must override utcoffset()\")\n\n    def dst(self, dt):\n        \"\"\"datetime -> DST offset in minutes east of UTC.\n\n        Return 0 if DST not in effect.  utcoffset() must include the DST\n        offset.\n        \"\"\"\n        raise NotImplementedError(\"tzinfo subclass must override dst()\")\n\n    def fromutc(self, dt):\n        \"datetime in UTC -> datetime in local time.\"\n\n        if not isinstance(dt, datetime):\n            raise TypeError(\"fromutc() requires a datetime argument\")\n        if dt.tzinfo is not self:\n            raise ValueError(\"dt.tzinfo is not self\")\n\n        dtoff = dt.utcoffset()\n        if dtoff is None:\n            raise ValueError(\"fromutc() requires a non-None utcoffset() \"\n                             \"result\")\n\n        # See the long comment block at the end of this file for an\n        # explanation of this algorithm.\n        dtdst = dt.dst()\n        if dtdst is None:\n            raise ValueError(\"fromutc() requires a non-None dst() result\")\n        delta = dtoff - dtdst\n        if delta:\n            dt = dt + delta\n            dtdst = dt.dst()\n            if dtdst is None:\n                raise ValueError(\"fromutc(): dt.dst gave inconsistent \"\n                                 \"results; cannot convert\")\n        if dtdst:\n            return dt + dtdst\n        else:\n            return dt\n\n_tzinfo_class = tzinfo\n\nclass time(object):\n    \"\"\"Time with time zone.\n\n    Constructors:\n\n    __new__()\n\n    Operators:\n\n    __repr__, __str__\n    __cmp__, __hash__\n\n    Methods:\n\n    strftime()\n    isoformat()\n    utcoffset()\n    tzname()\n    dst()\n\n    Properties (readonly):\n    hour, minute, second, microsecond, tzinfo\n    \"\"\"\n    __slots__ = '_hour', '_minute', '_second', '_microsecond', '_tzinfo', '_hashcode'\n\n    def __new__(cls, hour=0, minute=0, second=0, microsecond=0, tzinfo=None):\n        \"\"\"Constructor.\n\n        Arguments:\n\n        hour, minute (required)\n        second, microsecond (default to zero)\n        tzinfo (default to None)\n        \"\"\"\n        hour, minute, second, microsecond = _check_time_fields(\n            hour, minute, second, microsecond)\n        _check_tzinfo_arg(tzinfo)\n        self = object.__new__(cls)\n        self._hour = hour\n        self._minute = minute\n        self._second = second\n        self._microsecond = microsecond\n        self._tzinfo = tzinfo\n        self._hashcode = -1\n        return self\n\n    # Read-only field accessors\n    @property\n    def hour(self):\n        \"\"\"hour (0-23)\"\"\"\n        return self._hour\n\n    @property\n    def minute(self):\n        \"\"\"minute (0-59)\"\"\"\n        return self._minute\n\n    @property\n    def second(self):\n        \"\"\"second (0-59)\"\"\"\n        return self._second\n\n    @property\n    def microsecond(self):\n        \"\"\"microsecond (0-999999)\"\"\"\n        return self._microsecond\n\n    @property\n    def tzinfo(self):\n        \"\"\"timezone info object\"\"\"\n        return self._tzinfo\n\n    # Standard conversions, __hash__ (and helpers)\n\n    # Comparisons of time objects with other.\n\n    def __eq__(self, other):\n        if isinstance(other, time):\n            return self._cmp(other) == 0\n        else:\n            return False\n\n    def __ne__(self, other):\n        if isinstance(other, time):\n            return self._cmp(other) != 0\n        else:\n            return True\n\n    def __le__(self, other):\n        if isinstance(other, time):\n            return self._cmp(other) <= 0\n        else:\n            _cmperror(self, other)\n\n    def __lt__(self, other):\n        if isinstance(other, time):\n            return self._cmp(other) < 0\n        else:\n            _cmperror(self, other)\n\n    def __ge__(self, other):\n        if isinstance(other, time):\n            return self._cmp(other) >= 0\n        else:\n            _cmperror(self, other)\n\n    def __gt__(self, other):\n        if isinstance(other, time):\n            return self._cmp(other) > 0\n        else:\n            _cmperror(self, other)\n\n    def _cmp(self, other):\n        assert isinstance(other, time)\n        mytz = self._tzinfo\n        ottz = other._tzinfo\n        myoff = otoff = None\n\n        if mytz is ottz:\n            base_compare = True\n        else:\n            myoff = self._utcoffset()\n            otoff = other._utcoffset()\n            base_compare = myoff == otoff\n\n        if base_compare:\n            return _cmp((self._hour, self._minute, self._second,\n                         self._microsecond),\n                        (other._hour, other._minute, other._second,\n                         other._microsecond))\n        if myoff is None or otoff is None:\n            raise TypeError(\"can't compare offset-naive and offset-aware times\")\n        myhhmm = self._hour * 60 + self._minute - myoff\n        othhmm = other._hour * 60 + other._minute - otoff\n        return _cmp((myhhmm, self._second, self._microsecond),\n                    (othhmm, other._second, other._microsecond))\n\n    def __hash__(self):\n        \"\"\"Hash.\"\"\"\n        if self._hashcode == -1:\n            tzoff = self._utcoffset()\n            if not tzoff:  # zero or None\n                self._hashcode = hash(self._getstate()[0])\n            else:\n                h, m = divmod(self.hour * 60 + self.minute - tzoff, 60)\n                if 0 <= h < 24:\n                    self._hashcode = hash(time(h, m, self.second, self.microsecond))\n                else:\n                    self._hashcode = hash((h, m, self.second, self.microsecond))\n        return self._hashcode\n\n    # Conversion to string\n\n    def _tzstr(self, sep=\":\"):\n        \"\"\"Return formatted timezone offset (+xx:xx) or None.\"\"\"\n        off = self._utcoffset()\n        if off is not None:\n            if off < 0:\n                sign = \"-\"\n                off = -off\n            else:\n                sign = \"+\"\n            hh, mm = divmod(off, 60)\n            assert 0 <= hh < 24\n            off = \"%s%02d%s%02d\" % (sign, hh, sep, mm)\n        return off\n\n    def __repr__(self):\n        \"\"\"Convert to formal string, for repr().\"\"\"\n        if self._microsecond != 0:\n            s = \", %d, %d\" % (self._second, self._microsecond)\n        elif self._second != 0:\n            s = \", %d\" % self._second\n        else:\n            s = \"\"\n        module = \"datetime.\" if self.__class__ is time else \"\"\n        s= \"%s(%d, %d%s)\" % (module + self.__class__.__name__,\n                             self._hour, self._minute, s)\n        if self._tzinfo is not None:\n            assert s[-1:] == \")\"\n            s = s[:-1] + \", tzinfo=%r\" % self._tzinfo + \")\"\n        return s\n\n    def isoformat(self):\n        \"\"\"Return the time formatted according to ISO.\n\n        This is 'HH:MM:SS.mmmmmm+zz:zz', or 'HH:MM:SS+zz:zz' if\n        self.microsecond == 0.\n        \"\"\"\n        s = _format_time(self._hour, self._minute, self._second,\n                         self._microsecond)\n        tz = self._tzstr()\n        if tz:\n            s += tz\n        return s\n\n    __str__ = isoformat\n\n    def strftime(self, format):\n        \"\"\"Format using strftime().  The date part of the timestamp passed\n        to underlying strftime should not be used.\n        \"\"\"\n        # The year must be >= _MINYEARFMT else Python's strftime implementation\n        # can raise a bogus exception.\n        timetuple = (1900, 1, 1,\n                     self._hour, self._minute, self._second,\n                     0, 1, -1)\n        return _wrap_strftime(self, format, timetuple)\n\n    def __format__(self, fmt):\n        if not isinstance(fmt, (str, unicode)):\n            raise ValueError(\"__format__ expects str or unicode, not %s\" %\n                             fmt.__class__.__name__)\n        if len(fmt) != 0:\n            return self.strftime(fmt)\n        return str(self)\n\n    # Timezone functions\n\n    def utcoffset(self):\n        \"\"\"Return the timezone offset in minutes east of UTC (negative west of\n        UTC).\"\"\"\n        if self._tzinfo is None:\n            return None\n        offset = self._tzinfo.utcoffset(None)\n        offset = _check_utc_offset(\"utcoffset\", offset)\n        if offset is not None:\n            offset = timedelta._create(0, offset * 60, 0, True)\n        return offset\n\n    # Return an integer (or None) instead of a timedelta (or None).\n    def _utcoffset(self):\n        if self._tzinfo is None:\n            return None\n        offset = self._tzinfo.utcoffset(None)\n        offset = _check_utc_offset(\"utcoffset\", offset)\n        return offset\n\n    def tzname(self):\n        \"\"\"Return the timezone name.\n\n        Note that the name is 100% informational -- there's no requirement that\n        it mean anything in particular. For example, \"GMT\", \"UTC\", \"-500\",\n        \"-5:00\", \"EDT\", \"US/Eastern\", \"America/New York\" are all valid replies.\n        \"\"\"\n        if self._tzinfo is None:\n            return None\n        name = self._tzinfo.tzname(None)\n        _check_tzname(name)\n        return name\n\n    def dst(self):\n        \"\"\"Return 0 if DST is not in effect, or the DST offset (in minutes\n        eastward) if DST is in effect.\n\n        This is purely informational; the DST offset has already been added to\n        the UTC offset returned by utcoffset() if applicable, so there's no\n        need to consult dst() unless you're interested in displaying the DST\n        info.\n        \"\"\"\n        if self._tzinfo is None:\n            return None\n        offset = self._tzinfo.dst(None)\n        offset = _check_utc_offset(\"dst\", offset)\n        if offset is not None:\n            offset = timedelta._create(0, offset * 60, 0, True)\n        return offset\n\n    # Return an integer (or None) instead of a timedelta (or None).\n    def _dst(self):\n        if self._tzinfo is None:\n            return None\n        offset = self._tzinfo.dst(None)\n        offset = _check_utc_offset(\"dst\", offset)\n        return offset\n\n    def replace(self, hour=None, minute=None, second=None, microsecond=None,\n                tzinfo=True):\n        \"\"\"Return a new time with new values for the specified fields.\"\"\"\n        if hour is None:\n            hour = self.hour\n        if minute is None:\n            minute = self.minute\n        if second is None:\n            second = self.second\n        if microsecond is None:\n            microsecond = self.microsecond\n        if tzinfo is True:\n            tzinfo = self.tzinfo\n        return time(hour, minute, second, microsecond, tzinfo)\n\n    def __nonzero__(self):\n        if self.second or self.microsecond:\n            return True\n        offset = self._utcoffset() or 0\n        return self.hour * 60 + self.minute != offset\n\n_time_class = time  # so functions w/ args named \"time\" can get at the class\n\ntime.min = time(0, 0, 0)\ntime.max = time(23, 59, 59, 999999)\ntime.resolution = timedelta(microseconds=1)\n\nclass datetime(date):\n    \"\"\"datetime(year, month, day[, hour[, minute[, second[, microsecond[,tzinfo]]]]])\n\n    The year, month and day arguments are required. tzinfo may be None, or an\n    instance of a tzinfo subclass. The remaining arguments may be ints or longs.\n    \"\"\"\n    __slots__ = date.__slots__ + time.__slots__\n\n    def __new__(cls, year, month=None, day=None, hour=0, minute=0, second=0,\n                microsecond=0, tzinfo=None):\n        year, month, day = _check_date_fields(year, month, day)\n        hour, minute, second, microsecond = _check_time_fields(\n            hour, minute, second, microsecond)\n        _check_tzinfo_arg(tzinfo)\n        self = object.__new__(cls)\n        self._year = year\n        self._month = month\n        self._day = day\n        self._hour = hour\n        self._minute = minute\n        self._second = second\n        self._microsecond = microsecond\n        self._tzinfo = tzinfo\n        self._hashcode = -1\n        return self\n\n    # Read-only field accessors\n    @property\n    def hour(self):\n        \"\"\"hour (0-23)\"\"\"\n        return self._hour\n\n    @property\n    def minute(self):\n        \"\"\"minute (0-59)\"\"\"\n        return self._minute\n\n    @property\n    def second(self):\n        \"\"\"second (0-59)\"\"\"\n        return self._second\n\n    @property\n    def microsecond(self):\n        \"\"\"microsecond (0-999999)\"\"\"\n        return self._microsecond\n\n    @property\n    def tzinfo(self):\n        \"\"\"timezone info object\"\"\"\n        return self._tzinfo\n\n    @classmethod\n    def fromtimestamp(cls, timestamp, tz=None):\n        \"\"\"Construct a datetime from a POSIX timestamp (like time.time()).\n\n        A timezone info object may be passed in as well.\n        \"\"\"\n        _check_tzinfo_arg(tz)\n        converter = _time.localtime if tz is None else _time.gmtime\n        self = cls._from_timestamp(converter, timestamp, tz)\n        if tz is not None:\n            self = tz.fromutc(self)\n        return self\n\n    @classmethod\n    def utcfromtimestamp(cls, t):\n        \"Construct a UTC datetime from a POSIX timestamp (like time.time()).\"\n        return cls._from_timestamp(_time.gmtime, t, None)\n\n    @classmethod\n    def _from_timestamp(cls, converter, timestamp, tzinfo):\n        t_full = timestamp\n        timestamp = int(_math.floor(timestamp))\n        frac = t_full - timestamp\n        us = _round(frac * 1e6)\n\n        # If timestamp is less than one microsecond smaller than a\n        # full second, us can be rounded up to 1000000.  In this case,\n        # roll over to seconds, otherwise, ValueError is raised\n        # by the constructor.\n        if us == 1000000:\n            timestamp += 1\n            us = 0\n        y, m, d, hh, mm, ss, weekday, jday, dst = converter(timestamp)\n        ss = min(ss, 59)    # clamp out leap seconds if the platform has them\n        return cls(y, m, d, hh, mm, ss, us, tzinfo)\n\n    @classmethod\n    def now(cls, tz=None):\n        \"Construct a datetime from time.time() and optional time zone info.\"\n        t = _time.time()\n        return cls.fromtimestamp(t, tz)\n\n    @classmethod\n    def utcnow(cls):\n        \"Construct a UTC datetime from time.time().\"\n        t = _time.time()\n        return cls.utcfromtimestamp(t)\n\n    @classmethod\n    def combine(cls, date, time):\n        \"Construct a datetime from a given date and a given time.\"\n        if not isinstance(date, _date_class):\n            raise TypeError(\"date argument must be a date instance\")\n        if not isinstance(time, _time_class):\n            raise TypeError(\"time argument must be a time instance\")\n        return cls(date.year, date.month, date.day,\n                   time.hour, time.minute, time.second, time.microsecond,\n                   time.tzinfo)\n\n    def timetuple(self):\n        \"Return local time tuple compatible with time.localtime().\"\n        dst = self._dst()\n        if dst is None:\n            dst = -1\n        elif dst:\n            dst = 1\n        return _build_struct_time(self.year, self.month, self.day,\n                                  self.hour, self.minute, self.second,\n                                  dst)\n\n    def utctimetuple(self):\n        \"Return UTC time tuple compatible with time.gmtime().\"\n        y, m, d = self.year, self.month, self.day\n        hh, mm, ss = self.hour, self.minute, self.second\n        offset = self._utcoffset()\n        if offset:  # neither None nor 0\n            mm -= offset\n            y, m, d, hh, mm, ss, _ = _normalize_datetime(\n                y, m, d, hh, mm, ss, 0, ignore_overflow=True)\n        return _build_struct_time(y, m, d, hh, mm, ss, 0)\n\n    def date(self):\n        \"Return the date part.\"\n        return date(self._year, self._month, self._day)\n\n    def time(self):\n        \"Return the time part, with tzinfo None.\"\n        return time(self.hour, self.minute, self.second, self.microsecond)\n\n    def timetz(self):\n        \"Return the time part, with same tzinfo.\"\n        return time(self.hour, self.minute, self.second, self.microsecond,\n                    self._tzinfo)\n\n    def replace(self, year=None, month=None, day=None, hour=None,\n                minute=None, second=None, microsecond=None, tzinfo=True):\n        \"\"\"Return a new datetime with new values for the specified fields.\"\"\"\n        if year is None:\n            year = self.year\n        if month is None:\n            month = self.month\n        if day is None:\n            day = self.day\n        if hour is None:\n            hour = self.hour\n        if minute is None:\n            minute = self.minute\n        if second is None:\n            second = self.second\n        if microsecond is None:\n            microsecond = self.microsecond\n        if tzinfo is True:\n            tzinfo = self.tzinfo\n        return datetime(year, month, day, hour, minute, second, microsecond,\n                        tzinfo)\n\n    def astimezone(self, tz):\n        if not isinstance(tz, tzinfo):\n            raise TypeError(\"tz argument must be an instance of tzinfo\")\n\n        mytz = self.tzinfo\n        if mytz is None:\n            raise ValueError(\"astimezone() requires an aware datetime\")\n\n        if tz is mytz:\n            return self\n\n        # Convert self to UTC, and attach the new time zone object.\n        myoffset = self.utcoffset()\n        if myoffset is None:\n            raise ValueError(\"astimezone() requires an aware datetime\")\n        utc = (self - myoffset).replace(tzinfo=tz)\n\n        # Convert from UTC to tz's local time.\n        return tz.fromutc(utc)\n\n    # Ways to produce a string.\n\n    def ctime(self):\n        \"Return ctime() style string.\"\n        weekday = self.toordinal() % 7 or 7\n        return \"%s %s %2d %02d:%02d:%02d %04d\" % (\n            _DAYNAMES[weekday],\n            _MONTHNAMES[self._month],\n            self._day,\n            self._hour, self._minute, self._second,\n            self._year)\n\n    def isoformat(self, sep='T'):\n        \"\"\"Return the time formatted according to ISO.\n\n        This is 'YYYY-MM-DD HH:MM:SS.mmmmmm', or 'YYYY-MM-DD HH:MM:SS' if\n        self.microsecond == 0.\n\n        If self.tzinfo is not None, the UTC offset is also attached, giving\n        'YYYY-MM-DD HH:MM:SS.mmmmmm+HH:MM' or 'YYYY-MM-DD HH:MM:SS+HH:MM'.\n\n        Optional argument sep specifies the separator between date and\n        time, default 'T'.\n        \"\"\"\n        s = (\"%04d-%02d-%02d%c\" % (self._year, self._month, self._day, sep) +\n             _format_time(self._hour, self._minute, self._second,\n                          self._microsecond))\n        off = self._utcoffset()\n        if off is not None:\n            if off < 0:\n                sign = \"-\"\n                off = -off\n            else:\n                sign = \"+\"\n            hh, mm = divmod(off, 60)\n            s += \"%s%02d:%02d\" % (sign, hh, mm)\n        return s\n\n    def __repr__(self):\n        \"\"\"Convert to formal string, for repr().\"\"\"\n        L = [self._year, self._month, self._day,  # These are never zero\n             self._hour, self._minute, self._second, self._microsecond]\n        if L[-1] == 0:\n            del L[-1]\n        if L[-1] == 0:\n            del L[-1]\n        s = \", \".join(map(str, L))\n        module = \"datetime.\" if self.__class__ is datetime else \"\"\n        s = \"%s(%s)\" % (module + self.__class__.__name__, s)\n        if self._tzinfo is not None:\n            assert s[-1:] == \")\"\n            s = s[:-1] + \", tzinfo=%r\" % self._tzinfo + \")\"\n        return s\n\n    def __str__(self):\n        \"Convert to string, for str().\"\n        return self.isoformat(sep=' ')\n\n    @classmethod\n    def strptime(cls, date_string, format):\n        'string, format -> new datetime parsed from a string (like time.strptime()).'\n        from _strptime import _strptime\n        # _strptime._strptime returns a two-element tuple.  The first\n        # element is a time.struct_time object.  The second is the\n        # microseconds (which are not defined for time.struct_time).\n        struct, micros = _strptime(date_string, format)\n        return cls(*(struct[0:6] + (micros,)))\n\n    def utcoffset(self):\n        \"\"\"Return the timezone offset in minutes east of UTC (negative west of\n        UTC).\"\"\"\n        if self._tzinfo is None:\n            return None\n        offset = self._tzinfo.utcoffset(self)\n        offset = _check_utc_offset(\"utcoffset\", offset)\n        if offset is not None:\n            offset = timedelta._create(0, offset * 60, 0, True)\n        return offset\n\n    # Return an integer (or None) instead of a timedelta (or None).\n    def _utcoffset(self):\n        if self._tzinfo is None:\n            return None\n        offset = self._tzinfo.utcoffset(self)\n        offset = _check_utc_offset(\"utcoffset\", offset)\n        return offset\n\n    def tzname(self):\n        \"\"\"Return the timezone name.\n\n        Note that the name is 100% informational -- there's no requirement that\n        it mean anything in particular. For example, \"GMT\", \"UTC\", \"-500\",\n        \"-5:00\", \"EDT\", \"US/Eastern\", \"America/New York\" are all valid replies.\n        \"\"\"\n        if self._tzinfo is None:\n            return None\n        name = self._tzinfo.tzname(self)\n        _check_tzname(name)\n        return name\n\n    def dst(self):\n        \"\"\"Return 0 if DST is not in effect, or the DST offset (in minutes\n        eastward) if DST is in effect.\n\n        This is purely informational; the DST offset has already been added to\n        the UTC offset returned by utcoffset() if applicable, so there's no\n        need to consult dst() unless you're interested in displaying the DST\n        info.\n        \"\"\"\n        if self._tzinfo is None:\n            return None\n        offset = self._tzinfo.dst(self)\n        offset = _check_utc_offset(\"dst\", offset)\n        if offset is not None:\n            offset = timedelta._create(0, offset * 60, 0, True)\n        return offset\n\n    # Return an integer (or None) instead of a timedelta (or None).\n    def _dst(self):\n        if self._tzinfo is None:\n            return None\n        offset = self._tzinfo.dst(self)\n        offset = _check_utc_offset(\"dst\", offset)\n        return offset\n\n    # Comparisons of datetime objects with other.\n\n    def __eq__(self, other):\n        if isinstance(other, datetime):\n            return self._cmp(other) == 0\n        elif hasattr(other, \"timetuple\") and not isinstance(other, date):\n            return NotImplemented\n        else:\n            return False\n\n    def __ne__(self, other):\n        if isinstance(other, datetime):\n            return self._cmp(other) != 0\n        elif hasattr(other, \"timetuple\") and not isinstance(other, date):\n            return NotImplemented\n        else:\n            return True\n\n    def __le__(self, other):\n        if isinstance(other, datetime):\n            return self._cmp(other) <= 0\n        elif hasattr(other, \"timetuple\") and not isinstance(other, date):\n            return NotImplemented\n        else:\n            _cmperror(self, other)\n\n    def __lt__(self, other):\n        if isinstance(other, datetime):\n            return self._cmp(other) < 0\n        elif hasattr(other, \"timetuple\") and not isinstance(other, date):\n            return NotImplemented\n        else:\n            _cmperror(self, other)\n\n    def __ge__(self, other):\n        if isinstance(other, datetime):\n            return self._cmp(other) >= 0\n        elif hasattr(other, \"timetuple\") and not isinstance(other, date):\n            return NotImplemented\n        else:\n            _cmperror(self, other)\n\n    def __gt__(self, other):\n        if isinstance(other, datetime):\n            return self._cmp(other) > 0\n        elif hasattr(other, \"timetuple\") and not isinstance(other, date):\n            return NotImplemented\n        else:\n            _cmperror(self, other)\n\n    def _cmp(self, other):\n        assert isinstance(other, datetime)\n        mytz = self._tzinfo\n        ottz = other._tzinfo\n        myoff = otoff = None\n\n        if mytz is ottz:\n            base_compare = True\n        else:\n            if mytz is not None:\n                myoff = self._utcoffset()\n            if ottz is not None:\n                otoff = other._utcoffset()\n            base_compare = myoff == otoff\n\n        if base_compare:\n            return _cmp((self._year, self._month, self._day,\n                         self._hour, self._minute, self._second,\n                         self._microsecond),\n                        (other._year, other._month, other._day,\n                         other._hour, other._minute, other._second,\n                         other._microsecond))\n        if myoff is None or otoff is None:\n            raise TypeError(\"can't compare offset-naive and offset-aware datetimes\")\n        # XXX What follows could be done more efficiently...\n        diff = self - other     # this will take offsets into account\n        if diff.days < 0:\n            return -1\n        return diff and 1 or 0\n\n    def _add_timedelta(self, other, factor):\n        y, m, d, hh, mm, ss, us = _normalize_datetime(\n            self._year,\n            self._month,\n            self._day + other.days * factor,\n            self._hour,\n            self._minute,\n            self._second + other.seconds * factor,\n            self._microsecond + other.microseconds * factor)\n        return datetime(y, m, d, hh, mm, ss, us, tzinfo=self._tzinfo)\n\n    def __add__(self, other):\n        \"Add a datetime and a timedelta.\"\n        if not isinstance(other, timedelta):\n            return NotImplemented\n        return self._add_timedelta(other, 1)\n\n    __radd__ = __add__\n\n    def __sub__(self, other):\n        \"Subtract two datetimes, or a datetime and a timedelta.\"\n        if not isinstance(other, datetime):\n            if isinstance(other, timedelta):\n                return self._add_timedelta(other, -1)\n            return NotImplemented\n\n        delta_d = self.toordinal() - other.toordinal()\n        delta_s = (self._hour - other._hour) * 3600 + \\\n                  (self._minute - other._minute) * 60 + \\\n                  (self._second - other._second)\n        delta_us = self._microsecond - other._microsecond\n        base = timedelta._create(delta_d, delta_s, delta_us, True)\n        if self._tzinfo is other._tzinfo:\n            return base\n        myoff = self._utcoffset()\n        otoff = other._utcoffset()\n        if myoff == otoff:\n            return base\n        if myoff is None or otoff is None:\n            raise TypeError(\"can't subtract offset-naive and offset-aware datetimes\")\n        return base + timedelta(minutes = otoff-myoff)\n\n    def __hash__(self):\n        if self._hashcode == -1:\n            tzoff = self._utcoffset()\n            if tzoff is None:\n                self._hashcode = hash(self._getstate()[0])\n            else:\n                days = _ymd2ord(self.year, self.month, self.day)\n                seconds = self.hour * 3600 + (self.minute - tzoff) * 60 + self.second\n                self._hashcode = hash(timedelta(days, seconds, self.microsecond))\n        return self._hashcode\n\n\n\ndatetime.min = datetime(1, 1, 1)\ndatetime.max = datetime(9999, 12, 31, 23, 59, 59, 999999)\ndatetime.resolution = timedelta(microseconds=1)\n\n\ndef _isoweek1monday(year):\n    # Helper to calculate the day number of the Monday starting week 1\n    # XXX This could be done more efficiently\n    THURSDAY = 3\n    firstday = _ymd2ord(year, 1, 1)\n    firstweekday = (firstday + 6) % 7  # See weekday() above\n    week1monday = firstday - firstweekday\n    if firstweekday > THURSDAY:\n        week1monday += 7\n    return week1monday\n\n\"\"\"\nSome time zone algebra.  For a datetime x, let\n    x.n = x stripped of its timezone -- its naive time.\n    x.o = x.utcoffset(), and assuming that doesn't raise an exception or\n          return None\n    x.d = x.dst(), and assuming that doesn't raise an exception or\n          return None\n    x.s = x's standard offset, x.o - x.d\n\nNow some derived rules, where k is a duration (timedelta).\n\n1. x.o = x.s + x.d\n   This follows from the definition of x.s.\n\n2. If x and y have the same tzinfo member, x.s = y.s.\n   This is actually a requirement, an assumption we need to make about\n   sane tzinfo classes.\n\n3. The naive UTC time corresponding to x is x.n - x.o.\n   This is again a requirement for a sane tzinfo class.\n\n4. (x+k).s = x.s\n   This follows from #2, and that datimetimetz+timedelta preserves tzinfo.\n\n5. (x+k).n = x.n + k\n   Again follows from how arithmetic is defined.\n\nNow we can explain tz.fromutc(x).  Let's assume it's an interesting case\n(meaning that the various tzinfo methods exist, and don't blow up or return\nNone when called).\n\nThe function wants to return a datetime y with timezone tz, equivalent to x.\nx is already in UTC.\n\nBy #3, we want\n\n    y.n - y.o = x.n                             [1]\n\nThe algorithm starts by attaching tz to x.n, and calling that y.  So\nx.n = y.n at the start.  Then it wants to add a duration k to y, so that [1]\nbecomes true; in effect, we want to solve [2] for k:\n\n   (y+k).n - (y+k).o = x.n                      [2]\n\nBy #1, this is the same as\n\n   (y+k).n - ((y+k).s + (y+k).d) = x.n          [3]\n\nBy #5, (y+k).n = y.n + k, which equals x.n + k because x.n=y.n at the start.\nSubstituting that into [3],\n\n   x.n + k - (y+k).s - (y+k).d = x.n; the x.n terms cancel, leaving\n   k - (y+k).s - (y+k).d = 0; rearranging,\n   k = (y+k).s - (y+k).d; by #4, (y+k).s == y.s, so\n   k = y.s - (y+k).d\n\nOn the RHS, (y+k).d can't be computed directly, but y.s can be, and we\napproximate k by ignoring the (y+k).d term at first.  Note that k can't be\nvery large, since all offset-returning methods return a duration of magnitude\nless than 24 hours.  For that reason, if y is firmly in std time, (y+k).d must\nbe 0, so ignoring it has no consequence then.\n\nIn any case, the new value is\n\n    z = y + y.s                                 [4]\n\nIt's helpful to step back at look at [4] from a higher level:  it's simply\nmapping from UTC to tz's standard time.\n\nAt this point, if\n\n    z.n - z.o = x.n                             [5]\n\nwe have an equivalent time, and are almost done.  The insecurity here is\nat the start of daylight time.  Picture US Eastern for concreteness.  The wall\ntime jumps from 1:59 to 3:00, and wall hours of the form 2:MM don't make good\nsense then.  The docs ask that an Eastern tzinfo class consider such a time to\nbe EDT (because it's \"after 2\"), which is a redundant spelling of 1:MM EST\non the day DST starts.  We want to return the 1:MM EST spelling because that's\nthe only spelling that makes sense on the local wall clock.\n\nIn fact, if [5] holds at this point, we do have the standard-time spelling,\nbut that takes a bit of proof.  We first prove a stronger result.  What's the\ndifference between the LHS and RHS of [5]?  Let\n\n    diff = x.n - (z.n - z.o)                    [6]\n\nNow\n    z.n =                       by [4]\n    (y + y.s).n =               by #5\n    y.n + y.s =                 since y.n = x.n\n    x.n + y.s =                 since z and y are have the same tzinfo member,\n                                    y.s = z.s by #2\n    x.n + z.s\n\nPlugging that back into [6] gives\n\n    diff =\n    x.n - ((x.n + z.s) - z.o) =     expanding\n    x.n - x.n - z.s + z.o =         cancelling\n    - z.s + z.o =                   by #2\n    z.d\n\nSo diff = z.d.\n\nIf [5] is true now, diff = 0, so z.d = 0 too, and we have the standard-time\nspelling we wanted in the endcase described above.  We're done.  Contrarily,\nif z.d = 0, then we have a UTC equivalent, and are also done.\n\nIf [5] is not true now, diff = z.d != 0, and z.d is the offset we need to\nadd to z (in effect, z is in tz's standard time, and we need to shift the\nlocal clock into tz's daylight time).\n\nLet\n\n    z' = z + z.d = z + diff                     [7]\n\nand we can again ask whether\n\n    z'.n - z'.o = x.n                           [8]\n\nIf so, we're done.  If not, the tzinfo class is insane, according to the\nassumptions we've made.  This also requires a bit of proof.  As before, let's\ncompute the difference between the LHS and RHS of [8] (and skipping some of\nthe justifications for the kinds of substitutions we've done several times\nalready):\n\n    diff' = x.n - (z'.n - z'.o) =           replacing z'.n via [7]\n            x.n  - (z.n + diff - z'.o) =    replacing diff via [6]\n            x.n - (z.n + x.n - (z.n - z.o) - z'.o) =\n            x.n - z.n - x.n + z.n - z.o + z'.o =    cancel x.n\n            - z.n + z.n - z.o + z'.o =              cancel z.n\n            - z.o + z'.o =                      #1 twice\n            -z.s - z.d + z'.s + z'.d =          z and z' have same tzinfo\n            z'.d - z.d\n\nSo z' is UTC-equivalent to x iff z'.d = z.d at this point.  If they are equal,\nwe've found the UTC-equivalent so are done.  In fact, we stop with [7] and\nreturn z', not bothering to compute z'.d.\n\nHow could z.d and z'd differ?  z' = z + z.d [7], so merely moving z' by\na dst() offset, and starting *from* a time already in DST (we know z.d != 0),\nwould have to change the result dst() returns:  we start in DST, and moving\na little further into it takes us out of DST.\n\nThere isn't a sane case where this can happen.  The closest it gets is at\nthe end of DST, where there's an hour in UTC with no spelling in a hybrid\ntzinfo class.  In US Eastern, that's 5:MM UTC = 0:MM EST = 1:MM EDT.  During\nthat hour, on an Eastern clock 1:MM is taken as being in standard time (6:MM\nUTC) because the docs insist on that, but 0:MM is taken as being in daylight\ntime (4:MM UTC).  There is no local time mapping to 5:MM UTC.  The local\nclock jumps from 1:59 back to 1:00 again, and repeats the 1:MM hour in\nstandard time.  Since that's what the local clock *does*, we want to map both\nUTC hours 5:MM and 6:MM to 1:MM Eastern.  The result is ambiguous\nin local time, but so it goes -- it's the way the local clock works.\n\nWhen x = 5:MM UTC is the input to this algorithm, x.o=0, y.o=-5 and y.d=0,\nso z=0:MM.  z.d=60 (minutes) then, so [5] doesn't hold and we keep going.\nz' = z + z.d = 1:MM then, and z'.d=0, and z'.d - z.d = -60 != 0 so [8]\n(correctly) concludes that z' is not UTC-equivalent to x.\n\nBecause we know z.d said z was in daylight time (else [5] would have held and\nwe would have stopped then), and we know z.d != z'.d (else [8] would have held\nand we have stopped then), and there are only 2 possible values dst() can\nreturn in Eastern, it follows that z'.d must be 0 (which it is in the example,\nbut the reasoning doesn't depend on the example -- it depends on there being\ntwo possible dst() outcomes, one zero and the other non-zero).  Therefore\nz' must be in standard time, and is the spelling we want in this case.\n\nNote again that z' is not UTC-equivalent as far as the hybrid tzinfo class is\nconcerned (because it takes z' as being in standard time rather than the\ndaylight time we intend here), but returning it gives the real-life \"local\nclock repeats an hour\" behavior when mapping the \"unspellable\" UTC hour into\ntz.\n\nWhen the input is 6:MM, z=1:MM and z.d=0, and we stop at once, again with\nthe 1:MM standard time spelling we want.\n\nSo how can this break?  One of the assumptions must be violated.  Two\npossibilities:\n\n1) [2] effectively says that y.s is invariant across all y belong to a given\n   time zone.  This isn't true if, for political reasons or continental drift,\n   a region decides to change its base offset from UTC.\n\n2) There may be versions of \"double daylight\" time where the tail end of\n   the analysis gives up a step too early.  I haven't thought about that\n   enough to say.\n\nIn any case, it's clear that the default fromutc() is strong enough to handle\n\"almost all\" time zones:  so long as the standard offset is invariant, it\ndoesn't matter if daylight time transition points change from year to year, or\nif daylight time is skipped in some years; it doesn't matter how large or\nsmall dst() may get within its bounds; and it doesn't even matter if some\nperverse time zone returns a negative dst()).  So a breaking case must be\npretty bizarre, and a tzinfo subclass can override fromutc() if it is.\n\"\"\"\n","src/lib/dbhash.py":"raise NotImplementedError(\"dbhash is not yet implemented in Skulpt\")\n","src/lib/decimal.py":"raise NotImplementedError(\"decimal is not yet implemented in Skulpt\")\n","src/lib/difflib.py":"raise NotImplementedError(\"difflib is not yet implemented in Skulpt\")\n","src/lib/dircache.py":"raise NotImplementedError(\"dircache is not yet implemented in Skulpt\")\n","src/lib/dis.py":"raise NotImplementedError(\"dis is not yet implemented in Skulpt\")\n","src/lib/distutils/__init__.py":"raise NotImplementedError(\"distutils is not yet implemented in Skulpt\")\n","src/lib/distutils/command/__init__.py":"raise NotImplementedError(\"command is not yet implemented in Skulpt\")\n","src/lib/distutils/tests/__init__.py":"raise NotImplementedError(\"tests is not yet implemented in Skulpt\")\n","src/lib/doctest.py":"raise NotImplementedError(\"doctest is not yet implemented in Skulpt\")\n","src/lib/document.js":"var $builtinmodule=function(){var a,b={};return b.getElementById=new Sk.builtin.func(function(a){var c=document.getElementById(a.v);return c?Sk.misceval.callsimArray(b.Element,[c]):Sk.builtin.none.none$}),b.createElement=new Sk.builtin.func(function(a){var c=document.createElement(a.v);if(c)return Sk.misceval.callsimArray(b.Element,[c])}),b.getElementsByTagName=new Sk.builtin.func(function(a){for(var c=document.getElementsByTagName(a.v),d=[],e=c.length-1;0<=e;e--)d.push(Sk.misceval.callsimArray(b.Element,[c[e]]));return new Sk.builtin.list(d)}),b.getElementsByClassName=new Sk.builtin.func(function(a){for(var c=document.getElementsByClassName(a.v),d=[],e=0;e<c.length;e++)d.push(Sk.misceval.callsimArray(b.Element,[c[e]]));return new Sk.builtin.list(d)}),b.getElementsByName=new Sk.builtin.func(function(a){for(var c=document.getElementsByName(a.v),d=[],e=0;e<c.length;e++)d.push(Sk.misceval.callsimArray(b.Element,[c[e]]));return new Sk.builtin.list(d)}),b.currentDiv=new Sk.builtin.func(function(){if(void 0!==Sk.divid)return new Sk.builtin.str(Sk.divid);throw new Sk.builtin.AttributeError(\"There is no value set for divid\")}),a=function(a,b){b.__init__=new Sk.builtin.func(function(a,b){a.v=b,a.innerHTML=b.innerHTML,a.innerText=b.innerText,void 0!==b.value&&(a.value=b.value,Sk.abstr.objectSetItem(a.$d,new Sk.builtin.str(\"value\"),new Sk.builtin.str(a.value))),void 0!==b.checked&&(a.checked=b.checked,Sk.abstr.objectSetItem(a.$d,new Sk.builtin.str(\"checked\"),new Sk.builtin.str(a.checked))),Sk.abstr.objectSetItem(a.$d,new Sk.builtin.str(\"innerHTML\"),new Sk.builtin.str(a.innerHTML)),Sk.abstr.objectSetItem(a.$d,new Sk.builtin.str(\"innerText\"),new Sk.builtin.str(a.innerText))}),b.tp$getattr=Sk.builtin.object.prototype.GenericGetAttr,b.__setattr__=new Sk.builtin.func(function(a,b,c){b=Sk.ffi.remapToJs(b),\"innerHTML\"===b&&(a.innerHTML=c,a.v.innerHTML=c.v,Sk.abstr.objectSetItem(a.$d,new Sk.builtin.str(\"innerHTML\"),c)),\"innerText\"===b&&(a.innerText=c,a.v.innerText=c.v,Sk.abstr.objectSetItem(a.$d,new Sk.builtin.str(\"innerText\"),c))}),b.appendChild=new Sk.builtin.func(function(a,b){a.v.appendChild(b.v)}),b.removeChild=new Sk.builtin.func(function(a,b){a.v.removeChild(b.v)}),b.getCSS=new Sk.builtin.func(function(a,b){return new Sk.builtin.str(a.v.style[b.v])}),b.setCSS=new Sk.builtin.func(function(a,b,c){a.v.style[b.v]=c.v}),b.getAttribute=new Sk.builtin.func(function(a,b){var c=a.v.getAttribute(b.v);return c?new Sk.builtin.str(c):Sk.builtin.none.none$}),b.setAttribute=new Sk.builtin.func(function(a,b,c){a.v.setAttribute(b.v,c.v)}),b.getProperty=new Sk.builtin.func(function(a,b){var c=a.v[b.v];return c?new Sk.builtin.str(c):Sk.builtin.none.none$}),b.__str__=new Sk.builtin.func(function(a){return console.log(a.v.tagName),new Sk.builtin.str(a.v.tagName)}),b.__repr__=new Sk.builtin.func(function(){return new Sk.builtin.str(\"[DOM Element]\")})},b.Element=Sk.misceval.buildClass(b,a,\"Element\",[]),b};","src/lib/dumbdbm.py":"raise NotImplementedError(\"dumbdbm is not yet implemented in Skulpt\")\n","src/lib/dummy_thread.py":"raise NotImplementedError(\"dummy_thread is not yet implemented in Skulpt\")\n","src/lib/dummy_threading.py":"raise NotImplementedError(\"dummy_threading is not yet implemented in Skulpt\")\n","src/lib/email/__init__.py":"raise NotImplementedError(\"email is not yet implemented in Skulpt\")\n","src/lib/email/mime/__init__.py":"raise NotImplementedError(\"mime is not yet implemented in Skulpt\")\n","src/lib/email/test/data/__init__.py":"raise NotImplementedError(\"data is not yet implemented in Skulpt\")\n","src/lib/encodings/__init__.py":"raise NotImplementedError(\"encodings is not yet implemented in Skulpt\")\n","src/lib/errno.py":"\"\"\"This module makes available standard errno system symbols.\n\nThe value of each symbol is the corresponding integer value,\ne.g., on most systems, errno.ENOENT equals the integer 2.\n\nThe dictionary errno.errorcode maps numeric codes to symbol names,\ne.g., errno.errorcode[2] could be the string 'ENOENT'.\n\nSymbols that are not relevant to the underlying system are not defined.\n\nTo map error codes to error messages, use the function os.strerror(),\ne.g. os.strerror(2) could return 'No such file or directory'.\"\"\"\n\n\nE2BIG = 7\n\nEACCES = 13\n\nEADDRINUSE = 10048\n\nEADDRNOTAVAIL = 10049\n\nEAFNOSUPPORT = 10047\n\nEAGAIN = 11\n\nEALREADY = 10037\n\nEBADF = 9\n\nEBADMSG = 104\n\nEBUSY = 16\n\nECANCELED = 105\n\nECHILD = 10\n\nECONNABORTED = 10053\n\nECONNREFUSED = 10061\n\nECONNRESET = 10054\n\nEDEADLK = 36\n\nEDEADLOCK = 36\n\nEDESTADDRREQ = 10039\n\nEDOM = 33\n\nEDQUOT = 10069\n\nEEXIST = 17\n\nEFAULT = 14\n\nEFBIG = 27\n\nEHOSTDOWN = 10064\n\nEHOSTUNREACH = 10065\n\nEIDRM = 111\n\nEILSEQ = 42\n\nEINPROGRESS = 10036\n\nEINTR = 4\n\nEINVAL = 22\n\nEIO = 5\n\nEISCONN = 10056\n\nEISDIR = 21\n\nELOOP = 10062\n\nEMFILE = 24\n\nEMLINK = 31\n\nEMSGSIZE = 10040\n\nENAMETOOLONG = 38\n\nENETDOWN = 10050\n\nENETRESET = 10052\n\nENETUNREACH = 10051\n\nENFILE = 23\n\nENOBUFS = 10055\n\nENODATA = 120\n\nENODEV = 19\n\nENOENT = 2\n\nENOEXEC = 8\n\nENOLCK = 39\n\nENOLINK = 121\n\nENOMEM = 12\n\nENOMSG = 122\n\nENOPROTOOPT = 10042\n\nENOSPC = 28\n\nENOSR = 124\n\nENOSTR = 125\n\nENOSYS = 40\n\nENOTCONN = 10057\n\nENOTDIR = 20\n\nENOTEMPTY = 41\n\nENOTRECOVERABLE = 127\n\nENOTSOCK = 10038\n\nENOTSUP = 129\n\nENOTTY = 25\n\nENXIO = 6\n\nEOPNOTSUPP = 10045\n\nEOVERFLOW = 132\n\nEOWNERDEAD = 133\n\nEPERM = 1\n\nEPFNOSUPPORT = 10046\n\nEPIPE = 32\n\nEPROTO = 134\n\nEPROTONOSUPPORT = 10043\n\nEPROTOTYPE = 10041\n\nERANGE = 34\n\nEREMOTE = 10071\n\nEROFS = 30\n\nESHUTDOWN = 10058\n\nESOCKTNOSUPPORT = 10044\n\nESPIPE = 29\n\nESRCH = 3\n\nESTALE = 10070\n\nETIME = 137\n\nETIMEDOUT = 10060\n\nETOOMANYREFS = 10059\n\nETXTBSY = 139\n\nEUSERS = 10068\n\nEWOULDBLOCK = 10035\n\nEXDEV = 18\n\nWSABASEERR = 10000\n\nWSAEACCES = 10013\n\nWSAEADDRINUSE = 10048\n\nWSAEADDRNOTAVAIL = 10049\n\nWSAEAFNOSUPPORT = 10047\n\nWSAEALREADY = 10037\n\nWSAEBADF = 10009\n\nWSAECONNABORTED = 10053\n\nWSAECONNREFUSED = 10061\n\nWSAECONNRESET = 10054\n\nWSAEDESTADDRREQ = 10039\n\nWSAEDISCON = 10101\n\nWSAEDQUOT = 10069\n\nWSAEFAULT = 10014\n\nWSAEHOSTDOWN = 10064\n\nWSAEHOSTUNREACH = 10065\n\nWSAEINPROGRESS = 10036\n\nWSAEINTR = 10004\n\nWSAEINVAL = 10022\n\nWSAEISCONN = 10056\n\nWSAELOOP = 10062\n\nWSAEMFILE = 10024\n\nWSAEMSGSIZE = 10040\n\nWSAENAMETOOLONG = 10063\n\nWSAENETDOWN = 10050\n\nWSAENETRESET = 10052\n\nWSAENETUNREACH = 10051\n\nWSAENOBUFS = 10055\n\nWSAENOPROTOOPT = 10042\n\nWSAENOTCONN = 10057\n\nWSAENOTEMPTY = 10066\n\nWSAENOTSOCK = 10038\n\nWSAEOPNOTSUPP = 10045\n\nWSAEPFNOSUPPORT = 10046\n\nWSAEPROCLIM = 10067\n\nWSAEPROTONOSUPPORT = 10043\n\nWSAEPROTOTYPE = 10041\n\nWSAEREMOTE = 10071\n\nWSAESHUTDOWN = 10058\n\nWSAESOCKTNOSUPPORT = 10044\n\nWSAESTALE = 10070\n\nWSAETIMEDOUT = 10060\n\nWSAETOOMANYREFS = 10059\n\nWSAEUSERS = 10068\n\nWSAEWOULDBLOCK = 10035\n\nWSANOTINITIALISED = 10093\n\nWSASYSNOTREADY = 10091\n\nWSAVERNOTSUPPORTED = 10092\n\nclass __loader__(object):\n    \"\"\"Meta path import for built-in modules.\n\n        All methods are either class or static methods to avoid the need to\n        instantiate the class.\n\n        \"\"\"\n\n\n    __delattr__ = \"<slot wrapper '__delattr__' of 'object' objects>\"\n\n    __dict__ = \"{'__module__': '_frozen_importlib', '__doc__': 'Meta path import for built-in modules.\\n\\n    All methods are either class or static methods to avoid the need to\\n    instantiate the class.\\n\\n    ', 'module_repr': <staticmethod object at 0x00000153E1934208>, 'find_spec': <classmethod object at 0x00000153E1934240>, 'find_module': <classmethod object at 0x00000153E1934278>, 'create_module': <classmethod object at 0x00000153E19342B0>, 'exec_module': <classmethod object at 0x00000153E19342E8>, 'get_code': <classmethod object at 0x00000153E1934358>, 'get_source': <classmethod object at 0x00000153E19343C8>, 'is_package': <classmethod object at 0x00000153E1934438>, 'load_module': <classmethod object at 0x00000153E1934470>, '__dict__': <attribute '__dict__' of 'BuiltinImporter' objects>, '__weakref__': <attribute '__weakref__' of 'BuiltinImporter' objects>}\"\n\n    __dir__ = \"<method '__dir__' of 'object' objects>\"\n\n    __eq__ = \"<slot wrapper '__eq__' of 'object' objects>\"\n\n    __format__ = \"<method '__format__' of 'object' objects>\"\n\n    __ge__ = \"<slot wrapper '__ge__' of 'object' objects>\"\n\n    __getattribute__ = \"<slot wrapper '__getattribute__' of 'object' objects>\"\n\n    __gt__ = \"<slot wrapper '__gt__' of 'object' objects>\"\n\n    __hash__ = \"<slot wrapper '__hash__' of 'object' objects>\"\n\n    __init__ = \"<slot wrapper '__init__' of 'object' objects>\"\n\n    def __init_subclass__(*args,**kw):\n        \"\"\"This method is called when a class is subclassed.\n        The default implementation does nothing. It may be\n        overridden to extend subclasses.\n        \"\"\"\n        pass\n\n    __le__ = \"<slot wrapper '__le__' of 'object' objects>\"\n\n    __lt__ = \"<slot wrapper '__lt__' of 'object' objects>\"\n\n    __module__ = \"\"\"_frozen_importlib\"\"\"\n\n    __ne__ = \"<slot wrapper '__ne__' of 'object' objects>\"\n\n    def __new__(*args,**kw):\n        \"\"\"Create and return a new object.  See help(type) for accurate signature.\"\"\"\n        pass\n\n    __reduce__ = \"<method '__reduce__' of 'object' objects>\"\n\n    __reduce_ex__ = \"<method '__reduce_ex__' of 'object' objects>\"\n\n    __repr__ = \"<slot wrapper '__repr__' of 'object' objects>\"\n\n    __setattr__ = \"<slot wrapper '__setattr__' of 'object' objects>\"\n\n    __sizeof__ = \"<method '__sizeof__' of 'object' objects>\"\n\n    __str__ = \"<slot wrapper '__str__' of 'object' objects>\"\n\n    def __subclasshook__(*args,**kw):\n        \"\"\"Abstract classes can override this to customize issubclass().\n        This is invoked early on by abc.ABCMeta.__subclasscheck__().\n        It should return True, False or NotImplemented.  If it returns\n        NotImplemented, the normal algorithm is used.  Otherwise, it\n        overrides the normal algorithm (and the outcome is cached).\n        \"\"\"\n        pass\n\n    __weakref__ = \"<attribute '__weakref__' of 'BuiltinImporter' objects>\"\n\n    create_module = \"<bound method BuiltinImporter.create_module of <class '_frozen_importlib.BuiltinImporter'>>\"\n\n    exec_module = \"<bound method BuiltinImporter.exec_module of <class '_frozen_importlib.BuiltinImporter'>>\"\n\n    find_module = \"<bound method BuiltinImporter.find_module of <class '_frozen_importlib.BuiltinImporter'>>\"\n\n    find_spec = \"<bound method BuiltinImporter.find_spec of <class '_frozen_importlib.BuiltinImporter'>>\"\n\n    get_code = \"<bound method BuiltinImporter.get_code of <class '_frozen_importlib.BuiltinImporter'>>\"\n\n    get_source = \"<bound method BuiltinImporter.get_source of <class '_frozen_importlib.BuiltinImporter'>>\"\n\n    is_package = \"<bound method BuiltinImporter.is_package of <class '_frozen_importlib.BuiltinImporter'>>\"\n\n    load_module = \"<bound method _load_module_shim of <class '_frozen_importlib.BuiltinImporter'>>\"\n\n    def module_repr(*args,**kw):\n        \"\"\"Return repr for the module.\n                The method is deprecated.  The import machinery does the job itself.\n\n                \"\"\"\n        pass\n__spec__ = \"ModuleSpec(name='errno', loader=<class '_frozen_importlib.BuiltinImporter'>, origin='built-in')\"\n\nerrorcode = {v:k for (k, v) in globals().items() if k == k.upper()}\n","src/lib/filecmp.py":"raise NotImplementedError(\"filecmp is not yet implemented in Skulpt\")\n","src/lib/fileinput.py":"raise NotImplementedError(\"fileinput is not yet implemented in Skulpt\")\n","src/lib/fnmatch.py":"raise NotImplementedError(\"fnmatch is not yet implemented in Skulpt\")\n","src/lib/formatter.py":"raise NotImplementedError(\"formatter is not yet implemented in Skulpt\")\n","src/lib/fpformat.py":"raise NotImplementedError(\"fpformat is not yet implemented in Skulpt\")\n","src/lib/fractions.py":"raise NotImplementedError(\"fractions is not yet implemented in Skulpt\")\n","src/lib/ftplib.py":"raise NotImplementedError(\"ftplib is not yet implemented in Skulpt\")\n","src/lib/functools.py":"raise NotImplementedError(\"functools is not yet implemented in Skulpt\")\n","src/lib/genericpath.py":"raise NotImplementedError(\"genericpath is not yet implemented in Skulpt\")\n","src/lib/getopt.py":"raise NotImplementedError(\"getopt is not yet implemented in Skulpt\")\n","src/lib/getpass.py":"raise NotImplementedError(\"getpass is not yet implemented in Skulpt\")\n","src/lib/gettext.py":"raise NotImplementedError(\"gettext is not yet implemented in Skulpt\")\n","src/lib/glob.py":"raise NotImplementedError(\"glob is not yet implemented in Skulpt\")\n","src/lib/gzip.py":"raise NotImplementedError(\"gzip is not yet implemented in Skulpt\")\n","src/lib/hashlib.py":"raise NotImplementedError(\"hashlib is not yet implemented in Skulpt\")\n","src/lib/heapq.py":"raise NotImplementedError(\"heapq is not yet implemented in Skulpt\")\n","src/lib/hmac.py":"raise NotImplementedError(\"hmac is not yet implemented in Skulpt\")\n","src/lib/hotshot/__init__.py":"raise NotImplementedError(\"hotshot is not yet implemented in Skulpt\")\n","src/lib/htmlentitydefs.py":"raise NotImplementedError(\"htmlentitydefs is not yet implemented in Skulpt\")\n","src/lib/htmllib.py":"raise NotImplementedError(\"htmllib is not yet implemented in Skulpt\")\n","src/lib/httplib.py":"raise NotImplementedError(\"httplib is not yet implemented in Skulpt\")\n","src/lib/idlelib/Icons/__init__.py":"raise NotImplementedError(\"Icons is not yet implemented in Skulpt\")\n","src/lib/idlelib/__init__.py":"raise NotImplementedError(\"idlelib is not yet implemented in Skulpt\")\n","src/lib/ihooks.py":"raise NotImplementedError(\"ihooks is not yet implemented in Skulpt\")\n","src/lib/image.js":"var ImageMod,$builtinmodule;ImageMod||(ImageMod={},ImageMod.canvasLib=[]),$builtinmodule=function(){var a,b,c,d,e,f,g,h={};return h.Image=Sk.misceval.buildClass(h,function(a,b){var c=Math.floor;e=function(a){a.width=a.image.width,a.height=a.image.height,a.delay=0,a.updateCount=0,a.updateInterval=1,a.lastx=0,a.lasty=0,a.canvas=document.createElement(\"canvas\"),a.canvas.height=a.height,a.canvas.width=a.width,a.ctx=a.canvas.getContext(\"2d\"),a.ctx.drawImage(a.image,0,0),a.imagedata=a.ctx.getImageData(0,0,a.width,a.height)},b.__init__=new Sk.builtin.func(function(a,b){var c;Sk.builtin.pyCheckArgsLen(\"__init__\",arguments.length,2,2);try{a.image=document.getElementById(Sk.ffi.remapToJs(b)),e(a)}catch(b){a.image=null}if(null==a.image)return c=new Sk.misceval.Suspension,c.resume=function(){if(c.data.error)throw new Sk.builtin.IOError(c.data.error.message)},c.data={type:\"Sk.promise\",promise:new Promise(function(c,d){var f=new Image;f.crossOrigin=\"\",f.onerror=function(){d(Error(\"Failed to load URL: \"+f.src))},f.onload=function(){a.image=this,e(a),c()},f.src=g(b)})},c}),g=function(a){var b,c,d=\"function\"==typeof Sk.imageProxy?Sk.imageProxy:function(a){return b=document.createElement(\"a\"),b.href=c,window.location.host===b.host?a:Sk.imageProxy+\"/\"+a};return c=Sk.ffi.remapToJs(a),c=d(c),c},f=function(a,b,c){if(0>b||0>c||b>=a.width||c>=a.height)throw new Sk.builtin.ValueError(\"Pixel index out of range.\")};var i=function(a,b,c){var d;Sk.builtin.pyCheckArgsLen(\"setdelay\",arguments.length,2,3),a.delay=Sk.ffi.remapToJs(b),d=Sk.builtin.asnum$(c),a.updateInterval=d?d:1};b.set_delay=new Sk.builtin.func(i),b.setDelay=new Sk.builtin.func(i);var j=function(a){var b,d=[];for(Sk.builtin.pyCheckArgsLen(\"getpixels\",arguments.length,1,1),b=0;b<a.image.height*a.image.width;b++)d[b]=Sk.misceval.callsimArray(a.getPixel,[a,b%a.image.width,c(b/a.image.width)]);return new Sk.builtin.tuple(d)};b.get_pixels=new Sk.builtin.func(j),b.getPixels=new Sk.builtin.func(j),b.getData=new Sk.builtin.func(function(a){var b,d,e,g,h,j,k,l=[];for(Sk.builtin.pyCheckArgsLen(\"getData\",arguments.length,1,1),b=0;b<a.image.height*a.image.width;b++)d=b%a.image.width,e=c(b/a.image.width),f(a,d,e),k=4*e*a.width+4*d,g=a.imagedata.data[k],h=a.imagedata.data[k+1],j=a.imagedata.data[k+2],l[b]=new Sk.builtin.tuple([new Sk.builtin.int_(g),new Sk.builtin.int_(h),new Sk.builtin.int_(j)]);return new Sk.builtin.list(l)});var k=function(a,b,c){var d,e,g,i;return Sk.builtin.pyCheckArgsLen(\"getpixel\",arguments.length,3,3),b=Sk.builtin.asnum$(b),c=Sk.builtin.asnum$(c),f(a,b,c),i=4*c*a.width+4*b,d=a.imagedata.data[i],g=a.imagedata.data[i+1],e=a.imagedata.data[i+2],Sk.misceval.callsimArray(h.Pixel,[d,g,e,b,c])};b.get_pixel=new Sk.builtin.func(k),b.getPixel=new Sk.builtin.func(k),d=function(a,b,c){var d=new Sk.misceval.Suspension;return d.resume=function(){return Sk.builtin.none.none$},d.data={type:\"Sk.promise\",promise:new Promise(function(d){var e=Math.max,f=Math.abs,g=Math.min;a.updateCount++,0==a.updateCount%a.updateInterval?(a.lastx+a.updateInterval>=a.width?a.lastCtx.putImageData(a.imagedata,a.lastUlx,a.lastUly,0,a.lasty,a.width,2):a.lasty+a.updateInterval>=a.height?a.lastCtx.putImageData(a.imagedata,a.lastUlx,a.lastUly,a.lastx,0,2,a.height):a.lastCtx.putImageData(a.imagedata,a.lastUlx,a.lastUly,g(b,a.lastx),g(c,a.lasty),e(f(b-a.lastx),1),e(f(c-a.lasty),1)),a.lastx=b,a.lasty=c,0<a.delay?window.setTimeout(d,a.delay):d()):d()})},d};var l=function(a,b,c,e){var g;return Sk.builtin.pyCheckArgsLen(\"setpixel\",arguments.length,4,4),b=Sk.builtin.asnum$(b),c=Sk.builtin.asnum$(c),f(a,b,c),g=4*c*a.width+4*b,a.imagedata.data[g]=Sk.builtin.asnum$(Sk.misceval.callsimArray(e.getRed,[e])),a.imagedata.data[g+1]=Sk.builtin.asnum$(Sk.misceval.callsimArray(e.getGreen,[e])),a.imagedata.data[g+2]=Sk.builtin.asnum$(Sk.misceval.callsimArray(e.getBlue,[e])),a.imagedata.data[g+3]=255,d(a,b,c)};b.set_pixel=new Sk.builtin.func(l),b.setPixel=new Sk.builtin.func(l);var m=function(a,b,e){var g,h,i;return Sk.builtin.pyCheckArgsLen(\"setpixelat\",arguments.length,3,3),b=Sk.builtin.asnum$(b),g=b%a.image.width,h=c(b/a.image.width),f(a,g,h),i=4*h*a.width+4*g,a.imagedata.data[i]=Sk.builtin.asnum$(Sk.misceval.callsimArray(e.getRed,[e])),a.imagedata.data[i+1]=Sk.builtin.asnum$(Sk.misceval.callsimArray(e.getGreen,[e])),a.imagedata.data[i+2]=Sk.builtin.asnum$(Sk.misceval.callsimArray(e.getBlue,[e])),a.imagedata.data[i+3]=255,d(a,g,h)};b.set_pixel_at=new Sk.builtin.func(m),b.setPixelAt=new Sk.builtin.func(m);var n=function(a,b){var c,e,g;return Sk.builtin.pyCheckArgsLen(\"updatepixel\",arguments.length,2,2),c=Sk.builtin.asnum$(Sk.misceval.callsimArray(b.getX,[b])),e=Sk.builtin.asnum$(Sk.misceval.callsimArray(b.getY,[b])),f(a,c,e),g=4*e*a.width+4*c,a.imagedata.data[g]=Sk.builtin.asnum$(Sk.misceval.callsimArray(b.getRed,[b])),a.imagedata.data[g+1]=Sk.builtin.asnum$(Sk.misceval.callsimArray(b.getGreen,[b])),a.imagedata.data[g+2]=Sk.builtin.asnum$(Sk.misceval.callsimArray(b.getBlue,[b])),a.imagedata.data[g+3]=255,d(a,c,e)};b.update_pixel=new Sk.builtin.func(n),b.updatePixel=new Sk.builtin.func(n);var o=function(a){return Sk.builtin.pyCheckArgsLen(\"getheight\",arguments.length,1,1),new Sk.builtin.int_(a.height)};b.get_height=new Sk.builtin.func(o),b.getHeight=new Sk.builtin.func(o);var p=function(a){return Sk.builtin.pyCheckArgsLen(\"getwidth\",arguments.length,1,1),new Sk.builtin.int_(a.width)};b.get_width=new Sk.builtin.func(p),b.getWidth=new Sk.builtin.func(p),b.__getattr__=new Sk.builtin.func(function(a,b){return(b=Sk.ffi.remapToJs(b),\"height\"===b)?Sk.builtin.assk$(a.height):\"width\"===b?Sk.builtin.assk$(a.width):void 0}),b.__setattr__=new Sk.builtin.func(function(a,b){if(b=Sk.ffi.remapToJs(b),\"height\"===b||\"width\"===b)throw new Sk.builtin.Exception(\"Cannot change height or width they can only be set on creation\");else throw new Sk.builtin.Exception(\"Unknown attribute: \"+b)}),b.draw=new Sk.builtin.func(function(a,b,c,d){var e;return Sk.builtin.pyCheckArgsLen(\"draw\",arguments.length,2,4),e=new Sk.misceval.Suspension,e.resume=function(){return Sk.builtin.none.none$},e.data={type:\"Sk.promise\",promise:new Promise(function(e){var f,g;b=Sk.builtin.asnum$(b),c=Sk.builtin.asnum$(c),d=Sk.builtin.asnum$(d),f=Sk.misceval.callsimArray(b.getWin,[b]),g=f.getContext(\"2d\"),void 0===c&&(c=0,d=0),a.lastUlx=c,a.lastUly=d,a.lastCtx=g,g.putImageData(a.imagedata,c,d),0<a.delay?window.setTimeout(e,a.delay):window.setTimeout(e,200)})},e})},\"Image\",[]),c=function(a,b){b.__init__=new Sk.builtin.func(function(a,b,c){Sk.builtin.pyCheckArgsLen(\"__init__\",arguments.length,3,3),a.width=Sk.builtin.asnum$(b),a.height=Sk.builtin.asnum$(c),a.canvas=document.createElement(\"canvas\"),a.ctx=a.canvas.getContext(\"2d\"),a.canvas.height=a.height,a.canvas.width=a.width,a.imagedata=a.ctx.getImageData(0,0,a.width,a.height)})},h.EmptyImage=Sk.misceval.buildClass(h,c,\"EmptyImage\",[h.Image]),b=function(a,b){b.__init__=new Sk.builtin.func(function(a,c,d,e,b,f){Sk.builtin.pyCheckArgsLen(\"__init__\",arguments.length,4,6),a.red=Sk.builtin.asnum$(c),a.green=Sk.builtin.asnum$(d),a.blue=Sk.builtin.asnum$(e),a.x=Sk.builtin.asnum$(b),a.y=Sk.builtin.asnum$(f)});var c=function(a){return Sk.builtin.pyCheckArgsLen(\"getred\",arguments.length,1,1),Sk.builtin.assk$(a.red)};b.get_red=new Sk.builtin.func(c),b.getRed=new Sk.builtin.func(c);var d=function(a){return Sk.builtin.pyCheckArgsLen(\"getgreen\",arguments.length,1,1),Sk.builtin.assk$(a.green)};b.get_green=new Sk.builtin.func(d),b.getGreen=new Sk.builtin.func(d);var e=function(a){return Sk.builtin.pyCheckArgsLen(\"getblue\",arguments.length,1,1),Sk.builtin.assk$(a.blue)};b.get_blue=new Sk.builtin.func(e),b.getBlue=new Sk.builtin.func(e);var f=function(a){return Sk.builtin.pyCheckArgsLen(\"getx\",arguments.length,1,1),Sk.builtin.assk$(a.x)};b.get_x=new Sk.builtin.func(f),b.getX=new Sk.builtin.func(f);var g=function(a){return Sk.builtin.pyCheckArgsLen(\"gety\",arguments.length,1,1),Sk.builtin.assk$(a.y)};b.get_y=new Sk.builtin.func(g),b.getY=new Sk.builtin.func(g);var h=function(a,b){Sk.builtin.pyCheckArgsLen(\"setred\",arguments.length,2,2),a.red=Sk.builtin.asnum$(b)};b.set_red=new Sk.builtin.func(h),b.setRed=new Sk.builtin.func(h);var i=function(a,b){Sk.builtin.pyCheckArgsLen(\"setgreen\",arguments.length,2,2),a.green=Sk.builtin.asnum$(b)};b.set_green=new Sk.builtin.func(i),b.setGreen=new Sk.builtin.func(i);var j=function(a,c){Sk.builtin.pyCheckArgsLen(\"setblue\",arguments.length,2,2),a.blue=Sk.builtin.asnum$(c)};b.set_blue=new Sk.builtin.func(j),b.setBlue=new Sk.builtin.func(j),b.__getattr__=new Sk.builtin.func(function(a,b){return(b=Sk.ffi.remapToJs(b),\"red\"===b)?Sk.builtin.assk$(a.red):\"green\"===b?Sk.builtin.assk$(a.green):\"blue\"===b?Sk.builtin.assk$(a.blue):void 0}),b.__setattr__=new Sk.builtin.func(function(a,b,c){b=Sk.ffi.remapToJs(b),(\"red\"===b||\"green\"===b||\"blue\"===b)&&(a[b]=Sk.builtin.asnum$(c))});var k=function(a,b){Sk.builtin.pyCheckArgsLen(\"setx\",arguments.length,2,2),a.x=Sk.builtin.asnum$(b)};b.set_x=new Sk.builtin.func(k),b.setX=new Sk.builtin.func(k);var l=function(a,b){Sk.builtin.pyCheckArgsLen(\"sety\",arguments.length,2,2),a.y=Sk.builtin.asnum$(b)};b.set_y=new Sk.builtin.func(l),b.setY=new Sk.builtin.func(l),b.__getitem__=new Sk.builtin.func(function(a,b){return(b=Sk.builtin.asnum$(b),0===b)?a.red:1==b?a.green:2==b?a.blue:void 0}),b.__str__=new Sk.builtin.func(function(a){return Sk.ffi.remapToPy(\"[\"+a.red+\",\"+a.green+\",\"+a.blue+\"]\")}),b.getColorTuple=new Sk.builtin.func(function(){}),b.setRange=new Sk.builtin.func(function(a,b){a.max=Sk.builtin.asnum$(b)})},h.Pixel=Sk.misceval.buildClass(h,b,\"Pixel\",[]),a=function(a,b){b.__init__=new Sk.builtin.func(function(a,b,c){var d,e,f;Sk.builtin.pyCheckArgsLen(\"__init__\",arguments.length,1,3),d=ImageMod.canvasLib[Sk.canvas],void 0===d?(e=document.createElement(\"canvas\"),f=document.getElementById(Sk.canvas),a.theScreen=e,f.appendChild(e),ImageMod.canvasLib[Sk.canvas]=e,ImageMod.canvasLib[Sk.canvas]=a.theScreen):(a.theScreen=d,a.theScreen.height=a.theScreen.height),void 0===b?(Sk.availableHeight&&(a.theScreen.height=Sk.availableHeight),Sk.availableWidth&&(a.theScreen.width=Sk.availableWidth)):(a.theScreen.height=c.v,a.theScreen.width=b.v),a.theScreen.style.display=\"block\"}),b.getWin=new Sk.builtin.func(function(a){return a.theScreen}),b.exitonclick=new Sk.builtin.func(function(a){var b=a.theScreen.id;a.theScreen.onclick=function(){document.getElementById(b).style.display=\"none\",document.getElementById(b).onclick=null,delete ImageMod.canvasLib[b]}})},h.ImageWin=Sk.misceval.buildClass(h,a,\"ImageWin\",[]),h};","src/lib/imaplib.py":"raise NotImplementedError(\"imaplib is not yet implemented in Skulpt\")\n","src/lib/imghdr.py":"raise NotImplementedError(\"imghdr is not yet implemented in Skulpt\")\n","src/lib/imputil.py":"raise NotImplementedError(\"imputil is not yet implemented in Skulpt\")\n","src/lib/io.py":"raise NotImplementedError(\"io is not yet implemented in Skulpt\")\n","src/lib/json/__init__.py":"raise NotImplementedError(\"json is not yet implemented in Skulpt\")\n","src/lib/json/tests/__init__.py":"raise NotImplementedError(\"tests is not yet implemented in Skulpt\")\n","src/lib/keyword.py":"\n__all__ = [\"iskeyword\", \"kwlist\"]\n\nkwlist = [\n#--start keywords--\n        'and',\n        'as',\n        'assert',\n        'break',\n        'class',\n        'continue',\n        'def',\n        'del',\n        'elif',\n        'else',\n        'except',\n        'exec',\n        'finally',\n        'for',\n        'from',\n        'global',\n        'if',\n        'import',\n        'in',\n        'is',\n        'lambda',\n        'not',\n        'or',\n        'pass',\n        'print',\n        'raise',\n        'return',\n        'try',\n        'while',\n        'with',\n        'yield',\n#--end keywords--\n        ]\n\ndef iskeyword(wd):\n    return wd in kwlist\n\n","src/lib/lib-dynload/__init__.py":"raise NotImplementedError(\"lib-dynload is not yet implemented in Skulpt\")\n","src/lib/lib-tk/__init__.py":"raise NotImplementedError(\"lib-tk is not yet implemented in Skulpt\")\n","src/lib/lib2to3/__init__.py":"raise NotImplementedError(\"lib2to3 is not yet implemented in Skulpt\")\n","src/lib/lib2to3/fixes/__init__.py":"raise NotImplementedError(\"fixes is not yet implemented in Skulpt\")\n","src/lib/lib2to3/pgen2/__init__.py":"raise NotImplementedError(\"pgen2 is not yet implemented in Skulpt\")\n","src/lib/lib2to3/tests/__init__.py":"raise NotImplementedError(\"tests is not yet implemented in Skulpt\")\n","src/lib/linecache.py":"raise NotImplementedError(\"linecache is not yet implemented in Skulpt\")\n","src/lib/locale.py":"raise NotImplementedError(\"locale is not yet implemented in Skulpt\")\n","src/lib/logging/__init__.py":"raise NotImplementedError(\"logging is not yet implemented in Skulpt\")\n","src/lib/macpath.py":"raise NotImplementedError(\"macpath is not yet implemented in Skulpt\")\n","src/lib/macurl2path.py":"raise NotImplementedError(\"macurl2path is not yet implemented in Skulpt\")\n","src/lib/mailbox.py":"raise NotImplementedError(\"mailbox is not yet implemented in Skulpt\")\n","src/lib/mailcap.py":"raise NotImplementedError(\"mailcap is not yet implemented in Skulpt\")\n","src/lib/markupbase.py":"raise NotImplementedError(\"markupbase is not yet implemented in Skulpt\")\n","src/lib/math.js":"var $builtinmodule=function(){var a=Math.floor,b=Math.pow,c=Math.log,d=Math.sqrt,e=Math.E,f=Math.PI,g={pi:new Sk.builtin.float_(f),e:new Sk.builtin.float_(e),fabs:new Sk.builtin.func(function(a){var b=Math.abs;return Sk.builtin.pyCheckArgsLen(\"fabs\",arguments.length,1,1),Sk.builtin.pyCheckType(\"x\",\"number\",Sk.builtin.checkNumber(a)),new Sk.builtin.float_(b(Sk.builtin.asnum$(a)))}),asin:new Sk.builtin.func(function(a){var b=Math.asin;return Sk.builtin.pyCheckArgsLen(\"asin\",arguments.length,1,1),Sk.builtin.pyCheckType(\"rad\",\"number\",Sk.builtin.checkNumber(a)),new Sk.builtin.float_(b(Sk.builtin.asnum$(a)))}),acos:new Sk.builtin.func(function(a){var b=Math.acos;return Sk.builtin.pyCheckArgsLen(\"acos\",arguments.length,1,1),Sk.builtin.pyCheckType(\"rad\",\"number\",Sk.builtin.checkNumber(a)),new Sk.builtin.float_(b(Sk.builtin.asnum$(a)))}),atan:new Sk.builtin.func(function(a){var b=Math.atan;return Sk.builtin.pyCheckArgsLen(\"atan\",arguments.length,1,1),Sk.builtin.pyCheckType(\"rad\",\"number\",Sk.builtin.checkNumber(a)),new Sk.builtin.float_(b(Sk.builtin.asnum$(a)))}),atan2:new Sk.builtin.func(function(a,b){var c=Math.atan2;return Sk.builtin.pyCheckArgsLen(\"atan2\",arguments.length,2,2),Sk.builtin.pyCheckType(\"y\",\"number\",Sk.builtin.checkNumber(a)),Sk.builtin.pyCheckType(\"x\",\"number\",Sk.builtin.checkNumber(b)),new Sk.builtin.float_(c(Sk.builtin.asnum$(a),Sk.builtin.asnum$(b)))}),sin:new Sk.builtin.func(function(a){var b=Math.sin;return Sk.builtin.pyCheckArgsLen(\"sin\",arguments.length,1,1),Sk.builtin.pyCheckType(\"rad\",\"number\",Sk.builtin.checkNumber(a)),new Sk.builtin.float_(b(Sk.builtin.asnum$(a)))}),cos:new Sk.builtin.func(function(a){var b=Math.cos;return Sk.builtin.pyCheckArgsLen(\"cos\",arguments.length,1,1),Sk.builtin.pyCheckType(\"rad\",\"number\",Sk.builtin.checkNumber(a)),new Sk.builtin.float_(b(Sk.builtin.asnum$(a)))}),tan:new Sk.builtin.func(function(a){var b=Math.tan;return Sk.builtin.pyCheckArgsLen(\"tan\",arguments.length,1,1),Sk.builtin.pyCheckType(\"rad\",\"number\",Sk.builtin.checkNumber(a)),new Sk.builtin.float_(b(Sk.builtin.asnum$(a)))}),asinh:new Sk.builtin.func(function(a){Sk.builtin.pyCheckArgsLen(\"asinh\",arguments.length,1,1),Sk.builtin.pyCheckType(\"x\",\"number\",Sk.builtin.checkNumber(a)),a=Sk.builtin.asnum$(a);var b=a+d(a*a+1);return new Sk.builtin.float_(c(b))}),acosh:new Sk.builtin.func(function(a){Sk.builtin.pyCheckArgsLen(\"acosh\",arguments.length,1,1),Sk.builtin.pyCheckType(\"x\",\"number\",Sk.builtin.checkNumber(a)),a=Sk.builtin.asnum$(a);var b=a+d(a*a-1);return new Sk.builtin.float_(c(b))}),atanh:new Sk.builtin.func(function(a){Sk.builtin.pyCheckArgsLen(\"atanh\",arguments.length,1,1),Sk.builtin.pyCheckType(\"x\",\"number\",Sk.builtin.checkNumber(a)),a=Sk.builtin.asnum$(a);var b=(1+a)/(1-a);return new Sk.builtin.float_(c(b)/2)}),sinh:new Sk.builtin.func(function(a){Sk.builtin.pyCheckArgsLen(\"sinh\",arguments.length,1,1),Sk.builtin.pyCheckType(\"x\",\"number\",Sk.builtin.checkNumber(a)),a=Sk.builtin.asnum$(a);var c=b(e,a);return new Sk.builtin.float_((c-1/c)/2)}),cosh:new Sk.builtin.func(function(a){Sk.builtin.pyCheckArgsLen(\"cosh\",arguments.length,1,1),Sk.builtin.pyCheckType(\"x\",\"number\",Sk.builtin.checkNumber(a)),a=Sk.builtin.asnum$(a);var c=b(e,a);return new Sk.builtin.float_((c+1/c)/2)}),tanh:new Sk.builtin.func(function(a){Sk.builtin.pyCheckArgsLen(\"tanh\",arguments.length,1,1),Sk.builtin.pyCheckType(\"x\",\"number\",Sk.builtin.checkNumber(a)),a=Sk.builtin.asnum$(a);var c=b(e,a),d=1/c;return new Sk.builtin.float_((c-d)/2/((c+d)/2))}),ceil:new Sk.builtin.func(function(a){var b=Math.ceil;return Sk.builtin.pyCheckArgsLen(\"ceil\",arguments.length,1,1),Sk.builtin.pyCheckType(\"x\",\"number\",Sk.builtin.checkNumber(a)),Sk.__future__.ceil_floor_int?new Sk.builtin.int_(b(Sk.builtin.asnum$(a))):new Sk.builtin.float_(b(Sk.builtin.asnum$(a)))}),copysign:new Sk.builtin.func(function(a,b){Sk.builtin.pyCheckArgsLen(\"ceil\",arguments.length,2,2),Sk.builtin.pyCheckType(\"x\",\"number\",Sk.builtin.checkNumber(a)),Sk.builtin.pyCheckType(\"y\",\"number\",Sk.builtin.checkNumber(b));var c,d=Sk.ffi.remapToJs(a),e=Sk.ffi.remapToJs(b),f=0>d,g=0>d;return Sk.builtin.checkFloat(a)&&0===d&&(f=1/d==-Infinity),Sk.builtin.checkFloat(b)&&0===e&&(g=1/e==-Infinity),f&&g||!f&&!g?c=e:(f&&!g||!f&&g)&&(0===b?c=f?-0:0:c=-1*e),new Sk.builtin.float_(c)}),floor:new Sk.builtin.func(function(b){return Sk.builtin.pyCheckArgsLen(\"floor\",arguments.length,1,1),Sk.builtin.pyCheckType(\"x\",\"number\",Sk.builtin.checkNumber(b)),Sk.__future__.ceil_floor_int?new Sk.builtin.int_(a(Sk.builtin.asnum$(b))):new Sk.builtin.float_(a(Sk.builtin.asnum$(b)))}),sqrt:new Sk.builtin.func(function(a){return Sk.builtin.pyCheckArgsLen(\"sqrt\",arguments.length,1,1),Sk.builtin.pyCheckType(\"x\",\"number\",Sk.builtin.checkNumber(a)),new Sk.builtin.float_(d(Sk.builtin.asnum$(a)))}),trunc:new Sk.builtin.func(function(a){return Sk.builtin.pyCheckArgsLen(\"trunc\",arguments.length,1,1),Sk.builtin.pyCheckType(\"x\",\"number\",Sk.builtin.checkNumber(a)),new Sk.builtin.int_(0|Sk.builtin.asnum$(a))}),log:new Sk.builtin.func(function(a,b){if(Sk.builtin.pyCheckArgsLen(\"log\",arguments.length,1,2),Sk.builtin.pyCheckType(\"x\",\"number\",Sk.builtin.checkNumber(a)),void 0===b)return new Sk.builtin.float_(c(Sk.builtin.asnum$(a)));Sk.builtin.pyCheckType(\"base\",\"number\",Sk.builtin.checkNumber(b));var d=c(Sk.builtin.asnum$(a))/c(Sk.builtin.asnum$(b));return new Sk.builtin.float_(d)}),log10:new Sk.builtin.func(function(a){Sk.builtin.pyCheckArgsLen(\"log10\",arguments.length,1,1),Sk.builtin.pyCheckType(\"x\",\"number\",Sk.builtin.checkNumber(a));var b=c(Sk.builtin.asnum$(a))/c(10);return new Sk.builtin.float_(b)}),isinf:new Sk.builtin.func(function(a){Sk.builtin.pyCheckArgsLen(\"isinf\",arguments.length,1,1),Sk.builtin.pyCheckType(\"x\",\"number\",Sk.builtin.checkNumber(a));var b=Sk.builtin.asnum$(a);return isFinite(b)&&!isNaN(b)?Sk.builtin.bool.false$:Sk.builtin.bool.true$}),isnan:new Sk.builtin.func(function(a){Sk.builtin.pyCheckArgsLen(\"isnan\",arguments.length,1,1),Sk.builtin.pyCheckType(\"x\",\"float\",Sk.builtin.checkFloat(a));var b=Sk.builtin.asnum$(a);return isNaN(b)?Sk.builtin.bool.true$:Sk.builtin.bool.false$}),exp:new Sk.builtin.func(function(a){var b=Math.exp;return Sk.builtin.pyCheckArgsLen(\"exp\",arguments.length,1,1),Sk.builtin.pyCheckType(\"x\",\"number\",Sk.builtin.checkNumber(a)),new Sk.builtin.float_(b(Sk.builtin.asnum$(a)))}),pow:new Sk.builtin.func(function(a,c){return Sk.builtin.pyCheckArgsLen(\"pow\",arguments.length,2,2),Sk.builtin.pyCheckType(\"x\",\"number\",Sk.builtin.checkNumber(a)),Sk.builtin.pyCheckType(\"y\",\"number\",Sk.builtin.checkNumber(c)),new Sk.builtin.float_(b(Sk.builtin.asnum$(a),Sk.builtin.asnum$(c)))}),radians:new Sk.builtin.func(function(a){Sk.builtin.pyCheckArgsLen(\"radians\",arguments.length,1,1),Sk.builtin.pyCheckType(\"deg\",\"number\",Sk.builtin.checkNumber(a));var b=f/180*Sk.builtin.asnum$(a);return new Sk.builtin.float_(b)}),degrees:new Sk.builtin.func(function(a){Sk.builtin.pyCheckArgsLen(\"degrees\",arguments.length,1,1),Sk.builtin.pyCheckType(\"rad\",\"number\",Sk.builtin.checkNumber(a));var b=180/f*Sk.builtin.asnum$(a);return new Sk.builtin.float_(b)}),hypot:new Sk.builtin.func(function(a,b){return Sk.builtin.pyCheckArgsLen(\"hypot\",arguments.length,2,2),Sk.builtin.pyCheckType(\"x\",\"number\",Sk.builtin.checkNumber(a)),Sk.builtin.pyCheckType(\"y\",\"number\",Sk.builtin.checkNumber(b)),a=Sk.builtin.asnum$(a),b=Sk.builtin.asnum$(b),new Sk.builtin.float_(d(a*a+b*b))})},h=18;return g.factorial=new Sk.builtin.func(function(b){function c(a){Sk.builtin.asnum$nofloat(a);return new Sk.builtin.biginteger(a)}Sk.builtin.pyCheckArgsLen(\"factorial\",arguments.length,1,1),Sk.builtin.pyCheckType(\"x\",\"number\",Sk.builtin.checkNumber(b)),b=a(Sk.builtin.asnum$(b));for(var d=1,e=2;e<=b&&e<=h;e++)d*=e;if(b<=h)return new Sk.builtin.int_(d);d=c(d);for(var f,e=h+1;e<=b;e++)f=c(e),d=d.multiply(f);return new Sk.builtin.lng(d)}),g};","src/lib/md5.py":"raise NotImplementedError(\"md5 is not yet implemented in Skulpt\")\n","src/lib/mhlib.py":"raise NotImplementedError(\"mhlib is not yet implemented in Skulpt\")\n","src/lib/mimetools.py":"raise NotImplementedError(\"mimetools is not yet implemented in Skulpt\")\n","src/lib/mimetypes.py":"raise NotImplementedError(\"mimetypes is not yet implemented in Skulpt\")\n","src/lib/mimify.py":"raise NotImplementedError(\"mimify is not yet implemented in Skulpt\")\n","src/lib/modulefinder.py":"raise NotImplementedError(\"modulefinder is not yet implemented in Skulpt\")\n","src/lib/multifile.py":"raise NotImplementedError(\"multifile is not yet implemented in Skulpt\")\n","src/lib/multiprocessing/__init__.py":"raise NotImplementedError(\"multiprocessing is not yet implemented in Skulpt\")\n","src/lib/multiprocessing/dummy/__init__.py":"raise NotImplementedError(\"dummy is not yet implemented in Skulpt\")\n","src/lib/mutex.py":"raise NotImplementedError(\"mutex is not yet implemented in Skulpt\")\n","src/lib/netrc.py":"raise NotImplementedError(\"netrc is not yet implemented in Skulpt\")\n","src/lib/new.py":"raise NotImplementedError(\"new is not yet implemented in Skulpt\")\n","src/lib/nntplib.py":"raise NotImplementedError(\"nntplib is not yet implemented in Skulpt\")\n","src/lib/ntpath.py":"raise NotImplementedError(\"ntpath is not yet implemented in Skulpt\")\n","src/lib/nturl2path.py":"raise NotImplementedError(\"nturl2path is not yet implemented in Skulpt\")\n","src/lib/numbers.py":"Number = (int, float, complex)\nIntegral = int\nComplex = complex\n","src/lib/opcode.py":"raise NotImplementedError(\"opcode is not yet implemented in Skulpt\")\n","src/lib/operator.js":"var $builtinmodule=function(){var a={};return a.lt=new Sk.builtin.func(function(c,a){return Sk.builtin.bool(Sk.misceval.richCompareBool(c,a,\"Lt\"))}),a.__lt__=a.lt,a.le=new Sk.builtin.func(function(c,a){return Sk.builtin.bool(Sk.misceval.richCompareBool(c,a,\"LtE\"))}),a.__le__=a.le,a.eq=new Sk.builtin.func(function(c,a){return Sk.builtin.bool(Sk.misceval.richCompareBool(c,a,\"Eq\"))}),a.__eq__=a.eq,a.ne=new Sk.builtin.func(function(c,a){return Sk.builtin.bool(Sk.misceval.richCompareBool(c,a,\"NotEq\"))}),a.__ne__=a.ne,a.ge=new Sk.builtin.func(function(c,a){return Sk.builtin.bool(Sk.misceval.richCompareBool(c,a,\"GtE\"))}),a.__ge__=a.ge,a.gt=new Sk.builtin.func(function(c,a){return Sk.builtin.bool(Sk.misceval.richCompareBool(c,a,\"Gt\"))}),a.__gt__=a.gt,a.not_=new Sk.builtin.func(function(){throw new Sk.builtin.NotImplementedError(\"operator.not_() is not yet implemented in Skulpt\")}),a.truth=new Sk.builtin.func(function(a){return Sk.builtin.bool(a)}),a.is_=new Sk.builtin.func(function(c,a){return Sk.builtin.bool(Sk.misceval.richCompareBool(c,a,\"Is\"))}),a.is_not=new Sk.builtin.func(function(c,a){return Sk.builtin.bool(Sk.misceval.richCompareBool(c,a,\"IsNot\"))}),a.abs=new Sk.builtin.func(function(a){return Sk.misceval.callsimArray(Sk.builtin.abs,[a])}),a.__abs__=a.abs,a.add=new Sk.builtin.func(function(c,a){return Sk.abstr.objectAdd(c,a)}),a.__add__=a.add,a.and_=new Sk.builtin.func(function(c,a){return Sk.abstr.binary_op_(c,a,\"BitAnd\")}),a.__and__=a.and_,a.div=new Sk.builtin.func(function(c,a){return Sk.abstr.binary_op_(c,a,\"Div\")}),a.__div__=a.div,a.floordiv=new Sk.builtin.func(function(c,a){return Sk.abstr.binary_op_(c,a,\"FloorDiv\")}),a.__floordiv__=a.floordiv,a.index=new Sk.builtin.func(function(b){return new Sk.builtin.int_(Sk.misceval.asIndex(b))}),a.__index__=a.index,a.inv=new Sk.builtin.func(function(a){return Sk.abstr.numberUnaryOp(a,\"Invert\")}),a.__inv__=a.inv,a.invert=a.inv,a.__invert__=a.inv,a.lshift=new Sk.builtin.func(function(c,a){return Sk.abstr.binary_op_(c,a,\"LShift\")}),a.__lshift__=a.lshift,a.mod=new Sk.builtin.func(function(c,a){return Sk.abstr.binary_op_(c,a,\"Mod\")}),a.__mod__=a.mod,a.divmod=new Sk.builtin.func(function(c,a){return Sk.abstr.binary_op_(c,a,\"DivMod\")}),a.__divmod__=a.divmod,a.mul=new Sk.builtin.func(function(c,a){return Sk.abstr.binary_op_(c,a,\"Mult\")}),a.__mul__=a.mul,a.neg=new Sk.builtin.func(function(a){return Sk.abstr.objectNegative(a)}),a.__neg__=a.neg,a.or_=new Sk.builtin.func(function(c,a){return Sk.abstr.binary_op_(c,a,\"BitOr\")}),a.__or__=a.or_,a.pos=new Sk.builtin.func(function(a){return Sk.abstr.objectPositive(a)}),a.__pos__=a.pos,a.pow=new Sk.builtin.func(function(c,a){return Sk.abstr.binary_op_(c,a,\"Pow\")}),a.__pow__=a.pow,a.rshift=new Sk.builtin.func(function(c,a){return Sk.abstr.binary_op_(c,a,\"RShift\")}),a.__rshift__=a.rshift,a.sub=new Sk.builtin.func(function(c,a){return Sk.abstr.binary_op_(c,a,\"Sub\")}),a.__sub__=a.sub,a.truediv=a.div,a.__truediv__=a.div,a.xor=new Sk.builtin.func(function(c,a){return Sk.abstr.binary_op_(c,a,\"BitXor\")}),a.__xor__=a.xor,a.concat=new Sk.builtin.func(function(c,a){return Sk.abstr.sequenceConcat(c,a)}),a.__concat__=a.concat,a.contains=new Sk.builtin.func(function(c,a){return Sk.builtin.bool(Sk.abstr.sequenceContains(c,a))}),a.__contains__=a.contains,a.countOf=new Sk.builtin.func(function(c,a){return Sk.abstr.sequenceGetCountOf(c,a)}),a.delitem=new Sk.builtin.func(function(c,a){return Sk.abstr.sequenceDelItem(c,a)}),a.__delitem__=a.delitem,a.getitem=new Sk.builtin.func(function(c,a){return Sk.abstr.sequenceGetItem(c,a)}),a.__getitem__=a.getitem,a.indexOf=new Sk.builtin.func(function(c,a){return Sk.abstr.sequenceGetIndexOf(c,a)}),a.setitem=new Sk.builtin.func(function(d,a,b){return Sk.abstr.sequenceSetItem(d,a,b)}),a.__setitem__=a.setitem,a};","src/lib/optparse.py":"raise NotImplementedError(\"optparse is not yet implemented in Skulpt\")\n","src/lib/os.py":"r\"\"\"OS routines for Mac, NT, or Posix depending on what system we're on.\n\nThis exports:\n  - all functions from posix, nt, os2, or ce, e.g. unlink, stat, etc.\n  - os.path is one of the modules posixpath, or ntpath\n  - os.name is 'posix', 'nt', 'os2', 'ce' or 'riscos'\n  - os.curdir is a string representing the current directory ('.' or ':')\n  - os.pardir is a string representing the parent directory ('..' or '::')\n  - os.sep is the (or a most common) pathname separator ('/' or ':' or '\\\\')\n  - os.extsep is the extension separator ('.' or '/')\n  - os.altsep is the alternate pathname separator (None or '/')\n  - os.pathsep is the component separator used in $PATH etc\n  - os.linesep is the line separator in text files ('\\r' or '\\n' or '\\r\\n')\n  - os.defpath is the default search path for executables\n  - os.devnull is the file path of the null device ('/dev/null', etc.)\n\nPrograms that import and use 'os' stand a better chance of being\nportable between different platforms.  Of course, they must then\nonly use functions that are defined by all platforms (e.g., unlink\nand opendir), and leave all pathname manipulation to os.path\n(e.g., split and join).\n\"\"\"\n\n#'\n\nimport sys, errno\n\n_names = sys.builtin_module_names\n\n# Note:  more names are added to __all__ later.\n__all__ = [\"altsep\", \"curdir\", \"pardir\", \"sep\", \"extsep\", \"pathsep\", \"linesep\",\n           \"defpath\", \"name\", \"path\", \"devnull\",\n           \"SEEK_SET\", \"SEEK_CUR\", \"SEEK_END\"]\n\ndef _get_exports_list(module):\n    try:\n        return list(module.__all__)\n    except AttributeError:\n        return [n for n in dir(module) if n[0] != '_']\n\nif 'posix' in _names:\n    name = 'posix'\n    linesep = '\\n'\n    from posix import *\n    try:\n        from posix import _exit\n    except ImportError:\n        pass\n    import posixpath as path\n\n    import posix\n    __all__.extend(_get_exports_list(posix))\n    del posix\n\nelif 'nt' in _names:\n    name = 'nt'\n    linesep = '\\r\\n'\n    from nt import *\n    try:\n        from nt import _exit\n    except ImportError:\n        pass\n    import ntpath as path\n\n    import nt\n    __all__.extend(_get_exports_list(nt))\n    del nt\n\nelif 'os2' in _names:\n    name = 'os2'\n    linesep = '\\r\\n'\n    from os2 import *\n    try:\n        from os2 import _exit\n    except ImportError:\n        pass\n    if sys.version.find('EMX GCC') == -1:\n        import ntpath as path\n    else:\n        import os2emxpath as path\n        from _emx_link import link\n\n    import os2\n    __all__.extend(_get_exports_list(os2))\n    del os2\n\nelif 'ce' in _names:\n    name = 'ce'\n    linesep = '\\r\\n'\n    from ce import *\n    try:\n        from ce import _exit\n    except ImportError:\n        pass\n    # We can use the standard Windows path.\n    import ntpath as path\n\n    import ce\n    __all__.extend(_get_exports_list(ce))\n    del ce\n\nelif 'riscos' in _names:\n    name = 'riscos'\n    linesep = '\\n'\n    from riscos import *\n    try:\n        from riscos import _exit\n    except ImportError:\n        pass\n    import riscospath as path\n\n    import riscos\n    __all__.extend(_get_exports_list(riscos))\n    del riscos\n\nelse:\n    raise ImportError, 'no os specific module found'\n\nsys.modules['os.path'] = path\nfrom os.path import (curdir, pardir, sep, pathsep, defpath, extsep, altsep,\n    devnull)\n\ndel _names\n\n# Python uses fixed values for the SEEK_ constants; they are mapped\n# to native constants if necessary in posixmodule.c\nSEEK_SET = 0\nSEEK_CUR = 1\nSEEK_END = 2\n\n#'\n\n# Super directory utilities.\n# (Inspired by Eric Raymond; the doc strings are mostly his)\n\ndef makedirs(name, mode=0777):\n    \"\"\"makedirs(path [, mode=0777])\n\n    Super-mkdir; create a leaf directory and all intermediate ones.\n    Works like mkdir, except that any intermediate path segment (not\n    just the rightmost) will be created if it does not exist.  This is\n    recursive.\n\n    \"\"\"\n    head, tail = path.split(name)\n    if not tail:\n        head, tail = path.split(head)\n    if head and tail and not path.exists(head):\n        try:\n            makedirs(head, mode)\n        except e:\n            # be happy if someone already created the path\n            if e.errno != errno.EEXIST:\n                raise\n        if tail == curdir:           # xxx/newdir/. exists if xxx/newdir exists\n            return\n    mkdir(name, mode)\n\ndef removedirs(name):\n    \"\"\"removedirs(path)\n\n    Super-rmdir; remove a leaf directory and all empty intermediate\n    ones.  Works like rmdir except that, if the leaf directory is\n    successfully removed, directories corresponding to rightmost path\n    segments will be pruned away until either the whole path is\n    consumed or an error occurs.  Errors during this latter phase are\n    ignored -- they generally mean that a directory was not empty.\n\n    \"\"\"\n    rmdir(name)\n    head, tail = path.split(name)\n    if not tail:\n        head, tail = path.split(head)\n    while head and tail:\n        try:\n            rmdir(head)\n        except error:\n            break\n        head, tail = path.split(head)\n\ndef renames(old, new):\n    \"\"\"renames(old, new)\n\n    Super-rename; create directories as necessary and delete any left\n    empty.  Works like rename, except creation of any intermediate\n    directories needed to make the new pathname good is attempted\n    first.  After the rename, directories corresponding to rightmost\n    path segments of the old name will be pruned way until either the\n    whole path is consumed or a nonempty directory is found.\n\n    Note: this function can fail with the new directory structure made\n    if you lack permissions needed to unlink the leaf directory or\n    file.\n\n    \"\"\"\n    head, tail = path.split(new)\n    if head and tail and not path.exists(head):\n        makedirs(head)\n    rename(old, new)\n    head, tail = path.split(old)\n    if head and tail:\n        try:\n            removedirs(head)\n        except error:\n            pass\n\n__all__.extend([\"makedirs\", \"removedirs\", \"renames\"])\n\ndef walk(top, topdown=True, onerror=None, followlinks=False):\n    \"\"\"Directory tree generator.\n\n    For each directory in the directory tree rooted at top (including top\n    itself, but excluding '.' and '..'), yields a 3-tuple\n\n        dirpath, dirnames, filenames\n\n    dirpath is a string, the path to the directory.  dirnames is a list of\n    the names of the subdirectories in dirpath (excluding '.' and '..').\n    filenames is a list of the names of the non-directory files in dirpath.\n    Note that the names in the lists are just names, with no path components.\n    To get a full path (which begins with top) to a file or directory in\n    dirpath, do os.path.join(dirpath, name).\n\n    If optional arg 'topdown' is true or not specified, the triple for a\n    directory is generated before the triples for any of its subdirectories\n    (directories are generated top down).  If topdown is false, the triple\n    for a directory is generated after the triples for all of its\n    subdirectories (directories are generated bottom up).\n\n    When topdown is true, the caller can modify the dirnames list in-place\n    (e.g., via del or slice assignment), and walk will only recurse into the\n    subdirectories whose names remain in dirnames; this can be used to prune\n    the search, or to impose a specific order of visiting.  Modifying\n    dirnames when topdown is false is ineffective, since the directories in\n    dirnames have already been generated by the time dirnames itself is\n    generated.\n\n    By default errors from the os.listdir() call are ignored.  If\n    optional arg 'onerror' is specified, it should be a function; it\n    will be called with one argument, an os.error instance.  It can\n    report the error to continue with the walk, or raise the exception\n    to abort the walk.  Note that the filename is available as the\n    filename attribute of the exception object.\n\n    By default, os.walk does not follow symbolic links to subdirectories on\n    systems that support them.  In order to get this functionality, set the\n    optional argument 'followlinks' to true.\n\n    Caution:  if you pass a relative pathname for top, don't change the\n    current working directory between resumptions of walk.  walk never\n    changes the current directory, and assumes that the client doesn't\n    either.\n\n    Example:\n\n    import os\n    from os.path import join, getsize\n    for root, dirs, files in os.walk('python/Lib/email'):\n        print root, \"consumes\",\n        print sum([getsize(join(root, name)) for name in files]),\n        print \"bytes in\", len(files), \"non-directory files\"\n        if 'CVS' in dirs:\n            dirs.remove('CVS')  # don't visit CVS directories\n    \"\"\"\n\n    islink, join, isdir = path.islink, path.join, path.isdir\n\n    # We may not have read permission for top, in which case we can't\n    # get a list of the files the directory contains.  os.path.walk\n    # always suppressed the exception then, rather than blow up for a\n    # minor reason when (say) a thousand readable directories are still\n    # left to visit.  That logic is copied here.\n    try:\n        # Note that listdir and error are globals in this module due\n        # to earlier import-*.\n        names = listdir(top)\n    except error, err:\n        if onerror is not None:\n            onerror(err)\n        return\n\n    dirs, nondirs = [], []\n    for name in names:\n        if isdir(join(top, name)):\n            dirs.append(name)\n        else:\n            nondirs.append(name)\n\n    if topdown:\n        yield top, dirs, nondirs\n    for name in dirs:\n        new_path = join(top, name)\n        if followlinks or not islink(new_path):\n            for x in walk(new_path, topdown, onerror, followlinks):\n                yield x\n    if not topdown:\n        yield top, dirs, nondirs\n\n__all__.append(\"walk\")\n\n# Make sure os.environ exists, at least\ntry:\n    environ\nexcept NameError:\n    environ = {}\n\ndef execl(file, *args):\n    \"\"\"execl(file, *args)\n\n    Execute the executable file with argument list args, replacing the\n    current process. \"\"\"\n    execv(file, args)\n\ndef execle(file, *args):\n    \"\"\"execle(file, *args, env)\n\n    Execute the executable file with argument list args and\n    environment env, replacing the current process. \"\"\"\n    env = args[-1]\n    execve(file, args[:-1], env)\n\ndef execlp(file, *args):\n    \"\"\"execlp(file, *args)\n\n    Execute the executable file (which is searched for along $PATH)\n    with argument list args, replacing the current process. \"\"\"\n    execvp(file, args)\n\ndef execlpe(file, *args):\n    \"\"\"execlpe(file, *args, env)\n\n    Execute the executable file (which is searched for along $PATH)\n    with argument list args and environment env, replacing the current\n    process. \"\"\"\n    env = args[-1]\n    execvpe(file, args[:-1], env)\n\ndef execvp(file, args):\n    \"\"\"execvp(file, args)\n\n    Execute the executable file (which is searched for along $PATH)\n    with argument list args, replacing the current process.\n    args may be a list or tuple of strings. \"\"\"\n    _execvpe(file, args)\n\ndef execvpe(file, args, env):\n    \"\"\"execvpe(file, args, env)\n\n    Execute the executable file (which is searched for along $PATH)\n    with argument list args and environment env , replacing the\n    current process.\n    args may be a list or tuple of strings. \"\"\"\n    _execvpe(file, args, env)\n\n__all__.extend([\"execl\",\"execle\",\"execlp\",\"execlpe\",\"execvp\",\"execvpe\"])\n\ndef _execvpe(file, args, env=None):\n    if env is not None:\n        func = execve\n        argrest = (args, env)\n    else:\n        func = execv\n        argrest = (args,)\n        env = environ\n\n    head, tail = path.split(file)\n    if head:\n        func(file, *argrest)\n        return\n    if 'PATH' in env:\n        envpath = env['PATH']\n    else:\n        envpath = defpath\n    PATH = envpath.split(pathsep)\n    saved_exc = None\n    saved_tb = None\n    for dir in PATH:\n        fullname = path.join(dir, file)\n        try:\n            func(fullname, *argrest)\n        except error, e:\n            tb = sys.exc_info()[2]\n            if (e.errno != errno.ENOENT and e.errno != errno.ENOTDIR\n                and saved_exc is None):\n                saved_exc = e\n                saved_tb = tb\n    if saved_exc:\n        raise error, saved_exc, saved_tb\n    raise error, e, tb\n\n# Change environ to automatically call putenv() if it exists\ntry:\n    # This will fail if there's no putenv\n    putenv\nexcept NameError:\n    pass\nelse:\n    import UserDict\n\n    # Fake unsetenv() for Windows\n    # not sure about os2 here but\n    # I'm guessing they are the same.\n\n    if name in ('os2', 'nt'):\n        def unsetenv(key):\n            putenv(key, \"\")\n\n    if name == \"riscos\":\n        # On RISC OS, all env access goes through getenv and putenv\n        from riscosenviron import _Environ\n    elif name in ('os2', 'nt'):  # Where Env Var Names Must Be UPPERCASE\n        # But we store them as upper case\n        class _Environ(UserDict.IterableUserDict):\n            def __init__(self, environ):\n                UserDict.UserDict.__init__(self)\n                data = self.data\n                for k, v in environ.items():\n                    data[k.upper()] = v\n            def __setitem__(self, key, item):\n                putenv(key, item)\n                self.data[key.upper()] = item\n            def __getitem__(self, key):\n                return self.data[key.upper()]\n            try:\n                unsetenv\n            except NameError:\n                def __delitem__(self, key):\n                    del self.data[key.upper()]\n            else:\n                def __delitem__(self, key):\n                    unsetenv(key)\n                    del self.data[key.upper()]\n                def clear(self):\n                    for key in self.data.keys():\n                        unsetenv(key)\n                        del self.data[key]\n                def pop(self, key, *args):\n                    unsetenv(key)\n                    return self.data.pop(key.upper(), *args)\n            def has_key(self, key):\n                return key.upper() in self.data\n            def __contains__(self, key):\n                return key.upper() in self.data\n            def get(self, key, failobj=None):\n                return self.data.get(key.upper(), failobj)\n            def update(self, dict=None, **kwargs):\n                if dict:\n                    try:\n                        keys = dict.keys()\n                    except AttributeError:\n                        # List of (key, value)\n                        for k, v in dict:\n                            self[k] = v\n                    else:\n                        # got keys\n                        # cannot use items(), since mappings\n                        # may not have them.\n                        for k in keys:\n                            self[k] = dict[k]\n                if kwargs:\n                    self.update(kwargs)\n            def copy(self):\n                return dict(self)\n\n    else:  # Where Env Var Names Can Be Mixed Case\n        class _Environ(UserDict.IterableUserDict):\n            def __init__(self, environ):\n                UserDict.UserDict.__init__(self)\n                self.data = environ\n            def __setitem__(self, key, item):\n                putenv(key, item)\n                self.data[key] = item\n            def update(self,  dict=None, **kwargs):\n                if dict:\n                    try:\n                        keys = dict.keys()\n                    except AttributeError:\n                        # List of (key, value)\n                        for k, v in dict:\n                            self[k] = v\n                    else:\n                        # got keys\n                        # cannot use items(), since mappings\n                        # may not have them.\n                        for k in keys:\n                            self[k] = dict[k]\n                if kwargs:\n                    self.update(kwargs)\n            try:\n                unsetenv\n            except NameError:\n                pass\n            else:\n                def __delitem__(self, key):\n                    unsetenv(key)\n                    del self.data[key]\n                def clear(self):\n                    for key in self.data.keys():\n                        unsetenv(key)\n                        del self.data[key]\n                def pop(self, key, *args):\n                    unsetenv(key)\n                    return self.data.pop(key, *args)\n            def copy(self):\n                return dict(self)\n\n\n    environ = _Environ(environ)\n\ndef getenv(key, default=None):\n    \"\"\"Get an environment variable, return None if it doesn't exist.\n    The optional second argument can specify an alternate default.\"\"\"\n    return environ.get(key, default)\n__all__.append(\"getenv\")\n\ndef _exists(name):\n    return name in globals()\n\n# Supply spawn*() (probably only for Unix)\nif _exists(\"fork\") and not _exists(\"spawnv\") and _exists(\"execv\"):\n\n    P_WAIT = 0\n    P_NOWAIT = P_NOWAITO = 1\n\n    # XXX Should we support P_DETACH?  I suppose it could fork()**2\n    # and close the std I/O streams.  Also, P_OVERLAY is the same\n    # as execv*()?\n\n    def _spawnvef(mode, file, args, env, func):\n        # Internal helper; func is the exec*() function to use\n        pid = fork()\n        if not pid:\n            # Child\n            try:\n                if env is None:\n                    func(file, args)\n                else:\n                    func(file, args, env)\n            except:\n                _exit(127)\n        else:\n            # Parent\n            if mode == P_NOWAIT:\n                return pid # Caller is responsible for waiting!\n            while 1:\n                wpid, sts = waitpid(pid, 0)\n                if WIFSTOPPED(sts):\n                    continue\n                elif WIFSIGNALED(sts):\n                    return -WTERMSIG(sts)\n                elif WIFEXITED(sts):\n                    return WEXITSTATUS(sts)\n                else:\n                    raise error, \"Not stopped, signaled or exited???\"\n\n    def spawnv(mode, file, args):\n        \"\"\"spawnv(mode, file, args) -> integer\n\nExecute file with arguments from args in a subprocess.\nIf mode == P_NOWAIT return the pid of the process.\nIf mode == P_WAIT return the process's exit code if it exits normally;\notherwise return -SIG, where SIG is the signal that killed it. \"\"\"\n        return _spawnvef(mode, file, args, None, execv)\n\n    def spawnve(mode, file, args, env):\n        \"\"\"spawnve(mode, file, args, env) -> integer\n\nExecute file with arguments from args in a subprocess with the\nspecified environment.\nIf mode == P_NOWAIT return the pid of the process.\nIf mode == P_WAIT return the process's exit code if it exits normally;\notherwise return -SIG, where SIG is the signal that killed it. \"\"\"\n        return _spawnvef(mode, file, args, env, execve)\n\n    # Note: spawnvp[e] is't currently supported on Windows\n\n    def spawnvp(mode, file, args):\n        \"\"\"spawnvp(mode, file, args) -> integer\n\nExecute file (which is looked for along $PATH) with arguments from\nargs in a subprocess.\nIf mode == P_NOWAIT return the pid of the process.\nIf mode == P_WAIT return the process's exit code if it exits normally;\notherwise return -SIG, where SIG is the signal that killed it. \"\"\"\n        return _spawnvef(mode, file, args, None, execvp)\n\n    def spawnvpe(mode, file, args, env):\n        \"\"\"spawnvpe(mode, file, args, env) -> integer\n\nExecute file (which is looked for along $PATH) with arguments from\nargs in a subprocess with the supplied environment.\nIf mode == P_NOWAIT return the pid of the process.\nIf mode == P_WAIT return the process's exit code if it exits normally;\notherwise return -SIG, where SIG is the signal that killed it. \"\"\"\n        return _spawnvef(mode, file, args, env, execvpe)\n\nif _exists(\"spawnv\"):\n    # These aren't supplied by the basic Windows code\n    # but can be easily implemented in Python\n\n    def spawnl(mode, file, *args):\n        \"\"\"spawnl(mode, file, *args) -> integer\n\nExecute file with arguments from args in a subprocess.\nIf mode == P_NOWAIT return the pid of the process.\nIf mode == P_WAIT return the process's exit code if it exits normally;\notherwise return -SIG, where SIG is the signal that killed it. \"\"\"\n        return spawnv(mode, file, args)\n\n    def spawnle(mode, file, *args):\n        \"\"\"spawnle(mode, file, *args, env) -> integer\n\nExecute file with arguments from args in a subprocess with the\nsupplied environment.\nIf mode == P_NOWAIT return the pid of the process.\nIf mode == P_WAIT return the process's exit code if it exits normally;\notherwise return -SIG, where SIG is the signal that killed it. \"\"\"\n        env = args[-1]\n        return spawnve(mode, file, args[:-1], env)\n\n\n    __all__.extend([\"spawnv\", \"spawnve\", \"spawnl\", \"spawnle\",])\n\n\nif _exists(\"spawnvp\"):\n    # At the moment, Windows doesn't implement spawnvp[e],\n    # so it won't have spawnlp[e] either.\n    def spawnlp(mode, file, *args):\n        \"\"\"spawnlp(mode, file, *args) -> integer\n\nExecute file (which is looked for along $PATH) with arguments from\nargs in a subprocess with the supplied environment.\nIf mode == P_NOWAIT return the pid of the process.\nIf mode == P_WAIT return the process's exit code if it exits normally;\notherwise return -SIG, where SIG is the signal that killed it. \"\"\"\n        return spawnvp(mode, file, args)\n\n    def spawnlpe(mode, file, *args):\n        \"\"\"spawnlpe(mode, file, *args, env) -> integer\n\nExecute file (which is looked for along $PATH) with arguments from\nargs in a subprocess with the supplied environment.\nIf mode == P_NOWAIT return the pid of the process.\nIf mode == P_WAIT return the process's exit code if it exits normally;\notherwise return -SIG, where SIG is the signal that killed it. \"\"\"\n        env = args[-1]\n        return spawnvpe(mode, file, args[:-1], env)\n\n\n    __all__.extend([\"spawnvp\", \"spawnvpe\", \"spawnlp\", \"spawnlpe\",])\n\n\n# Supply popen2 etc. (for Unix)\nif _exists(\"fork\"):\n    if not _exists(\"popen2\"):\n        def popen2(cmd, mode=\"t\", bufsize=-1):\n            \"\"\"Execute the shell command 'cmd' in a sub-process.  On UNIX, 'cmd'\n            may be a sequence, in which case arguments will be passed directly to\n            the program without shell intervention (as with os.spawnv()).  If 'cmd'\n            is a string it will be passed to the shell (as with os.system()). If\n            'bufsize' is specified, it sets the buffer size for the I/O pipes.  The\n            file objects (child_stdin, child_stdout) are returned.\"\"\"\n            import warnings\n            msg = \"os.popen2 is deprecated.  Use the subprocess module.\"\n            warnings.warn(msg, DeprecationWarning, stacklevel=2)\n\n            import subprocess\n            PIPE = subprocess.PIPE\n            p = subprocess.Popen(cmd, shell=isinstance(cmd, basestring),\n                                 bufsize=bufsize, stdin=PIPE, stdout=PIPE,\n                                 close_fds=True)\n            return p.stdin, p.stdout\n        __all__.append(\"popen2\")\n\n    if not _exists(\"popen3\"):\n        def popen3(cmd, mode=\"t\", bufsize=-1):\n            \"\"\"Execute the shell command 'cmd' in a sub-process.  On UNIX, 'cmd'\n            may be a sequence, in which case arguments will be passed directly to\n            the program without shell intervention (as with os.spawnv()).  If 'cmd'\n            is a string it will be passed to the shell (as with os.system()). If\n            'bufsize' is specified, it sets the buffer size for the I/O pipes.  The\n            file objects (child_stdin, child_stdout, child_stderr) are returned.\"\"\"\n            import warnings\n            msg = \"os.popen3 is deprecated.  Use the subprocess module.\"\n            warnings.warn(msg, DeprecationWarning, stacklevel=2)\n\n            import subprocess\n            PIPE = subprocess.PIPE\n            p = subprocess.Popen(cmd, shell=isinstance(cmd, basestring),\n                                 bufsize=bufsize, stdin=PIPE, stdout=PIPE,\n                                 stderr=PIPE, close_fds=True)\n            return p.stdin, p.stdout, p.stderr\n        __all__.append(\"popen3\")\n\n    if not _exists(\"popen4\"):\n        def popen4(cmd, mode=\"t\", bufsize=-1):\n            \"\"\"Execute the shell command 'cmd' in a sub-process.  On UNIX, 'cmd'\n            may be a sequence, in which case arguments will be passed directly to\n            the program without shell intervention (as with os.spawnv()).  If 'cmd'\n            is a string it will be passed to the shell (as with os.system()). If\n            'bufsize' is specified, it sets the buffer size for the I/O pipes.  The\n            file objects (child_stdin, child_stdout_stderr) are returned.\"\"\"\n            import warnings\n            msg = \"os.popen4 is deprecated.  Use the subprocess module.\"\n            warnings.warn(msg, DeprecationWarning, stacklevel=2)\n\n            import subprocess\n            PIPE = subprocess.PIPE\n            p = subprocess.Popen(cmd, shell=isinstance(cmd, basestring),\n                                 bufsize=bufsize, stdin=PIPE, stdout=PIPE,\n                                 stderr=subprocess.STDOUT, close_fds=True)\n            return p.stdin, p.stdout\n        __all__.append(\"popen4\")\n\nimport copy_reg as _copy_reg\n\ndef _make_stat_result(tup, dict):\n    return stat_result(tup, dict)\n\ndef _pickle_stat_result(sr):\n    (type, args) = sr.__reduce__()\n    return (_make_stat_result, args)\n\ntry:\n    _copy_reg.pickle(stat_result, _pickle_stat_result, _make_stat_result)\nexcept NameError: # stat_result may not exist\n    pass\n\ndef _make_statvfs_result(tup, dict):\n    return statvfs_result(tup, dict)\n\ndef _pickle_statvfs_result(sr):\n    (type, args) = sr.__reduce__()\n    return (_make_statvfs_result, args)\n\ntry:\n    _copy_reg.pickle(statvfs_result, _pickle_statvfs_result,\n                     _make_statvfs_result)\nexcept NameError: # statvfs_result may not exist\n    pass\n\nif not _exists(\"urandom\"):\n    def urandom(n):\n        \"\"\"urandom(n) -> str\n\n        Return a string of n random bytes suitable for cryptographic use.\n\n        \"\"\"\n        try:\n            _urandomfd = open(\"/dev/urandom\", O_RDONLY)\n        except (IOError):\n            raise NotImplementedError(\"/dev/urandom (or equivalent) not found\")\n        try:\n            bs = b\"\"\n            while n > len(bs):\n                bs += read(_urandomfd, n - len(bs))\n        finally:\n            close(_urandomfd)\n        return bs","src/lib/os2emxpath.py":"raise NotImplementedError(\"os2emxpath is not yet implemented in Skulpt\")\n","src/lib/pdb.py":"raise NotImplementedError(\"pdb is not yet implemented in Skulpt\")\n","src/lib/pickle.py":"raise NotImplementedError(\"pickle is not yet implemented in Skulpt\")\n","src/lib/pickletools.py":"raise NotImplementedError(\"pickletools is not yet implemented in Skulpt\")\n","src/lib/pipes.py":"raise NotImplementedError(\"pipes is not yet implemented in Skulpt\")\n","src/lib/pkgutil.py":"raise NotImplementedError(\"pkgutil is not yet implemented in Skulpt\")\n","src/lib/platform.js":"var $builtinmodule=function(){var a={},b=\"undefined\"!=typeof window&&\"undefined\"!=typeof window.navigator;return a.python_implementation=new Sk.builtin.func(function(){return Sk.builtin.pyCheckArgsLen(\"python_implementation\",arguments.length,0,0),new Sk.builtin.str(\"Skulpt\")}),a.node=new Sk.builtin.func(function(){return Sk.builtin.pyCheckArgsLen(\"node\",arguments.length,0,0),new Sk.builtin.str(\"\")}),a.version=new Sk.builtin.func(function(){return Sk.builtin.pyCheckArgsLen(\"version\",arguments.length,0,0),new Sk.builtin.str(\"\")}),a.python_version=new Sk.builtin.func(function(){var a;return Sk.builtin.pyCheckArgsLen(\"python_version\",arguments.length,0,0),a=Sk.__future__.python_version?\"3.2.0\":\"2.7.0\",new Sk.builtin.str(a)}),a.system=new Sk.builtin.func(function(){var a;return Sk.builtin.pyCheckArgsLen(\"system\",arguments.length,0,0),a=b?window.navigator.appCodeName:\"\",new Sk.builtin.str(a)}),a.machine=new Sk.builtin.func(function(){var a;return Sk.builtin.pyCheckArgsLen(\"machine\",arguments.length,0,0),a=b?window.navigator.platform:\"\",new Sk.builtin.str(a)}),a.release=new Sk.builtin.func(function(){var a;return Sk.builtin.pyCheckArgsLen(\"release\",arguments.length,0,0),a=b?window.navigator.appVersion:\"\",new Sk.builtin.str(a)}),a.architecture=new Sk.builtin.func(function(){return Sk.builtin.pyCheckArgsLen(\"architecture\",arguments.length,0,0),new Sk.builtin.tuple([new Sk.builtin.str(\"64bit\"),new Sk.builtin.str(\"\")])}),a.processor=new Sk.builtin.func(function(){return Sk.builtin.pyCheckArgsLen(\"processor\",arguments.length,0,0),new Sk.builtin.str(\"\")}),a};","src/lib/platform.py":"raise NotImplementedError(\"platform is not yet implemented in Skulpt\")\n","src/lib/plistlib.py":"raise NotImplementedError(\"plistlib is not yet implemented in Skulpt\")\n","src/lib/popen2.py":"raise NotImplementedError(\"popen2 is not yet implemented in Skulpt\")\n","src/lib/poplib.py":"raise NotImplementedError(\"poplib is not yet implemented in Skulpt\")\n","src/lib/posix.py":"\"\"\"This module provides access to operating system functionality that is\nstandardized by the C Standard and the POSIX standard (a thinly\ndisguised Unix interface).  Refer to the library manual and\ncorresponding Unix manual entries for more information on calls.\"\"\"\n\nfrom browser import window\n\ndef _randint(a, b):\n    return int(window.Math.random()*(b-a+1)+a)\n    \nF_OK = 0\n\nO_APPEND = 8\n\nO_BINARY = 32768\n\nO_CREAT = 256\n\nO_EXCL = 1024\n\nO_NOINHERIT = 128\n\nO_RANDOM = 16\n\nO_RDONLY = 0\n\nO_RDWR = 2\n\nO_SEQUENTIAL = 32\n\nO_SHORT_LIVED = 4096\n\nO_TEMPORARY = 64\n\nO_TEXT = 16384\n\nO_TRUNC = 512\n\nO_WRONLY = 1\n\nP_DETACH = 4\n\nP_NOWAIT = 1\n\nP_NOWAITO = 3\n\nP_OVERLAY = 2\n\nP_WAIT = 0\n\nR_OK = 4\n\nTMP_MAX = 32767\n\nW_OK = 2\n\nX_OK = 1\n\nclass __loader__:\n    pass\n\ndef _exit(*args,**kw):\n    \"\"\"_exit(status)    \n    Exit to the system with specified status, without normal exit processing.\"\"\"\n    pass\n\ndef _getdiskusage(*args,**kw):\n    \"\"\"_getdiskusage(path) -> (total, free)    \n    Return disk usage statistics about the given path as (total, free) tuple.\"\"\"\n    pass\n\ndef _getfileinformation(*args,**kw):\n    pass\n\ndef _getfinalpathname(*args,**kw):\n    pass\n\ndef _getfullpathname(*args,**kw):\n    pass\n\n_have_functions = ['MS_WINDOWS']\n\ndef _isdir(*args,**kw):\n    \"\"\"Return true if the pathname refers to an existing directory.\"\"\"\n    pass\n\ndef abort(*args,**kw):\n    \"\"\"abort() -> does not return!    \n    Abort the interpreter immediately.  This 'dumps core' or otherwise fails\n    in the hardest way possible on the hosting operating system.\"\"\"\n    pass\n\ndef access(*args,**kw):\n    \"\"\"access(path, mode, *, dir_fd=None, effective_ids=False, follow_symlinks=True)    \n    Use the real uid/gid to test for access to a path.  Returns True if granted,\n    False otherwise.\n    \n    If dir_fd is not None, it should be a file descriptor open to a directory,\n      and path should be relative; path will then be relative to that directory.\n    If effective_ids is True, access will use the effective uid/gid instead of\n      the real uid/gid.\n    If follow_symlinks is False, and the last element of the path is a symbolic\n      link, access will examine the symbolic link itself instead of the file the\n      link points to.\n    dir_fd, effective_ids, and follow_symlinks may not be implemented\n      on your platform.  If they are unavailable, using them will raise a\n      NotImplementedError.\n    \n    Note that most operations will use the effective uid/gid, therefore this\n      routine can be used in a suid/sgid environment to test if the invoking user\n      has the specified access to the path.\n    The mode argument can be F_OK to test existence, or the inclusive-OR\n      of R_OK, W_OK, and X_OK.\"\"\"\n    pass\n\ndef chdir(*args,**kw):\n    \"\"\"chdir(path)    \n    Change the current working directory to the specified path.\n    \n    path may always be specified as a string.\n    On some platforms, path may also be specified as an open file descriptor.\n      If this functionality is unavailable, using it raises an exception.\"\"\"\n    pass\n\ndef chmod(*args,**kw):\n    \"\"\"chmod(path, mode, *, dir_fd=None, follow_symlinks=True)    \n    Change the access permissions of a file.\n    \n    path may always be specified as a string.\n    On some platforms, path may also be specified as an open file descriptor.\n      If this functionality is unavailable, using it raises an exception.\n    If dir_fd is not None, it should be a file descriptor open to a directory,\n      and path should be relative; path will then be relative to that directory.\n    If follow_symlinks is False, and the last element of the path is a symbolic\n      link, chmod will modify the symbolic link itself instead of the file the\n      link points to.\n    It is an error to use dir_fd or follow_symlinks when specifying path as\n      an open file descriptor.\n    dir_fd and follow_symlinks may not be implemented on your platform.\n      If they are unavailable, using them will raise a NotImplementedError.\"\"\"\n    pass\n\ndef close(*args,**kw):\n    \"\"\"close(fd)    \n    Close a file descriptor (for low level IO).\"\"\"\n    pass\n\ndef closerange(*args,**kw):\n    \"\"\"closerange(fd_low, fd_high)    \n    Closes all file descriptors in [fd_low, fd_high), ignoring errors.\"\"\"\n    pass\n\ndef device_encoding(*args,**kw):\n    \"\"\"device_encoding(fd) -> str    \n    Return a string describing the encoding of the device\n    if the output is a terminal; else return None.\"\"\"\n    pass\n\ndef dup(*args,**kw):\n    \"\"\"dup(fd) -> fd2    \n    Return a duplicate of a file descriptor.\"\"\"\n    pass\n\ndef dup2(*args,**kw):\n    \"\"\"dup2(old_fd, new_fd)    \n    Duplicate file descriptor.\"\"\"\n    pass\n\nenviron = {'PYTHONUSERBASE': ' '}\n\nerror = OSError\n\ndef execv(*args,**kw):\n    \"\"\"execv(path, args)    \n    Execute an executable path with arguments, replacing current process.\n    \n        path: path of executable file\n        args: tuple or list of strings\"\"\"\n    pass\n\ndef execve(*args,**kw):\n    \"\"\"execve(path, args, env)    \n    Execute a path with arguments and environment, replacing current process.\n    \n        path: path of executable file\n        args: tuple or list of arguments\n        env: dictionary of strings mapping to strings\n    \n    On some platforms, you may specify an open file descriptor for path;\n      execve will execute the program the file descriptor is open to.\n      If this functionality is unavailable, using it raises NotImplementedError.\"\"\"\n    pass\n\ndef fstat(*args,**kw):\n    \"\"\"fstat(fd) -> stat result    \n    Like stat(), but for an open file descriptor.\n    Equivalent to stat(fd=fd).\"\"\"\n    pass\n\ndef fsync(*args,**kw):\n    \"\"\"fsync(fildes)    \n    force write of file with filedescriptor to disk.\"\"\"\n    pass\n\ndef get_terminal_size(*args,**kw):\n    \"\"\"Return the size of the terminal window as (columns, lines).    \n    The optional argument fd (default standard output) specifies\n    which file descriptor should be queried.\n    \n    If the file descriptor is not connected to a terminal, an OSError\n    is thrown.\n    \n    This function will only be defined if an implementation is\n    available for this system.\n    \n    shutil.get_terminal_size is the high-level function which should \n    normally be used, os.get_terminal_size is the low-level implementation.\"\"\"\n    pass\n\ndef getcwd(*args,**kw):\n    \"\"\"getcwd() -> path    \n    Return a unicode string representing the current working directory.\"\"\"\n    return __BRYTHON__.brython_path # XXX fix me\n\ndef getcwdb(*args,**kw):\n    \"\"\"getcwdb() -> path    \n    Return a bytes string representing the current working directory.\"\"\"\n    pass\n\ndef getlogin(*args,**kw):\n    \"\"\"getlogin() -> string    \n    Return the actual login name.\"\"\"\n    pass\n\ndef getpid(*args,**kw):\n    \"\"\"getpid() -> pid    \n    Return the current process id\"\"\"\n    return 0\n\ndef getppid(*args,**kw):\n    \"\"\"getppid() -> ppid    \n    Return the parent's process id.  If the parent process has already exited,\n    Windows machines will still return its id; others systems will return the id\n    of the 'init' process (1).\"\"\"\n    pass\n\ndef isatty(*args,**kw):\n    \"\"\"isatty(fd) -> bool    \n    Return True if the file descriptor 'fd' is an open file descriptor\n    connected to the slave end of a terminal.\"\"\"\n    pass\n\ndef kill(*args,**kw):\n    \"\"\"kill(pid, sig)    \n    Kill a process with a signal.\"\"\"\n    pass\n\ndef link(*args,**kw):\n    \"\"\"link(src, dst, *, src_dir_fd=None, dst_dir_fd=None, follow_symlinks=True)    \n    Create a hard link to a file.\n    \n    If either src_dir_fd or dst_dir_fd is not None, it should be a file\n      descriptor open to a directory, and the respective path string (src or dst)\n      should be relative; the path will then be relative to that directory.\n    If follow_symlinks is False, and the last element of src is a symbolic\n      link, link will create a link to the symbolic link itself instead of the\n      file the link points to.\n    src_dir_fd, dst_dir_fd, and follow_symlinks may not be implemented on your\n      platform.  If they are unavailable, using them will raise a\n      NotImplementedError.\"\"\"\n    pass\n\ndef listdir(*args,**kw):\n    \"\"\"listdir(path='.') -> list_of_filenames    \n    Return a list containing the names of the files in the directory.\n    The list is in arbitrary order.  It does not include the special\n    entries '.' and '..' even if they are present in the directory.\n    \n    path can be specified as either str or bytes.  If path is bytes,\n      the filenames returned will also be bytes; in all other circumstances\n      the filenames returned will be str.\n    On some platforms, path may also be specified as an open file descriptor;\n      the file descriptor must refer to a directory.\n      If this functionality is unavailable, using it raises NotImplementedError.\"\"\"\n    raise NotImplementedError(\"browser can't list files in a directory\")\n\ndef lseek(*args,**kw):\n    \"\"\"lseek(fd, pos, how) -> newpos    \n    Set the current position of a file descriptor.\n    Return the new cursor position in bytes, starting from the beginning.\"\"\"\n    pass\n\ndef lstat(*args,**kw):\n    \"\"\"lstat(path, *, dir_fd=None) -> stat result    \n    Like stat(), but do not follow symbolic links.\n    Equivalent to stat(path, follow_symlinks=False).\"\"\"\n    return stat_result()\n\ndef mkdir(*args,**kw):\n    \"\"\"mkdir(path, mode=0o777, *, dir_fd=None)    \n    Create a directory.\n    \n    If dir_fd is not None, it should be a file descriptor open to a directory,\n      and path should be relative; path will then be relative to that directory.\n    dir_fd may not be implemented on your platform.\n      If it is unavailable, using it will raise a NotImplementedError.\n    \n    The mode argument is ignored on Windows.\"\"\"\n    pass\n\ndef open(path, flags, mode=0o777, *args, dir_fd=None):\n    \"\"\"open(path, flags, mode=0o777, *, dir_fd=None)    \n    Open a file for low level IO.  Returns a file handle (integer).\n    \n    If dir_fd is not None, it should be a file descriptor open to a directory,\n      and path should be relative; path will then be relative to that directory.\n    dir_fd may not be implemented on your platform.\n      If it is unavailable, using it will raise a NotImplementedError.\"\"\"\n    \n    ## lets assume this is reading/writing to a local storage in the browser\n    from browser.local_storage import storage\n    \n    class mystorage:\n      def __init__(self, path, flags):\n          self._path=path\n          self._pos=0\n          self._flags=flags\n\n          if self._flags & O_RDONLY == O_RDONLY:\n             self._data=storage.get(self._path, None)\n             if self._data is None:\n                raise FileNotFoundError(\"%s not found\" % self._path)\n          elif self._flags & O_WRONLY == O_WRONLY:\n             storage[self._path]=''\n\n      def seek(self, pos):\n          self._pos=pos\n\n      def read(self, size=None):\n          if size is None:\n             _result=self._data[self._pos:]\n             self._pos=len(self._data)\n             return _result\n\n          assert size <= len(self._data) - self._pos\n          _result=self._data[self._pos: self._pos+size]\n          self._pos+=size\n          return _result\n\n      def write(self, data):\n          storage[self._path]+=str(data)\n\n      def close(self):\n          pass\n\n    return mystorage(path, flags)\n\ndef pipe(*args,**kw):\n    \"\"\"pipe() -> (read_end, write_end)    \n    Create a pipe.\"\"\"\n    pass\n\ndef putenv(*args,**kw):\n    \"\"\"putenv(key, value)    \n    Change or add an environment variable.\"\"\"\n    pass\n\ndef read(*args,**kw):\n    \"\"\"read(fd, buffersize) -> string    \n    Read a file descriptor.\"\"\"\n    pass\n\ndef readlink(*args,**kw):\n    \"\"\"readlink(path, *, dir_fd=None) -> path    \n    Return a string representing the path to which the symbolic link points.\n    \n    If dir_fd is not None, it should be a file descriptor open to a directory,\n      and path should be relative; path will then be relative to that directory.\n    dir_fd may not be implemented on your platform.\n      If it is unavailable, using it will raise a NotImplementedError.\"\"\"\n    pass\n\ndef remove(*args,**kw):\n    \"\"\"remove(path, *, dir_fd=None)    \n    Remove a file (same as unlink()).\n    \n    If dir_fd is not None, it should be a file descriptor open to a directory,\n      and path should be relative; path will then be relative to that directory.\n    dir_fd may not be implemented on your platform.\n      If it is unavailable, using it will raise a NotImplementedError.\"\"\"\n    pass\n\ndef rename(*args,**kw):\n    \"\"\"rename(src, dst, *, src_dir_fd=None, dst_dir_fd=None)    \n    Rename a file or directory.\n    \n    If either src_dir_fd or dst_dir_fd is not None, it should be a file\n      descriptor open to a directory, and the respective path string (src or dst)\n      should be relative; the path will then be relative to that directory.\n    src_dir_fd and dst_dir_fd, may not be implemented on your platform.\n      If they are unavailable, using them will raise a NotImplementedError.\"\"\"\n    pass\n\ndef replace(*args,**kw):\n    \"\"\"replace(src, dst, *, src_dir_fd=None, dst_dir_fd=None)    \n    Rename a file or directory, overwriting the destination.\n    \n    If either src_dir_fd or dst_dir_fd is not None, it should be a file\n      descriptor open to a directory, and the respective path string (src or dst)\n      should be relative; the path will then be relative to that directory.\n    src_dir_fd and dst_dir_fd, may not be implemented on your platform.\n      If they are unavailable, using them will raise a NotImplementedError.\"\"\"\n    pass\n\ndef rmdir(*args,**kw):\n    \"\"\"rmdir(path, *, dir_fd=None)    \n    Remove a directory.\n    \n    If dir_fd is not None, it should be a file descriptor open to a directory,\n      and path should be relative; path will then be relative to that directory.\n    dir_fd may not be implemented on your platform.\n      If it is unavailable, using it will raise a NotImplementedError.\"\"\"\n    pass\n\ndef spawnv(*args,**kw):\n    \"\"\"spawnv(mode, path, args)    \n    Execute the program 'path' in a new process.\n    \n        mode: mode of process creation\n        path: path of executable file\n        args: tuple or list of strings\"\"\"\n    pass\n\ndef spawnve(*args,**kw):\n    \"\"\"spawnve(mode, path, args, env)    \n    Execute the program 'path' in a new process.\n    \n        mode: mode of process creation\n        path: path of executable file\n        args: tuple or list of arguments\n        env: dictionary of strings mapping to strings\"\"\"\n    pass\n\ndef startfile(*args,**kw):\n    \"\"\"startfile(filepath [, operation]) - Start a file with its associated    application.\n    \n    When \"operation\" is not specified or \"open\", this acts like\n    double-clicking the file in Explorer, or giving the file name as an\n    argument to the DOS \"start\" command: the file is opened with whatever\n    application (if any) its extension is associated.\n    When another \"operation\" is given, it specifies what should be done with\n    the file.  A typical operation is \"print\".\n    \n    startfile returns as soon as the associated application is launched.\n    There is no option to wait for the application to close, and no way\n    to retrieve the application's exit status.\n    \n    The filepath is relative to the current directory.  If you want to use\n    an absolute path, make sure the first character is not a slash (\"/\");\n    the underlying Win32 ShellExecute function doesn't work if it is.\"\"\"\n    pass\n\ndef stat(*args,**kw):\n    \"\"\"stat(path, *, dir_fd=None, follow_symlinks=True) -> stat result    \n    Perform a stat system call on the given path.\n    \n    path may be specified as either a string or as an open file descriptor.\n    \n    If dir_fd is not None, it should be a file descriptor open to a directory,\n      and path should be relative; path will then be relative to that directory.\n      dir_fd may not be supported on your platform; if it is unavailable, using\n      it will raise a NotImplementedError.\n    If follow_symlinks is False, and the last element of the path is a symbolic\n      link, stat will examine the symbolic link itself instead of the file the\n      link points to.\n    It is an error to use dir_fd or follow_symlinks when specifying path as\n      an open file descriptor.\"\"\"\n    return stat_result()\n\ndef stat_float_times(*args,**kw):\n    \"\"\"stat_float_times([newval]) -> oldval    \n    Determine whether os.[lf]stat represents time stamps as float objects.\n    If newval is True, future calls to stat() return floats, if it is False,\n    future calls return ints. \n    If newval is omitted, return the current setting.\n    \"\"\"\n    pass\n\nclass stat_result:\n\n    def __init__(self):\n        \"\"\"st_mode - protection bits, \n        st_ino - inode number, \n        st_dev - device, \n        st_nlink - number of hard links, \n        st_uid - user id of owner, \n        st_gid - group id of owner, \n        st_size - size of file, in bytes, \n        st_atime - time of most recent access expressed in seconds, \n        st_mtime - time of most recent content modification expressed in \n            seconds, \n        st_ctime - platform dependent; time of most recent metadata change on \n            Unix, or the time of creation on Windows, expressed in seconds \n        st_atime_ns - time of most recent access expressed in nanoseconds as an\n             integer, \n        st_mtime_ns - time of most recent content modification expressed in \n            nanoseconds as an integer, \n        st_ctime_ns - platform dependent; time of most recent metadata change \n            on Unix, or the time of creation on Windows, expressed in \n            nanoseconds as an integer \"\"\"\n        # Brython : fake values\n        self.st_atime = window.Date.new()\n        self.st_mtime = self.st_ctime = self.st_atime_ns = \\\n            self.st_mtime_ns = self.st_ctime_ns = self.st_atime\n        self.st_uid = self.st_gid = self.st_ino = -1\n        self.st_mode = 0\n        self.st_size = 1\n\nclass statvfs_result:\n    pass\n\ndef strerror(*args,**kw):\n    \"\"\"strerror(code) -> string    \n    Translate an error code to a message string.\"\"\"\n    pass\n\ndef symlink(*args,**kw):\n    \"\"\"symlink(src, dst, target_is_directory=False, *, dir_fd=None)    \n    Create a symbolic link pointing to src named dst.\n    \n    target_is_directory is required on Windows if the target is to be\n      interpreted as a directory.  (On Windows, symlink requires\n      Windows 6.0 or greater, and raises a NotImplementedError otherwise.)\n      target_is_directory is ignored on non-Windows platforms.\n    \n    If dir_fd is not None, it should be a file descriptor open to a directory,\n      and path should be relative; path will then be relative to that directory.\n    dir_fd may not be implemented on your platform.\n      If it is unavailable, using it will raise a NotImplementedError.\"\"\"\n    pass\n\ndef system(*args,**kw):\n    \"\"\"system(command) -> exit_status    \n    Execute the command (a string) in a subshell.\"\"\"\n    pass\n\nclass terminal_size:\n    pass\n\ndef times(*args,**kw):\n    \"\"\"times() -> times_result    \n    Return an object containing floating point numbers indicating process\n    times.  The object behaves like a named tuple with these fields:\n      (utime, stime, cutime, cstime, elapsed_time)\"\"\"\n    pass\n\nclass times_result:\n    pass\n\ndef umask(*args,**kw):\n    \"\"\"umask(new_mask) -> old_mask    \n    Set the current numeric umask and return the previous umask.\"\"\"\n    pass\n\nclass uname_result:\n    pass\n\ndef unlink(path, *args, dir_fd=None):\n    \"\"\"unlink(path, *, dir_fd=None)    \n    Remove a file (same as remove()).\n    \n    If dir_fd is not None, it should be a file descriptor open to a directory,\n      and path should be relative; path will then be relative to that directory.\n    dir_fd may not be implemented on your platform.\n      If it is unavailable, using it will raise a NotImplementedError.\"\"\"\n    pass\n\ndef urandom(n):\n    \"\"\"urandom(n) -> str    \n    Return n random bytes suitable for cryptographic use.\"\"\"\n    randbytes= [_randint(0,255) for i in range(n)]\n    return bytes(randbytes)\n\ndef utime(*args,**kw):\n    \"\"\"utime(path, times=None, *, ns=None, dir_fd=None, follow_symlinks=True)    Set the access and modified time of path.\n    \n    path may always be specified as a string.\n    On some platforms, path may also be specified as an open file descriptor.\n      If this functionality is unavailable, using it raises an exception.\n    \n    If times is not None, it must be a tuple (atime, mtime);\n        atime and mtime should be expressed as float seconds since the epoch.\n    If ns is not None, it must be a tuple (atime_ns, mtime_ns);\n        atime_ns and mtime_ns should be expressed as integer nanoseconds\n        since the epoch.\n    If both times and ns are None, utime uses the current time.\n    Specifying tuples for both times and ns is an error.\n    \n    If dir_fd is not None, it should be a file descriptor open to a directory,\n      and path should be relative; path will then be relative to that directory.\n    If follow_symlinks is False, and the last element of the path is a symbolic\n      link, utime will modify the symbolic link itself instead of the file the\n      link points to.\n    It is an error to use dir_fd or follow_symlinks when specifying path\n      as an open file descriptor.\n    dir_fd and follow_symlinks may not be available on your platform.\n      If they are unavailable, using them will raise a NotImplementedError.\"\"\"\n    pass\n\ndef waitpid(*args,**kw):\n    \"\"\"waitpid(pid, options) -> (pid, status << 8)    \n    Wait for completion of a given process.  options is ignored on Windows.\"\"\"\n    pass\n\ndef write(*args,**kw):\n    \"\"\"write(fd, string) -> byteswritten    \n    Write a string to a file descriptor.\"\"\"\n    pass\n\n## put WIFSIGNALED here. its needed by os module, and os module imports all\n## functions in this module\ndef WIFSIGNALED(a):\n    return False\n\ndef WTERMSIG(status):\n    return 0\n\ndef WIFSIGNALED(status):\n    \"Return True if the process exited due to a signal, otherwise return False\"\n    return False\n\ndef WIFEXITED(status):\n    return False\n\ndef WEXITSTATUS(status):\n    pass\n\ndef WNOHANG():\n    return (0,0)\n","src/lib/posixfile.py":"raise NotImplementedError(\"posixfile is not yet implemented in Skulpt\")\n","src/lib/posixpath.py":"\"\"\"Common operations on Posix pathnames.\n\nInstead of importing this module directly, import os and refer to\nthis module as os.path.  The \"os.path\" name is an alias for this\nmodule on Posix systems; on other systems (e.g. Mac, Windows),\nos.path provides the same operations in a manner specific to that\nplatform, and is an alias to another module (e.g. macpath, ntpath).\n\nSome of this can actually be useful on non-Posix systems too, e.g.\nfor manipulation of the pathname component of URLs.\n\"\"\"\n\nimport os\nimport stat\nimport genericpath\nimport warnings\nfrom genericpath import *\n\n__all__ = [\"normcase\",\"isabs\",\"join\",\"splitdrive\",\"split\",\"splitext\",\n           \"basename\",\"dirname\",\"commonprefix\",\"getsize\",\"getmtime\",\n           \"getatime\",\"getctime\",\"islink\",\"exists\",\"lexists\",\"isdir\",\"isfile\",\n           \"ismount\",\"walk\",\"expanduser\",\"expandvars\",\"normpath\",\"abspath\",\n           \"samefile\",\"sameopenfile\",\"samestat\",\n           \"curdir\",\"pardir\",\"sep\",\"pathsep\",\"defpath\",\"altsep\",\"extsep\",\n           \"devnull\",\"realpath\",\"supports_unicode_filenames\",\"relpath\"]\n\n# strings representing various path-related bits and pieces\ncurdir = '.'\npardir = '..'\nextsep = '.'\nsep = '/'\npathsep = ':'\ndefpath = ':/bin:/usr/bin'\naltsep = None\ndevnull = '/dev/null'\n\n# Normalize the case of a pathname.  Trivial in Posix, string.lower on Mac.\n# On MS-DOS this may also turn slashes into backslashes; however, other\n# normalizations (such as optimizing '../' away) are not allowed\n# (another function should be defined to do that).\n\ndef normcase(s):\n    \"\"\"Normalize case of pathname.  Has no effect under Posix\"\"\"\n    return s\n\n\n# Return whether a path is absolute.\n# Trivial in Posix, harder on the Mac or MS-DOS.\n\ndef isabs(s):\n    \"\"\"Test whether a path is absolute\"\"\"\n    return s.startswith('/')\n\n\n# Join pathnames.\n# Ignore the previous parts if a part is absolute.\n# Insert a '/' unless the first part is empty or already ends in '/'.\n\ndef join(a, *p):\n    \"\"\"Join two or more pathname components, inserting '/' as needed.\n    If any component is an absolute path, all previous path components\n    will be discarded.\"\"\"\n    path = a\n    for b in p:\n        if b.startswith('/'):\n            path = b\n        elif path == '' or path.endswith('/'):\n            path +=  b\n        else:\n            path += '/' + b\n    return path\n\n\n# Split a path in head (everything up to the last '/') and tail (the\n# rest).  If the path ends in '/', tail will be empty.  If there is no\n# '/' in the path, head  will be empty.\n# Trailing '/'es are stripped from head unless it is the root.\n\ndef split(p):\n    \"\"\"Split a pathname.  Returns tuple \"(head, tail)\" where \"tail\" is\n    everything after the final slash.  Either part may be empty.\"\"\"\n    i = p.rfind('/') + 1\n    head, tail = p[:i], p[i:]\n    if head and head != '/'*len(head):\n        head = head.rstrip('/')\n    return head, tail\n\n\n# Split a path in root and extension.\n# The extension is everything starting at the last dot in the last\n# pathname component; the root is everything before that.\n# It is always true that root + ext == p.\n\ndef splitext(p):\n    return genericpath._splitext(p, sep, altsep, extsep)\nsplitext.__doc__ = genericpath._splitext.__doc__\n\n# Split a pathname into a drive specification and the rest of the\n# path.  Useful on DOS/Windows/NT; on Unix, the drive is always empty.\n\ndef splitdrive(p):\n    \"\"\"Split a pathname into drive and path. On Posix, drive is always\n    empty.\"\"\"\n    return '', p\n\n\n# Return the tail (basename) part of a path, same as split(path)[1].\n\ndef basename(p):\n    \"\"\"Returns the final component of a pathname\"\"\"\n    i = p.rfind('/') + 1\n    return p[i:]\n\n\n# Return the head (dirname) part of a path, same as split(path)[0].\n\ndef dirname(p):\n    \"\"\"Returns the directory component of a pathname\"\"\"\n    i = p.rfind('/') + 1\n    head = p[:i]\n    if head and head != '/'*len(head):\n        head = head.rstrip('/')\n    return head\n\n\n# Is a path a symbolic link?\n# This will always return false on systems where os.lstat doesn't exist.\n\ndef islink(path):\n    \"\"\"Test whether a path is a symbolic link\"\"\"\n    try:\n        st = os.lstat(path)\n    except (os.error, AttributeError):\n        return False\n    return stat.S_ISLNK(st.st_mode)\n\n# Being true for dangling symbolic links is also useful.\n\ndef lexists(path):\n    \"\"\"Test whether a path exists.  Returns True for broken symbolic links\"\"\"\n    try:\n        os.lstat(path)\n    except os.error:\n        return False\n    return True\n\n\n# Are two filenames really pointing to the same file?\n\ndef samefile(f1, f2):\n    \"\"\"Test whether two pathnames reference the same actual file\"\"\"\n    s1 = os.stat(f1)\n    s2 = os.stat(f2)\n    return samestat(s1, s2)\n\n\n# Are two open files really referencing the same file?\n# (Not necessarily the same file descriptor!)\n\ndef sameopenfile(fp1, fp2):\n    \"\"\"Test whether two open file objects reference the same file\"\"\"\n    s1 = os.fstat(fp1)\n    s2 = os.fstat(fp2)\n    return samestat(s1, s2)\n\n\n# Are two stat buffers (obtained from stat, fstat or lstat)\n# describing the same file?\n\ndef samestat(s1, s2):\n    \"\"\"Test whether two stat buffers reference the same file\"\"\"\n    return s1.st_ino == s2.st_ino and \\\n           s1.st_dev == s2.st_dev\n\n\n# Is a path a mount point?\n# (Does this work for all UNIXes?  Is it even guaranteed to work by Posix?)\n\ndef ismount(path):\n    \"\"\"Test whether a path is a mount point\"\"\"\n    try:\n        s1 = os.lstat(path)\n        s2 = os.lstat(join(path, '..'))\n    except os.error:\n        return False # It doesn't exist -- so not a mount point :-)\n    dev1 = s1.st_dev\n    dev2 = s2.st_dev\n    if dev1 != dev2:\n        return True     # path/.. on a different device as path\n    ino1 = s1.st_ino\n    ino2 = s2.st_ino\n    if ino1 == ino2:\n        return True     # path/.. is the same i-node as path\n    return False\n\n\n# Directory tree walk.\n# For each directory under top (including top itself, but excluding\n# '.' and '..'), func(arg, dirname, filenames) is called, where\n# dirname is the name of the directory and filenames is the list\n# of files (and subdirectories etc.) in the directory.\n# The func may modify the filenames list, to implement a filter,\n# or to impose a different order of visiting.\n\ndef walk(top, func, arg):\n    \"\"\"Directory tree walk with callback function.\n\n    For each directory in the directory tree rooted at top (including top\n    itself, but excluding '.' and '..'), call func(arg, dirname, fnames).\n    dirname is the name of the directory, and fnames a list of the names of\n    the files and subdirectories in dirname (excluding '.' and '..').  func\n    may modify the fnames list in-place (e.g. via del or slice assignment),\n    and walk will only recurse into the subdirectories whose names remain in\n    fnames; this can be used to implement a filter, or to impose a specific\n    order of visiting.  No semantics are defined for, or required of, arg,\n    beyond that arg is always passed to func.  It can be used, e.g., to pass\n    a filename pattern, or a mutable object designed to accumulate\n    statistics.  Passing None for arg is common.\"\"\"\n    warnings.warnpy3k(\"In 3.x, os.path.walk is removed in favor of os.walk.\",\n                      stacklevel=2)\n    try:\n        names = os.listdir(top)\n    except os.error:\n        return\n    func(arg, top, names)\n    for name in names:\n        name = join(top, name)\n        try:\n            st = os.lstat(name)\n        except os.error:\n            continue\n        if stat.S_ISDIR(st.st_mode):\n            walk(name, func, arg)\n\n\n# Expand paths beginning with '~' or '~user'.\n# '~' means $HOME; '~user' means that user's home directory.\n# If the path doesn't begin with '~', or if the user or $HOME is unknown,\n# the path is returned unchanged (leaving error reporting to whatever\n# function is called with the expanded path as argument).\n# See also module 'glob' for expansion of *, ? and [...] in pathnames.\n# (A function should also be defined to do full *sh-style environment\n# variable expansion.)\n\ndef expanduser(path):\n    \"\"\"Expand ~ and ~user constructions.  If user or $HOME is unknown,\n    do nothing.\"\"\"\n    if not path.startswith('~'):\n        return path\n    i = path.find('/', 1)\n    if i < 0:\n        i = len(path)\n    if i == 1:\n        if 'HOME' not in os.environ:\n            import pwd\n            userhome = pwd.getpwuid(os.getuid()).pw_dir\n        else:\n            userhome = os.environ['HOME']\n    else:\n        import pwd\n        try:\n            pwent = pwd.getpwnam(path[1:i])\n        except KeyError:\n            return path\n        userhome = pwent.pw_dir\n    userhome = userhome.rstrip('/') or userhome\n    return userhome + path[i:]\n\n\n# Expand paths containing shell variable substitutions.\n# This expands the forms $variable and ${variable} only.\n# Non-existent variables are left unchanged.\n\n_varprog = None\n\ndef expandvars(path):\n    \"\"\"Expand shell variables of form $var and ${var}.  Unknown variables\n    are left unchanged.\"\"\"\n    global _varprog\n    if '$' not in path:\n        return path\n    if not _varprog:\n        import re\n        _varprog = re.compile(r'\\$(\\w+|\\{[^}]*\\})')\n    i = 0\n    while True:\n        m = _varprog.search(path, i)\n        if not m:\n            break\n        i, j = m.span(0)\n        name = m.group(1)\n        if name.startswith('{') and name.endswith('}'):\n            name = name[1:-1]\n        if name in os.environ:\n            tail = path[j:]\n            path = path[:i] + os.environ[name]\n            i = len(path)\n            path += tail\n        else:\n            i = j\n    return path\n\n\n# Normalize a path, e.g. A//B, A/./B and A/foo/../B all become A/B.\n# It should be understood that this may change the meaning of the path\n# if it contains symbolic links!\n\ndef normpath(path):\n    \"\"\"Normalize path, eliminating double slashes, etc.\"\"\"\n    # Preserve unicode (if path is unicode)\n    slash, dot = (u'/', u'.') if isinstance(path, unicode) else ('/', '.')\n    if path == '':\n        return dot\n    initial_slashes = path.startswith('/')\n    # POSIX allows one or two initial slashes, but treats three or more\n    # as single slash.\n    if (initial_slashes and\n        path.startswith('//') and not path.startswith('///')):\n        initial_slashes = 2\n    comps = path.split('/')\n    new_comps = []\n    for comp in comps:\n        if comp in ('', '.'):\n            continue\n        if (comp != '..' or (not initial_slashes and not new_comps) or\n             (new_comps and new_comps[-1] == '..')):\n            new_comps.append(comp)\n        elif new_comps:\n            new_comps.pop()\n    comps = new_comps\n    path = slash.join(comps)\n    if initial_slashes:\n        path = slash*initial_slashes + path\n    return path or dot\n\n\ndef abspath(path):\n    \"\"\"Return an absolute path.\"\"\"\n    if not isabs(path):\n        if isinstance(path, unicode):\n            cwd = os.getcwdu()\n        else:\n            cwd = os.getcwd()\n        path = join(cwd, path)\n    return normpath(path)\n\n\n# Return a canonical path (i.e. the absolute location of a file on the\n# filesystem).\n\ndef realpath(filename):\n    \"\"\"Return the canonical path of the specified filename, eliminating any\nsymbolic links encountered in the path.\"\"\"\n    if isabs(filename):\n        bits = ['/'] + filename.split('/')[1:]\n    else:\n        bits = [''] + filename.split('/')\n\n    for i in range(2, len(bits)+1):\n        component = join(*bits[0:i])\n        # Resolve symbolic links.\n        if islink(component):\n            resolved = _resolve_link(component)\n            if resolved is None:\n                # Infinite loop -- return original component + rest of the path\n                return abspath(join(*([component] + bits[i:])))\n            else:\n                newpath = join(*([resolved] + bits[i:]))\n                return realpath(newpath)\n\n    return abspath(filename)\n\n\ndef _resolve_link(path):\n    \"\"\"Internal helper function.  Takes a path and follows symlinks\n    until we either arrive at something that isn't a symlink, or\n    encounter a path we've seen before (meaning that there's a loop).\n    \"\"\"\n    paths_seen = set()\n    while islink(path):\n        if path in paths_seen:\n            # Already seen this path, so we must have a symlink loop\n            return None\n        paths_seen.add(path)\n        # Resolve where the link points to\n        resolved = os.readlink(path)\n        if not isabs(resolved):\n            dir = dirname(path)\n            path = normpath(join(dir, resolved))\n        else:\n            path = normpath(resolved)\n    return path\n\nsupports_unicode_filenames = False\n\ndef relpath(path, start=curdir):\n    \"\"\"Return a relative version of a path\"\"\"\n\n    if not path:\n        raise ValueError(\"no path specified\")\n\n    start_list = abspath(start).split(sep)\n    path_list = abspath(path).split(sep)\n\n    # Work out how much of the filepath is shared by start and path.\n    i = len(commonprefix([start_list, path_list]))\n\n    rel_list = [pardir] * (len(start_list)-i) + path_list[i:]\n    if not rel_list:\n        return curdir\n    return join(*rel_list)","src/lib/pprint.py":"raise NotImplementedError(\"pprint is not yet implemented in Skulpt\")\n","src/lib/processing.js":"var $builtinmodule=function(){var b,c,d,e,f,g,h,a=Math.PI,j={},k=[],l=!0,m=null;return j.processing=null,j.p=null,j.X=new Sk.builtin.int_(0),j.Y=new Sk.builtin.int_(1),j.Z=new Sk.builtin.int_(2),j.R=new Sk.builtin.int_(3),j.G=new Sk.builtin.int_(4),j.B=new Sk.builtin.int_(5),j.A=new Sk.builtin.int_(6),j.U=new Sk.builtin.int_(7),j.V=new Sk.builtin.int_(8),j.NX=new Sk.builtin.int_(9),j.NY=new Sk.builtin.int_(10),j.NZ=new Sk.builtin.int_(11),j.EDGE=new Sk.builtin.int_(12),j.SR=new Sk.builtin.int_(13),j.SG=new Sk.builtin.int_(14),j.SB=new Sk.builtin.int_(15),j.SA=new Sk.builtin.int_(16),j.SW=new Sk.builtin.int_(17),j.TX=new Sk.builtin.int_(18),j.TY=new Sk.builtin.int_(19),j.TZ=new Sk.builtin.int_(20),j.VX=new Sk.builtin.int_(21),j.VY=new Sk.builtin.int_(22),j.VZ=new Sk.builtin.int_(23),j.VW=new Sk.builtin.int_(24),j.AR=new Sk.builtin.int_(25),j.AG=new Sk.builtin.int_(26),j.AB=new Sk.builtin.int_(27),j.DR=new Sk.builtin.int_(3),j.DG=new Sk.builtin.int_(4),j.DB=new Sk.builtin.int_(5),j.DA=new Sk.builtin.int_(6),j.SPR=new Sk.builtin.int_(28),j.SPG=new Sk.builtin.int_(29),j.SPB=new Sk.builtin.int_(30),j.SHINE=new Sk.builtin.int_(31),j.ER=new Sk.builtin.int_(32),j.EG=new Sk.builtin.int_(33),j.EB=new Sk.builtin.int_(34),j.BEEN_LIT=new Sk.builtin.int_(35),j.VERTEX_FIELD_COUNT=new Sk.builtin.int_(36),j.CENTER=new Sk.builtin.int_(3),j.RADIUS=new Sk.builtin.int_(2),j.CORNERS=new Sk.builtin.int_(1),j.CORNER=new Sk.builtin.int_(0),j.DIAMETER=new Sk.builtin.int_(3),j.BASELINE=new Sk.builtin.int_(0),j.TOP=new Sk.builtin.int_(101),j.BOTTOM=new Sk.builtin.int_(102),j.NORMAL=new Sk.builtin.int_(1),j.NORMALIZED=new Sk.builtin.int_(1),j.IMAGE=new Sk.builtin.int_(2),j.MODEL=new Sk.builtin.int_(4),j.SHAPE=new Sk.builtin.int_(5),j.AMBIENT=new Sk.builtin.int_(0),j.DIRECTIONAL=new Sk.builtin.int_(1),j.SPOT=new Sk.builtin.int_(3),j.RGB=new Sk.builtin.int_(1),j.ARGB=new Sk.builtin.int_(2),j.HSB=new Sk.builtin.int_(3),j.ALPHA=new Sk.builtin.int_(4),j.CMYK=new Sk.builtin.int_(5),j.TIFF=new Sk.builtin.int_(0),j.TARGA=new Sk.builtin.int_(1),j.JPEG=new Sk.builtin.int_(2),j.GIF=new Sk.builtin.int_(3),j.MITER=new Sk.builtin.str(\"miter\"),j.BEVEL=new Sk.builtin.str(\"bevel\"),j.ROUND=new Sk.builtin.str(\"round\"),j.SQUARE=new Sk.builtin.str(\"butt\"),j.PROJECT=new Sk.builtin.str(\"square\"),j.P2D=new Sk.builtin.int_(1),j.JAVA2D=new Sk.builtin.int_(1),j.WEBGL=new Sk.builtin.int_(2),j.P3D=new Sk.builtin.int_(2),j.OPENGL=new Sk.builtin.int_(2),j.PDF=new Sk.builtin.int_(0),j.DXF=new Sk.builtin.int_(0),j.OTHER=new Sk.builtin.int_(0),j.WINDOWS=new Sk.builtin.int_(1),j.MAXOSX=new Sk.builtin.int_(2),j.LINUX=new Sk.builtin.int_(3),j.EPSILON=new Sk.builtin.float_(1e-4),j.MAX_FLOAT=new Sk.builtin.float_(34028235e31),j.MIN_FLOAT=new Sk.builtin.float_(-34028235e31),j.MAX_INT=new Sk.builtin.int_(2147483647),j.MIN_INT=new Sk.builtin.int_(-2147483648),j.HALF_PI=new Sk.builtin.float_(a/2),j.THIRD_PI=new Sk.builtin.float_(a/3),j.PI=new Sk.builtin.float_(a),j.TWO_PI=new Sk.builtin.float_(2*a),j.TAU=new Sk.builtin.float_(2*a),j.QUARTER_PI=new Sk.builtin.float_(a/4),j.DEG_TO_RAD=new Sk.builtin.float_(a/180),j.RAD_TO_DEG=new Sk.builtin.float_(180/a),j.WHITESPACE=Sk.builtin.str(\" \\t\\n\\r\\f\\xA0\"),j.POINT=new Sk.builtin.int_(2),j.POINTS=new Sk.builtin.int_(2),j.LINE=new Sk.builtin.int_(4),j.LINES=new Sk.builtin.int_(4),j.TRIANGLE=new Sk.builtin.int_(8),j.TRIANGLES=new Sk.builtin.int_(9),j.TRIANGLE_FAN=new Sk.builtin.int_(11),j.TRIANGLE_STRIP=new Sk.builtin.int_(10),j.QUAD=new Sk.builtin.int_(16),j.QUADS=new Sk.builtin.int_(16),j.QUAD_STRIP=new Sk.builtin.int_(17),j.POLYGON=new Sk.builtin.int_(20),j.PATH=new Sk.builtin.int_(21),j.RECT=new Sk.builtin.int_(30),j.ELLIPSE=new Sk.builtin.int_(31),j.ARC=new Sk.builtin.int_(32),j.SPHERE=new Sk.builtin.int_(40),j.BOX=new Sk.builtin.int_(41),j.GROUP=new Sk.builtin.int_(0),j.PRIMITIVE=new Sk.builtin.int_(1),j.GEOMETRY=new Sk.builtin.int_(3),j.VERTEX=new Sk.builtin.int_(0),j.BEZIER_VERTEX=new Sk.builtin.int_(1),j.CURVE_VERTEX=new Sk.builtin.int_(2),j.BREAK=new Sk.builtin.int_(3),j.CLOSESHAPE=new Sk.builtin.int_(4),j.REPLACE=new Sk.builtin.int_(0),j.BLEND=new Sk.builtin.int_(1),j.ADD=new Sk.builtin.int_(2),j.SUBTRACT=new Sk.builtin.int_(4),j.LIGHTEST=new Sk.builtin.int_(8),j.DARKEST=new Sk.builtin.int_(16),j.DIFFERENCE=new Sk.builtin.int_(32),j.EXCLUSION=new Sk.builtin.int_(64),j.MULTIPLY=new Sk.builtin.int_(128),j.SCREEN=new Sk.builtin.int_(256),j.OVERLAY=new Sk.builtin.int_(512),j.HARD_LIGHT=new Sk.builtin.int_(1024),j.SOFT_LIGHT=new Sk.builtin.int_(2048),j.DODGE=new Sk.builtin.int_(4096),j.BURN=new Sk.builtin.int_(8192),j.ALPHA_MASK=new Sk.builtin.int_(4278190080),j.RED_MASK=new Sk.builtin.int_(16711680),j.GREEN_MASK=new Sk.builtin.int_(65280),j.BLUE_MASK=new Sk.builtin.int_(255),j.CUSTOM=new Sk.builtin.int_(0),j.ORTHOGRAPHIC=new Sk.builtin.int_(2),j.PERSPECTIVE=new Sk.builtin.int_(3),j.ARROW=new Sk.builtin.str(\"default\"),j.CROSS=new Sk.builtin.str(\"crosshair\"),j.HAND=new Sk.builtin.str(\"pointer\"),j.MOVE=new Sk.builtin.str(\"move\"),j.TEXT=new Sk.builtin.str(\"text\"),j.WAIT=new Sk.builtin.str(\"wait\"),j.NOCURSOR=Sk.builtin.assk$(\"url('data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw=='), auto\",Sk.builtin.nmber.str),j.DISABLE_OPENGL_2X_SMOOTH=new Sk.builtin.int_(1),j.ENABLE_OPENGL_2X_SMOOTH=new Sk.builtin.int_(-1),j.ENABLE_OPENGL_4X_SMOOTH=new Sk.builtin.int_(2),j.ENABLE_NATIVE_FONTS=new Sk.builtin.int_(3),j.DISABLE_DEPTH_TEST=new Sk.builtin.int_(4),j.ENABLE_DEPTH_TEST=new Sk.builtin.int_(-4),j.ENABLE_DEPTH_SORT=new Sk.builtin.int_(5),j.DISABLE_DEPTH_SORT=new Sk.builtin.int_(-5),j.DISABLE_OPENGL_ERROR_REPORT=new Sk.builtin.int_(6),j.ENABLE_OPENGL_ERROR_REPORT=new Sk.builtin.int_(-6),j.ENABLE_ACCURATE_TEXTURES=new Sk.builtin.int_(7),j.DISABLE_ACCURATE_TEXTURES=new Sk.builtin.int_(-7),j.HINT_COUNT=new Sk.builtin.int_(10),j.OPEN=new Sk.builtin.int_(1),j.CLOSE=new Sk.builtin.int_(2),j.BLUR=new Sk.builtin.int_(11),j.GRAY=new Sk.builtin.int_(12),j.INVERT=new Sk.builtin.int_(13),j.OPAQUE=new Sk.builtin.int_(14),j.POSTERIZE=new Sk.builtin.int_(15),j.THRESHOLD=new Sk.builtin.int_(16),j.ERODE=new Sk.builtin.int_(17),j.DILATE=new Sk.builtin.int_(18),j.BACKSPACE=new Sk.builtin.int_(8),j.TAB=new Sk.builtin.int_(9),j.ENTER=new Sk.builtin.int_(10),j.RETURN=new Sk.builtin.int_(13),j.ESC=new Sk.builtin.int_(27),j.DELETE=new Sk.builtin.int_(127),j.CODED=new Sk.builtin.int_(65535),j.SHIFT=new Sk.builtin.int_(16),j.CONTROL=new Sk.builtin.int_(17),j.ALT=new Sk.builtin.int_(18),j.CAPSLK=new Sk.builtin.int_(20),j.PGUP=new Sk.builtin.int_(33),j.PGDN=new Sk.builtin.int_(34),j.END=new Sk.builtin.int_(35),j.HOME=new Sk.builtin.int_(36),j.LEFT=new Sk.builtin.int_(37),j.UP=new Sk.builtin.int_(38),j.RIGHT=new Sk.builtin.int_(39),j.DOWN=new Sk.builtin.int_(40),j.F1=new Sk.builtin.int_(112),j.F2=new Sk.builtin.int_(113),j.F3=new Sk.builtin.int_(114),j.F4=new Sk.builtin.int_(115),j.F5=new Sk.builtin.int_(116),j.F6=new Sk.builtin.int_(117),j.F7=new Sk.builtin.int_(118),j.F8=new Sk.builtin.int_(119),j.F9=new Sk.builtin.int_(120),j.F10=new Sk.builtin.int_(121),j.F11=new Sk.builtin.int_(122),j.F12=new Sk.builtin.int_(123),j.NUMLK=new Sk.builtin.int_(144),j.META=new Sk.builtin.int_(157),j.INSERT=new Sk.builtin.int_(155),j.SINCOS_LENGTH=new Sk.builtin.int_(720),j.PRECISIONB=new Sk.builtin.int_(15),j.PRECISIONF=new Sk.builtin.int_(32768),j.PREC_MAXVAL=new Sk.builtin.int_(32767),j.PREC_ALPHA_SHIFT=new Sk.builtin.int_(9),j.PREC_RED_SHIFT=new Sk.builtin.int_(1),j.NORMAL_MODE_AUTO=new Sk.builtin.int_(0),j.NORMAL_MODE_SHAPE=new Sk.builtin.int_(1),j.NORMAL_MODE_VERTEX=new Sk.builtin.int_(2),j.MAX_LIGHTS=new Sk.builtin.int_(8),j.line=new Sk.builtin.func(function(a,b,c,d){j.processing.line(a.v,b.v,c.v,d.v)}),j.ellipse=new Sk.builtin.func(function(a,b,c,d){j.processing.ellipse(a.v,b.v,c.v,d.v)}),j.text=new Sk.builtin.func(function(a,b,c){j.processing.text(a.v,b.v,c.v)}),j.point=new Sk.builtin.func(function(a,b){j.processing.point(a.v,b.v)}),j.arc=new Sk.builtin.func(function(a,b,c,d,e,f){j.processing.arc(a.v,b.v,c.v,d.v,e.v,f.v)}),j.quad=new Sk.builtin.func(function(a,b,c,d,e,f,g,h){j.processing.quad(a.v,b.v,c.v,d.v,e.v,f.v,g.v,h.v)}),j.rect=new Sk.builtin.func(function(a,b,c,d,e){\"undefined\"==typeof e?j.processing.rect(a.v,b.v,c.v,d.v):j.processing.rect(a.v,b.v,c.v,d.v,e.v)}),j.triangle=new Sk.builtin.func(function(a,b,c,d,e,f){j.processing.triangle(a.v,b.v,c.v,d.v,e.v,f.v)}),j.bezier=new Sk.builtin.func(function(a,b,c,d,e,f,g,h,i,k,l,m){\"undefined\"==typeof i?j.processing.bezier(a.v,b.v,c.v,d.v,e.v,f.v,g.v,h.v):j.processing.bezier(a.v,b.v,c.v,d.v,e.v,f.v,g.v,h.v,i.v,k.v,l.v,m.v)}),j.alpha=new Sk.builtin.func(function(a,c,d){return\"undefined\"==typeof c?new Sk.builtin.float_(j.processing.alpha(a.v)):\"undefined\"==typeof d?new Sk.builtin.float_(j.processing.alpha(a.v,c.v)):new Sk.builtin.float_(j.processing.alpha(a.v,c.v,d.v))}),j.ambient=new Sk.builtin.func(function(a,c,d){\"undefined\"==typeof c?j.processing.ambient(a.v):\"undefined\"==typeof d?j.processing.ambient(a.v,c.v):j.processing.ambient(a.v,c.v,d.v)}),j.ambientLight=new Sk.builtin.func(function(a,b,c,d,e,f){\"undefined\"==typeof d?j.processing.ambientLight(a.v,b.v,c.v):\"undefined\"==typeof e?j.processing.ambientLight(a.v,b.v,c.v,d.v):\"undefined\"==typeof f?j.processing.ambientLight(a.v,b.v,c.v,d.v,e.v):j.processing.ambientLight(a.v,b.v,c.v,d.v,e.v,f.v)}),j.beginCamera=new Sk.builtin.func(function(){j.processing.beginCamera()}),j.beginShape=new Sk.builtin.func(function(a){\"undefined\"==typeof a&&(a=j.POLYGON),j.processing.beginShape(a.v)}),j.bezierDetail=new Sk.builtin.func(function(a){a=\"undefined\"==typeof a?20:a.v,j.processing.bezierDetail(a)}),j.bezierPoint=new Sk.builtin.func(function(e,a,b,c,d){j.processing.bezierPoint(e.v,a.v,b.v,c.v,d.v)}),j.bezierTangent=new Sk.builtin.func(function(e,a,b,c,d){j.processing.bezierTangent(e.v,a.v,b.v,c.v,d.v)}),j.bezierVertex=new Sk.builtin.func(function(a,b,c,d,e,f,g,h,i){\"undefined\"==typeof g?j.processing.bezierVertex(a.v,b.v,c.v,d.v,e.v,f.v):\"undefined\"==typeof h?j.processing.bezierVertex(a.v,b.v,c.v,d.v,e.v,f.v,g.v):\"undefined\"==typeof i?j.processing.bezierVertex(a.v,b.v,c.v,d.v,e.v,f.v,g.v,h.v):j.processing.bezierVertex(a.v,b.v,c.v,d.v,e.v,f.v,g.v,h.v,i.v)}),j.blend=new Sk.builtin.func(function(a,b,c,d,e,f,g,h,i,k){other instanceof Sk.builtin.int_||other instanceof Sk.builtin.float_?j.processing.blend(a.v,b.v,c.v,d.v,e.v,f.v,g.v,h.v,i.v):j.processing.blend(a.v,b.v,c.v,d.v,e.v,f.v,g.v,h.v,i.v,k.v)}),j.blendColor=new Sk.builtin.func(function(a,b,d){var e=Sk.misceval.callsimArray(j.color,[new Sk.builtin.int_(0),new Sk.builtin.int_(0),new Sk.builtin.int_(0)]);return e.v=j.processing.blendColor(a.v,b.v,d.v),e}),j.brightness=new Sk.builtin.func(function(a,c,d){return\"undefined\"==typeof c?new Sk.builtin.float_(j.processing.brightness(a.v)):\"undefined\"==typeof d?new Sk.builtin.float_(j.processing.brightness(a.v,c.v)):new Sk.builtin.float_(j.processing.brightness(a.v,c.v,d.v))}),j.camera=new Sk.builtin.func(function(a,b,c,d,e,f,g,h,i){\"undefined\"==typeof a?j.processing.camera():j.processing.camera(a.v,b.v,c.v,d.v,e.v,f.v,g.v,h.v,i.v)}),j.constrain=new Sk.builtin.func(function(a,b,c){return new Sk.builtin.float_(j.processing.constrain(a.v,b.v,c.v))}),j.copy=new Sk.builtin.func(function(a,b,c,d,e,f,g,h,i){other instanceof Sk.builtin.int_||other instanceof Sk.builtin.float_?j.processing.copy(a.v,b.v,c.v,d.v,e.v,f.v,g.v,h.v):j.processing.copy(a.v,b.v,c.v,d.v,e.v,f.v,g.v,h.v,i.v)}),j.createFont=new Sk.builtin.func(function(a,b,c,d){var e=Sk.misceval.callsimArray(j.PFont);return e.v=\"undefined\"==typeof c?j.processing.createFont(a.v,b.v):\"undefined\"==typeof d?j.processing.createFont(a.v,b.v,c.v):j.processing.createFont(a.v,b.v,c.v,d.v),e}),j.createGraphics=new Sk.builtin.func(function(a,b,c,d){var e=Sk.misceval.callsimArray(j.PGraphics);return e.v=\"undefined\"==typeof d?j.processing.createGraphics(a.v,b.v,c.v):j.processing.createGraphics(a.v,b.v,c.v,d.v),e}),j.createImage=new Sk.builtin.func(function(a,b,c){var d=Sk.misceval.callsimArray(j.PImage);return d.v=j.processing.createImage(a.v,b.v,c.v),d}),j.cursor=new Sk.builtin.func(function(a,b,c){\"undefined\"==typeof a?j.processing.cursor():\"undefined\"==typeof b?j.processing.cursor(a.v):\"undefined\"==typeof c?j.processing.cursor(a.v,b.v):j.processing.cursor(a.v,b.v,c.v)}),j.curve=new Sk.builtin.func(function(a,b,c,d,e,f,g,h,i,k,l,m){\"undefined\"==typeof i?j.processing.curve(a.v,b.v,c.v,d.v,e.v,f.v,g.v,h.v):\"undefined\"==typeof k?j.processing.curve(a.v,b.v,c.v,d.v,e.v,f.v,g.v,h.v,i.v):\"undefined\"==typeof l?j.processing.curve(a.v,b.v,c.v,d.v,e.v,f.v,g.v,h.v,i.v,k.v):\"undefined\"==typeof m?j.processing.curve(a.v,b.v,c.v,d.v,e.v,f.v,g.v,h.v,i.v,k.v,l.v):j.processing.curve(a.v,b.v,c.v,d.v,e.v,f.v,g.v,h.v,i.v,k.v,l.v,m.v)}),j.curveDetail=new Sk.builtin.func(function(a){j.processing.curveDetail(a.v)}),j.curvePoint=new Sk.builtin.func(function(e,a,b,c,d){j.processing.curvePoint(e.v,a.v,b.v,c.v,d.v)}),j.curveTangent=new Sk.builtin.func(function(e,a,b,c,d){j.processing.curveTangent(e.v,a.v,b.v,c.v,d.v)}),j.curveTightness=new Sk.builtin.func(function(a){j.processing.curveTightness(a.v)}),j.curveVertex=new Sk.builtin.func(function(a,b,c){\"undefined\"==typeof c?j.processing.curveVertex(a.v,b.v):j.processing.curveVertex(a.v,b.v,c.v)}),j.day=new Sk.builtin.func(function(){return new Sk.builtin.int_(j.processing.day())}),j.degrees=new Sk.builtin.func(function(a){return new Sk.builtin.float_(j.processing.degrees(a.v))}),j.directionalLight=new Sk.builtin.func(function(a,b,c,d,e,f){j.processing.directionalLight(a.v,b.v,c.v,d.v,e.v,f.v)}),j.dist=new Sk.builtin.func(function(a,b,c,d,e,f){return\"undefined\"==typeof e?new Sk.builtin.float_(j.processing.dist(a.v,b.v,c.v,d.v)):\"undefined\"==typeof f?new Sk.builtin.float_(j.processing.dist(a.v,b.v,c.v,d.v,e.v)):new Sk.builtin.float_(j.processing.dist(a.v,b.v,c.v,d.v,e.v,f.v))}),j.emissive=new Sk.builtin.func(function(a,b,c){\"undefined\"==typeof b?j.processing.emissive(a.v):\"undefined\"==typeof c?j.processing.emissive(a.v,b.v):j.processing.emissive(a.v,b.v,c.v)}),j.endCamera=new Sk.builtin.func(function(){j.processing.endCamera()}),j.endShape=new Sk.builtin.func(function(a){\"undefined\"==typeof a?j.processing.endShape():j.processing.endShape(a.v)}),j.filter=new Sk.builtin.func(function(a,b){\"undefined\"==typeof b?j.processing.filter(a.v):j.processing.filter(a.v,b.v)}),j.frustum=new Sk.builtin.func(function(a,b,c,d,e,f){j.processing.frustum(a,b,c,d,e,f)}),j.hint=new Sk.builtin.func(function(a){j.processing.hint(a)}),j.hour=new Sk.builtin.func(function(){return new Sk.builtin.int_(j.processing.hour())}),j.hue=new Sk.builtin.func(function(a){return new Sk.builtin.float_(j.processing.hue(a.v))}),j.imageMode=new Sk.builtin.func(function(a){j.processing.imageMode(a.v)}),j.lerp=new Sk.builtin.func(function(a,b,c){return new Sk.builtin.float_(j.processing.lerp(a.v,b.v,c.v))}),j.lerpColor=new Sk.builtin.func(function(a,b,d){var e=Sk.misceval.callsimArray(j.color,[new Sk.builtin.int_(0),new Sk.builtin.int_(0),new Sk.builtin.int_(0)]);return e.v=j.processing.lerpColor(a.v,b.v,d.v),e}),j.lightFalloff=new Sk.builtin.func(function(a,b,c){j.processing.lightFalloff(a.v,b.v,c.v)}),j.lights=new Sk.builtin.func(function(){j.processing.lights()}),j.lightSpecular=new Sk.builtin.func(function(a,b,c){j.processing.lightSpecular(a.v,b.v,c.v)}),j.loadBytes=new Sk.builtin.func(function(a){return new Sk.builtin.list(j.processing.loadBytes(a.v))}),j.loadFont=new Sk.builtin.func(function(a){var b=Sk.misceval.callsimArray(j.PFont);return b.v=j.processing.loadFont(a.v),b}),j.loadShape=new Sk.builtin.func(function(a){var b=Sk.misceval.callsimArray(j.PShapeSVG,[new Sk.builtin.str(\"string\"),a]);return b}),j.loadStrings=new Sk.builtin.func(function(a){return new Sk.builtin.list(j.processing.loadStrings(a.v))}),j.mag=new Sk.builtin.func(function(d,a,b){return\"undefined\"==typeof b?new Sk.builtin.float_(j.processing.mag(d.v,a.v)):new Sk.builtin.float_(j.processing.mag(d.v,a.v,b.v))}),j.map=new Sk.builtin.func(function(a,b,c,d,e){return new Sk.builtin.float_(j.processing.map(a.v,b.v,c.v,d.v,e.v))}),j.millis=new Sk.builtin.func(function(){return new Sk.builtin.int_(j.processing.millis())}),j.minute=new Sk.builtin.func(function(){return new Sk.builtin.int_(j.processing.minute())}),j.modelX=new Sk.builtin.func(function(a,b,c){return new Sk.builtin.float_(j.processing.modelX(a.v,b.v,c.v))}),j.modelY=new Sk.builtin.func(function(a,b,c){return new Sk.builtin.float_(j.processing.modelY(a.v,b.v,c.v))}),j.modelZ=new Sk.builtin.func(function(a,b,c){return new Sk.builtin.float_(j.processing.modelZ(a.v,b.v,c.v))}),j.month=new Sk.builtin.func(function(){return new Sk.builtin.int_(j.processing.month())}),j.noCursor=new Sk.builtin.func(function(){j.processing.noCursor()}),j.noise=new Sk.builtin.func(function(a,b,c){return\"undefined\"==typeof b?new Sk.builtin.float_(j.processing.noise(a.v)):\"undefined\"==typeof c?new Sk.builtin.float_(j.processing.noise(a.v,b.v)):new Sk.builtin.float_(j.processing.noise(a.v,b.v,c.v))}),j.noiseDetail=new Sk.builtin.func(function(a,b){j.processing.noiseDetail(a.v,b.v)}),j.noiseSeed=new Sk.builtin.func(function(a){return new Sk.builtin.float_(j.processing.noiseSeed(a.v))}),j.noLights=new Sk.builtin.func(function(){j.processing.noLights()}),j.norm=new Sk.builtin.func(function(a,b,c){return new Sk.builtin.float_(j.processing.norm(a.v,b.v,c.v))}),j.normal=new Sk.builtin.func(function(a,b,c){j.processing.normal(a.v,b.v,c.v)}),j.noTint=new Sk.builtin.func(function(){j.processing.noTint()}),j.ortho=new Sk.builtin.func(function(a,b,c,d,e,f){j.processing.ortho(a.v,b.v,c.v,d.v,e.v,f.v)}),j.perspective=new Sk.builtin.func(function(a,b,c,d){\"undefined\"==typeof a?j.processing.perspective():\"undefined\"==typeof b?j.processing.perspective(a.v):\"undefined\"==typeof c?j.processing.perspective(a.v,b.v):\"undefined\"==typeof d?j.processing.perspective(a.v,b.v,c.v):j.processing.perspective(a.v,b.v,c.v,d.v)}),j.pointLight=new Sk.builtin.func(function(a,b,c,d,e,f){j.processing.pointLight(a.v,b.v,c.v,d.v,e.v,f.v)}),j.printCamera=new Sk.builtin.func(function(){j.processing.printCamera()}),j.println=new Sk.builtin.func(function(a){j.processing.println(a.v)}),j.printProjection=new Sk.builtin.func(function(){j.processing.printProjection()}),j.radians=new Sk.builtin.func(function(a){return new Sk.builtin.float_(j.processing.radians(a.v))}),j.randomSeed=new Sk.builtin.func(function(a){return new Sk.builtin.float_(j.processing.randomSeed(a.v))}),j.random=new Sk.builtin.func(function(a,b){return\"undefined\"==typeof a?new Sk.builtin.float_(j.processing.random()):\"undefined\"==typeof b?new Sk.builtin.float_(j.processing.random(a.v)):new Sk.builtin.float_(j.processing.random(a.v,b.v))}),j.requestImage=new Sk.builtin.func(function(a,b){var c=Sk.misceval.callsimArray(j.PImage);return c.v=\"undefined\"==typeof b?j.processing.requestImage(a.v):j.processing.requestImage(a.v,b.v),c}),j.saturation=new Sk.builtin.func(function(a){return new Sk.builtin.float_(j.processing.saturation(a.v))}),j.save=new Sk.builtin.func(function(a){j.processing.save(a.v)}),j.saveFrame=new Sk.builtin.func(function(a){\"undefined\"==typeof a?j.processing.saveFrame():j.processing.saveFrame(a.v)}),j.saveStrings=new Sk.builtin.func(function(a,b){j.processing.saveStrings(a.v,b.v)}),j.screenX=new Sk.builtin.func(function(a,b,c){return new Sk.builtin.float_(j.processing.screenX(a.v,b.v,c.v))}),j.screenY=new Sk.builtin.func(function(a,b,c){return new Sk.builtin.float_(j.processing.screenY(a.v,b.v,c.v))}),j.screenZ=new Sk.builtin.func(function(a,b,c){return new Sk.builtin.float_(j.processing.screenZ(a.v,b.v,c.v))}),j.second=new Sk.builtin.func(function(){return new Sk.builtin.int_(j.processing.second())}),j.shape=new Sk.builtin.func(function(a,b,c,d,e){\"undefined\"==typeof b?j.processing.shape(a.v):\"undefined\"==typeof c?j.processing.shape(a.v,b.v):\"undefined\"==typeof d?j.processing.shape(a.v,b.v,c.v):\"undefined\"==typeof e?j.processing.shape(a.v,b.v,c.v,d.v):j.processing.shape(a.v,b.v,c.v,d.v,e.v)}),j.shapeMode=new Sk.builtin.func(function(a){j.processing.shapeMode(a.v)}),j.shininess=new Sk.builtin.func(function(a){j.processing.shininess(a.v)}),j.specular=new Sk.builtin.func(function(a,b,c){\"undefined\"==typeof b?j.processing.specular(a.v):\"undefined\"==typeof c?j.processing.specular(a.v,b.v):j.processing.specular(a.v,b.v,c.v)}),j.spotLight=new Sk.builtin.func(function(a,b,c,d,e,f,g,h){j.processing.spotLight(a.v,b.v,c.v,d.v,e.v,f.v,g.v,h.v)}),j.sq=new Sk.builtin.func(function(a){return new Sk.builtin.float_(j.processing.sq(a))}),j.status=new Sk.builtin.func(function(a){j.processing.status(a.v)}),j.textAlign=new Sk.builtin.func(function(a,b){\"undefined\"==typeof b?j.processing.textAlign(a.v):j.processing.textAlign(a.v,b.v)}),j.textAscent=new Sk.builtin.func(function(){return new Sk.builtin.float_(j.processing.textAscent())}),j.textDescent=new Sk.builtin.func(function(){return new Sk.builtin.float_(j.processing.textDescent())}),j.textFont=new Sk.builtin.func(function(a,b){\"undefined\"==typeof b?j.processing.textFont(a.v):j.processing.textFont(a.v,b.v)}),j.textLeading=new Sk.builtin.func(function(a){j.processing.textLeading(a.v)}),j.textMode=new Sk.builtin.func(function(a){j.processing.textMode(a.v)}),j.textSize=new Sk.builtin.func(function(a){j.processing.textSize(a.v)}),j.texture=new Sk.builtin.func(function(a){j.processing.texture(a.v)}),j.textureMode=new Sk.builtin.func(function(a){j.processing.textureMode(a.v)}),j.textWidth=new Sk.builtin.func(function(a){return new Sk.builtin.float_(j.processing.textWidth(a.v))}),j.tint=new Sk.builtin.func(function(a,b,c,d){\"undefined\"==typeof b?j.processing.tint(a.v):\"undefined\"==typeof c?j.processing.tint(a.v,b.v):\"undefined\"==typeof d?j.processing.tint(a.v,b.v,c.v):j.processing.tint(a.v,b.v,c.v,d.v)}),j.updatePixels=new Sk.builtin.func(function(){j.processing.updatePixels()}),j.vertex=new Sk.builtin.func(function(a,b,c,d,e){\"undefined\"==typeof c?j.processing.vertex(a.v,b.v):\"undefined\"==typeof d?j.processing.vertex(a.v,b.v,c.v):\"undefined\"==typeof e?j.processing.vertex(a.v,b.v,c.v,d.v):j.processing.vertex(a.v,b.v,c.v,d.v,e.v)}),j.year=new Sk.builtin.func(function(){return new Sk.builtin.int_(j.processing.year())}),j.box=new Sk.builtin.func(function(a){j.processing.box(a.v)}),j.sphere=new Sk.builtin.func(function(a){j.processing.sphere(a.v)}),j.sphereDetail=new Sk.builtin.func(function(a,b){\"undefined\"==typeof b?j.processing.sphereDetail(a.v):j.processing.sphereDetail(a.v,b.v)}),j.background=new Sk.builtin.func(function(a,c,d){\"undefined\"!=typeof c&&(c=c.v),\"undefined\"!=typeof d&&(d=d.v),j.processing.background(a.v,c,d)}),j.fill=new Sk.builtin.func(function(a,c,d,e){\"undefined\"!=typeof c&&(c=c.v),\"undefined\"!=typeof d&&(d=d.v),\"undefined\"!=typeof e&&(e=e.v),j.processing.fill(a.v,c,d,e)}),j.stroke=new Sk.builtin.func(function(a,c,d,e){\"undefined\"!=typeof c&&(c=c.v),\"undefined\"!=typeof d&&(d=d.v),\"undefined\"!=typeof e&&(e=e.v),j.processing.stroke(a.v,c,d,e)}),j.noStroke=new Sk.builtin.func(function(){j.processing.noStroke()}),j.colorMode=new Sk.builtin.func(function(a,b,c,d,e){b=\"undefined\"==typeof b?255:b.v,\"undefined\"!=typeof c&&(c=c.v),\"undefined\"!=typeof d&&(d=d.v),\"undefined\"!=typeof e&&(e=e.v),j.processing.colorMode(a.v,b,c,d,e)}),j.noFill=new Sk.builtin.func(function(){j.processing.noFill()}),j.loop=new Sk.builtin.func(function(){if(null===j.processing)throw new Sk.builtin.Exception(\"loop() should be called after run()\");l=!0,j.processing.loop()}),j.noLoop=new Sk.builtin.func(function(){if(null===j.processing)throw new Sk.builtin.Exception(\"noLoop() should be called after run()\");l=!1,j.processing.noLoop()}),j.frameRate=new Sk.builtin.func(function(a){j.processing.frameRate(a.v)}),j.width=new Sk.builtin.int_(0),j.height=new Sk.builtin.int_(0),j.renderMode=j.P2D,j.size=new Sk.builtin.func(function(a,b,c){\"undefined\"==typeof c&&(c=j.P2D),j.processing.size(a.v,b.v,c.v),j.width=new Sk.builtin.int_(j.processing.width),j.height=new Sk.builtin.int_(j.processing.height),j.renderMode=c}),j.exitp=new Sk.builtin.func(function(){j.processing.exit()}),j.mouseX=new Sk.builtin.func(function(){return new Sk.builtin.int_(j.processing.mouseX)}),j.mouseY=new Sk.builtin.func(function(){return new Sk.builtin.int_(j.processing.mouseY)}),j.pmouseX=new Sk.builtin.func(function(){return new Sk.builtin.int_(j.processing.pmouseX)}),j.pmouseY=new Sk.builtin.func(function(){return new Sk.builtin.int_(j.processing.pmouseY)}),j.rectMode=new Sk.builtin.func(function(a){j.processing.rectMode(a.v)}),j.strokeWeight=new Sk.builtin.func(function(a){j.processing.strokeWeight(a.v)}),j.smooth=new Sk.builtin.func(function(){j.processing.smooth()}),j.noSmooth=new Sk.builtin.func(function(){j.processing.noSmooth()}),j.ellipseMode=new Sk.builtin.func(function(a){j.processing.ellipseMode(a.v)}),j.strokeCap=new Sk.builtin.func(function(a){j.processing.strokeCap(a.v)}),j.strokeJoin=new Sk.builtin.func(function(a){j.processing.strokeJoin(a.v)}),j.rotate=new Sk.builtin.func(function(a){j.processing.rotate(a.v)}),j.rotateX=new Sk.builtin.func(function(a){j.processing.rotateX(a.v)}),j.rotateY=new Sk.builtin.func(function(a){j.processing.rotateY(a.v)}),j.rotateZ=new Sk.builtin.func(function(a){j.processing.rotateZ(a.v)}),j.scale=new Sk.builtin.func(function(a,b,c){b=\"undefined\"==typeof b?1:b.v,c=\"undefined\"==typeof c?1:c.v,j.processing.scale(a.v,b,c)}),j.translate=new Sk.builtin.func(function(a,b,c){b=\"undefined\"==typeof b?1:b.v,c=\"undefined\"==typeof c?1:c.v,j.processing.translate(a.v,b,c)}),j.popMatrix=new Sk.builtin.func(function(){j.processing.popMatrix()}),j.pushMatrix=new Sk.builtin.func(function(){j.processing.pushMatrix()}),j.applyMatrix=new Sk.builtin.func(function(){var a,b=Array.prototype.slice.call(arguments,0,16);for(a=0;a<b.length;a++)b[a]=\"undefined\"==typeof b[a]?0:b[a].v;j.processing.applyMatrix.apply(j.processing,b)}),j.resetMatrix=new Sk.builtin.func(function(){j.processing.resetMatrix()}),j.printMatrix=new Sk.builtin.func(function(){return Sk.ffi.remapToPy(j.processing.printMatrix())}),j.run=new Sk.builtin.func(function(){var a=document.getElementById(Sk.canvas);if(!a)throw new Error(\"Processing module: Canvas element not specified\");if(window.Processing.logger={log:function(a){Sk.misceval.print_(a)}},m=window.Processing.getInstanceById(Sk.canvas),m&&m.exit(),j.p=new window.Processing(a,function(a){j.processing=a,a.draw=function(){var b=!1;for(var c in k)0===k[c].width&&(b=!0);if(!0==b)return!0===l?void 0:void a.loop();if(!1===l&&a.noLoop(),j.frameCount=a.frameCount,Sk.globals.draw)try{Sk.misceval.callsimArray(Sk.globals.draw)}catch(a){Sk.uncaughtException(a)}};var b=[\"setup\",\"mouseMoved\",\"mouseClicked\",\"mouseDragged\",\"mouseMoved\",\"mouseOut\",\"mouseOver\",\"mousePressed\",\"mouseReleased\",\"keyPressed\",\"keyReleased\",\"keyTyped\"];for(var c in b)Sk.globals[b[c]]&&(a[b[c]]=new Function(\"try {Sk.misceval.callsimArray(Sk.globals['\"+b[c]+\"']);} catch(e) {Sk.uncaughtException(e);}\"))}),0===j.width.v&&0===j.height.v){var b=a.offsetWidth,c=a.offsetHeight;Sk.misceval.callsimArray(j.size,[new Sk.builtin.int_(b),new Sk.builtin.int_(c),j.renderMode])}}),g=function(a,b){b.__getattr__=new Sk.builtin.func(function(a,b){return(b=Sk.ffi.remapToJs(b),\"x\"===b)?Sk.builtin.assk$(j.processing.mouseX):\"y\"===b?Sk.builtin.assk$(j.processing.mouseY):\"px\"===b?Sk.builtin.assk$(j.processing.pmouseX):\"py\"===b?Sk.builtin.assk$(j.processing.pmouseY):\"pressed\"===b?new Sk.builtin.bool(j.processing.__mousePressed):\"button\"===b?Sk.builtin.assk$(j.processing.mouseButton):void 0})},j.Mouse=Sk.misceval.buildClass(j,g,\"Mouse\",[]),j.mouse=Sk.misceval.callsimArray(j.Mouse),f=function(a,b){b.__getattr__=new Sk.builtin.func(function(a,b){return(b=Sk.ffi.remapToJs(b),\"key\"===b)?new Sk.builtin.str(j.processing.key.toString()):\"keyCode\"===b?Sk.builtin.assk$(j.processing.keyCode):\"keyPressed\"===b?new Sk.builtin.str(j.processing.keyPressed):void 0})},j.Keyboard=Sk.misceval.buildClass(j,f,\"Keyboard\",[]),j.keyboard=Sk.misceval.callsimArray(j.Keyboard),e=function(a,b){b.__getattr__=new Sk.builtin.func(function(a,b){return(b=Sk.ffi.remapToJs(b),\"frameCount\"===b)?Sk.builtin.assk$(j.processing.frameCount):\"frameRate\"===b?Sk.builtin.assk$(j.processing.frameRate):\"height\"===b?Sk.builtin.assk$(j.processing.height):\"width\"===b?Sk.builtin.assk$(j.processing.width):\"online\"===b?new Sk.builtin.bool(j.processing.online):\"focused\"===b?new Sk.builtin.bool(j.processing.focused):void 0})},j.Environment=Sk.misceval.buildClass(j,e,\"Environment\",[]),j.environment=Sk.misceval.callsimArray(j.Environment),d=function(a,b){b.__init__=new Sk.builtin.func(function(a){a.pixels=null}),b.__getattr__=new Sk.builtin.func(function(a,b){return(b=Sk.ffi.remapToJs(b),\"height\"===b)?Sk.builtin.assk$(j.processing.height):\"width\"===b?Sk.builtin.assk$(j.processing.width):(\"pixels\"===b&&null==a.pixels&&(a.pixels=new Sk.builtin.list(j.processing.pixels.toArray())),a.pixels)})},j.Screen=Sk.misceval.buildClass(j,d,\"Screen\",[]),j.screen=Sk.misceval.callsimArray(j.Screen),j.loadPixels=new Sk.builtin.func(function(){j.processing.loadPixels()}),c=function(a,b){b.__init__=new Sk.builtin.func(function(a,b,c,d,e){\"undefined\"!=typeof c&&(c=c.v),\"undefined\"!=typeof d&&(d=d.v),\"undefined\"!=typeof e&&(e=e.v),a.v=j.processing.color(b.v,c,d,e)})},j.color=Sk.misceval.buildClass(j,c,\"color\",[]),j.red=new Sk.builtin.func(function(a){return new Sk.builtin.int_(j.processing.red(a.v))}),j.green=new Sk.builtin.func(function(a){return new Sk.builtin.int_(j.processing.green(a.v))}),j.blue=new Sk.builtin.func(function(a){return new Sk.builtin.int_(j.processing.blue(a.v))}),b=function(a,b){b.__init__=new Sk.builtin.func(function(a,b,c,d){a.v=\"undefined\"==typeof b?new j.processing.PImage:\"undefined\"==typeof c?new j.processing.PImage(b.v):\"undefined\"==typeof d?new j.processing.PImage(b.v,c.v):new j.processing.PImage(b.v,c.v,d.v)}),b.__getattr__=new Sk.builtin.func(function(a,b){return b=Sk.ffi.remapToJs(b),\"width\"===b?Sk.builtin.assk$(a.v.width):\"height\"===b?Sk.builtin.assk$(a.v.height):void 0})},j.loadImage=new Sk.builtin.func(function(a){var b=j.processing.loadImage(a.v);k.push(b);var c=Sk.misceval.callsimArray(j.PImage);return c.v=b,c}),j.image=new Sk.builtin.func(function(a,b,c,d,e){\"undefined\"==typeof d?j.processing.image(a.v,b.v,c.v):j.processing.image(a.v,b.v,c.v,d.v,e.v)}),j.get=new Sk.builtin.func(function(a,b){var c=j.processing.get(a.v,b.v);return Sk.misceval.callsimArray(j.color,[new Sk.builtin.int_(j.processing.red(c)),new Sk.builtin.int_(j.processing.green(c)),new Sk.builtin.int_(j.processing.blue(c))])}),j.set=new Sk.builtin.func(function(a,b,c){j.processing.set(a.v,b.v,c.v)}),h=function(a,b){b.__init__=new Sk.builtin.func(function(a,b,c,d){a.v=\"undefined\"==typeof b?new j.processing.PVector:\"undefined\"==typeof d?new j.processing.PVector(b.v,c.v):new j.processing.PVector(b.v,c.v,d.v)}),b.__getattr__=new Sk.builtin.func(function(a,b){return(b=Sk.ffi.remapToJs(b),\"x\"===b)?Sk.builtin.assk$(a.v.x):\"y\"===b?Sk.builtin.assk$(a.v.y):\"z\"===b?Sk.builtin.assk$(a.v.z):void 0}),b.get=new Sk.builtin.func(function(a){var b=Sk.misceval.callsimArray(j.PVector);return b.v=a.v.get(),b}),b.set=new Sk.builtin.func(function(a,b,c,b){\"undefined\"==typeof z?a.v.set(b.v,c.v):a.v.set(b.v,c.v,z.v)}),b.mag=new Sk.builtin.func(function(a){return Sk.builtin.assk$(a.v.mag())}),b.add=new Sk.builtin.func(function(a,b){var c=Sk.misceval.callsimArray(j.PVector);return c.v=a.v.add(b.v),c}),b.sub=new Sk.builtin.func(function(a,b){var c=Sk.misceval.callsimArray(j.PVector);return c.v=a.v.sub(b.v),c}),b.mult=new Sk.builtin.func(function(a,b){var c=Sk.misceval.callsimArray(j.PVector);return c.v=a.v.mult(b.v),c}),b.div=new Sk.builtin.func(function(a,b){var c=Sk.misceval.callsimArray(j.PVector);return c.v=a.v.dic(b.v),c}),b.dist=new Sk.builtin.func(function(a,b){return Sk.builtin.assk$(a.v.dist(b.v))}),b.dot=new Sk.builtin.func(function(a,b,c,d){return\"undefined\"==typeof c?Sk.builtin.assk$(a.v.dot(b.v)):Sk.builtin.assk$(a.v.dot(b.v,c.v,d.v))}),b.cross=new Sk.builtin.func(function(a,b){var c=Sk.misceval.callsimArray(j.PVector);return c.v=a.v.cross(b.v),c}),b.normalize=new Sk.builtin.func(function(a){a.v.normalize()}),b.limit=new Sk.builtin.func(function(a,b){a.v.limit(b.v)}),b.angleBetween=new Sk.builtin.func(function(a,b){return Sk.builtin.assk$(a.v.angleBetween(b.v))}),b.array=new Sk.builtin.func(function(a){return new Sk.builtin.list(a.v.array())})},fontClass=function(a,b){b.__init__=new Sk.builtin.func(function(a,b){a.v=\"undefined\"==typeof b?new j.processing.PFont:new j.processing.PVector(b.v)}),b.list=new Sk.builtin.func(function(a){return new Sk.builtin.list(a.v.list())})},graphicsClass=function(a,b){b.__init__=new Sk.builtin.func(function(a,b,c,d){a.v=\"undefined\"==typeof b?new j.processing.PVector:\"undefined\"==typeof d?new j.processing.PVector(b.v,c.v):new j.processing.PVector(b.v,c.v,d.v)}),b.beginDraw=new Sk.builtin.func(function(a){a.v.beginDraw()}),b.endDraw=new Sk.builtin.func(function(a){a.v.endDraw()})},shapeClass=function(a,b){b.__init__=new Sk.builtin.func(function(a,b,c,d){a.v=\"undefined\"==typeof b?null:\"undefined\"==typeof c?new j.processing.PShapeSVG(b.v):\"undefined\"==typeof d?new j.processing.PShapeSVG(b.v,c.v):new j.processing.PShapeSVG(b.v,c.v,d.v)}),b.__getattr__=new Sk.builtin.func(function(a,b){return(b=Sk.ffi.remapToJs(b),\"width\"===b)?Sk.builtin.assk$(a.v.width):\"height\"===b?Sk.builtin.assk$(a.v.height):void 0}),b.isVisible=new Sk.builtin.func(function(a){return new Sk.builtin.bool(a.v.isVisible())}),b.setVisible=new Sk.builtin.func(function(a,b){a.v.setVisible(b.v)}),b.disableStyle=new Sk.builtin.func(function(a){a.v.disableStyle()}),b.enableStyle=new Sk.builtin.func(function(a){a.v.enableStyle()}),b.getChild=new Sk.builtin.func(function(a,b){var c=a.v.getChild(b.v);if(null!=c){var d=Sk.misceval.callsimArray(j.PShapeSVG);return d.v=c,d}return null}),b.translate=new Sk.builtin.func(function(a,b,c,d){\"undefined\"==typeof d?a.v.translate(b.v,c.v):a.v.translate(b.v,c.v,d.v)}),b.rotate=new Sk.builtin.func(function(a,b){a.v.rotate(b.v)}),b.rotateX=new Sk.builtin.func(function(a,b){a.v.rotateX(b.v)}),b.rotateY=new Sk.builtin.func(function(a){a.v.rotateY(angle.v)}),b.rotateZ=new Sk.builtin.func(function(a){a.v.rotateZ(angle.v)}),b.scale=new Sk.builtin.func(function(a,b,c,d){\"undefined\"==typeof c?a.v.scale(b.v):\"undefined\"==typeof d?a.v.scale(b.v,c.v):a.v.scale(b.v,c.v,d.v)})},j.PFont=Sk.misceval.buildClass(j,fontClass,\"PFont\",[]),j.PGraphics=Sk.misceval.buildClass(j,graphicsClass,\"PGraphics\",[]),j.PShapeSVG=Sk.misceval.buildClass(j,shapeClass,\"PShapeSVG\",[]),j.PVector=Sk.misceval.buildClass(j,h,\"PVector\",[]),j.PImage=Sk.misceval.buildClass(j,b,\"PImage\",[]),j};","src/lib/profile.py":"raise NotImplementedError(\"profile is not yet implemented in Skulpt\")\n","src/lib/pstats.py":"raise NotImplementedError(\"pstats is not yet implemented in Skulpt\")\n","src/lib/pty.py":"raise NotImplementedError(\"pty is not yet implemented in Skulpt\")\n","src/lib/py_compile.py":"raise NotImplementedError(\"py_compile is not yet implemented in Skulpt\")\n","src/lib/pyclbr.py":"raise NotImplementedError(\"pyclbr is not yet implemented in Skulpt\")\n","src/lib/pydoc.py":"raise NotImplementedError(\"pydoc is not yet implemented in Skulpt\")\n","src/lib/pydoc_topics.py":"raise NotImplementedError(\"pydoc_topics is not yet implemented in Skulpt\")\n","src/lib/pythonds/__init__.py":"","src/lib/pythonds/basic/__init__.py":"\n#__all__ = [\"stack\"]\n\n\n#from .stack import Stack\n#from .queue import Queue\n\n\n\n","src/lib/pythonds/basic/deque.py":"# Bradley N. Miller, David L. Ranum\n# Introduction to Data Structures and Algorithms in Python\n# Copyright 2005\n# \n#deque.py\r\n\r\n\r\nclass Deque:\r\n    def __init__(self):\r\n        self.items = []\r\n\r\n    def isEmpty(self):\r\n        return self.items == []\r\n\r\n    def addFront(self, item):\r\n        self.items.append(item)\r\n\r\n    def addRear(self, item):\r\n        self.items.insert(0,item)\r\n\r\n    def removeFront(self):\r\n        return self.items.pop()\r\n\r\n    def removeRear(self):\r\n        return self.items.pop(0)\r\n\r\n    def size(self):\r\n        return len(self.items)\r\n","src/lib/pythonds/basic/queue.py":"# Bradley N. Miller, David L. Ranum\n# Introduction to Data Structures and Algorithms in Python\n# Copyright 2005\n# \n#queue.py\r\n\r\nclass Queue:\r\n    def __init__(self):\r\n        self.items = []\r\n\r\n    def isEmpty(self):\r\n        return self.items == []\r\n\r\n    def enqueue(self, item):\r\n        self.items.insert(0,item)\r\n\r\n    def dequeue(self):\r\n        return self.items.pop()\r\n\r\n    def size(self):\r\n        return len(self.items)\r\n","src/lib/pythonds/basic/stack.py":"# Bradley N. Miller, David L. Ranum\n# Introduction to Data Structures and Algorithms in Python\n# Copyright 2005\n# \n#stack.py\r\n\r\nclass Stack:\r\n    def __init__(self):\r\n        self.items = []\r\n\r\n    def isEmpty(self):\r\n        return self.items == []\r\n\r\n    def push(self, item):\r\n        self.items.append(item)\r\n\r\n    def pop(self):\r\n        return self.items.pop()\r\n\r\n    def peek(self):\r\n        return self.items[len(self.items)-1]\r\n\r\n    def size(self):\r\n        return len(self.items)\r\n\r\n","src/lib/pythonds/graphs/__init__.py":"\n\nfrom .adjGraph import Graph\nfrom .adjGraph import Vertex\nfrom .priorityQueue import PriorityQueue\n","src/lib/pythonds/graphs/adjGraph.py":"#\n#  adjGraph\n#\n#  Created by Brad Miller on 2005-02-24.\n#  Copyright (c) 2005 Brad Miller, David Ranum, Luther College. All rights reserved.\n#\n\nimport sys\nimport os\nimport unittest\n\nclass Graph:\n    def __init__(self):\n        self.vertices = {}\n        self.numVertices = 0\n        \n    def addVertex(self,key):\n        self.numVertices = self.numVertices + 1\n        newVertex = Vertex(key)\n        self.vertices[key] = newVertex\n        return newVertex\n    \n    def getVertex(self,n):\n        if n in self.vertices:\n            return self.vertices[n]\n        else:\n            return None\n\n    def __contains__(self,n):\n        return n in self.vertices\n    \n    def addEdge(self,f,t,cost=0):\n            if f not in self.vertices:\n                nv = self.addVertex(f)\n            if t not in self.vertices:\n                nv = self.addVertex(t)\n            self.vertices[f].addNeighbor(self.vertices[t],cost)\n    \n    def getVertices(self):\n        return list(self.vertices.keys())\n        \n    def __iter__(self):\n        return iter(self.vertices.values())\n                \nclass Vertex:\n    def __init__(self,num):\n        self.id = num\n        self.connectedTo = {}\n        self.color = 'white'\n        self.dist = sys.maxsize\n        self.pred = None\n        self.disc = 0\n        self.fin = 0\n\n    # def __lt__(self,o):\n    #     return self.id < o.id\n    \n    def addNeighbor(self,nbr,weight=0):\n        self.connectedTo[nbr] = weight\n        \n    def setColor(self,color):\n        self.color = color\n        \n    def setDistance(self,d):\n        self.dist = d\n\n    def setPred(self,p):\n        self.pred = p\n\n    def setDiscovery(self,dtime):\n        self.disc = dtime\n        \n    def setFinish(self,ftime):\n        self.fin = ftime\n        \n    def getFinish(self):\n        return self.fin\n        \n    def getDiscovery(self):\n        return self.disc\n        \n    def getPred(self):\n        return self.pred\n        \n    def getDistance(self):\n        return self.dist\n        \n    def getColor(self):\n        return self.color\n    \n    def getConnections(self):\n        return self.connectedTo.keys()\n        \n    def getWeight(self,nbr):\n        return self.connectedTo[nbr]\n                \n    def __str__(self):\n        return str(self.id) + \":color \" + self.color + \":disc \" + str(self.disc) + \":fin \" + str(self.fin) + \":dist \" + str(self.dist) + \":pred \\n\\t[\" + str(self.pred)+ \"]\\n\"\n    \n    def getId(self):\n        return self.id\n\nclass adjGraphTests(unittest.TestCase):\n    def setUp(self):\n        self.tGraph = Graph()\n        \n    def testMakeGraph(self):\n        gFile = open(\"test.dat\")\n        for line in gFile:\n            fVertex, tVertex = line.split('|')\n            fVertex = int(fVertex)\n            tVertex = int(tVertex)\n            self.tGraph.addEdge(fVertex,tVertex)\n        for i in self.tGraph:\n            adj = i.getAdj()\n            for k in adj:\n                print(i, k)\n\n        \nif __name__ == '__main__':\n    unittest.main()\n              \n","src/lib/pythonds/graphs/priorityQueue.py":"# Bradley N. Miller, David L. Ranum\n# Introduction to Data Structures and Algorithms in Python\n# Copyright 2005\n# \nimport unittest\n\n# this implementation of binary heap takes key value pairs,\n# we will assume that the keys are all comparable\n\nclass PriorityQueue:\n    def __init__(self):\n        self.heapArray = [(0,0)]\n        self.currentSize = 0\n\n    def buildHeap(self,alist):\n        self.currentSize = len(alist)\n        self.heapArray = [(0,0)]\n        for i in alist:\n            self.heapArray.append(i)\n        i = len(alist) // 2            \n        while (i > 0):\n            self.percDown(i)\n            i = i - 1\n                        \n    def percDown(self,i):\n        while (i * 2) <= self.currentSize:\n            mc = self.minChild(i)\n            if self.heapArray[i][0] > self.heapArray[mc][0]:\n                tmp = self.heapArray[i]\n                self.heapArray[i] = self.heapArray[mc]\n                self.heapArray[mc] = tmp\n            i = mc\n                \n    def minChild(self,i):\n        if i*2 > self.currentSize:\n            return -1\n        else:\n            if i*2 + 1 > self.currentSize:\n                return i*2\n            else:\n                if self.heapArray[i*2][0] < self.heapArray[i*2+1][0]:\n                    return i*2\n                else:\n                    return i*2+1\n\n    def percUp(self,i):\n        while i // 2 > 0:\n            if self.heapArray[i][0] < self.heapArray[i//2][0]:\n               tmp = self.heapArray[i//2]\n               self.heapArray[i//2] = self.heapArray[i]\n               self.heapArray[i] = tmp\n            i = i//2\n \n    def add(self,k):\n        self.heapArray.append(k)\n        self.currentSize = self.currentSize + 1\n        self.percUp(self.currentSize)\n\n    def delMin(self):\n        retval = self.heapArray[1][1]\n        self.heapArray[1] = self.heapArray[self.currentSize]\n        self.currentSize = self.currentSize - 1\n        self.heapArray.pop()\n        self.percDown(1)\n        return retval\n        \n    def isEmpty(self):\n        if self.currentSize == 0:\n            return True\n        else:\n            return False\n\n    def decreaseKey(self,val,amt):\n        # this is a little wierd, but we need to find the heap thing to decrease by\n        # looking at its value\n        done = False\n        i = 1\n        myKey = 0\n        while not done and i <= self.currentSize:\n            if self.heapArray[i][1] == val:\n                done = True\n                myKey = i\n            else:\n                i = i + 1\n        if myKey > 0:\n            self.heapArray[myKey] = (amt,self.heapArray[myKey][1])\n            self.percUp(myKey)\n            \n    def __contains__(self,vtx):\n        for pair in self.heapArray:\n            if pair[1] == vtx:\n                return True\n        return False\n        \nclass TestBinHeap(unittest.TestCase):\n    def setUp(self):\n        self.theHeap = PriorityQueue()\n        self.theHeap.add((2,'x'))\n        self.theHeap.add((3,'y'))\n        self.theHeap.add((5,'z'))\n        self.theHeap.add((6,'a'))\n        self.theHeap.add((4,'d'))\n\n\n    def testInsert(self):\n        assert self.theHeap.currentSize == 5\n\n    def testDelmin(self):\n        assert self.theHeap.delMin() == 'x'\n        assert self.theHeap.delMin() == 'y'\n    \n    def testDecKey(self):\n        self.theHeap.decreaseKey('d',1)\n        assert self.theHeap.delMin() == 'd'\n        \nif __name__ == '__main__':\n    unittest.main()\n","src/lib/pythonds/trees/__init__.py":"\n# from .binaryTree import BinaryTree\n# from .balance import AVLTree\n# from .bst import BinarySearchTree\n# from .binheap import BinHeap\n\n\n","src/lib/pythonds/trees/balance.py":"#!/bin/env python3.1\n# Bradley N. Miller, David L. Ranum\n# Introduction to Data Structures and Algorithms in Python\n# Copyright 2005, 2010\n# \n\nfrom .bst import BinarySearchTree, TreeNode\n\nclass AVLTree(BinarySearchTree):\n    '''\n    Author:  Brad Miller\n    Date:  1/15/2005\n    Description:  Imlement a binary search tree with the following interface\n                  functions:  \n                  __contains__(y) <==> y in x\n                  __getitem__(y) <==> x[y]\n                  __init__()\n                  __len__() <==> len(x)\n                  __setitem__(k,v) <==> x[k] = v\n                  clear()\n                  get(k)\n                  has_key(k)\n                  items() \n                  keys() \n                  values()\n                  put(k,v)\n    '''\n\n\n    def _put(self,key,val,currentNode):\n        if key < currentNode.key:\n            if currentNode.hasLeftChild():\n                self._put(key,val,currentNode.leftChild)\n            else:\n                currentNode.leftChild = TreeNode(key,val,parent=currentNode)\n                self.updateBalance(currentNode.leftChild)\n        else:\n            if currentNode.hasRightChild():\n                self._put(key,val,currentNode.rightChild)\n            else:\n                currentNode.rightChild = TreeNode(key,val,parent=currentNode)\n                self.updateBalance(currentNode.rightChild)                \n\n    def updateBalance(self,node):\n        if node.balanceFactor > 1 or node.balanceFactor < -1:\n            self.rebalance(node)\n            return\n        if node.parent != None:\n            if node.isLeftChild():\n                node.parent.balanceFactor += 1\n            elif node.isRightChild():\n                node.parent.balanceFactor -= 1\n\n            if node.parent.balanceFactor != 0:\n                self.updateBalance(node.parent)\n\n    def rebalance(self,node):\n        if node.balanceFactor < 0:\n            if node.rightChild.balanceFactor > 0:\n                # Do an LR Rotation\n                self.rotateRight(node.rightChild)\n                self.rotateLeft(node)\n            else:\n                # single left\n                self.rotateLeft(node)\n        elif node.balanceFactor > 0:\n            if node.leftChild.balanceFactor < 0:\n                # Do an RL Rotation\n                self.rotateLeft(node.leftChild)\n                self.rotateRight(node)\n            else:\n                # single right\n                self.rotateRight(node)\n\n    def rotateLeft(self,rotRoot):\n        newRoot = rotRoot.rightChild\n        rotRoot.rightChild = newRoot.leftChild\n        if newRoot.leftChild != None:\n            newRoot.leftChild.parent = rotRoot\n        newRoot.parent = rotRoot.parent\n        if rotRoot.isRoot():\n            self.root = newRoot\n        else:\n            if rotRoot.isLeftChild():\n                rotRoot.parent.leftChild = newRoot\n            else:\n                rotRoot.parent.rightChild = newRoot\n        newRoot.leftChild = rotRoot\n        rotRoot.parent = newRoot\n        rotRoot.balanceFactor = rotRoot.balanceFactor + 1 - min(newRoot.balanceFactor, 0)\n        newRoot.balanceFactor = newRoot.balanceFactor + 1 + max(rotRoot.balanceFactor, 0)\n\n\n    def rotateRight(self,rotRoot):\n        newRoot = rotRoot.leftChild\n        rotRoot.leftChild = newRoot.rightChild\n        if newRoot.rightChild != None:\n            newRoot.rightChild.parent = rotRoot\n        newRoot.parent = rotRoot.parent\n        if rotRoot.isRoot():\n            self.root = newRoot\n        else:\n            if rotRoot.isRightChild():\n                rotRoot.parent.rightChild = newRoot\n            else:\n                rotRoot.parent.leftChild = newRoot\n        newRoot.rightChild = rotRoot\n        rotRoot.parent = newRoot\n        rotRoot.balanceFactor = rotRoot.balanceFactor - 1 - max(newRoot.balanceFactor, 0)\n        newRoot.balanceFactor = newRoot.balanceFactor - 1 + min(rotRoot.balanceFactor, 0)\n        \n","src/lib/pythonds/trees/binaryTree.py":"# Bradley N. Miller, David L. Ranum\n# Introduction to Data Structures and Algorithms in Python\n# Copyright 2005\n# \n\nclass BinaryTree:\n    \"\"\"\n    A recursive implementation of Binary Tree\n    Using links and Nodes approach.\n    \"\"\"    \n    def __init__(self,rootObj):\n        self.key = rootObj\n        self.leftChild = None\n        self.rightChild = None\n\n    def insertLeft(self,newNode):\n        if self.leftChild == None:\n            self.leftChild = BinaryTree(newNode)\n        else:\n            t = BinaryTree(newNode)\n            t.left = self.leftChild\n            self.leftChild = t\n    \n    def insertRight(self,newNode):\n        if self.rightChild == None:\n            self.rightChild = BinaryTree(newNode)\n        else:\n            t = BinaryTree(newNode)\n            t.right = self.rightChild\n            self.rightChild = t\n\n    def isLeaf(self):\n        return ((not self.leftChild) and (not self.rightChild))\n\n    def getRightChild(self):\n        return self.rightChild\n\n    def getLeftChild(self):\n        return self.leftChild\n\n    def setRootVal(self,obj):\n        self.key = obj\n\n    def getRootVal(self,):\n        return self.key\n\n    def inorder(self):\n        if self.leftChild:\n            self.leftChild.inorder()\n        print(self.key)\n        if self.rightChild:\n            self.rightChild.inorder()\n\n    def postorder(self):\n        if self.leftChild:\n            self.leftChild.postorder()\n        if self.rightChild:\n            self.rightChild.postorder()\n        print(self.key)\n\n\n    def preorder(self):\n        print(self.key)\n        if self.leftChild:\n            self.leftChild.preorder()\n        if self.rightChild:\n            self.rightChild.preorder()\n\n    def printexp(self):\n        if self.leftChild:\n            print('(')\n            self.leftChild.printexp()\n        print(self.key)\n        if self.rightChild:\n            self.rightChild.printexp()\n            print(')')\n\n    def postordereval(self):\n        opers = {'+':operator.add, '-':operator.sub, '*':operator.mul, '/':operator.truediv}\n        res1 = None\n        res2 = None\n        if self.leftChild:\n            res1 = self.leftChild.postordereval()  #// \\label{peleft}\n        if self.rightChild:\n            res2 = self.rightChild.postordereval() #// \\label{peright}\n        if res1 and res2:\n            return opers[self.key](res1,res2) #// \\label{peeval}\n        else:\n            return self.key\n\ndef inorder(tree):\n    if tree != None:\n        inorder(tree.getLeftChild())\n        print(tree.getRootVal())\n        inorder(tree.getRightChild())\n\ndef printexp(tree):\n    if tree.leftChild:\n        print('(')\n        printexp(tree.getLeftChild())\n    print(tree.getRootVal())\n    if tree.rightChild:\n        printexp(tree.getRightChild())\n        print(')') \n\ndef printexp(tree):\n    sVal = \"\"\n    if tree:\n        sVal = '(' + printexp(tree.getLeftChild())\n        sVal = sVal + str(tree.getRootVal())\n        sVal = sVal + printexp(tree.getRightChild()) + ')'\n    return sVal\n\ndef postordereval(tree):\n    opers = {'+':operator.add, '-':operator.sub, '*':operator.mul, '/':operator.truediv}\n    res1 = None\n    res2 = None\n    if tree:\n        res1 = postordereval(tree.getLeftChild())  #// \\label{peleft}\n        res2 = postordereval(tree.getRightChild()) #// \\label{peright}\n        if res1 and res2:\n            return opers[tree.getRootVal()](res1,res2) #// \\label{peeval}\n        else:\n            return tree.getRootVal()\n\ndef height(tree):\n    if tree == None:\n        return -1\n    else:\n        return 1 + max(height(tree.leftChild),height(tree.rightChild))\n\n# t = BinaryTree(7)\n# t.insertLeft(3)\n# t.insertRight(9)\n# inorder(t)\n# import operator\n# x = BinaryTree('*')\n# x.insertLeft('+')\n# l = x.getLeftChild()\n# l.insertLeft(4)\n# l.insertRight(5)\n# x.insertRight(7)\n# print(printexp(x))\n# print(postordereval(x))\n# print(height(x))\n","src/lib/pythonds/trees/binheap.py":"# Bradley N. Miller, David L. Ranum\n# Introduction to Data Structures and Algorithms in Python\n# Copyright 2005\n# \n\n# this heap takes key value pairs, we will assume that the keys are integers\nclass BinHeap:\n    def __init__(self):\n        self.heapList = [0]\n        self.currentSize = 0\n\n\n    def buildHeap(self,alist):\n        i = len(alist) // 2\n        self.currentSize = len(alist)\n        self.heapList = [0] + alist[:]\n        print(len(self.heapList), i)\n        while (i > 0):\n            print(self.heapList, i)\n            self.percDown(i)\n            i = i - 1\n        print(self.heapList,i)\n                        \n    def percDown(self,i):\n        while (i * 2) <= self.currentSize:\n            mc = self.minChild(i)\n            if self.heapList[i] > self.heapList[mc]:\n                tmp = self.heapList[i]\n                self.heapList[i] = self.heapList[mc]\n                self.heapList[mc] = tmp\n            i = mc\n                \n    def minChild(self,i):\n        if i * 2 + 1 > self.currentSize:\n            return i * 2\n        else:\n            if self.heapList[i * 2] < self.heapList[i * 2 + 1]:\n                return i * 2\n            else:\n                return i * 2 + 1\n\n    def percUp(self,i):\n        while i // 2 > 0:\n            if self.heapList[i] < self.heapList[i//2]:\n               tmp = self.heapList[i // 2]\n               self.heapList[i // 2] = self.heapList[i]\n               self.heapList[i] = tmp\n            i = i // 2\n \n    def insert(self,k):\n        self.heapList.append(k)\n        self.currentSize = self.currentSize + 1\n        self.percUp(self.currentSize)\n\n    def delMin(self):\n        retval = self.heapList[1]\n        self.heapList[1] = self.heapList[self.currentSize]\n        self.currentSize = self.currentSize - 1\n        self.heapList.pop()\n        self.percDown(1)\n        return retval\n        \n    def isEmpty(self):\n        if currentSize == 0:\n            return True\n        else:\n            return False\n","src/lib/pythonds/trees/bst.py":"#!/bin/env python3.1\n# Bradley N. Miller, David L. Ranum\n# Introduction to Data Structures and Algorithms in Python\n# Copyright 2005, 2010\n# \n\nclass BinarySearchTree:\n    '''\n    Author:  Brad Miller\n    Date:  1/15/2005\n    Description:  Imlement a binary search tree with the following interface\n                  functions:  \n                  __contains__(y) <==> y in x\n                  __getitem__(y) <==> x[y]\n                  __init__()\n                  __len__() <==> len(x)\n                  __setitem__(k,v) <==> x[k] = v\n                  clear()\n                  get(k)\n                  items() \n                  keys() \n                  values()\n                  put(k,v)\n                  in\n                  del <==> \n    '''\n\n    def __init__(self):\n        self.root = None\n        self.size = 0\n    \n    def put(self,key,val):\n        if self.root:\n            self._put(key,val,self.root)\n        else:\n            self.root = TreeNode(key,val)\n        self.size = self.size + 1\n\n    def _put(self,key,val,currentNode):\n        if key < currentNode.key:\n            if currentNode.hasLeftChild():\n                self._put(key,val,currentNode.leftChild)\n            else:\n                currentNode.leftChild = TreeNode(key,val,parent=currentNode)\n        else:\n            if currentNode.hasRightChild():\n                self._put(key,val,currentNode.rightChild)\n            else:\n                currentNode.rightChild = TreeNode(key,val,parent=currentNode)\n            \n    def __setitem__(self,k,v):\n        self.put(k,v)\n\n    def get(self,key):\n        if self.root:\n            res = self._get(key,self.root)\n            if res:\n                return res.payload\n            else:\n                return None\n        else:\n            return None\n        \n    def _get(self,key,currentNode):\n        if not currentNode:\n            return None\n        elif currentNode.key == key:\n            return currentNode\n        elif key < currentNode.key:\n            return self._get(key,currentNode.leftChild)\n        else:\n            return self._get(key,currentNode.rightChild)\n            \n        \n    def __getitem__(self,key):\n        res = self.get(key)\n        if res:\n            return res\n        else:\n            raise KeyError('Error, key not in tree')\n            \n\n    def __contains__(self,key):\n        if self._get(key,self.root):\n            return True\n        else:\n            return False\n        \n    def length(self):\n        return self.size\n\n    def __len__(self):\n        return self.size\n\n    def __iter__(self):\n        return self.root.__iter__()\n    \n    def delete(self,key):\n        if self.size > 1:\n            nodeToRemove = self._get(key,self.root)\n            if nodeToRemove:\n                self.remove(nodeToRemove)\n                self.size = self.size-1\n            else:\n                raise KeyError('Error, key not in tree')\n        elif self.size == 1 and self.root.key == key:\n            self.root = None\n            self.size = self.size - 1\n        else:\n            raise KeyError('Error, key not in tree')\n\n    def __delitem__(self,key):\n        self.delete(key)\n    \n    def remove(self,currentNode):\n        if currentNode.isLeaf(): #leaf\n            if currentNode == currentNode.parent.leftChild:\n                currentNode.parent.leftChild = None\n            else:\n                currentNode.parent.rightChild = None\n        elif currentNode.hasBothChildren(): #interior\n            succ = currentNode.findSuccessor()\n            succ.spliceOut()\n            currentNode.key = succ.key\n            currentNode.payload = succ.payload\n        else: # this node has one child\n            if currentNode.hasLeftChild():\n                if currentNode.isLeftChild():\n                    currentNode.leftChild.parent = currentNode.parent\n                    currentNode.parent.leftChild = currentNode.leftChild\n                elif currentNode.isRightChild():\n                    currentNode.leftChild.parent = currentNode.parent\n                    currentNode.parent.rightChild = currentNode.leftChild\n                else:\n                    currentNode.replaceNodeData(currentNode.leftChild.key,\n                                       currentNode.leftChild.payload,\n                                       currentNode.leftChild.leftChild,\n                                       currentNode.leftChild.rightChild)\n            else:\n                if currentNode.isLeftChild():\n                    currentNode.rightChild.parent = currentNode.parent\n                    currentNode.parent.leftChild = currentNode.rightChild\n                elif currentNode.isRightChild():\n                    currentNode.rightChild.parent = currentNode.parent\n                    currentNode.parent.rightChild = currentNode.rightChild\n                else:\n                    currentNode.replaceNodeData(currentNode.rightChild.key,\n                                       currentNode.rightChild.payload,\n                                       currentNode.rightChild.leftChild,\n                                       currentNode.rightChild.rightChild)\n\n    def inorder(self):\n        self._inorder(self.root)\n\n    def _inorder(self,tree):\n        if tree != None:\n            self._inorder(tree.leftChild)\n            print(tree.key)\n            self._inorder(tree.rightChild)\n\n    def postorder(self):\n        self._postorder(self.root)\n\n    def _postorder(self, tree):\n        if tree:\n            self._postorder(tree.rightChild)\n            self._postorder(tree.leftChild)\n            print(tree.key)            \n\n    def preorder(self):\n        self._preorder(self,self.root)\n\n    def _preorder(self,tree):\n        if tree:\n            print(tree.key)            \n            self._preorder(tree.leftChild)\n            self._preorder(tree.rightChild)\n\n                \nclass TreeNode:\n    def __init__(self,key,val,left=None,right=None,parent=None):\n        self.key = key\n        self.payload = val\n        self.leftChild = left\n        self.rightChild = right\n        self.parent = parent\n        self.balanceFactor = 0\n        \n    def hasLeftChild(self):\n        return self.leftChild\n\n    def hasRightChild(self):\n        return self.rightChild\n    \n    def isLeftChild(self):\n        return self.parent and self.parent.leftChild == self\n\n    def isRightChild(self):\n        return self.parent and self.parent.rightChild == self\n\n    def isRoot(self):\n        return not self.parent\n\n    def isLeaf(self):\n        return not (self.rightChild or self.leftChild)\n\n    def hasAnyChildren(self):\n        return self.rightChild or self.leftChild\n\n    def hasBothChildren(self):\n        return self.rightChild and self.leftChild\n    \n    def replaceNodeData(self,key,value,lc,rc):\n        self.key = key\n        self.payload = value\n        self.leftChild = lc\n        self.rightChild = rc\n        if self.hasLeftChild():\n            self.leftChild.parent = self\n        if self.hasRightChild():\n            self.rightChild.parent = self\n        \n    def findSuccessor(self):\n        succ = None\n        if self.hasRightChild():\n            succ = self.rightChild.findMin()\n        else:\n            if self.parent:\n                if self.isLeftChild():\n                    succ = self.parent\n                else:\n                    self.parent.rightChild = None\n                    succ = self.parent.findSuccessor()\n                    self.parent.rightChild = self\n        return succ\n\n\n    def spliceOut(self):\n        if self.isLeaf():\n            if self.isLeftChild():\n                self.parent.leftChild = None\n            else:\n                self.parent.rightChild = None\n        elif self.hasAnyChildren():\n            if self.hasLeftChild():\n                if self.isLeftChild():\n                    self.parent.leftChild = self.leftChild\n                else:\n                    self.parent.rightChild = self.leftChild\n                self.leftChild.parent = self.parent\n            else:\n                if self.isLeftChild():\n                    self.parent.leftChild = self.rightChild\n                else:\n                    self.parent.rightChild = self.rightChild\n                self.rightChild.parent = self.parent\n\n    def findMin(self):\n        current = self\n        while current.hasLeftChild():\n            current = current.leftChild\n        return current\n\n    def __iter__(self):\n        \"\"\"The standard inorder traversal of a binary tree.\"\"\"\n        if self:\n            if self.hasLeftChild():\n                for elem in self.leftChild:\n                    yield elem\n            yield self.key\n            if self.hasRightChild():\n                for elem in self.rightChild:\n                    yield elem\n\n            \n","src/lib/pytz/__init__.py":"'''\ndatetime.tzinfo timezone definitions generated from the\nOlson timezone database:\n\n    ftp://elsie.nci.nih.gov/pub/tz*.tar.gz\n\nSee the datetime section of the Python Library Reference for information\non how to use these modules.\n'''\n\nimport sys\nimport datetime\n''' import os.path '''\n\nfrom pytz.exceptions import AmbiguousTimeError\nfrom pytz.exceptions import InvalidTimeError\nfrom pytz.exceptions import NonExistentTimeError\nfrom pytz.exceptions import UnknownTimeZoneError\nfrom pytz.lazy import LazyDict, LazyList, LazySet\nfrom pytz.tzinfo import unpickler, BaseTzInfo\nfrom pytz.tzfile import build_tzinfo\n\n\n# The IANA (nee Olson) database is updated several times a year.\nOLSON_VERSION = '2018e'\nVERSION = '2018.5'  # pip compatible version number.\n__version__ = VERSION\n\nOLSEN_VERSION = OLSON_VERSION  # Old releases had this misspelling\n\n__all__ = [\n    'timezone', 'utc', 'country_timezones', 'country_names',\n    'AmbiguousTimeError', 'InvalidTimeError',\n    'NonExistentTimeError', 'UnknownTimeZoneError',\n    'all_timezones', 'all_timezones_set',\n    'common_timezones', 'common_timezones_set',\n    'BaseTzInfo',\n]\n\n\nif sys.version_info[0] > 2:  # Python 3.x\n\n    # Python 3.x doesn't have unicode(), making writing code\n    # for Python 2.3 and Python 3.x a pain.\n    unicode = str\n\n    def ascii(s):\n        r\"\"\"\n        >>> ascii('Hello')\n        'Hello'\n        >>> ascii('\\N{TRADE MARK SIGN}') #doctest: +IGNORE_EXCEPTION_DETAIL\n        Traceback (most recent call last):\n            ...\n        UnicodeEncodeError: ...\n        \"\"\"\n        if type(s) == bytes:\n            s = s.decode('ASCII')\n        else:\n            s.encode('ASCII')  # Raise an exception if not ASCII\n        return s  # But the string - not a byte string.\n\nelse:  # Python 2.x\n\n    def ascii(s):\n        r\"\"\"\n        >>> ascii('Hello')\n        'Hello'\n        >>> ascii(u'Hello')\n        'Hello'\n        >>> ascii(u'\\N{TRADE MARK SIGN}') #doctest: +IGNORE_EXCEPTION_DETAIL\n        Traceback (most recent call last):\n            ...\n        UnicodeEncodeError: ...\n        \"\"\"\n        return s.encode('ASCII')\n\n\ndef open_resource(name):\n    \"\"\"Open a resource from the zoneinfo subdir for reading.\n\n    Uses the pkg_resources module if available and no standard file\n    found at the calculated location.\n\n    It is possible to specify different location for zoneinfo\n    subdir by using the PYTZ_TZDATADIR environment variable.\n    \"\"\"\n    name_parts = name.lstrip('/').split('/')\n    for part in name_parts:\n        if part == os.path.pardir or os.path.sep in part:\n            raise ValueError('Bad path segment: %r' % part)\n    zoneinfo_dir = os.environ.get('PYTZ_TZDATADIR', None)\n    if zoneinfo_dir is not None:\n        filename = os.path.join(zoneinfo_dir, *name_parts)\n    else:\n        filename = os.path.join(os.path.dirname(__file__),\n                                'zoneinfo', *name_parts)\n        if not os.path.exists(filename):\n            # http://bugs.launchpad.net/bugs/383171 - we avoid using this\n            # unless absolutely necessary to help when a broken version of\n            # pkg_resources is installed.\n            try:\n                from pkg_resources import resource_stream\n            except ImportError:\n                resource_stream = None\n\n            if resource_stream is not None:\n                return resource_stream(__name__, 'zoneinfo/' + name)\n    return open(filename, 'rb')\n\n\ndef resource_exists(name):\n    \"\"\"Return true if the given resource exists\"\"\"\n    try:\n        open_resource(name).close()\n        return True\n    except IOError:\n        return False\n\n\n_tzinfo_cache = {}\n\n\ndef timezone(zone):\n    r''' Return a datetime.tzinfo implementation for the given timezone\n\n    >>> from datetime import datetime, timedelta\n    >>> utc = timezone('UTC')\n    >>> eastern = timezone('US/Eastern')\n    >>> eastern.zone\n    'US/Eastern'\n    >>> timezone(unicode('US/Eastern')) is eastern\n    True\n    >>> utc_dt = datetime(2002, 10, 27, 6, 0, 0, tzinfo=utc)\n    >>> loc_dt = utc_dt.astimezone(eastern)\n    >>> fmt = '%Y-%m-%d %H:%M:%S %Z (%z)'\n    >>> loc_dt.strftime(fmt)\n    '2002-10-27 01:00:00 EST (-0500)'\n    >>> (loc_dt - timedelta(minutes=10)).strftime(fmt)\n    '2002-10-27 00:50:00 EST (-0500)'\n    >>> eastern.normalize(loc_dt - timedelta(minutes=10)).strftime(fmt)\n    '2002-10-27 01:50:00 EDT (-0400)'\n    >>> (loc_dt + timedelta(minutes=10)).strftime(fmt)\n    '2002-10-27 01:10:00 EST (-0500)'\n\n    Raises UnknownTimeZoneError if passed an unknown zone.\n\n    >>> try:\n    ...     timezone('Asia/Shangri-La')\n    ... except UnknownTimeZoneError:\n    ...     print('Unknown')\n    Unknown\n\n    >>> try:\n    ...     timezone(unicode('\\N{TRADE MARK SIGN}'))\n    ... except UnknownTimeZoneError:\n    ...     print('Unknown')\n    Unknown\n\n    '''\n    if zone.upper() == 'UTC':\n        return utc\n\n    try:\n        zone = ascii(zone)\n    except UnicodeEncodeError:\n        # All valid timezones are ASCII\n        raise UnknownTimeZoneError(zone)\n\n    zone = _unmunge_zone(zone)\n    if zone not in _tzinfo_cache:\n        if zone in all_timezones_set:\n            fp = open_resource(zone)\n            try:\n                _tzinfo_cache[zone] = build_tzinfo(zone, fp)\n            finally:\n                fp.close()\n        else:\n            raise UnknownTimeZoneError(zone)\n\n    return _tzinfo_cache[zone]\n\n\ndef _unmunge_zone(zone):\n    \"\"\"Undo the time zone name munging done by older versions of pytz.\"\"\"\n    return zone.replace('_plus_', '+').replace('_minus_', '-')\n\n\nZERO = datetime.timedelta(0)\nHOUR = datetime.timedelta(hours=1)\n\n\nclass UTC(BaseTzInfo):\n    \"\"\"UTC\n\n    Optimized UTC implementation. It unpickles using the single module global\n    instance defined beneath this class declaration.\n    \"\"\"\n    zone = \"UTC\"\n\n    _utcoffset = ZERO\n    _dst = ZERO\n    _tzname = zone\n\n    def fromutc(self, dt):\n        if dt.tzinfo is None:\n            return self.localize(dt)\n        return super(utc.__class__, self).fromutc(dt)\n\n    def utcoffset(self, dt):\n        return ZERO\n\n    def tzname(self, dt):\n        return \"UTC\"\n\n    def dst(self, dt):\n        return ZERO\n\n    def __reduce__(self):\n        return _UTC, ()\n\n    def localize(self, dt, is_dst=False):\n        '''Convert naive time to local time'''\n        if dt.tzinfo is not None:\n            raise ValueError('Not naive datetime (tzinfo is already set)')\n        return dt.replace(tzinfo=self)\n\n    def normalize(self, dt, is_dst=False):\n        '''Correct the timezone information on the given datetime'''\n        if dt.tzinfo is self:\n            return dt\n        if dt.tzinfo is None:\n            raise ValueError('Naive time - no tzinfo set')\n        return dt.astimezone(self)\n\n    def __repr__(self):\n        return \"<UTC>\"\n\n    def __str__(self):\n        return \"UTC\"\n\n\nUTC = utc = UTC()  # UTC is a singleton\n\n\ndef _UTC():\n    \"\"\"Factory function for utc unpickling.\n\n    Makes sure that unpickling a utc instance always returns the same\n    module global.\n\n    These examples belong in the UTC class above, but it is obscured; or in\n    the README.txt, but we are not depending on Python 2.4 so integrating\n    the README.txt examples with the unit tests is not trivial.\n\n    >>> import datetime, pickle\n    >>> dt = datetime.datetime(2005, 3, 1, 14, 13, 21, tzinfo=utc)\n    >>> naive = dt.replace(tzinfo=None)\n    >>> p = pickle.dumps(dt, 1)\n    >>> naive_p = pickle.dumps(naive, 1)\n    >>> len(p) - len(naive_p)\n    17\n    >>> new = pickle.loads(p)\n    >>> new == dt\n    True\n    >>> new is dt\n    False\n    >>> new.tzinfo is dt.tzinfo\n    True\n    >>> utc is UTC is timezone('UTC')\n    True\n    >>> utc is timezone('GMT')\n    False\n    \"\"\"\n    return utc\n_UTC.__safe_for_unpickling__ = True\n\n\ndef _p(*args):\n    \"\"\"Factory function for unpickling pytz tzinfo instances.\n\n    Just a wrapper around tzinfo.unpickler to save a few bytes in each pickle\n    by shortening the path.\n    \"\"\"\n    return unpickler(*args)\n_p.__safe_for_unpickling__ = True\n\n\nclass _CountryTimezoneDict(LazyDict):\n    \"\"\"Map ISO 3166 country code to a list of timezone names commonly used\n    in that country.\n\n    iso3166_code is the two letter code used to identify the country.\n\n    >>> def print_list(list_of_strings):\n    ...     'We use a helper so doctests work under Python 2.3 -> 3.x'\n    ...     for s in list_of_strings:\n    ...         print(s)\n\n    >>> print_list(country_timezones['nz'])\n    Pacific/Auckland\n    Pacific/Chatham\n    >>> print_list(country_timezones['ch'])\n    Europe/Zurich\n    >>> print_list(country_timezones['CH'])\n    Europe/Zurich\n    >>> print_list(country_timezones[unicode('ch')])\n    Europe/Zurich\n    >>> print_list(country_timezones['XXX'])\n    Traceback (most recent call last):\n    ...\n    KeyError: 'XXX'\n\n    Previously, this information was exposed as a function rather than a\n    dictionary. This is still supported::\n\n    >>> print_list(country_timezones('nz'))\n    Pacific/Auckland\n    Pacific/Chatham\n    \"\"\"\n    def __call__(self, iso3166_code):\n        \"\"\"Backwards compatibility.\"\"\"\n        return self[iso3166_code]\n\n    def _fill(self):\n        data = {}\n        zone_tab = open_resource('zone.tab')\n        try:\n            for line in zone_tab:\n                line = line.decode('UTF-8')\n                if line.startswith('#'):\n                    continue\n                code, coordinates, zone = line.split(None, 4)[:3]\n                if zone not in all_timezones_set:\n                    continue\n                try:\n                    data[code].append(zone)\n                except KeyError:\n                    data[code] = [zone]\n            self.data = data\n        finally:\n            zone_tab.close()\n\ncountry_timezones = _CountryTimezoneDict()\n\n\nclass _CountryNameDict(LazyDict):\n    '''Dictionary proving ISO3166 code -> English name.\n\n    >>> print(country_names['au'])\n    Australia\n    '''\n    def _fill(self):\n        data = {}\n        zone_tab = open_resource('iso3166.tab')\n        try:\n            for line in zone_tab.readlines():\n                line = line.decode('UTF-8')\n                if line.startswith('#'):\n                    continue\n                code, name = line.split(None, 1)\n                data[code] = name.strip()\n            self.data = data\n        finally:\n            zone_tab.close()\n\ncountry_names = _CountryNameDict()\n\n\n# Time-zone info based solely on fixed offsets\n\nclass _FixedOffset(datetime.tzinfo):\n\n    zone = None  # to match the standard pytz API\n\n    def __init__(self, minutes):\n        if abs(minutes) >= 1440:\n            raise ValueError(\"absolute offset is too large\", minutes)\n        self._minutes = minutes\n        self._offset = datetime.timedelta(minutes=minutes)\n\n    def utcoffset(self, dt):\n        return self._offset\n\n    def __reduce__(self):\n        return FixedOffset, (self._minutes, )\n\n    def dst(self, dt):\n        return ZERO\n\n    def tzname(self, dt):\n        return None\n\n    def __repr__(self):\n        return 'pytz.FixedOffset(%d)' % self._minutes\n\n    def localize(self, dt, is_dst=False):\n        '''Convert naive time to local time'''\n        if dt.tzinfo is not None:\n            raise ValueError('Not naive datetime (tzinfo is already set)')\n        return dt.replace(tzinfo=self)\n\n    def normalize(self, dt, is_dst=False):\n        '''Correct the timezone information on the given datetime'''\n        if dt.tzinfo is self:\n            return dt\n        if dt.tzinfo is None:\n            raise ValueError('Naive time - no tzinfo set')\n        return dt.astimezone(self)\n\ndef FixedOffset(offset, _tzinfos={}):\n    \"\"\"return a fixed-offset timezone based off a number of minutes.\n\n        >>> one = FixedOffset(-330)\n        >>> one\n        pytz.FixedOffset(-330)\n        >>> str(one.utcoffset(datetime.datetime.now()))\n        '-1 day, 18:30:00'\n        >>> str(one.dst(datetime.datetime.now()))\n        '0:00:00'\n\n        >>> two = FixedOffset(1380)\n        >>> two\n        pytz.FixedOffset(1380)\n        >>> str(two.utcoffset(datetime.datetime.now()))\n        '23:00:00'\n        >>> str(two.dst(datetime.datetime.now()))\n        '0:00:00'\n\n    The datetime.timedelta must be between the range of -1 and 1 day,\n    non-inclusive.\n\n        >>> FixedOffset(1440)\n        Traceback (most recent call last):\n        ...\n        ValueError: ('absolute offset is too large', 1440)\n\n        >>> FixedOffset(-1440)\n        Traceback (most recent call last):\n        ...\n        ValueError: ('absolute offset is too large', -1440)\n\n    An offset of 0 is special-cased to return UTC.\n\n        >>> FixedOffset(0) is UTC\n        True\n\n    There should always be only one instance of a FixedOffset per timedelta.\n    This should be true for multiple creation calls.\n\n        >>> FixedOffset(-330) is one\n        True\n        >>> FixedOffset(1380) is two\n        True\n\n    It should also be true for pickling.\n\n        >>> import pickle\n        >>> pickle.loads(pickle.dumps(one)) is one\n        True\n        >>> pickle.loads(pickle.dumps(two)) is two\n        True\n    \"\"\"\n    if offset == 0:\n        return UTC\n\n    info = _tzinfos.get(offset)\n    if info is None:\n        # We haven't seen this one before. we need to save it.\n\n        # Use setdefault to avoid a race condition and make sure we have\n        # only one\n        info = _tzinfos.setdefault(offset, _FixedOffset(offset))\n\n    return info\n\nFixedOffset.__safe_for_unpickling__ = True\n\n\ndef _test():\n    import doctest\n    sys.path.insert(0, os.pardir)\n    import pytz\n    return doctest.testmod(pytz)\n\nif __name__ == '__main__':\n    _test()\n","src/lib/pytz/exceptions.py":"'''\nCustom exceptions raised by pytz.\n'''\n\n__all__ = [\n    'UnknownTimeZoneError', 'InvalidTimeError', 'AmbiguousTimeError',\n    'NonExistentTimeError',\n]\n\n\nclass UnknownTimeZoneError(KeyError):\n    '''Exception raised when pytz is passed an unknown timezone.\n\n    >>> isinstance(UnknownTimeZoneError(), LookupError)\n    True\n\n    This class is actually a subclass of KeyError to provide backwards\n    compatibility with code relying on the undocumented behavior of earlier\n    pytz releases.\n\n    >>> isinstance(UnknownTimeZoneError(), KeyError)\n    True\n    '''\n    pass\n\n\nclass InvalidTimeError(Exception):\n    '''Base class for invalid time exceptions.'''\n\n\nclass AmbiguousTimeError(InvalidTimeError):\n    '''Exception raised when attempting to create an ambiguous wallclock time.\n\n    At the end of a DST transition period, a particular wallclock time will\n    occur twice (once before the clocks are set back, once after). Both\n    possibilities may be correct, unless further information is supplied.\n\n    See DstTzInfo.normalize() for more info\n    '''\n\n\nclass NonExistentTimeError(InvalidTimeError):\n    '''Exception raised when attempting to create a wallclock time that\n    cannot exist.\n\n    At the start of a DST transition period, the wallclock time jumps forward.\n    The instants jumped over never occur.\n    '''\n","src/lib/pytz/lazy.py":"from threading import RLock\ntry:\n    from collections.abc import Mapping as DictMixin\nexcept ImportError:  # Python < 3.3\n    try:\n        from UserDict import DictMixin  # Python 2\n    except ImportError:  # Python 3.0-3.3\n        from collections import Mapping as DictMixin\n\n\n# With lazy loading, we might end up with multiple threads triggering\n# it at the same time. We need a lock.\n_fill_lock = RLock()\n\n\nclass LazyDict(DictMixin):\n    \"\"\"Dictionary populated on first use.\"\"\"\n    data = None\n\n    def __getitem__(self, key):\n        if self.data is None:\n            _fill_lock.acquire()\n            try:\n                if self.data is None:\n                    self._fill()\n            finally:\n                _fill_lock.release()\n        return self.data[key.upper()]\n\n    def __contains__(self, key):\n        if self.data is None:\n            _fill_lock.acquire()\n            try:\n                if self.data is None:\n                    self._fill()\n            finally:\n                _fill_lock.release()\n        return key in self.data\n\n    def __iter__(self):\n        if self.data is None:\n            _fill_lock.acquire()\n            try:\n                if self.data is None:\n                    self._fill()\n            finally:\n                _fill_lock.release()\n        return iter(self.data)\n\n    def __len__(self):\n        if self.data is None:\n            _fill_lock.acquire()\n            try:\n                if self.data is None:\n                    self._fill()\n            finally:\n                _fill_lock.release()\n        return len(self.data)\n\n    def keys(self):\n        if self.data is None:\n            _fill_lock.acquire()\n            try:\n                if self.data is None:\n                    self._fill()\n            finally:\n                _fill_lock.release()\n        return self.data.keys()\n\n\nclass LazyList(list):\n    \"\"\"List populated on first use.\"\"\"\n\n    _props = [\n        '__str__', '__repr__', '__unicode__',\n        '__hash__', '__sizeof__', '__cmp__',\n        '__lt__', '__le__', '__eq__', '__ne__', '__gt__', '__ge__',\n        'append', 'count', 'index', 'extend', 'insert', 'pop', 'remove',\n        'reverse', 'sort', '__add__', '__radd__', '__iadd__', '__mul__',\n        '__rmul__', '__imul__', '__contains__', '__len__', '__nonzero__',\n        '__getitem__', '__setitem__', '__delitem__', '__iter__',\n        '__reversed__', '__getslice__', '__setslice__', '__delslice__']\n\n    def __new__(cls, fill_iter=None):\n\n        if fill_iter is None:\n            return list()\n\n        # We need a new class as we will be dynamically messing with its\n        # methods.\n        class LazyList(list):\n            pass\n\n        fill_iter = [fill_iter]\n\n        def lazy(name):\n            def _lazy(self, *args, **kw):\n                _fill_lock.acquire()\n                try:\n                    if len(fill_iter) > 0:\n                        list.extend(self, fill_iter.pop())\n                        for method_name in cls._props:\n                            delattr(LazyList, method_name)\n                finally:\n                    _fill_lock.release()\n                return getattr(list, name)(self, *args, **kw)\n            return _lazy\n\n        for name in cls._props:\n            setattr(LazyList, name, lazy(name))\n\n        new_list = LazyList()\n        return new_list\n\n# Not all versions of Python declare the same magic methods.\n# Filter out properties that don't exist in this version of Python\n# from the list.\nLazyList._props = [prop for prop in LazyList._props if hasattr(list, prop)]\n\n\nclass LazySet(set):\n    \"\"\"Set populated on first use.\"\"\"\n\n    _props = (\n        '__str__', '__repr__', '__unicode__',\n        '__hash__', '__sizeof__', '__cmp__',\n        '__lt__', '__le__', '__eq__', '__ne__', '__gt__', '__ge__',\n        '__contains__', '__len__', '__nonzero__',\n        '__getitem__', '__setitem__', '__delitem__', '__iter__',\n        '__sub__', '__and__', '__xor__', '__or__',\n        '__rsub__', '__rand__', '__rxor__', '__ror__',\n        '__isub__', '__iand__', '__ixor__', '__ior__',\n        'add', 'clear', 'copy', 'difference', 'difference_update',\n        'discard', 'intersection', 'intersection_update', 'isdisjoint',\n        'issubset', 'issuperset', 'pop', 'remove',\n        'symmetric_difference', 'symmetric_difference_update',\n        'union', 'update')\n\n    def __new__(cls, fill_iter=None):\n\n        if fill_iter is None:\n            return set()\n\n        class LazySet(set):\n            pass\n\n        fill_iter = [fill_iter]\n\n        def lazy(name):\n            def _lazy(self, *args, **kw):\n                _fill_lock.acquire()\n                try:\n                    if len(fill_iter) > 0:\n                        for i in fill_iter.pop():\n                            set.add(self, i)\n                        for method_name in cls._props:\n                            delattr(LazySet, method_name)\n                finally:\n                    _fill_lock.release()\n                return getattr(set, name)(self, *args, **kw)\n            return _lazy\n\n        for name in cls._props:\n            setattr(LazySet, name, lazy(name))\n\n        new_set = LazySet()\n        return new_set\n\n# Not all versions of Python declare the same magic methods.\n# Filter out properties that don't exist in this version of Python\n# from the list.\nLazySet._props = [prop for prop in LazySet._props if hasattr(set, prop)]\n","src/lib/pytz/reference.py":"'''\nReference tzinfo implementations from the Python docs.\nUsed for testing against as they are only correct for the years\n1987 to 2006. Do not use these for real code.\n'''\n\nfrom datetime import tzinfo, timedelta, datetime\nfrom pytz import HOUR, ZERO, UTC\n\n__all__ = [\n    'FixedOffset',\n    'LocalTimezone',\n    'USTimeZone',\n    'Eastern',\n    'Central',\n    'Mountain',\n    'Pacific',\n    'UTC'\n]\n\n\n# A class building tzinfo objects for fixed-offset time zones.\n# Note that FixedOffset(0, \"UTC\") is a different way to build a\n# UTC tzinfo object.\nclass FixedOffset(tzinfo):\n    \"\"\"Fixed offset in minutes east from UTC.\"\"\"\n\n    def __init__(self, offset, name):\n        self.__offset = timedelta(minutes=offset)\n        self.__name = name\n\n    def utcoffset(self, dt):\n        return self.__offset\n\n    def tzname(self, dt):\n        return self.__name\n\n    def dst(self, dt):\n        return ZERO\n\n\nimport time as _time\n\nSTDOFFSET = timedelta(seconds=-_time.timezone)\nif _time.daylight:\n    DSTOFFSET = timedelta(seconds=-_time.altzone)\nelse:\n    DSTOFFSET = STDOFFSET\n\nDSTDIFF = DSTOFFSET - STDOFFSET\n\n\n# A class capturing the platform's idea of local time.\nclass LocalTimezone(tzinfo):\n\n    def utcoffset(self, dt):\n        if self._isdst(dt):\n            return DSTOFFSET\n        else:\n            return STDOFFSET\n\n    def dst(self, dt):\n        if self._isdst(dt):\n            return DSTDIFF\n        else:\n            return ZERO\n\n    def tzname(self, dt):\n        return _time.tzname[self._isdst(dt)]\n\n    def _isdst(self, dt):\n        tt = (dt.year, dt.month, dt.day,\n              dt.hour, dt.minute, dt.second,\n              dt.weekday(), 0, -1)\n        stamp = _time.mktime(tt)\n        tt = _time.localtime(stamp)\n        return tt.tm_isdst > 0\n\nLocal = LocalTimezone()\n\n\ndef first_sunday_on_or_after(dt):\n    days_to_go = 6 - dt.weekday()\n    if days_to_go:\n        dt += timedelta(days_to_go)\n    return dt\n\n\n# In the US, DST starts at 2am (standard time) on the first Sunday in April.\nDSTSTART = datetime(1, 4, 1, 2)\n# and ends at 2am (DST time; 1am standard time) on the last Sunday of Oct.\n# which is the first Sunday on or after Oct 25.\nDSTEND = datetime(1, 10, 25, 1)\n\n\n# A complete implementation of current DST rules for major US time zones.\nclass USTimeZone(tzinfo):\n\n    def __init__(self, hours, reprname, stdname, dstname):\n        self.stdoffset = timedelta(hours=hours)\n        self.reprname = reprname\n        self.stdname = stdname\n        self.dstname = dstname\n\n    def __repr__(self):\n        return self.reprname\n\n    def tzname(self, dt):\n        if self.dst(dt):\n            return self.dstname\n        else:\n            return self.stdname\n\n    def utcoffset(self, dt):\n        return self.stdoffset + self.dst(dt)\n\n    def dst(self, dt):\n        if dt is None or dt.tzinfo is None:\n            # An exception may be sensible here, in one or both cases.\n            # It depends on how you want to treat them.  The default\n            # fromutc() implementation (called by the default astimezone()\n            # implementation) passes a datetime with dt.tzinfo is self.\n            return ZERO\n        assert dt.tzinfo is self\n\n        # Find first Sunday in April & the last in October.\n        start = first_sunday_on_or_after(DSTSTART.replace(year=dt.year))\n        end = first_sunday_on_or_after(DSTEND.replace(year=dt.year))\n\n        # Can't compare naive to aware objects, so strip the timezone from\n        # dt first.\n        if start <= dt.replace(tzinfo=None) < end:\n            return HOUR\n        else:\n            return ZERO\n\nEastern = USTimeZone(-5, \"Eastern\", \"EST\", \"EDT\")\nCentral = USTimeZone(-6, \"Central\", \"CST\", \"CDT\")\nMountain = USTimeZone(-7, \"Mountain\", \"MST\", \"MDT\")\nPacific = USTimeZone(-8, \"Pacific\", \"PST\", \"PDT\")\n","src/lib/pytz/tests/test_docs.py":"# -*- coding: ascii -*-\n\nfrom doctest import DocFileSuite\nimport unittest\nimport os.path\nimport sys\n\nTHIS_DIR = os.path.dirname(__file__)\n\nREADME = os.path.join(THIS_DIR, os.pardir, os.pardir, 'README.txt')\n\n\nclass DocumentationTestCase(unittest.TestCase):\n    def test_readme_encoding(self):\n        '''Confirm the README.txt is pure ASCII.'''\n        f = open(README, 'rb')\n        try:\n            f.read().decode('ASCII')\n        finally:\n            f.close()\n\n\ndef test_suite():\n    \"For the Z3 test runner\"\n    return unittest.TestSuite((\n        DocumentationTestCase('test_readme_encoding'),\n        DocFileSuite(os.path.join(os.pardir, os.pardir, 'README.txt'))))\n\n\nif __name__ == '__main__':\n    sys.path.insert(\n        0, os.path.abspath(os.path.join(THIS_DIR, os.pardir, os.pardir))\n    )\n    unittest.main(defaultTest='test_suite')\n","src/lib/pytz/tests/test_lazy.py":"from operator import (\n    eq, ge, gt, le, lt, ne, add, concat, not_, sub, and_, or_, xor\n)\nimport os.path\nimport sys\nimport unittest\nimport warnings\n\n\nif __name__ == '__main__':\n    # Only munge path if invoked as a script. Testrunners should have setup\n    # the paths already\n    sys.path.insert(0, os.path.abspath(os.path.join(os.pardir, os.pardir)))\n\n\nfrom pytz.lazy import LazyList, LazySet\n\n\nclass LazyListTestCase(unittest.TestCase):\n    initial_data = [3, 2, 1]\n\n    def setUp(self):\n        self.base = [3, 2, 1]\n        self.lesser = [2, 1, 0]\n        self.greater = [4, 3, 2]\n\n        self.lazy = LazyList(iter(list(self.base)))\n\n    def test_unary_ops(self):\n        unary_ops = [str, repr, len, bool, not_]\n        try:\n            unary_ops.append(unicode)\n        except NameError:\n            pass  # unicode no longer exists in Python 3.\n\n        for op in unary_ops:\n            self.assertEqual(\n                op(self.lazy),\n                op(self.base), str(op))\n\n    def test_binary_ops(self):\n        binary_ops = [eq, ge, gt, le, lt, ne, add, concat]\n        try:\n            binary_ops.append(cmp)\n        except NameError:\n            pass  # cmp no longer exists in Python 3.\n\n        for op in binary_ops:\n            self.assertEqual(\n                op(self.lazy, self.lazy),\n                op(self.base, self.base), str(op))\n            for other in [self.base, self.lesser, self.greater]:\n                self.assertEqual(\n                    op(self.lazy, other),\n                    op(self.base, other), '%s %s' % (op, other))\n                self.assertEqual(\n                    op(other, self.lazy),\n                    op(other, self.base), '%s %s' % (op, other))\n\n        # Multiplication\n        self.assertEqual(self.lazy * 3, self.base * 3)\n        self.assertEqual(3 * self.lazy, 3 * self.base)\n\n        # Contains\n        self.assertTrue(2 in self.lazy)\n        self.assertFalse(42 in self.lazy)\n\n    def test_iadd(self):\n        self.lazy += [1]\n        self.base += [1]\n        self.assertEqual(self.lazy, self.base)\n\n    def test_bool(self):\n        self.assertTrue(bool(self.lazy))\n        self.assertFalse(bool(LazyList()))\n        self.assertFalse(bool(LazyList(iter([]))))\n\n    def test_hash(self):\n        self.assertRaises(TypeError, hash, self.lazy)\n\n    def test_isinstance(self):\n        self.assertTrue(isinstance(self.lazy, list))\n        self.assertFalse(isinstance(self.lazy, tuple))\n\n    def test_callable(self):\n        try:\n            callable\n        except NameError:\n            return  # No longer exists with Python 3.\n        self.assertFalse(callable(self.lazy))\n\n    def test_append(self):\n        self.base.append('extra')\n        self.lazy.append('extra')\n        self.assertEqual(self.lazy, self.base)\n\n    def test_count(self):\n        self.assertEqual(self.lazy.count(2), 1)\n\n    def test_index(self):\n        self.assertEqual(self.lazy.index(2), 1)\n\n    def test_extend(self):\n        self.base.extend([6, 7])\n        self.lazy.extend([6, 7])\n        self.assertEqual(self.lazy, self.base)\n\n    def test_insert(self):\n        self.base.insert(0, 'ping')\n        self.lazy.insert(0, 'ping')\n        self.assertEqual(self.lazy, self.base)\n\n    def test_pop(self):\n        self.assertEqual(self.lazy.pop(), self.base.pop())\n        self.assertEqual(self.lazy, self.base)\n\n    def test_remove(self):\n        self.base.remove(2)\n        self.lazy.remove(2)\n        self.assertEqual(self.lazy, self.base)\n\n    def test_reverse(self):\n        self.base.reverse()\n        self.lazy.reverse()\n        self.assertEqual(self.lazy, self.base)\n\n    def test_reversed(self):\n        self.assertEqual(list(reversed(self.lazy)), list(reversed(self.base)))\n\n    def test_sort(self):\n        self.base.sort()\n        self.assertNotEqual(self.lazy, self.base, 'Test data already sorted')\n        self.lazy.sort()\n        self.assertEqual(self.lazy, self.base)\n\n    def test_sorted(self):\n        self.assertEqual(sorted(self.lazy), sorted(self.base))\n\n    def test_getitem(self):\n        for idx in range(-len(self.base), len(self.base)):\n            self.assertEqual(self.lazy[idx], self.base[idx])\n\n    def test_setitem(self):\n        for idx in range(-len(self.base), len(self.base)):\n            self.base[idx] = idx + 1000\n            self.assertNotEqual(self.lazy, self.base)\n            self.lazy[idx] = idx + 1000\n            self.assertEqual(self.lazy, self.base)\n\n    def test_delitem(self):\n        del self.base[0]\n        self.assertNotEqual(self.lazy, self.base)\n        del self.lazy[0]\n        self.assertEqual(self.lazy, self.base)\n\n        del self.base[-2]\n        self.assertNotEqual(self.lazy, self.base)\n        del self.lazy[-2]\n        self.assertEqual(self.lazy, self.base)\n\n    def test_iter(self):\n        self.assertEqual(list(iter(self.lazy)), list(iter(self.base)))\n\n    def test_getslice(self):\n        for i in range(-len(self.base), len(self.base)):\n            for j in range(-len(self.base), len(self.base)):\n                for step in [-1, 1]:\n                    self.assertEqual(self.lazy[i:j:step], self.base[i:j:step])\n\n    def test_setslice(self):\n        for i in range(-len(self.base), len(self.base)):\n            for j in range(-len(self.base), len(self.base)):\n                for step in [-1, 1]:\n                    replacement = range(0, len(self.base[i:j:step]))\n                    self.base[i:j:step] = replacement\n                    self.lazy[i:j:step] = replacement\n                    self.assertEqual(self.lazy, self.base)\n\n    def test_delslice(self):\n        del self.base[0:1]\n        del self.lazy[0:1]\n        self.assertEqual(self.lazy, self.base)\n\n        del self.base[-1:1:-1]\n        del self.lazy[-1:1:-1]\n        self.assertEqual(self.lazy, self.base)\n\n\nclass LazySetTestCase(unittest.TestCase):\n    initial_data = set([3, 2, 1])\n\n    def setUp(self):\n        self.base = set([3, 2, 1])\n        self.lazy = LazySet(iter(set(self.base)))\n\n    def test_unary_ops(self):\n        # These ops just need to work.\n        unary_ops = [str, repr]\n        try:\n            unary_ops.append(unicode)\n        except NameError:\n            pass  # unicode no longer exists in Python 3.\n\n        for op in unary_ops:\n            op(self.lazy)  # These ops just need to work.\n\n        # These ops should return identical values as a real set.\n        unary_ops = [len, bool, not_]\n\n        for op in unary_ops:\n            self.assertEqual(\n                op(self.lazy),\n                op(self.base), '%s(lazy) == %r' % (op, op(self.lazy)))\n\n    def test_binary_ops(self):\n        binary_ops = [eq, ge, gt, le, lt, ne, sub, and_, or_, xor]\n        try:\n            binary_ops.append(cmp)\n        except NameError:\n            pass  # cmp no longer exists in Python 3.\n\n        for op in binary_ops:\n            self.assertEqual(\n                op(self.lazy, self.lazy),\n                op(self.base, self.base), str(op))\n            self.assertEqual(\n                op(self.lazy, self.base),\n                op(self.base, self.base), str(op))\n            self.assertEqual(\n                op(self.base, self.lazy),\n                op(self.base, self.base), str(op))\n\n        # Contains\n        self.assertTrue(2 in self.lazy)\n        self.assertFalse(42 in self.lazy)\n\n    def test_iops(self):\n        try:\n            iops = [isub, iand, ior, ixor]\n        except NameError:\n            return  # Don't exist in older Python versions.\n        for op in iops:\n            # Mutating operators, so make fresh copies.\n            lazy = LazySet(self.base)\n            base = self.base.copy()\n            op(lazy, set([1]))\n            op(base, set([1]))\n            self.assertEqual(lazy, base, str(op))\n\n    def test_bool(self):\n        self.assertTrue(bool(self.lazy))\n        self.assertFalse(bool(LazySet()))\n        self.assertFalse(bool(LazySet(iter([]))))\n\n    def test_hash(self):\n        self.assertRaises(TypeError, hash, self.lazy)\n\n    def test_isinstance(self):\n        self.assertTrue(isinstance(self.lazy, set))\n\n    def test_callable(self):\n        try:\n            callable\n        except NameError:\n            return  # No longer exists with Python 3.\n        self.assertFalse(callable(self.lazy))\n\n    def test_add(self):\n        self.base.add('extra')\n        self.lazy.add('extra')\n        self.assertEqual(self.lazy, self.base)\n\n    def test_copy(self):\n        self.assertEqual(self.lazy.copy(), self.base)\n\n    def test_method_ops(self):\n        ops = [\n            'difference', 'intersection', 'isdisjoint',\n            'issubset', 'issuperset', 'symmetric_difference', 'union',\n            'difference_update', 'intersection_update',\n            'symmetric_difference_update', 'update']\n        for op in ops:\n            if not hasattr(set, op):\n                continue  # Not in this version of Python.\n            # Make a copy, as some of the ops are mutating.\n            lazy = LazySet(set(self.base))\n            base = set(self.base)\n            self.assertEqual(\n                getattr(lazy, op)(set([1])),\n                getattr(base, op)(set([1])), op)\n            self.assertEqual(lazy, base, op)\n\n    def test_discard(self):\n        self.base.discard(1)\n        self.assertNotEqual(self.lazy, self.base)\n        self.lazy.discard(1)\n        self.assertEqual(self.lazy, self.base)\n\n    def test_pop(self):\n        self.assertEqual(self.lazy.pop(), self.base.pop())\n        self.assertEqual(self.lazy, self.base)\n\n    def test_remove(self):\n        self.base.remove(2)\n        self.lazy.remove(2)\n        self.assertEqual(self.lazy, self.base)\n\n    def test_clear(self):\n        self.lazy.clear()\n        self.assertEqual(self.lazy, set())\n\n\nif __name__ == '__main__':\n    warnings.simplefilter(\"error\")  # Warnings should be fatal in tests.\n    unittest.main()\n","src/lib/pytz/tests/test_tzinfo.py":"# -*- coding: ascii -*-\n\nimport doctest\nimport sys\nimport os\nimport os.path\nimport unittest\ntry:\n    import cPickle as pickle\nexcept ImportError:\n    import pickle\nfrom datetime import (\n    datetime,\n    timedelta\n)\nimport warnings\n\nif __name__ == '__main__':\n    # Only munge path if invoked as a script. Testrunners should have setup\n    # the paths already\n    sys.path.insert(0, os.path.abspath(os.path.join(os.pardir, os.pardir)))\n\nimport pytz\nfrom pytz import reference\nfrom pytz.tzfile import _byte_string\nfrom pytz.tzinfo import DstTzInfo, StaticTzInfo\n\n# I test for expected version to ensure the correct version of pytz is\n# actually being tested.\nEXPECTED_VERSION = '2018.5'\nEXPECTED_OLSON_VERSION = '2018e'\n\nfmt = '%Y-%m-%d %H:%M:%S %Z%z'\n\nNOTIME = timedelta(0)\n\n# GMT is a tzinfo.StaticTzInfo--the class we primarily want to test--while\n# UTC is reference implementation.  They both have the same timezone meaning.\nUTC = pytz.timezone('UTC')\nGMT = pytz.timezone('GMT')\nassert isinstance(GMT, StaticTzInfo), 'GMT is no longer a StaticTzInfo'\n\n\ndef prettydt(dt):\n    \"\"\"datetime as a string using a known format.\n\n    We don't use strftime as it doesn't handle years earlier than 1900\n    per http://bugs.python.org/issue1777412\n    \"\"\"\n    if dt.utcoffset() >= timedelta(0):\n        offset = '+%s' % (dt.utcoffset(),)\n    else:\n        offset = '-%s' % (-1 * dt.utcoffset(),)\n    return '%04d-%02d-%02d %02d:%02d:%02d %s %s' % (\n        dt.year, dt.month, dt.day,\n        dt.hour, dt.minute, dt.second,\n        dt.tzname(), offset)\n\n\nif sys.version_info[0] > 2:\n    # Python 3.x doesn't have unicode(), making writing code\n    # for Python 2.3 and Python 3.x a pain.\n    unicode = str\n\n\nclass BasicTest(unittest.TestCase):\n\n    def testVersion(self):\n        # Ensuring the correct version of pytz has been loaded\n        self.assertEqual(\n            EXPECTED_VERSION, pytz.__version__,\n            'Incorrect pytz version loaded. Import path is stuffed '\n            'or this test needs updating. (Wanted %s, got %s)'\n            % (EXPECTED_VERSION, pytz.__version__)\n        )\n\n        self.assertEqual(\n            EXPECTED_OLSON_VERSION, pytz.OLSON_VERSION,\n            'Incorrect pytz version loaded. Import path is stuffed '\n            'or this test needs updating. (Wanted %s, got %s)'\n            % (EXPECTED_OLSON_VERSION, pytz.OLSON_VERSION)\n        )\n\n    def testGMT(self):\n        now = datetime.now(tz=GMT)\n        self.assertTrue(now.utcoffset() == NOTIME)\n        self.assertTrue(now.dst() == NOTIME)\n        self.assertTrue(now.timetuple() == now.utctimetuple())\n        self.assertTrue(now == now.replace(tzinfo=UTC))\n\n    def testReferenceUTC(self):\n        now = datetime.now(tz=UTC)\n        self.assertTrue(now.utcoffset() == NOTIME)\n        self.assertTrue(now.dst() == NOTIME)\n        self.assertTrue(now.timetuple() == now.utctimetuple())\n\n    def testUnknownOffsets(self):\n        # This tzinfo behavior is required to make\n        # datetime.time.{utcoffset, dst, tzname} work as documented.\n\n        dst_tz = pytz.timezone('US/Eastern')\n\n        # This information is not known when we don't have a date,\n        # so return None per API.\n        self.assertTrue(dst_tz.utcoffset(None) is None)\n        self.assertTrue(dst_tz.dst(None) is None)\n        # We don't know the abbreviation, but this is still a valid\n        # tzname per the Python documentation.\n        self.assertEqual(dst_tz.tzname(None), 'US/Eastern')\n\n    def clearCache(self):\n        pytz._tzinfo_cache.clear()\n\n    def testUnicodeTimezone(self):\n        # We need to ensure that cold lookups work for both Unicode\n        # and traditional strings, and that the desired singleton is\n        # returned.\n        self.clearCache()\n        eastern = pytz.timezone(unicode('US/Eastern'))\n        self.assertTrue(eastern is pytz.timezone('US/Eastern'))\n\n        self.clearCache()\n        eastern = pytz.timezone('US/Eastern')\n        self.assertTrue(eastern is pytz.timezone(unicode('US/Eastern')))\n\n    def testStaticTzInfo(self):\n        # Ensure that static timezones are correctly detected,\n        # per lp:1602807\n        static = pytz.timezone('Etc/GMT-4')\n        self.assertTrue(isinstance(static, StaticTzInfo))\n\n\nclass PicklingTest(unittest.TestCase):\n\n    def _roundtrip_tzinfo(self, tz):\n        p = pickle.dumps(tz)\n        unpickled_tz = pickle.loads(p)\n        self.assertTrue(tz is unpickled_tz, '%s did not roundtrip' % tz.zone)\n\n    def _roundtrip_datetime(self, dt):\n        # Ensure that the tzinfo attached to a datetime instance\n        # is identical to the one returned. This is important for\n        # DST timezones, as some state is stored in the tzinfo.\n        tz = dt.tzinfo\n        p = pickle.dumps(dt)\n        unpickled_dt = pickle.loads(p)\n        unpickled_tz = unpickled_dt.tzinfo\n        self.assertTrue(tz is unpickled_tz, '%s did not roundtrip' % tz.zone)\n\n    def testDst(self):\n        tz = pytz.timezone('Europe/Amsterdam')\n        dt = datetime(2004, 2, 1, 0, 0, 0)\n\n        for localized_tz in tz._tzinfos.values():\n            self._roundtrip_tzinfo(localized_tz)\n            self._roundtrip_datetime(dt.replace(tzinfo=localized_tz))\n\n    def testRoundtrip(self):\n        for zone in pytz.all_timezones:\n            tz = pytz.timezone(zone)\n            self._roundtrip_tzinfo(tz)\n\n    def testDatabaseFixes(self):\n        # Hack the pickle to make it refer to a timezone abbreviation\n        # that does not match anything. The unpickler should be able\n        # to repair this case\n        tz = pytz.timezone('Australia/Melbourne')\n        p = pickle.dumps(tz)\n        tzname = tz._tzname\n        hacked_p = p.replace(\n            _byte_string(tzname),\n            _byte_string('?' * len(tzname))\n        )\n        self.assertNotEqual(p, hacked_p)\n        unpickled_tz = pickle.loads(hacked_p)\n        self.assertTrue(tz is unpickled_tz)\n\n        # Simulate a database correction. In this case, the incorrect\n        # data will continue to be used.\n        p = pickle.dumps(tz)\n        new_utcoffset = tz._utcoffset.seconds + 42\n\n        # Python 3 introduced a new pickle protocol where numbers are stored in\n        # hexadecimal representation. Here we extract the pickle\n        # representation of the number for the current Python version.\n        old_pickle_pattern = pickle.dumps(tz._utcoffset.seconds)[3:-1]\n        new_pickle_pattern = pickle.dumps(new_utcoffset)[3:-1]\n        hacked_p = p.replace(old_pickle_pattern, new_pickle_pattern)\n\n        self.assertNotEqual(p, hacked_p)\n        unpickled_tz = pickle.loads(hacked_p)\n        self.assertEqual(unpickled_tz._utcoffset.seconds, new_utcoffset)\n        self.assertTrue(tz is not unpickled_tz)\n\n    def testOldPickles(self):\n        # Ensure that applications serializing pytz instances as pickles\n        # have no troubles upgrading to a new pytz release. These pickles\n        # where created with pytz2006j\n        east1 = pickle.loads(\n            _byte_string(\n                \"cpytz\\n_p\\np1\\n(S'US/Eastern'\\np2\\nI-18000\\n\"\n                \"I0\\nS'EST'\\np3\\ntRp4\\n.\"\n            )\n        )\n        east2 = pytz.timezone('US/Eastern').localize(\n            datetime(2006, 1, 1)).tzinfo\n        self.assertTrue(east1 is east2)\n\n        # Confirm changes in name munging between 2006j and 2007c cause\n        # no problems.\n        pap1 = pickle.loads(_byte_string(\n            \"cpytz\\n_p\\np1\\n(S'America/Port_minus_au_minus_Prince'\"\n            \"\\np2\\nI-17340\\nI0\\nS'PPMT'\\np3\\ntRp4\\n.\"))\n        pap2 = pytz.timezone('America/Port-au-Prince').localize(\n            datetime(1910, 1, 1)).tzinfo\n        self.assertTrue(pap1 is pap2)\n\n        gmt1 = pickle.loads(_byte_string(\n            \"cpytz\\n_p\\np1\\n(S'Etc/GMT_plus_10'\\np2\\ntRp3\\n.\"))\n        gmt2 = pytz.timezone('Etc/GMT+10')\n        self.assertTrue(gmt1 is gmt2)\n\n\nclass USEasternDSTStartTestCase(unittest.TestCase):\n    tzinfo = pytz.timezone('US/Eastern')\n\n    # 24 hours before DST changeover\n    transition_time = datetime(2002, 4, 7, 7, 0, 0, tzinfo=UTC)\n\n    # Increase for 'flexible' DST transitions due to 1 minute granularity\n    # of Python's datetime library\n    instant = timedelta(seconds=1)\n\n    # before transition\n    before = {\n        'tzname': 'EST',\n        'utcoffset': timedelta(hours=-5),\n        'dst': timedelta(hours=0),\n    }\n\n    # after transition\n    after = {\n        'tzname': 'EDT',\n        'utcoffset': timedelta(hours=-4),\n        'dst': timedelta(hours=1),\n    }\n\n    def _test_tzname(self, utc_dt, wanted):\n        tzname = wanted['tzname']\n        dt = utc_dt.astimezone(self.tzinfo)\n        self.assertEqual(\n            dt.tzname(), tzname,\n            'Expected %s as tzname for %s. Got %s' % (\n                tzname, str(utc_dt), dt.tzname()\n            )\n        )\n\n    def _test_utcoffset(self, utc_dt, wanted):\n        utcoffset = wanted['utcoffset']\n        dt = utc_dt.astimezone(self.tzinfo)\n        self.assertEqual(\n            dt.utcoffset(), wanted['utcoffset'],\n            'Expected %s as utcoffset for %s. Got %s' % (\n                utcoffset, utc_dt, dt.utcoffset()\n            )\n        )\n\n    def _test_dst(self, utc_dt, wanted):\n        dst = wanted['dst']\n        dt = utc_dt.astimezone(self.tzinfo)\n        self.assertEqual(\n            dt.dst(), dst,\n            'Expected %s as dst for %s. Got %s' % (dst, utc_dt, dt.dst())\n        )\n\n    def test_arithmetic(self):\n        utc_dt = self.transition_time\n\n        for days in range(-420, 720, 20):\n            delta = timedelta(days=days)\n\n            # Make sure we can get back where we started\n            dt = utc_dt.astimezone(self.tzinfo)\n            dt2 = dt + delta\n            dt2 = dt2 - delta\n            self.assertEqual(dt, dt2)\n\n            # Make sure arithmetic crossing DST boundaries ends\n            # up in the correct timezone after normalization\n            utc_plus_delta = (utc_dt + delta).astimezone(self.tzinfo)\n            local_plus_delta = self.tzinfo.normalize(dt + delta)\n            self.assertEqual(\n                prettydt(utc_plus_delta), prettydt(local_plus_delta),\n                'Incorrect result for delta==%d days.  Wanted %r. Got %r' % (\n                    days, prettydt(utc_plus_delta), prettydt(local_plus_delta),\n                )\n            )\n\n    def _test_all(self, utc_dt, wanted):\n        self._test_utcoffset(utc_dt, wanted)\n        self._test_tzname(utc_dt, wanted)\n        self._test_dst(utc_dt, wanted)\n\n    def testDayBefore(self):\n        self._test_all(\n            self.transition_time - timedelta(days=1), self.before\n        )\n\n    def testTwoHoursBefore(self):\n        self._test_all(\n            self.transition_time - timedelta(hours=2), self.before\n        )\n\n    def testHourBefore(self):\n        self._test_all(\n            self.transition_time - timedelta(hours=1), self.before\n        )\n\n    def testInstantBefore(self):\n        self._test_all(\n            self.transition_time - self.instant, self.before\n        )\n\n    def testTransition(self):\n        self._test_all(\n            self.transition_time, self.after\n        )\n\n    def testInstantAfter(self):\n        self._test_all(\n            self.transition_time + self.instant, self.after\n        )\n\n    def testHourAfter(self):\n        self._test_all(\n            self.transition_time + timedelta(hours=1), self.after\n        )\n\n    def testTwoHoursAfter(self):\n        self._test_all(\n            self.transition_time + timedelta(hours=1), self.after\n        )\n\n    def testDayAfter(self):\n        self._test_all(\n            self.transition_time + timedelta(days=1), self.after\n        )\n\n\nclass USEasternDSTEndTestCase(USEasternDSTStartTestCase):\n    tzinfo = pytz.timezone('US/Eastern')\n    transition_time = datetime(2002, 10, 27, 6, 0, 0, tzinfo=UTC)\n    before = {\n        'tzname': 'EDT',\n        'utcoffset': timedelta(hours=-4),\n        'dst': timedelta(hours=1),\n    }\n    after = {\n        'tzname': 'EST',\n        'utcoffset': timedelta(hours=-5),\n        'dst': timedelta(hours=0),\n    }\n\n\nclass USEasternEPTStartTestCase(USEasternDSTStartTestCase):\n    transition_time = datetime(1945, 8, 14, 23, 0, 0, tzinfo=UTC)\n    before = {\n        'tzname': 'EWT',\n        'utcoffset': timedelta(hours=-4),\n        'dst': timedelta(hours=1),\n    }\n    after = {\n        'tzname': 'EPT',\n        'utcoffset': timedelta(hours=-4),\n        'dst': timedelta(hours=1),\n    }\n\n\nclass USEasternEPTEndTestCase(USEasternDSTStartTestCase):\n    transition_time = datetime(1945, 9, 30, 6, 0, 0, tzinfo=UTC)\n    before = {\n        'tzname': 'EPT',\n        'utcoffset': timedelta(hours=-4),\n        'dst': timedelta(hours=1),\n    }\n    after = {\n        'tzname': 'EST',\n        'utcoffset': timedelta(hours=-5),\n        'dst': timedelta(hours=0),\n    }\n\n\nclass WarsawWMTEndTestCase(USEasternDSTStartTestCase):\n    # In 1915, Warsaw changed from Warsaw to Central European time.\n    # This involved the clocks being set backwards, causing a end-of-DST\n    # like situation without DST being involved.\n    tzinfo = pytz.timezone('Europe/Warsaw')\n    transition_time = datetime(1915, 8, 4, 22, 36, 0, tzinfo=UTC)\n    before = {\n        'tzname': 'WMT',\n        'utcoffset': timedelta(hours=1, minutes=24),\n        'dst': timedelta(0),\n    }\n    after = {\n        'tzname': 'CET',\n        'utcoffset': timedelta(hours=1),\n        'dst': timedelta(0),\n    }\n\n\nclass VilniusWMTEndTestCase(USEasternDSTStartTestCase):\n    # At the end of 1916, Vilnius changed timezones putting its clock\n    # forward by 11 minutes 35 seconds. Neither timezone was in DST mode.\n    tzinfo = pytz.timezone('Europe/Vilnius')\n    instant = timedelta(seconds=31)\n    transition_time = datetime(1916, 12, 31, 22, 36, 00, tzinfo=UTC)\n    before = {\n        'tzname': 'WMT',\n        'utcoffset': timedelta(hours=1, minutes=24),\n        'dst': timedelta(0),\n    }\n    after = {\n        'tzname': 'KMT',\n        'utcoffset': timedelta(hours=1, minutes=36),  # Really 1:35:36\n        'dst': timedelta(0),\n    }\n\n\nclass VilniusCESTStartTestCase(USEasternDSTStartTestCase):\n    # In 1941, Vilnius changed from MSG to CEST, switching to summer\n    # time while simultaneously reducing its UTC offset by two hours,\n    # causing the clocks to go backwards for this summer time\n    # switchover.\n    tzinfo = pytz.timezone('Europe/Vilnius')\n    transition_time = datetime(1941, 6, 23, 21, 00, 00, tzinfo=UTC)\n    before = {\n        'tzname': 'MSK',\n        'utcoffset': timedelta(hours=3),\n        'dst': timedelta(0),\n    }\n    after = {\n        'tzname': 'CEST',\n        'utcoffset': timedelta(hours=2),\n        'dst': timedelta(hours=1),\n    }\n\n\nclass LondonHistoryStartTestCase(USEasternDSTStartTestCase):\n    # The first known timezone transition in London was in 1847 when\n    # clocks where synchronized to GMT. However, we currently only\n    # understand v1 format tzfile(5) files which does handle years\n    # this far in the past, so our earliest known transition is in\n    # 1916.\n    tzinfo = pytz.timezone('Europe/London')\n    # transition_time = datetime(1847, 12, 1, 1, 15, 00, tzinfo=UTC)\n    # before = {\n    #     'tzname': 'LMT',\n    #     'utcoffset': timedelta(minutes=-75),\n    #     'dst': timedelta(0),\n    #     }\n    # after = {\n    #     'tzname': 'GMT',\n    #     'utcoffset': timedelta(0),\n    #     'dst': timedelta(0),\n    #     }\n    transition_time = datetime(1916, 5, 21, 2, 00, 00, tzinfo=UTC)\n    before = {\n        'tzname': 'GMT',\n        'utcoffset': timedelta(0),\n        'dst': timedelta(0),\n    }\n    after = {\n        'tzname': 'BST',\n        'utcoffset': timedelta(hours=1),\n        'dst': timedelta(hours=1),\n    }\n\n\nclass LondonHistoryEndTestCase(USEasternDSTStartTestCase):\n    # Timezone switchovers are projected into the future, even\n    # though no official statements exist or could be believed even\n    # if they did exist. We currently only check the last known\n    # transition in 2037, as we are still using v1 format tzfile(5)\n    # files.\n    tzinfo = pytz.timezone('Europe/London')\n    # transition_time = datetime(2499, 10, 25, 1, 0, 0, tzinfo=UTC)\n    transition_time = datetime(2037, 10, 25, 1, 0, 0, tzinfo=UTC)\n    before = {\n        'tzname': 'BST',\n        'utcoffset': timedelta(hours=1),\n        'dst': timedelta(hours=1),\n    }\n    after = {\n        'tzname': 'GMT',\n        'utcoffset': timedelta(0),\n        'dst': timedelta(0),\n    }\n\n\nclass NoumeaHistoryStartTestCase(USEasternDSTStartTestCase):\n    # Noumea adopted a whole hour offset in 1912. Previously\n    # it was 11 hours, 5 minutes and 48 seconds off UTC. However,\n    # due to limitations of the Python datetime library, we need\n    # to round that to 11 hours 6 minutes.\n    tzinfo = pytz.timezone('Pacific/Noumea')\n    transition_time = datetime(1912, 1, 12, 12, 54, 12, tzinfo=UTC)\n    before = {\n        'tzname': 'LMT',\n        'utcoffset': timedelta(hours=11, minutes=6),\n        'dst': timedelta(0),\n    }\n    after = {\n        'tzname': '+11',  # pre-2017a, NCT\n        'utcoffset': timedelta(hours=11),\n        'dst': timedelta(0),\n    }\n\n\nclass NoumeaDSTEndTestCase(USEasternDSTStartTestCase):\n    # Noumea dropped DST in 1997.\n    tzinfo = pytz.timezone('Pacific/Noumea')\n    transition_time = datetime(1997, 3, 1, 15, 00, 00, tzinfo=UTC)\n    before = {\n        'tzname': '+12',  # pre-2017a, NCST\n        'utcoffset': timedelta(hours=12),\n        'dst': timedelta(hours=1),\n    }\n    after = {\n        'tzname': '+11',  # pre-2017a, NCT\n        'utcoffset': timedelta(hours=11),\n        'dst': timedelta(0),\n    }\n\n\nclass NoumeaNoMoreDSTTestCase(NoumeaDSTEndTestCase):\n    # Noumea dropped DST in 1997. Here we test that it stops occuring.\n    transition_time = (\n        NoumeaDSTEndTestCase.transition_time + timedelta(days=365 * 10))\n    before = NoumeaDSTEndTestCase.after\n    after = NoumeaDSTEndTestCase.after\n\n\nclass TahitiTestCase(USEasternDSTStartTestCase):\n    # Tahiti has had a single transition in its history.\n    tzinfo = pytz.timezone('Pacific/Tahiti')\n    transition_time = datetime(1912, 10, 1, 9, 58, 16, tzinfo=UTC)\n    before = {\n        'tzname': 'LMT',\n        'utcoffset': timedelta(hours=-9, minutes=-58),\n        'dst': timedelta(0),\n    }\n    after = {\n        'tzname': '-10',  # pre-2017a, TAHT\n        'utcoffset': timedelta(hours=-10),\n        'dst': timedelta(0),\n    }\n\n\nclass SamoaInternationalDateLineChange(USEasternDSTStartTestCase):\n    # At the end of 2011, Samoa will switch from being east of the\n    # international dateline to the west. There will be no Dec 30th\n    # 2011 and it will switch from UTC-10 to UTC+14.\n    tzinfo = pytz.timezone('Pacific/Apia')\n    transition_time = datetime(2011, 12, 30, 10, 0, 0, tzinfo=UTC)\n    before = {\n        'tzname': '-10',  # pre-2017a, SDT\n        'utcoffset': timedelta(hours=-10),\n        'dst': timedelta(hours=1),\n    }\n    after = {\n        'tzname': '+14',  # pre-2017a, WSDT\n        'utcoffset': timedelta(hours=14),\n        'dst': timedelta(hours=1),\n    }\n\n\nclass ReferenceUSEasternDSTStartTestCase(USEasternDSTStartTestCase):\n    tzinfo = reference.Eastern\n\n    def test_arithmetic(self):\n        # Reference implementation cannot handle this\n        pass\n\n\nclass ReferenceUSEasternDSTEndTestCase(USEasternDSTEndTestCase):\n    tzinfo = reference.Eastern\n\n    def testHourBefore(self):\n        # Python's datetime library has a bug, where the hour before\n        # a daylight saving transition is one hour out. For example,\n        # at the end of US/Eastern daylight saving time, 01:00 EST\n        # occurs twice (once at 05:00 UTC and once at 06:00 UTC),\n        # whereas the first should actually be 01:00 EDT.\n        # Note that this bug is by design - by accepting this ambiguity\n        # for one hour one hour per year, an is_dst flag on datetime.time\n        # became unnecessary.\n        self._test_all(self.transition_time - timedelta(hours=1), self.after)\n\n    def testInstantBefore(self):\n        self._test_all(self.transition_time - timedelta(seconds=1), self.after)\n\n    def test_arithmetic(self):\n        # Reference implementation cannot handle this\n        pass\n\n\nclass LocalTestCase(unittest.TestCase):\n    def testLocalize(self):\n        loc_tz = pytz.timezone('Europe/Amsterdam')\n\n        loc_time = loc_tz.localize(datetime(1930, 5, 10, 0, 0, 0))\n        # Actually +00:19:32, but Python datetime rounds this\n        self.assertEqual(loc_time.strftime('%Z%z'), 'AMT+0020')\n\n        loc_time = loc_tz.localize(datetime(1930, 5, 20, 0, 0, 0))\n        # Actually +00:19:32, but Python datetime rounds this\n        self.assertEqual(loc_time.strftime('%Z%z'), 'NST+0120')\n\n        loc_time = loc_tz.localize(datetime(1940, 5, 10, 0, 0, 0))\n        # pre-2017a, abbreviation was NCT\n        self.assertEqual(loc_time.strftime('%Z%z'), '+0020+0020')\n\n        loc_time = loc_tz.localize(datetime(1940, 5, 20, 0, 0, 0))\n        self.assertEqual(loc_time.strftime('%Z%z'), 'CEST+0200')\n\n        loc_time = loc_tz.localize(datetime(2004, 2, 1, 0, 0, 0))\n        self.assertEqual(loc_time.strftime('%Z%z'), 'CET+0100')\n\n        loc_time = loc_tz.localize(datetime(2004, 4, 1, 0, 0, 0))\n        self.assertEqual(loc_time.strftime('%Z%z'), 'CEST+0200')\n\n        loc_time = loc_tz.localize(datetime(1943, 3, 29, 1, 59, 59))\n        self.assertEqual(loc_time.strftime('%Z%z'), 'CET+0100')\n\n        # Switch to US\n        loc_tz = pytz.timezone('US/Eastern')\n\n        # End of DST ambiguity check\n        loc_time = loc_tz.localize(datetime(1918, 10, 27, 1, 59, 59), is_dst=1)\n        self.assertEqual(loc_time.strftime('%Z%z'), 'EDT-0400')\n\n        loc_time = loc_tz.localize(datetime(1918, 10, 27, 1, 59, 59), is_dst=0)\n        self.assertEqual(loc_time.strftime('%Z%z'), 'EST-0500')\n\n        self.assertRaises(\n            pytz.AmbiguousTimeError,\n            loc_tz.localize, datetime(1918, 10, 27, 1, 59, 59), is_dst=None\n        )\n\n        # Start of DST non-existent times\n        loc_time = loc_tz.localize(datetime(1918, 3, 31, 2, 0, 0), is_dst=0)\n        self.assertEqual(loc_time.strftime('%Z%z'), 'EST-0500')\n\n        loc_time = loc_tz.localize(datetime(1918, 3, 31, 2, 0, 0), is_dst=1)\n        self.assertEqual(loc_time.strftime('%Z%z'), 'EDT-0400')\n\n        self.assertRaises(\n            pytz.NonExistentTimeError,\n            loc_tz.localize, datetime(1918, 3, 31, 2, 0, 0), is_dst=None\n        )\n\n        # Weird changes - war time and peace time both is_dst==True\n\n        loc_time = loc_tz.localize(datetime(1942, 2, 9, 3, 0, 0))\n        self.assertEqual(loc_time.strftime('%Z%z'), 'EWT-0400')\n\n        loc_time = loc_tz.localize(datetime(1945, 8, 14, 19, 0, 0))\n        self.assertEqual(loc_time.strftime('%Z%z'), 'EPT-0400')\n\n        loc_time = loc_tz.localize(datetime(1945, 9, 30, 1, 0, 0), is_dst=1)\n        self.assertEqual(loc_time.strftime('%Z%z'), 'EPT-0400')\n\n        loc_time = loc_tz.localize(datetime(1945, 9, 30, 1, 0, 0), is_dst=0)\n        self.assertEqual(loc_time.strftime('%Z%z'), 'EST-0500')\n\n        # Weird changes - ambiguous time (end-of-DST like) but is_dst==False\n        for zonename, ambiguous_naive, expected in [\n                ('Europe/Warsaw', datetime(1915, 8, 4, 23, 59, 59),\n                 ['1915-08-04 23:59:59 WMT+0124',\n                  '1915-08-04 23:59:59 CET+0100']),\n                ('Europe/Moscow', datetime(2014, 10, 26, 1, 30),\n                 ['2014-10-26 01:30:00 MSK+0400',\n                  '2014-10-26 01:30:00 MSK+0300'])]:\n            loc_tz = pytz.timezone(zonename)\n            self.assertRaises(\n                pytz.AmbiguousTimeError,\n                loc_tz.localize, ambiguous_naive, is_dst=None\n            )\n            # Also test non-boolean is_dst in the weird case\n            for dst in [True, timedelta(1), False, timedelta(0)]:\n                loc_time = loc_tz.localize(ambiguous_naive, is_dst=dst)\n                self.assertEqual(loc_time.strftime(fmt), expected[not dst])\n\n    def testNormalize(self):\n        tz = pytz.timezone('US/Eastern')\n        dt = datetime(2004, 4, 4, 7, 0, 0, tzinfo=UTC).astimezone(tz)\n        dt2 = dt - timedelta(minutes=10)\n        self.assertEqual(\n            dt2.strftime('%Y-%m-%d %H:%M:%S %Z%z'),\n            '2004-04-04 02:50:00 EDT-0400'\n        )\n\n        dt2 = tz.normalize(dt2)\n        self.assertEqual(\n            dt2.strftime('%Y-%m-%d %H:%M:%S %Z%z'),\n            '2004-04-04 01:50:00 EST-0500'\n        )\n\n    def testPartialMinuteOffsets(self):\n        # utcoffset in Amsterdam was not a whole minute until 1937\n        # However, we fudge this by rounding them, as the Python\n        # datetime library\n        tz = pytz.timezone('Europe/Amsterdam')\n        utc_dt = datetime(1914, 1, 1, 13, 40, 28, tzinfo=UTC)  # correct\n        utc_dt = utc_dt.replace(second=0)  # But we need to fudge it\n        loc_dt = utc_dt.astimezone(tz)\n        self.assertEqual(\n            loc_dt.strftime('%Y-%m-%d %H:%M:%S %Z%z'),\n            '1914-01-01 14:00:00 AMT+0020'\n        )\n\n        # And get back...\n        utc_dt = loc_dt.astimezone(UTC)\n        self.assertEqual(\n            utc_dt.strftime('%Y-%m-%d %H:%M:%S %Z%z'),\n            '1914-01-01 13:40:00 UTC+0000'\n        )\n\n    def no_testCreateLocaltime(self):\n        # It would be nice if this worked, but it doesn't.\n        tz = pytz.timezone('Europe/Amsterdam')\n        dt = datetime(2004, 10, 31, 2, 0, 0, tzinfo=tz)\n        self.assertEqual(\n            dt.strftime(fmt),\n            '2004-10-31 02:00:00 CET+0100'\n        )\n\n\nclass CommonTimezonesTestCase(unittest.TestCase):\n    def test_bratislava(self):\n        # Bratislava is the default timezone for Slovakia, but our\n        # heuristics where not adding it to common_timezones. Ideally,\n        # common_timezones should be populated from zone.tab at runtime,\n        # but I'm hesitant to pay the startup cost as loading the list\n        # on demand whilst remaining backwards compatible seems\n        # difficult.\n        self.assertTrue('Europe/Bratislava' in pytz.common_timezones)\n        self.assertTrue('Europe/Bratislava' in pytz.common_timezones_set)\n\n    def test_us_eastern(self):\n        self.assertTrue('US/Eastern' in pytz.common_timezones)\n        self.assertTrue('US/Eastern' in pytz.common_timezones_set)\n\n    def test_belfast(self):\n        # Belfast uses London time.\n        self.assertTrue('Europe/Belfast' in pytz.all_timezones_set)\n        self.assertFalse('Europe/Belfast' in pytz.common_timezones)\n        self.assertFalse('Europe/Belfast' in pytz.common_timezones_set)\n\n\nclass BaseTzInfoTestCase:\n    '''Ensure UTC, StaticTzInfo and DstTzInfo work consistently.\n\n    These tests are run for each type of tzinfo.\n    '''\n    tz = None  # override\n    tz_class = None  # override\n\n    def test_expectedclass(self):\n        self.assertTrue(isinstance(self.tz, self.tz_class))\n\n    def test_fromutc(self):\n        # naive datetime.\n        dt1 = datetime(2011, 10, 31)\n\n        # localized datetime, same timezone.\n        dt2 = self.tz.localize(dt1)\n\n        # Both should give the same results. Note that the standard\n        # Python tzinfo.fromutc() only supports the second.\n        for dt in [dt1, dt2]:\n            loc_dt = self.tz.fromutc(dt)\n            loc_dt2 = pytz.utc.localize(dt1).astimezone(self.tz)\n            self.assertEqual(loc_dt, loc_dt2)\n\n        # localized datetime, different timezone.\n        new_tz = pytz.timezone('Europe/Paris')\n        self.assertTrue(self.tz is not new_tz)\n        dt3 = new_tz.localize(dt1)\n        self.assertRaises(ValueError, self.tz.fromutc, dt3)\n\n    def test_normalize(self):\n        other_tz = pytz.timezone('Europe/Paris')\n        self.assertTrue(self.tz is not other_tz)\n\n        dt = datetime(2012, 3, 26, 12, 0)\n        other_dt = other_tz.localize(dt)\n\n        local_dt = self.tz.normalize(other_dt)\n\n        self.assertTrue(local_dt.tzinfo is not other_dt.tzinfo)\n        self.assertNotEqual(\n            local_dt.replace(tzinfo=None), other_dt.replace(tzinfo=None))\n\n    def test_astimezone(self):\n        other_tz = pytz.timezone('Europe/Paris')\n        self.assertTrue(self.tz is not other_tz)\n\n        dt = datetime(2012, 3, 26, 12, 0)\n        other_dt = other_tz.localize(dt)\n\n        local_dt = other_dt.astimezone(self.tz)\n\n        self.assertTrue(local_dt.tzinfo is not other_dt.tzinfo)\n        self.assertNotEqual(\n            local_dt.replace(tzinfo=None), other_dt.replace(tzinfo=None))\n\n\nclass OptimizedUTCTestCase(unittest.TestCase, BaseTzInfoTestCase):\n    tz = pytz.utc\n    tz_class = tz.__class__\n\n\nclass LegacyUTCTestCase(unittest.TestCase, BaseTzInfoTestCase):\n    # Deprecated timezone, but useful for comparison tests.\n    tz = pytz.timezone('Etc/UTC')\n    tz_class = StaticTzInfo\n\n\nclass StaticTzInfoTestCase(unittest.TestCase, BaseTzInfoTestCase):\n    tz = pytz.timezone('GMT')\n    tz_class = StaticTzInfo\n\n\nclass DstTzInfoTestCase(unittest.TestCase, BaseTzInfoTestCase):\n    tz = pytz.timezone('Australia/Melbourne')\n    tz_class = DstTzInfo\n\n\ndef test_suite():\n    suite = unittest.TestSuite()\n    suite.addTest(doctest.DocTestSuite('pytz'))\n    suite.addTest(doctest.DocTestSuite('pytz.tzinfo'))\n    import test_tzinfo\n    suite.addTest(unittest.defaultTestLoader.loadTestsFromModule(test_tzinfo))\n    return suite\n\n\nif __name__ == '__main__':\n    warnings.simplefilter(\"error\")  # Warnings should be fatal in tests.\n    unittest.main(defaultTest='test_suite')\n","src/lib/pytz/tzfile.py":"#!/usr/bin/env python\n'''\n$Id: tzfile.py,v 1.8 2004/06/03 00:15:24 zenzen Exp $\n'''\n\nfrom datetime import datetime\nfrom struct import unpack, calcsize\n\nfrom pytz.tzinfo import StaticTzInfo, DstTzInfo, memorized_ttinfo\nfrom pytz.tzinfo import memorized_datetime, memorized_timedelta\n\n\ndef _byte_string(s):\n    \"\"\"Cast a string or byte string to an ASCII byte string.\"\"\"\n    return s.encode('ASCII')\n\n_NULL = _byte_string('\\0')\n\n\ndef _std_string(s):\n    \"\"\"Cast a string or byte string to an ASCII string.\"\"\"\n    return str(s.decode('ASCII'))\n\n\ndef build_tzinfo(zone, fp):\n    head_fmt = '>4s c 15x 6l'\n    head_size = calcsize(head_fmt)\n    (magic, format, ttisgmtcnt, ttisstdcnt, leapcnt, timecnt,\n        typecnt, charcnt) = unpack(head_fmt, fp.read(head_size))\n\n    # Make sure it is a tzfile(5) file\n    assert magic == _byte_string('TZif'), 'Got magic %s' % repr(magic)\n\n    # Read out the transition times, localtime indices and ttinfo structures.\n    data_fmt = '>%(timecnt)dl %(timecnt)dB %(ttinfo)s %(charcnt)ds' % dict(\n        timecnt=timecnt, ttinfo='lBB' * typecnt, charcnt=charcnt)\n    data_size = calcsize(data_fmt)\n    data = unpack(data_fmt, fp.read(data_size))\n\n    # make sure we unpacked the right number of values\n    assert len(data) == 2 * timecnt + 3 * typecnt + 1\n    transitions = [memorized_datetime(trans)\n                   for trans in data[:timecnt]]\n    lindexes = list(data[timecnt:2 * timecnt])\n    ttinfo_raw = data[2 * timecnt:-1]\n    tznames_raw = data[-1]\n    del data\n\n    # Process ttinfo into separate structs\n    ttinfo = []\n    tznames = {}\n    i = 0\n    while i < len(ttinfo_raw):\n        # have we looked up this timezone name yet?\n        tzname_offset = ttinfo_raw[i + 2]\n        if tzname_offset not in tznames:\n            nul = tznames_raw.find(_NULL, tzname_offset)\n            if nul < 0:\n                nul = len(tznames_raw)\n            tznames[tzname_offset] = _std_string(\n                tznames_raw[tzname_offset:nul])\n        ttinfo.append((ttinfo_raw[i],\n                       bool(ttinfo_raw[i + 1]),\n                       tznames[tzname_offset]))\n        i += 3\n\n    # Now build the timezone object\n    if len(ttinfo) == 1 or len(transitions) == 0:\n        ttinfo[0][0], ttinfo[0][2]\n        cls = type(zone, (StaticTzInfo,), dict(\n            zone=zone,\n            _utcoffset=memorized_timedelta(ttinfo[0][0]),\n            _tzname=ttinfo[0][2]))\n    else:\n        # Early dates use the first standard time ttinfo\n        i = 0\n        while ttinfo[i][1]:\n            i += 1\n        if ttinfo[i] == ttinfo[lindexes[0]]:\n            transitions[0] = datetime.min\n        else:\n            transitions.insert(0, datetime.min)\n            lindexes.insert(0, i)\n\n        # calculate transition info\n        transition_info = []\n        for i in range(len(transitions)):\n            inf = ttinfo[lindexes[i]]\n            utcoffset = inf[0]\n            if not inf[1]:\n                dst = 0\n            else:\n                for j in range(i - 1, -1, -1):\n                    prev_inf = ttinfo[lindexes[j]]\n                    if not prev_inf[1]:\n                        break\n                dst = inf[0] - prev_inf[0]  # dst offset\n\n                # Bad dst? Look further. DST > 24 hours happens when\n                # a timzone has moved across the international dateline.\n                if dst <= 0 or dst > 3600 * 3:\n                    for j in range(i + 1, len(transitions)):\n                        stdinf = ttinfo[lindexes[j]]\n                        if not stdinf[1]:\n                            dst = inf[0] - stdinf[0]\n                            if dst > 0:\n                                break  # Found a useful std time.\n\n            tzname = inf[2]\n\n            # Round utcoffset and dst to the nearest minute or the\n            # datetime library will complain. Conversions to these timezones\n            # might be up to plus or minus 30 seconds out, but it is\n            # the best we can do.\n            utcoffset = int((utcoffset + 30) // 60) * 60\n            dst = int((dst + 30) // 60) * 60\n            transition_info.append(memorized_ttinfo(utcoffset, dst, tzname))\n\n        cls = type(zone, (DstTzInfo,), dict(\n            zone=zone,\n            _utc_transition_times=transitions,\n            _transition_info=transition_info))\n\n    return cls()\n\nif __name__ == '__main__':\n    import os.path\n    from pprint import pprint\n    base = os.path.join(os.path.dirname(__file__), 'zoneinfo')\n    tz = build_tzinfo('Australia/Melbourne',\n                      open(os.path.join(base, 'Australia', 'Melbourne'), 'rb'))\n    tz = build_tzinfo('US/Eastern',\n                      open(os.path.join(base, 'US', 'Eastern'), 'rb'))\n    pprint(tz._utc_transition_times)\n","src/lib/pytz/tzinfo.py":"'''Base classes and helpers for building zone specific tzinfo classes'''\n\nfrom datetime import datetime, timedelta, tzinfo\nfrom bisect import bisect_right\ntry:\n    set\nexcept NameError:\n    from sets import Set as set\n\nimport pytz\nfrom pytz.exceptions import AmbiguousTimeError, NonExistentTimeError\n\n__all__ = []\n\n_timedelta_cache = {}\n\n\ndef memorized_timedelta(seconds):\n    '''Create only one instance of each distinct timedelta'''\n    try:\n        return _timedelta_cache[seconds]\n    except KeyError:\n        delta = timedelta(seconds=seconds)\n        _timedelta_cache[seconds] = delta\n        return delta\n\n_epoch = datetime.utcfromtimestamp(0)\n_datetime_cache = {0: _epoch}\n\n\ndef memorized_datetime(seconds):\n    '''Create only one instance of each distinct datetime'''\n    try:\n        return _datetime_cache[seconds]\n    except KeyError:\n        # NB. We can't just do datetime.utcfromtimestamp(seconds) as this\n        # fails with negative values under Windows (Bug #90096)\n        dt = _epoch + timedelta(seconds=seconds)\n        _datetime_cache[seconds] = dt\n        return dt\n\n_ttinfo_cache = {}\n\n\ndef memorized_ttinfo(*args):\n    '''Create only one instance of each distinct tuple'''\n    try:\n        return _ttinfo_cache[args]\n    except KeyError:\n        ttinfo = (\n            memorized_timedelta(args[0]),\n            memorized_timedelta(args[1]),\n            args[2]\n        )\n        _ttinfo_cache[args] = ttinfo\n        return ttinfo\n\n_notime = memorized_timedelta(0)\n\n\ndef _to_seconds(td):\n    '''Convert a timedelta to seconds'''\n    return td.seconds + td.days * 24 * 60 * 60\n\n\nclass BaseTzInfo(tzinfo):\n    # Overridden in subclass\n    _utcoffset = None\n    _tzname = None\n    zone = None\n\n    def __str__(self):\n        return self.zone\n\n\nclass StaticTzInfo(BaseTzInfo):\n    '''A timezone that has a constant offset from UTC\n\n    These timezones are rare, as most locations have changed their\n    offset at some point in their history\n    '''\n    def fromutc(self, dt):\n        '''See datetime.tzinfo.fromutc'''\n        if dt.tzinfo is not None and dt.tzinfo is not self:\n            raise ValueError('fromutc: dt.tzinfo is not self')\n        return (dt + self._utcoffset).replace(tzinfo=self)\n\n    def utcoffset(self, dt, is_dst=None):\n        '''See datetime.tzinfo.utcoffset\n\n        is_dst is ignored for StaticTzInfo, and exists only to\n        retain compatibility with DstTzInfo.\n        '''\n        return self._utcoffset\n\n    def dst(self, dt, is_dst=None):\n        '''See datetime.tzinfo.dst\n\n        is_dst is ignored for StaticTzInfo, and exists only to\n        retain compatibility with DstTzInfo.\n        '''\n        return _notime\n\n    def tzname(self, dt, is_dst=None):\n        '''See datetime.tzinfo.tzname\n\n        is_dst is ignored for StaticTzInfo, and exists only to\n        retain compatibility with DstTzInfo.\n        '''\n        return self._tzname\n\n    def localize(self, dt, is_dst=False):\n        '''Convert naive time to local time'''\n        if dt.tzinfo is not None:\n            raise ValueError('Not naive datetime (tzinfo is already set)')\n        return dt.replace(tzinfo=self)\n\n    def normalize(self, dt, is_dst=False):\n        '''Correct the timezone information on the given datetime.\n\n        This is normally a no-op, as StaticTzInfo timezones never have\n        ambiguous cases to correct:\n\n        >>> from pytz import timezone\n        >>> gmt = timezone('GMT')\n        >>> isinstance(gmt, StaticTzInfo)\n        True\n        >>> dt = datetime(2011, 5, 8, 1, 2, 3, tzinfo=gmt)\n        >>> gmt.normalize(dt) is dt\n        True\n\n        The supported method of converting between timezones is to use\n        datetime.astimezone(). Currently normalize() also works:\n\n        >>> la = timezone('America/Los_Angeles')\n        >>> dt = la.localize(datetime(2011, 5, 7, 1, 2, 3))\n        >>> fmt = '%Y-%m-%d %H:%M:%S %Z (%z)'\n        >>> gmt.normalize(dt).strftime(fmt)\n        '2011-05-07 08:02:03 GMT (+0000)'\n        '''\n        if dt.tzinfo is self:\n            return dt\n        if dt.tzinfo is None:\n            raise ValueError('Naive time - no tzinfo set')\n        return dt.astimezone(self)\n\n    def __repr__(self):\n        return '<StaticTzInfo %r>' % (self.zone,)\n\n    def __reduce__(self):\n        # Special pickle to zone remains a singleton and to cope with\n        # database changes.\n        return pytz._p, (self.zone,)\n\n\nclass DstTzInfo(BaseTzInfo):\n    '''A timezone that has a variable offset from UTC\n\n    The offset might change if daylight saving time comes into effect,\n    or at a point in history when the region decides to change their\n    timezone definition.\n    '''\n    # Overridden in subclass\n\n    # Sorted list of DST transition times, UTC\n    _utc_transition_times = None\n\n    # [(utcoffset, dstoffset, tzname)] corresponding to\n    # _utc_transition_times entries\n    _transition_info = None\n\n    zone = None\n\n    # Set in __init__\n\n    _tzinfos = None\n    _dst = None  # DST offset\n\n    def __init__(self, _inf=None, _tzinfos=None):\n        if _inf:\n            self._tzinfos = _tzinfos\n            self._utcoffset, self._dst, self._tzname = _inf\n        else:\n            _tzinfos = {}\n            self._tzinfos = _tzinfos\n            self._utcoffset, self._dst, self._tzname = (\n                self._transition_info[0])\n            _tzinfos[self._transition_info[0]] = self\n            for inf in self._transition_info[1:]:\n                if inf not in _tzinfos:\n                    _tzinfos[inf] = self.__class__(inf, _tzinfos)\n\n    def fromutc(self, dt):\n        '''See datetime.tzinfo.fromutc'''\n        if (dt.tzinfo is not None and\n                getattr(dt.tzinfo, '_tzinfos', None) is not self._tzinfos):\n            raise ValueError('fromutc: dt.tzinfo is not self')\n        dt = dt.replace(tzinfo=None)\n        idx = max(0, bisect_right(self._utc_transition_times, dt) - 1)\n        inf = self._transition_info[idx]\n        return (dt + inf[0]).replace(tzinfo=self._tzinfos[inf])\n\n    def normalize(self, dt):\n        '''Correct the timezone information on the given datetime\n\n        If date arithmetic crosses DST boundaries, the tzinfo\n        is not magically adjusted. This method normalizes the\n        tzinfo to the correct one.\n\n        To test, first we need to do some setup\n\n        >>> from pytz import timezone\n        >>> utc = timezone('UTC')\n        >>> eastern = timezone('US/Eastern')\n        >>> fmt = '%Y-%m-%d %H:%M:%S %Z (%z)'\n\n        We next create a datetime right on an end-of-DST transition point,\n        the instant when the wallclocks are wound back one hour.\n\n        >>> utc_dt = datetime(2002, 10, 27, 6, 0, 0, tzinfo=utc)\n        >>> loc_dt = utc_dt.astimezone(eastern)\n        >>> loc_dt.strftime(fmt)\n        '2002-10-27 01:00:00 EST (-0500)'\n\n        Now, if we subtract a few minutes from it, note that the timezone\n        information has not changed.\n\n        >>> before = loc_dt - timedelta(minutes=10)\n        >>> before.strftime(fmt)\n        '2002-10-27 00:50:00 EST (-0500)'\n\n        But we can fix that by calling the normalize method\n\n        >>> before = eastern.normalize(before)\n        >>> before.strftime(fmt)\n        '2002-10-27 01:50:00 EDT (-0400)'\n\n        The supported method of converting between timezones is to use\n        datetime.astimezone(). Currently, normalize() also works:\n\n        >>> th = timezone('Asia/Bangkok')\n        >>> am = timezone('Europe/Amsterdam')\n        >>> dt = th.localize(datetime(2011, 5, 7, 1, 2, 3))\n        >>> fmt = '%Y-%m-%d %H:%M:%S %Z (%z)'\n        >>> am.normalize(dt).strftime(fmt)\n        '2011-05-06 20:02:03 CEST (+0200)'\n        '''\n        if dt.tzinfo is None:\n            raise ValueError('Naive time - no tzinfo set')\n\n        # Convert dt in localtime to UTC\n        offset = dt.tzinfo._utcoffset\n        dt = dt.replace(tzinfo=None)\n        dt = dt - offset\n        # convert it back, and return it\n        return self.fromutc(dt)\n\n    def localize(self, dt, is_dst=False):\n        '''Convert naive time to local time.\n\n        This method should be used to construct localtimes, rather\n        than passing a tzinfo argument to a datetime constructor.\n\n        is_dst is used to determine the correct timezone in the ambigous\n        period at the end of daylight saving time.\n\n        >>> from pytz import timezone\n        >>> fmt = '%Y-%m-%d %H:%M:%S %Z (%z)'\n        >>> amdam = timezone('Europe/Amsterdam')\n        >>> dt  = datetime(2004, 10, 31, 2, 0, 0)\n        >>> loc_dt1 = amdam.localize(dt, is_dst=True)\n        >>> loc_dt2 = amdam.localize(dt, is_dst=False)\n        >>> loc_dt1.strftime(fmt)\n        '2004-10-31 02:00:00 CEST (+0200)'\n        >>> loc_dt2.strftime(fmt)\n        '2004-10-31 02:00:00 CET (+0100)'\n        >>> str(loc_dt2 - loc_dt1)\n        '1:00:00'\n\n        Use is_dst=None to raise an AmbiguousTimeError for ambiguous\n        times at the end of daylight saving time\n\n        >>> try:\n        ...     loc_dt1 = amdam.localize(dt, is_dst=None)\n        ... except AmbiguousTimeError:\n        ...     print('Ambiguous')\n        Ambiguous\n\n        is_dst defaults to False\n\n        >>> amdam.localize(dt) == amdam.localize(dt, False)\n        True\n\n        is_dst is also used to determine the correct timezone in the\n        wallclock times jumped over at the start of daylight saving time.\n\n        >>> pacific = timezone('US/Pacific')\n        >>> dt = datetime(2008, 3, 9, 2, 0, 0)\n        >>> ploc_dt1 = pacific.localize(dt, is_dst=True)\n        >>> ploc_dt2 = pacific.localize(dt, is_dst=False)\n        >>> ploc_dt1.strftime(fmt)\n        '2008-03-09 02:00:00 PDT (-0700)'\n        >>> ploc_dt2.strftime(fmt)\n        '2008-03-09 02:00:00 PST (-0800)'\n        >>> str(ploc_dt2 - ploc_dt1)\n        '1:00:00'\n\n        Use is_dst=None to raise a NonExistentTimeError for these skipped\n        times.\n\n        >>> try:\n        ...     loc_dt1 = pacific.localize(dt, is_dst=None)\n        ... except NonExistentTimeError:\n        ...     print('Non-existent')\n        Non-existent\n        '''\n        if dt.tzinfo is not None:\n            raise ValueError('Not naive datetime (tzinfo is already set)')\n\n        # Find the two best possibilities.\n        possible_loc_dt = set()\n        for delta in [timedelta(days=-1), timedelta(days=1)]:\n            loc_dt = dt + delta\n            idx = max(0, bisect_right(\n                self._utc_transition_times, loc_dt) - 1)\n            inf = self._transition_info[idx]\n            tzinfo = self._tzinfos[inf]\n            loc_dt = tzinfo.normalize(dt.replace(tzinfo=tzinfo))\n            if loc_dt.replace(tzinfo=None) == dt:\n                possible_loc_dt.add(loc_dt)\n\n        if len(possible_loc_dt) == 1:\n            return possible_loc_dt.pop()\n\n        # If there are no possibly correct timezones, we are attempting\n        # to convert a time that never happened - the time period jumped\n        # during the start-of-DST transition period.\n        if len(possible_loc_dt) == 0:\n            # If we refuse to guess, raise an exception.\n            if is_dst is None:\n                raise NonExistentTimeError(dt)\n\n            # If we are forcing the pre-DST side of the DST transition, we\n            # obtain the correct timezone by winding the clock forward a few\n            # hours.\n            elif is_dst:\n                return self.localize(\n                    dt + timedelta(hours=6), is_dst=True) - timedelta(hours=6)\n\n            # If we are forcing the post-DST side of the DST transition, we\n            # obtain the correct timezone by winding the clock back.\n            else:\n                return self.localize(\n                    dt - timedelta(hours=6),\n                    is_dst=False) + timedelta(hours=6)\n\n        # If we get this far, we have multiple possible timezones - this\n        # is an ambiguous case occuring during the end-of-DST transition.\n\n        # If told to be strict, raise an exception since we have an\n        # ambiguous case\n        if is_dst is None:\n            raise AmbiguousTimeError(dt)\n\n        # Filter out the possiblilities that don't match the requested\n        # is_dst\n        filtered_possible_loc_dt = [\n            p for p in possible_loc_dt if bool(p.tzinfo._dst) == is_dst\n        ]\n\n        # Hopefully we only have one possibility left. Return it.\n        if len(filtered_possible_loc_dt) == 1:\n            return filtered_possible_loc_dt[0]\n\n        if len(filtered_possible_loc_dt) == 0:\n            filtered_possible_loc_dt = list(possible_loc_dt)\n\n        # If we get this far, we have in a wierd timezone transition\n        # where the clocks have been wound back but is_dst is the same\n        # in both (eg. Europe/Warsaw 1915 when they switched to CET).\n        # At this point, we just have to guess unless we allow more\n        # hints to be passed in (such as the UTC offset or abbreviation),\n        # but that is just getting silly.\n        #\n        # Choose the earliest (by UTC) applicable timezone if is_dst=True\n        # Choose the latest (by UTC) applicable timezone if is_dst=False\n        # i.e., behave like end-of-DST transition\n        dates = {}  # utc -> local\n        for local_dt in filtered_possible_loc_dt:\n            utc_time = (\n                local_dt.replace(tzinfo=None) - local_dt.tzinfo._utcoffset)\n            assert utc_time not in dates\n            dates[utc_time] = local_dt\n        return dates[[min, max][not is_dst](dates)]\n\n    def utcoffset(self, dt, is_dst=None):\n        '''See datetime.tzinfo.utcoffset\n\n        The is_dst parameter may be used to remove ambiguity during DST\n        transitions.\n\n        >>> from pytz import timezone\n        >>> tz = timezone('America/St_Johns')\n        >>> ambiguous = datetime(2009, 10, 31, 23, 30)\n\n        >>> str(tz.utcoffset(ambiguous, is_dst=False))\n        '-1 day, 20:30:00'\n\n        >>> str(tz.utcoffset(ambiguous, is_dst=True))\n        '-1 day, 21:30:00'\n\n        >>> try:\n        ...     tz.utcoffset(ambiguous)\n        ... except AmbiguousTimeError:\n        ...     print('Ambiguous')\n        Ambiguous\n\n        '''\n        if dt is None:\n            return None\n        elif dt.tzinfo is not self:\n            dt = self.localize(dt, is_dst)\n            return dt.tzinfo._utcoffset\n        else:\n            return self._utcoffset\n\n    def dst(self, dt, is_dst=None):\n        '''See datetime.tzinfo.dst\n\n        The is_dst parameter may be used to remove ambiguity during DST\n        transitions.\n\n        >>> from pytz import timezone\n        >>> tz = timezone('America/St_Johns')\n\n        >>> normal = datetime(2009, 9, 1)\n\n        >>> str(tz.dst(normal))\n        '1:00:00'\n        >>> str(tz.dst(normal, is_dst=False))\n        '1:00:00'\n        >>> str(tz.dst(normal, is_dst=True))\n        '1:00:00'\n\n        >>> ambiguous = datetime(2009, 10, 31, 23, 30)\n\n        >>> str(tz.dst(ambiguous, is_dst=False))\n        '0:00:00'\n        >>> str(tz.dst(ambiguous, is_dst=True))\n        '1:00:00'\n        >>> try:\n        ...     tz.dst(ambiguous)\n        ... except AmbiguousTimeError:\n        ...     print('Ambiguous')\n        Ambiguous\n\n        '''\n        if dt is None:\n            return None\n        elif dt.tzinfo is not self:\n            dt = self.localize(dt, is_dst)\n            return dt.tzinfo._dst\n        else:\n            return self._dst\n\n    def tzname(self, dt, is_dst=None):\n        '''See datetime.tzinfo.tzname\n\n        The is_dst parameter may be used to remove ambiguity during DST\n        transitions.\n\n        >>> from pytz import timezone\n        >>> tz = timezone('America/St_Johns')\n\n        >>> normal = datetime(2009, 9, 1)\n\n        >>> tz.tzname(normal)\n        'NDT'\n        >>> tz.tzname(normal, is_dst=False)\n        'NDT'\n        >>> tz.tzname(normal, is_dst=True)\n        'NDT'\n\n        >>> ambiguous = datetime(2009, 10, 31, 23, 30)\n\n        >>> tz.tzname(ambiguous, is_dst=False)\n        'NST'\n        >>> tz.tzname(ambiguous, is_dst=True)\n        'NDT'\n        >>> try:\n        ...     tz.tzname(ambiguous)\n        ... except AmbiguousTimeError:\n        ...     print('Ambiguous')\n        Ambiguous\n        '''\n        if dt is None:\n            return self.zone\n        elif dt.tzinfo is not self:\n            dt = self.localize(dt, is_dst)\n            return dt.tzinfo._tzname\n        else:\n            return self._tzname\n\n    def __repr__(self):\n        if self._dst:\n            dst = 'DST'\n        else:\n            dst = 'STD'\n        if self._utcoffset > _notime:\n            return '<DstTzInfo %r %s+%s %s>' % (\n                self.zone, self._tzname, self._utcoffset, dst\n            )\n        else:\n            return '<DstTzInfo %r %s%s %s>' % (\n                self.zone, self._tzname, self._utcoffset, dst\n            )\n\n    def __reduce__(self):\n        # Special pickle to zone remains a singleton and to cope with\n        # database changes.\n        return pytz._p, (\n            self.zone,\n            _to_seconds(self._utcoffset),\n            _to_seconds(self._dst),\n            self._tzname\n        )\n\n\ndef unpickler(zone, utcoffset=None, dstoffset=None, tzname=None):\n    \"\"\"Factory function for unpickling pytz tzinfo instances.\n\n    This is shared for both StaticTzInfo and DstTzInfo instances, because\n    database changes could cause a zones implementation to switch between\n    these two base classes and we can't break pickles on a pytz version\n    upgrade.\n    \"\"\"\n    # Raises a KeyError if zone no longer exists, which should never happen\n    # and would be a bug.\n    tz = pytz.timezone(zone)\n\n    # A StaticTzInfo - just return it\n    if utcoffset is None:\n        return tz\n\n    # This pickle was created from a DstTzInfo. We need to\n    # determine which of the list of tzinfo instances for this zone\n    # to use in order to restore the state of any datetime instances using\n    # it correctly.\n    utcoffset = memorized_timedelta(utcoffset)\n    dstoffset = memorized_timedelta(dstoffset)\n    try:\n        return tz._tzinfos[(utcoffset, dstoffset, tzname)]\n    except KeyError:\n        # The particular state requested in this timezone no longer exists.\n        # This indicates a corrupt pickle, or the timezone database has been\n        # corrected violently enough to make this particular\n        # (utcoffset,dstoffset) no longer exist in the zone, or the\n        # abbreviation has been changed.\n        pass\n\n    # See if we can find an entry differing only by tzname. Abbreviations\n    # get changed from the initial guess by the database maintainers to\n    # match reality when this information is discovered.\n    for localized_tz in tz._tzinfos.values():\n        if (localized_tz._utcoffset == utcoffset and\n                localized_tz._dst == dstoffset):\n            return localized_tz\n\n    # This (utcoffset, dstoffset) information has been removed from the\n    # zone. Add it back. This might occur when the database maintainers have\n    # corrected incorrect information. datetime instances using this\n    # incorrect information will continue to do so, exactly as they were\n    # before being pickled. This is purely an overly paranoid safety net - I\n    # doubt this will ever been needed in real life.\n    inf = (utcoffset, dstoffset, tzname)\n    tz._tzinfos[inf] = tz.__class__(inf, tz._tzinfos)\n    return tz._tzinfos[inf]\n","src/lib/quopri.py":"raise NotImplementedError(\"quopri is not yet implemented in Skulpt\")\n","src/lib/random.js":"var MersenneTwister=function(a){a==null&&(a=new Date().getTime()),this.N=624,this.M=397,this.MATRIX_A=2567483615,this.UPPER_MASK=2147483648,this.LOWER_MASK=2147483647,this.mt=Array(this.N),this.mti=this.N+1,this.init_genrand(a)};MersenneTwister.prototype.init_genrand=function(a){for(this.mt[0]=a>>>0,this.mti=1;this.mti<this.N;this.mti++){var a=this.mt[this.mti-1]^this.mt[this.mti-1]>>>30;this.mt[this.mti]=(1812433253*((4294901760&a)>>>16)<<16)+1812433253*(65535&a)+this.mti,this.mt[this.mti]>>>=0}},MersenneTwister.prototype.init_by_array=function(a,b){var d,e,f;for(this.init_genrand(19650218),d=1,e=0,f=this.N>b?this.N:b;f;f--){var g=this.mt[d-1]^this.mt[d-1]>>>30;this.mt[d]=(this.mt[d]^(1664525*((4294901760&g)>>>16)<<16)+1664525*(65535&g))+a[e]+e,this.mt[d]>>>=0,d++,e++,d>=this.N&&(this.mt[0]=this.mt[this.N-1],d=1),e>=b&&(e=0)}for(f=this.N-1;f;f--){var g=this.mt[d-1]^this.mt[d-1]>>>30;this.mt[d]=(this.mt[d]^(1566083941*((4294901760&g)>>>16)<<16)+1566083941*(65535&g))-d,this.mt[d]>>>=0,d++,d>=this.N&&(this.mt[0]=this.mt[this.N-1],d=1)}this.mt[0]=2147483648},MersenneTwister.prototype.genrand_int32=function(){var a,b=[0,this.MATRIX_A];if(this.mti>=this.N){var d;for(this.mti==this.N+1&&this.init_genrand(5489),d=0;d<this.N-this.M;d++)a=this.mt[d]&this.UPPER_MASK|this.mt[d+1]&this.LOWER_MASK,this.mt[d]=this.mt[d+this.M]^a>>>1^b[1&a];for(;d<this.N-1;d++)a=this.mt[d]&this.UPPER_MASK|this.mt[d+1]&this.LOWER_MASK,this.mt[d]=this.mt[d+(this.M-this.N)]^a>>>1^b[1&a];a=this.mt[this.N-1]&this.UPPER_MASK|this.mt[0]&this.LOWER_MASK,this.mt[this.N-1]=this.mt[this.M-1]^a>>>1^b[1&a],this.mti=0}return a=this.mt[this.mti++],a^=a>>>11,a^=2636928640&a<<7,a^=4022730752&a<<15,a^=a>>>18,a>>>0},MersenneTwister.prototype.genrand_int31=function(){return this.genrand_int32()>>>1},MersenneTwister.prototype.genrand_real1=function(){return this.genrand_int32()*(1/4294967295)},MersenneTwister.prototype.random=function(){return this.genrand_int32()*(1/4294967296)},MersenneTwister.prototype.genrand_real3=function(){return(this.genrand_int32()+.5)*(1/4294967296)},MersenneTwister.prototype.genrand_res53=function(){var d=this.genrand_int32()>>>5,a=this.genrand_int32()>>>6;return(67108864*d+a)*(1/9007199254740992)};var $builtinmodule=function(){var a=Math.log,b=Math.sqrt,d={},e=new MersenneTwister,f=void 0;d.seed=new Sk.builtin.func(function(a){return Sk.builtin.pyCheckArgsLen(\"seed\",arguments.length,0,1),a=Sk.builtin.asnum$(a),e=0<arguments.length?new MersenneTwister(a):new MersenneTwister,Sk.builtin.none.none$}),d.random=new Sk.builtin.func(function(){return Sk.builtin.pyCheckArgsLen(\"random\",arguments.length,0,0),new Sk.builtin.float_(e.genrand_res53())});var g=function(a){return 0|a},h=function(a,b,d){var f,h,i;if(!Sk.builtin.checkInt(a))throw new Sk.builtin.ValueError(\"non-integer first argument for randrange()\");if(void 0===b)return i=g(e.genrand_res53()*a),new Sk.builtin.int_(i);if(!Sk.builtin.checkInt(b))throw new Sk.builtin.ValueError(\"non-integer stop for randrange()\");if(void 0===d&&(d=1),f=b-a,1==d&&0<f)return i=a+g(e.genrand_res53()*f),new Sk.builtin.int_(i);if(1==d)throw new Sk.builtin.ValueError(\"empty range for randrange() (\"+a+\", \"+b+\", \"+f+\")\");if(!Sk.builtin.checkInt(d))throw new Sk.builtin.ValueError(\"non-integer step for randrange()\");if(0<d)h=g((f+d-1)/d);else if(0>d)h=g((f+d+1)/d);else throw new Sk.builtin.ValueError(\"zero step for randrange()\");if(0>=h)throw new Sk.builtin.ValueError(\"empty range for randrange()\");return i=a+d*g(e.genrand_res53()*h),new Sk.builtin.int_(i)};d.randint=new Sk.builtin.func(function(d,e){return Sk.builtin.pyCheckArgsLen(\"randint\",arguments.length,2,2),d=Sk.builtin.asnum$(d),e=Sk.builtin.asnum$(e),h(d,e+1)}),d.randrange=new Sk.builtin.func(function(a,b,d){return Sk.builtin.pyCheckArgsLen(\"randrange\",arguments.length,1,3),a=Sk.builtin.asnum$(a),b=Sk.builtin.asnum$(b),d=Sk.builtin.asnum$(d),h(a,b,d)}),d.uniform=new Sk.builtin.func(function(d,f){Sk.builtin.pyCheckArgsLen(\"uniform\",arguments.length,2,2),d=Sk.builtin.asnum$(d),f=Sk.builtin.asnum$(f);var g=e.genrand_res53();return c=d+g*(f-d),new Sk.builtin.float_(c)}),d.triangular=new Sk.builtin.func(function(a,d,f){Sk.builtin.pyCheckArgsLen(\"triangular\",arguments.length,2,3),Sk.builtin.pyCheckType(\"low\",\"number\",Sk.builtin.checkNumber(a)),Sk.builtin.pyCheckType(\"high\",\"number\",Sk.builtin.checkNumber(d));var g,h,i;return a=Sk.builtin.asnum$(a),d=Sk.builtin.asnum$(d),a>d&&(i=a,a=d,d=i),void 0===f||f instanceof Sk.builtin.none?f=(d-a)/2:(Sk.builtin.pyCheckType(\"mode\",\"number\",Sk.builtin.checkNumber(f)),f=Sk.builtin.asnum$(f)),g=e.genrand_res53(),h=g<(f-a)/(d-a)?a+b(g*(d-a)*(f-a)):d-b((1-g)*(d-a)*(d-f)),new Sk.builtin.float_(h)});var i=function(d,g){var k,l,m,n,o,h=Math.sin,i=Math.cos,j=Math.PI;return void 0===f?(k=e.genrand_res53(),l=e.genrand_res53(),m=b(-2*a(k)),n=2*j*l,o=m*i(n),f=m*h(n)):(o=f,f=void 0),d+g*o};return d.gauss=new Sk.builtin.func(function(a,b){return Sk.builtin.pyCheckArgsLen(\"gauss\",arguments.length,2,2),Sk.builtin.pyCheckType(\"mu\",\"number\",Sk.builtin.checkNumber(a)),Sk.builtin.pyCheckType(\"sigma\",\"number\",Sk.builtin.checkNumber(b)),a=Sk.builtin.asnum$(a),b=Sk.builtin.asnum$(b),new Sk.builtin.float_(i(a,b))}),d.normalvariate=d.gauss,d.lognormvariate=new Sk.builtin.func(function(a,b){var d=Math.exp;return Sk.builtin.pyCheckArgsLen(\"lognormvariate\",arguments.length,2,2),Sk.builtin.pyCheckType(\"mu\",\"number\",Sk.builtin.checkNumber(a)),Sk.builtin.pyCheckType(\"sigma\",\"number\",Sk.builtin.checkNumber(b)),a=Sk.builtin.asnum$(a),b=Sk.builtin.asnum$(b),new Sk.builtin.float_(d(i(a,b)))}),d.expovariate=new Sk.builtin.func(function(b){Sk.builtin.pyCheckArgsLen(\"expovariate\",arguments.length,1,1),Sk.builtin.pyCheckType(\"lambd\",\"number\",Sk.builtin.checkNumber(b)),b=Sk.builtin.asnum$(b);var d=e.genrand_res53();return new Sk.builtin.float_(-a(d)/b)}),d.choice=new Sk.builtin.func(function(a){if(Sk.builtin.pyCheckArgsLen(\"choice\",arguments.length,1,1),Sk.builtin.pyCheckType(\"seq\",\"sequence\",Sk.builtin.checkSequence(a)),void 0!==a.sq$length){var b=g(e.genrand_res53()*a.sq$length());return a.mp$subscript(b)}throw new Sk.builtin.TypeError(\"object has no length\")}),d.shuffle=new Sk.builtin.func(function(a){if(Sk.builtin.pyCheckArgsLen(\"shuffle\",arguments.length,1,1),Sk.builtin.pyCheckType(\"x\",\"sequence\",Sk.builtin.checkSequence(a)),void 0===a.sq$length)throw new Sk.builtin.TypeError(\"object has no length\");else if(void 0!==a.mp$ass_subscript)for(var b=a.sq$length()-1;0<b;b-=1){var d=g(e.genrand_res53()*(b+1)),f=a.mp$subscript(d);a.mp$ass_subscript(d,a.mp$subscript(b)),a.mp$ass_subscript(b,f)}else throw new Sk.builtin.TypeError(\"object is immutable\");return Sk.builtin.none.none$}),d.sample=new Sk.builtin.func(function(a,b){var f,g,h,l,m,d=Math.floor;for(Sk.builtin.pyCheckArgsLen(\"sample\",arguments.length,2,2),Sk.builtin.pyCheckType(\"population\",\"iterable\",Sk.builtin.checkIterable(a)),Sk.builtin.pyCheckType(\"k\",\"integer\",Sk.builtin.checkInt(b)),b=Sk.builtin.asnum$(b),m=[],h=Sk.abstr.iter(a),(f=0,l=h.tp$iternext());void 0!==l;f++,l=h.tp$iternext())g=d(e.genrand_res53()*(f+1)),f<b?(g<f&&(m[f]=m[g]),m[g]=l):g<b&&(m[g]=l);if(f<b)throw new Sk.builtin.ValueError(\"sample larger than population\");return Sk.builtin.list(m)}),d};","src/lib/re.js":"var $builtinmodule=function(name){var validGroups,convert,getFlags,_split,_findall,matchobj,_search,_match,regexobj,mod={};return mod.I=2,mod.IGNORECASE=2,mod.M=8,mod.MULTILINE=8,validGroups=[\"(?:\",\"(?=\",\"(?!\"],convert=function(a){var b,c,d;if(c=a.match(/\\(\\?./g),c)for(d=0;d<c.length;d++)if(-1==validGroups.indexOf(c[d]))throw new Sk.builtin.ValueError(\"Disallowed group in pattern: '\"+c[d]+\"'\");return b=a.replace(\"/\\\\/g\",\"\\\\\\\\\"),b=a.replace(/([^\\\\]){,(?![^\\[]*\\])/g,\"$1{0,\"),b},getFlags=function(a){var b=\"g\";return(a&mod.IGNORECASE)==mod.IGNORECASE&&(b+=\"i\"),(a&mod.MULTILINE)==mod.MULTILINE&&(b+=\"m\"),b},_split=function(a,b,c,d){var e,f,g,h,i,j,k,l,m;if(Sk.builtin.pyCheckArgsLen(\"split\",arguments.length,2,4),!Sk.builtin.checkString(a))throw new Sk.builtin.TypeError(\"pattern must be a string\");if(!Sk.builtin.checkString(b))throw new Sk.builtin.TypeError(\"string must be a string\");if(void 0===c&&(c=0),!Sk.builtin.checkNumber(c))throw new Sk.builtin.TypeError(\"maxsplit must be a number\");if(void 0===d&&(d=0),!Sk.builtin.checkNumber(d))throw new Sk.builtin.TypeError(\"flags must be a number\");for(c=Sk.builtin.asnum$(c),e=Sk.ffi.unwrapo(a),f=Sk.ffi.unwrapo(b),e=convert(e),g=null!==e.match(/^\\(.*\\)$/),h=getFlags(d),i=new RegExp(e,h),j=[],k,l=0,m=0;null!=(k=i.exec(f))&&k.index!==i.lastIndex&&(j.push(new Sk.builtin.str(f.substring(l,k.index))),g&&j.push(new Sk.builtin.str(k[0])),l=i.lastIndex,m+=1,!(c&&m>=c)););return j.push(new Sk.builtin.str(f.substring(l))),new Sk.builtin.list(j)},_split.co_varnames=[\"pattern\",\"string\",\"maxsplit\",\"flags\"],_split.$defaults=[new Sk.builtin.int_(0),new Sk.builtin.int_(0)],mod.split=new Sk.builtin.func(_split),_findall=function(a,b,c){var d,e,f,g,h,j;if(Sk.builtin.pyCheckArgsLen(\"findall\",arguments.length,2,3),!Sk.builtin.checkString(a))throw new Sk.builtin.TypeError(\"pattern must be a string\");if(!Sk.builtin.checkString(b))throw new Sk.builtin.TypeError(\"string must be a string\");if(void 0===c&&(c=0),!Sk.builtin.checkNumber(c))throw new Sk.builtin.TypeError(\"flags must be a number\");if(d=Sk.ffi.unwrapo(a),e=Sk.ffi.unwrapo(b),d=convert(d),f=getFlags(c),g=new RegExp(d,f),d.match(/\\$/)){var k=new RegExp(/\\n$/);e.match(k)&&(e=e.slice(0,-1))}for(h=[],j;null!=(j=g.exec(e));){if(2>j.length)h.push(new Sk.builtin.str(j[0]));else if(2==j.length)h.push(new Sk.builtin.str(j[1]));else{for(var l=[],m=1;m<j.length;m++)l.push(new Sk.builtin.str(j[m]));h.push(new Sk.builtin.tuple(l))}j.index===g.lastIndex&&(g.lastIndex+=1)}return new Sk.builtin.list(h)},_findall.co_varnames=[\"pattern\",\"string\",\"flags\"],_findall.$defaults=[new Sk.builtin.int_(0)],mod.findall=new Sk.builtin.func(_findall),matchobj=function(a,b){b.__init__=new Sk.builtin.func(function(a,b,c,d){a.thematch=b,a.re=c,a.string=d}),b.groups=new Sk.builtin.func(function(a){var b=a.thematch.v.slice(1);return new Sk.builtin.tuple(b)}),b.group=new Sk.builtin.func(function(a,b){if(b=void 0===b?0:Sk.builtin.asnum$(b),b>=a.thematch.v.length)throw new Sk.builtin.IndexError(\"Index out of range: \"+b);return a.thematch.v[b]})},mod.MatchObject=Sk.misceval.buildClass(mod,matchobj,\"MatchObject\",[]),mod._findre=function(res,string){res=res.replace(/([^\\\\]){,(?![^\\[]*\\])/g,\"$1{0,\");var matches,sitem,retval,re=eval(res),patt=/\\n$/,str=Sk.ffi.remapToJs(string);if(matches=str.match(patt)?str.slice(0,-1).match(re):str.match(re),retval=new Sk.builtin.list,null==matches)return retval;for(var i=0;i<matches.length;++i)sitem=new Sk.builtin.str(matches[i]),retval.v.push(sitem);return retval},_search=function(a,b,c){var d,e;if(Sk.builtin.pyCheckArgsLen(\"search\",arguments.length,2,3),!Sk.builtin.checkString(a))throw new Sk.builtin.TypeError(\"pattern must be a string\");if(!Sk.builtin.checkString(b))throw new Sk.builtin.TypeError(\"string must be a string\");if(void 0===c&&(c=0),!Sk.builtin.checkNumber(c))throw new Sk.builtin.TypeError(\"flags must be a number\");return(e=\"/\"+a.v.replace(/\\//g,\"\\\\/\")+\"/\",lst=mod._findre(e,b),1>lst.v.length)?Sk.builtin.none.none$:(d=Sk.misceval.callsimArray(mod.MatchObject,[lst,a,b]),d)},_search.co_varnames=[\"pattern\",\"string\",\"flags\"],_search.$defaults=[new Sk.builtin.int_(0)],mod.search=new Sk.builtin.func(_search),_match=function(a,b,c){var d,e;if(Sk.builtin.pyCheckArgsLen(\"match\",arguments.length,2,3),!Sk.builtin.checkString(a))throw new Sk.builtin.TypeError(\"pattern must be a string\");if(!Sk.builtin.checkString(b))throw new Sk.builtin.TypeError(\"string must be a string\");if(void 0===c&&(c=0),!Sk.builtin.checkNumber(c))throw new Sk.builtin.TypeError(\"flags must be a number\");return(pat=Sk.ffi.remapToJs(a),e=\"/^\"+pat.replace(/\\//g,\"\\\\/\")+\"/\",lst=mod._findre(e,b),1>Sk.ffi.remapToJs(lst).length)?Sk.builtin.none.none$:(d=Sk.misceval.callsimArray(mod.MatchObject,[lst,a,b]),d)},_match.co_varnames=[\"pattern\",\"string\",\"flags\"],_match.$defaults=[new Sk.builtin.int_(0)],mod.match=new Sk.builtin.func(_match),regexobj=function(a,b){var c,d,e,f,g,h;b.__init__=new Sk.builtin.func(function(a,b,c){a.re=b,a.flags=void 0===c?0:c}),h=new Sk.builtin.func(function(a){var b=\"re.compile('\"+Sk.ffi.remapToPy(a.re)+\"')\";return Sk.ffi.remapToPy(b.substring(0,212))}),b.__str__=h,b.__repr__=h,c=function(a,b,c){var d=Sk.ffi.remapToJs(a),e=null==b?0:Sk.ffi.remapToJs(b),f=null==c?d.length:Sk.ffi.remapToJs(c);return\"^\"==e&&(e=d.indexOf(\"\\n\")+1),f==Sk.builtin.none.none$&&(f=d.length),Sk.ffi.remapToPy(d.substring(e,f))},d=function(a,b,d,e){Sk.builtin.pyCheckArgsLen(\"search\",arguments.length,2,4);var f=c(b,d,e);return _search(a.re,f,a.flags)},d.co_varnames=[\"self\",\"string\",\"pos\",\"endpos\"],d.$defaults=[new Sk.builtin.int_(0),Sk.builtin.none.none$],b.search=new Sk.builtin.func(d),e=function(a,b,d,e){Sk.builtin.pyCheckArgsLen(\"match\",arguments.length,2,4);var f=c(b,d,e);return _match(a.re,f,a.flags)},e.co_varnames=[\"self\",\"string\",\"pos\",\"endpos\"],e.$defaults=[new Sk.builtin.int_(0),Sk.builtin.none.none$],b.match=new Sk.builtin.func(e),f=function(a,b,c){if(Sk.builtin.pyCheckArgsLen(\"split\",arguments.length,2,3),void 0===c&&(c=0),!Sk.builtin.checkInt(c))throw new Sk.builtin.TypeError(\"maxsplit must be an integer\");return _split(a.re,b,c,a.flags)},f.co_varnames=[\"self\",\"string\",\"maxsplit\"],f.$defaults=[new Sk.builtin.int_(0)],b.split=new Sk.builtin.func(f),g=function(a,b,d,e){Sk.builtin.pyCheckArgsLen(\"findall\",arguments.length,2,4);var f=c(b,d,e);return _findall(a.re,f,a.flags)},g.co_varnames=[\"self\",\"string\",\"pos\",\"endpos\"],g.$defaults=[new Sk.builtin.int_(0),Sk.builtin.none.none$],b.findall=new Sk.builtin.func(g)},mod.RegexObject=Sk.misceval.buildClass(mod,regexobj,\"RegexObject\",[]),mod.compile=new Sk.builtin.func(function(a,b){var c;if(Sk.builtin.pyCheckArgsLen(\"compile\",arguments.length,1,2),!Sk.builtin.checkString(a))throw new Sk.builtin.TypeError(\"pattern must be a string\");if(void 0===b&&(b=0),!Sk.builtin.checkNumber(b))throw new Sk.builtin.TypeError(\"flags must be a number\");return c=Sk.misceval.callsimArray(mod.RegexObject,[a,b]),c}),mod.purge=new Sk.builtin.func(function(){}),mod};","src/lib/repr.py":"raise NotImplementedError(\"repr is not yet implemented in Skulpt\")\n","src/lib/rexec.py":"raise NotImplementedError(\"rexec is not yet implemented in Skulpt\")\n","src/lib/rfc822.py":"raise NotImplementedError(\"rfc822 is not yet implemented in Skulpt\")\n","src/lib/rlcompleter.py":"raise NotImplementedError(\"rlcompleter is not yet implemented in Skulpt\")\n","src/lib/robotparser.py":"raise NotImplementedError(\"robotparser is not yet implemented in Skulpt\")\n","src/lib/runpy.py":"raise NotImplementedError(\"runpy is not yet implemented in Skulpt\")\n","src/lib/sched.py":"raise NotImplementedError(\"sched is not yet implemented in Skulpt\")\n","src/lib/sets.py":"raise NotImplementedError(\"sets is not yet implemented in Skulpt\")\n","src/lib/sgmllib.py":"raise NotImplementedError(\"sgmllib is not yet implemented in Skulpt\")\n","src/lib/sha.py":"raise NotImplementedError(\"sha is not yet implemented in Skulpt\")\n","src/lib/shelve.py":"raise NotImplementedError(\"shelve is not yet implemented in Skulpt\")\n","src/lib/shlex.py":"raise NotImplementedError(\"shlex is not yet implemented in Skulpt\")\n","src/lib/shutil.py":"raise NotImplementedError(\"shutil is not yet implemented in Skulpt\")\n","src/lib/signal.js":"var $builtinmodule=function(){var a={SIG_DFL:new Sk.builtin.int_(0),SIG_IGN:new Sk.builtin.int_(1),CTRL_C_EVENT:new Sk.builtin.int_(0),CTRL_BREAK_EVENT:new Sk.builtin.int_(0),NSIG:new Sk.builtin.int_(23),SIGHUP:new Sk.builtin.int_(1),SIGNINT:new Sk.builtin.int_(2),SIGILL:new Sk.builtin.int_(4),SIGFPE:new Sk.builtin.int_(8),SIGKILL:new Sk.builtin.int_(9),SIGSEGV:new Sk.builtin.int_(11),SIGTERM:new Sk.builtin.int_(15),SIGBREAK:new Sk.builtin.int_(21),SIGABRT:new Sk.builtin.int_(22),pause:new Sk.builtin.func(function(){Sk.builtin.pyCheckArgsLen(\"pause\",arguments.length,0,0);var a=new Sk.misceval.Suspension;return a.resume=function(){return Sk.builtin.none.none$},a.data={type:\"Sk.promise\",promise:new Promise(function(a){if(null!=Sk.signals&&Sk.signals.addEventListener){function b(){Sk.signals.removeEventListener(b),a()}Sk.signals.addEventListener(b)}else console.warn(\"signal.pause() not supported\"),Sk.misceval.print_(\"signal.pause() not supported\"),a()})},a}),signal:new Sk.builtin.func(function(){throw new Sk.builtin.NotImplementedError(\"signal.signal is not supported.\")})};return a};","src/lib/site.py":"raise NotImplementedError(\"site is not yet implemented in Skulpt\")\n","src/lib/smtpd.py":"raise NotImplementedError(\"smtpd is not yet implemented in Skulpt\")\n","src/lib/smtplib.py":"raise NotImplementedError(\"smtplib is not yet implemented in Skulpt\")\n","src/lib/sndhdr.py":"raise NotImplementedError(\"sndhdr is not yet implemented in Skulpt\")\n","src/lib/socket.py":"raise NotImplementedError(\"socket is not yet implemented in Skulpt\")\n","src/lib/sqlite3/__init__.py":"raise NotImplementedError(\"sqlite3 is not yet implemented in Skulpt\")\n","src/lib/sre.py":"raise NotImplementedError(\"sre is not yet implemented in Skulpt\")\n","src/lib/sre_compile.py":"raise NotImplementedError(\"sre_compile is not yet implemented in Skulpt\")\n","src/lib/sre_constants.py":"raise NotImplementedError(\"sre_constants is not yet implemented in Skulpt\")\n","src/lib/sre_parse.py":"raise NotImplementedError(\"sre_parse is not yet implemented in Skulpt\")\n","src/lib/ssl.py":"raise NotImplementedError(\"ssl is not yet implemented in Skulpt\")\n","src/lib/stat.py":"\"\"\"Constants/functions for interpreting results of os.stat() and os.lstat().\n\nSuggested usage: from stat import *\n\"\"\"\n\n# Indices for stat struct members in the tuple returned by os.stat()\n\nST_MODE  = 0\nST_INO   = 1\nST_DEV   = 2\nST_NLINK = 3\nST_UID   = 4\nST_GID   = 5\nST_SIZE  = 6\nST_ATIME = 7\nST_MTIME = 8\nST_CTIME = 9\n\n# Extract bits from the mode\n\ndef S_IMODE(mode):\n    \"\"\"Return the portion of the file's mode that can be set by\n    os.chmod().\n    \"\"\"\n    return mode & 0o7777\n\ndef S_IFMT(mode):\n    \"\"\"Return the portion of the file's mode that describes the\n    file type.\n    \"\"\"\n    return mode & 0o170000\n\n# Constants used as S_IFMT() for various file types\n# (not all are implemented on all systems)\n\nS_IFDIR  = 0o040000  # directory\nS_IFCHR  = 0o020000  # character device\nS_IFBLK  = 0o060000  # block device\nS_IFREG  = 0o100000  # regular file\nS_IFIFO  = 0o010000  # fifo (named pipe)\nS_IFLNK  = 0o120000  # symbolic link\nS_IFSOCK = 0o140000  # socket file\n\n# Functions to test for each file type\n\ndef S_ISDIR(mode):\n    \"\"\"Return True if mode is from a directory.\"\"\"\n    return S_IFMT(mode) == S_IFDIR\n\ndef S_ISCHR(mode):\n    \"\"\"Return True if mode is from a character special device file.\"\"\"\n    return S_IFMT(mode) == S_IFCHR\n\ndef S_ISBLK(mode):\n    \"\"\"Return True if mode is from a block special device file.\"\"\"\n    return S_IFMT(mode) == S_IFBLK\n\ndef S_ISREG(mode):\n    \"\"\"Return True if mode is from a regular file.\"\"\"\n    return S_IFMT(mode) == S_IFREG\n\ndef S_ISFIFO(mode):\n    \"\"\"Return True if mode is from a FIFO (named pipe).\"\"\"\n    return S_IFMT(mode) == S_IFIFO\n\ndef S_ISLNK(mode):\n    \"\"\"Return True if mode is from a symbolic link.\"\"\"\n    return S_IFMT(mode) == S_IFLNK\n\ndef S_ISSOCK(mode):\n    \"\"\"Return True if mode is from a socket.\"\"\"\n    return S_IFMT(mode) == S_IFSOCK\n\n# Names for permission bits\n\nS_ISUID = 0o4000  # set UID bit\nS_ISGID = 0o2000  # set GID bit\nS_ENFMT = S_ISGID # file locking enforcement\nS_ISVTX = 0o1000  # sticky bit\nS_IREAD = 0o0400  # Unix V7 synonym for S_IRUSR\nS_IWRITE = 0o0200 # Unix V7 synonym for S_IWUSR\nS_IEXEC = 0o0100  # Unix V7 synonym for S_IXUSR\nS_IRWXU = 0o0700  # mask for owner permissions\nS_IRUSR = 0o0400  # read by owner\nS_IWUSR = 0o0200  # write by owner\nS_IXUSR = 0o0100  # execute by owner\nS_IRWXG = 0o0070  # mask for group permissions\nS_IRGRP = 0o0040  # read by group\nS_IWGRP = 0o0020  # write by group\nS_IXGRP = 0o0010  # execute by group\nS_IRWXO = 0o0007  # mask for others (not in group) permissions\nS_IROTH = 0o0004  # read by others\nS_IWOTH = 0o0002  # write by others\nS_IXOTH = 0o0001  # execute by others\n\n# Names for file flags\n\nUF_NODUMP    = 0x00000001  # do not dump file\nUF_IMMUTABLE = 0x00000002  # file may not be changed\nUF_APPEND    = 0x00000004  # file may only be appended to\nUF_OPAQUE    = 0x00000008  # directory is opaque when viewed through a union stack\nUF_NOUNLINK  = 0x00000010  # file may not be renamed or deleted\nUF_COMPRESSED = 0x00000020 # OS X: file is hfs-compressed\nUF_HIDDEN    = 0x00008000  # OS X: file should not be displayed\nSF_ARCHIVED  = 0x00010000  # file may be archived\nSF_IMMUTABLE = 0x00020000  # file may not be changed\nSF_APPEND    = 0x00040000  # file may only be appended to\nSF_NOUNLINK  = 0x00100000  # file may not be renamed or deleted\nSF_SNAPSHOT  = 0x00200000  # file is a snapshot file\n\n\n_filemode_table = (\n    ((S_IFLNK,         \"l\"),\n     (S_IFSOCK,        \"s\"),  # Must appear before IFREG and IFDIR as IFSOCK == IFREG | IFDIR\n     (S_IFREG,         \"-\"),\n     (S_IFBLK,         \"b\"),\n     (S_IFDIR,         \"d\"),\n     (S_IFCHR,         \"c\"),\n     (S_IFIFO,         \"p\")),\n\n    ((S_IRUSR,         \"r\"),),\n    ((S_IWUSR,         \"w\"),),\n    ((S_IXUSR|S_ISUID, \"s\"),\n     (S_ISUID,         \"S\"),\n     (S_IXUSR,         \"x\")),\n\n    ((S_IRGRP,         \"r\"),),\n    ((S_IWGRP,         \"w\"),),\n    ((S_IXGRP|S_ISGID, \"s\"),\n     (S_ISGID,         \"S\"),\n     (S_IXGRP,         \"x\")),\n\n    ((S_IROTH,         \"r\"),),\n    ((S_IWOTH,         \"w\"),),\n    ((S_IXOTH|S_ISVTX, \"t\"),\n     (S_ISVTX,         \"T\"),\n     (S_IXOTH,         \"x\"))\n)\n\ndef filemode(mode):\n    \"\"\"Convert a file's mode to a string of the form '-rwxrwxrwx'.\"\"\"\n    perm = []\n    for table in _filemode_table:\n        for bit, char in table:\n            if mode & bit == bit:\n                perm.append(char)\n                break\n        else:\n            perm.append(\"-\")\n    return \"\".join(perm)\n\n\n# Windows FILE_ATTRIBUTE constants for interpreting os.stat()'s\n# \"st_file_attributes\" member\n\nFILE_ATTRIBUTE_ARCHIVE = 32\nFILE_ATTRIBUTE_COMPRESSED = 2048\nFILE_ATTRIBUTE_DEVICE = 64\nFILE_ATTRIBUTE_DIRECTORY = 16\nFILE_ATTRIBUTE_ENCRYPTED = 16384\nFILE_ATTRIBUTE_HIDDEN = 2\nFILE_ATTRIBUTE_INTEGRITY_STREAM = 32768\nFILE_ATTRIBUTE_NORMAL = 128\nFILE_ATTRIBUTE_NOT_CONTENT_INDEXED = 8192\nFILE_ATTRIBUTE_NO_SCRUB_DATA = 131072\nFILE_ATTRIBUTE_OFFLINE = 4096\nFILE_ATTRIBUTE_READONLY = 1\nFILE_ATTRIBUTE_REPARSE_POINT = 1024\nFILE_ATTRIBUTE_SPARSE_FILE = 512\nFILE_ATTRIBUTE_SYSTEM = 4\nFILE_ATTRIBUTE_TEMPORARY = 256\nFILE_ATTRIBUTE_VIRTUAL = 65536\n\n\n# If available, use C implementation\ntry:\n    from _stat import *\nexcept ImportError:\n    pass\n\n","src/lib/statvfs.py":"raise NotImplementedError(\"statvfs is not yet implemented in Skulpt\")\n","src/lib/string.js":"var $builtinmodule=function(){var a={};return a.ascii_lowercase=Sk.builtin.str(\"abcdefghijklmnopqrstuvwxyz\"),a.ascii_uppercase=Sk.builtin.str(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"),a.ascii_letters=Sk.builtin.str(a.ascii_lowercase.v+a.ascii_uppercase.v),a.lowercase=Sk.builtin.str(\"abcdefghijklmnopqrstuvwxyz\"),a.uppercase=Sk.builtin.str(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"),a.letters=Sk.builtin.str(a.lowercase.v+a.uppercase.v),a.digits=Sk.builtin.str(\"0123456789\"),a.hexdigits=Sk.builtin.str(\"0123456789abcdefABCDEF\"),a.octdigits=Sk.builtin.str(\"01234567\"),a.punctuation=Sk.builtin.str(\"!\\\"#$%&'()*+,-./:;<=>?@[\\\\]^_`{|}~\"),a.whitespace=Sk.builtin.str(\"\\t\\n\\x0B\\f\\r \"),a.printable=Sk.builtin.str(a.digits.v+a.letters.v+a.punctuation.v+\" \\t\\n\\r\\x0B\\f\"),a.split=new Sk.builtin.func(function(a,b,c){return Sk.misceval.callsimArray(Sk.builtin.str.prototype.split,[a,b,c])}),a.capitalize=new Sk.builtin.func(function(a){return Sk.misceval.callsimArray(Sk.builtin.str.prototype.capitalize,[a])}),a.join=new Sk.builtin.func(function(a,b){return void 0===b&&(b=Sk.builtin.str(\" \")),Sk.misceval.callsimArray(Sk.builtin.str.prototype.join,[b,a])}),a.capwords=new Sk.builtin.func(function(b,c){if(Sk.builtin.pyCheckArgsLen(\"capwords\",arguments.length,1,2),!Sk.builtin.checkString(b))throw new Sk.builtin.TypeError(\"s must be a string\");if(void 0===c&&(c=Sk.builtin.str(\" \")),!Sk.builtin.checkString(c))throw new Sk.builtin.TypeError(\"sep must be a string\");for(var d=Sk.misceval.callsimArray(a.split,[b,c]),e=[],f=0;f<d.v.length;f++){var g=Sk.builtin.list.prototype.list_subscript_.call(d,f),h=Sk.misceval.callsimArray(a.capitalize,[g]);e.push(h)}return Sk.misceval.callsimArray(a.join,[new Sk.builtin.list(e),c])}),a};","src/lib/string.py":"raise NotImplementedError(\"string is not yet implemented in Skulpt\")\n","src/lib/stringold.py":"raise NotImplementedError(\"stringold is not yet implemented in Skulpt\")\n","src/lib/stringprep.py":"raise NotImplementedError(\"stringprep is not yet implemented in Skulpt\")\n","src/lib/struct.py":"raise NotImplementedError(\"struct is not yet implemented in Skulpt\")\n","src/lib/subprocess.py":"raise NotImplementedError(\"subprocess is not yet implemented in Skulpt\")\n","src/lib/sunau.py":"raise NotImplementedError(\"sunau is not yet implemented in Skulpt\")\n","src/lib/sunaudio.py":"raise NotImplementedError(\"sunaudio is not yet implemented in Skulpt\")\n","src/lib/symbol.py":"raise NotImplementedError(\"symbol is not yet implemented in Skulpt\")\n","src/lib/symtable.py":"raise NotImplementedError(\"symtable is not yet implemented in Skulpt\")\n","src/lib/tabnanny.py":"raise NotImplementedError(\"tabnanny is not yet implemented in Skulpt\")\n","src/lib/tarfile.py":"raise NotImplementedError(\"tarfile is not yet implemented in Skulpt\")\n","src/lib/telnetlib.py":"raise NotImplementedError(\"telnetlib is not yet implemented in Skulpt\")\n","src/lib/tempfile.py":"raise NotImplementedError(\"tempfile is not yet implemented in Skulpt\")\n","src/lib/test/__init__.py":"__author__ = 'bmiller'\n\ndef testEqual(actual, expected):\n    if type(expected) == type(1):\n        if actual == expected:\n            print('Pass')\n            return True\n    elif type(expected) == type(1.11):\n        if abs(actual-expected) < 0.00001:\n            print('Pass')\n            return True\n    else:\n        if actual == expected:\n            print('Pass')\n            return True\n    print('Test Failed: expected ' + str(expected) + ' but got ' + str(actual))\n    return False\n\ndef testNotEqual(actual, expected):\n    pass\n\n","src/lib/test/decimaltestdata/__init__.py":"raise NotImplementedError(\"decimaltestdata is not yet implemented in Skulpt\")\n","src/lib/test/test_support.py":"\"\"\"Supporting definitions for the Python regression tests.\"\"\"\n\nif __name__ != 'test.test_support':\n    raise ImportError('test_support must be imported from the test package')\n\nimport unittest\n\n\n# def run_unittest(*classes):\n#     \"\"\"Run tests from unittest.TestCase-derived classes.\"\"\"\n#     valid_types = (unittest.TestSuite, unittest.TestCase)\n#     suite = unittest.TestSuite()\n#     for cls in classes:\n#         if isinstance(cls, str):\n#             if cls in sys.modules:\n#                 suite.addTest(unittest.findTestCases(sys.modules[cls]))\n#             else:\n#                 raise ValueError(\"str arguments must be keys in sys.modules\")\n#         elif isinstance(cls, valid_types):\n#             suite.addTest(cls)\n#         else:\n#             suite.addTest(unittest.makeSuite(cls))\n#     _run_suite(suite)\n\ndef run_unittest(*classes):\n    \"\"\"Run tests from unittest.TestCase-derived classes.\"\"\"\n    for cls in classes:\n        print cls\n        if issubclass(cls, unittest.TestCase):\n            cls().main()\n        else:\n            print \"Don't know what to do with \", cls\n","src/lib/textwrap.py":"raise NotImplementedError(\"textwrap is not yet implemented in Skulpt\")\n","src/lib/this.py":"raise NotImplementedError(\"this is not yet implemented in Skulpt\")\n","src/lib/threading.py":"raise NotImplementedError(\"threading is not yet implemented in Skulpt\")\n","src/lib/time.js":"var $builtinmodule=function(){function a(a){if(!(a instanceof m))throw new Sk.builtin.TypeError(\"Required argument 'struct_time' must be of type: 'struct_time'\");var b,c=a.v.length,d=a.v;for(b=0;b<c;++b)if(!Sk.builtin.checkInt(d[b]))throw new Sk.builtin.TypeError(\"struct_time may only contain integers\");return!0}function b(a,b,d){var c=a.toString();return Array(b-c.length+1).join(d||\" \")+c}function c(a){return 0==(3&a)&&(0!=a%100||0==a%400)}function d(a,b){b=b||!1;var d=b?a.getUTCMonth():a.getMonth(),e=b?a.getUTCDate():a.getDate(),f=[0,31,59,90,120,151,181,212,243,273,304,334][d]+e;return 1<d&&c(b?a.getUTCFullYear():a.getFullYear())&&f++,f}function e(){var a=Math.max,b=new Date(2002,0,1),c=new Date(2002,6,1);return a(b.getTimezoneOffset(),c.getTimezoneOffset())}function f(a){return a.getTimezoneOffset()<e()}function g(a){var b,c=/\\((.*)\\)/.exec(a.toString());if(null!=this.navigator&&(b=this.navigator.userLanguage||this.navigator.language),c&&1<c.length)return c[1];if(void 0===b)return null;try{var d=a.toLocaleString(b,{timeZoneName:\"short\"});return c=d.split(\" \"),c[c.length-1]}catch(a){return null}}function h(a,b){return b=b||!1,new m([Sk.builtin.assk$(b?a.getUTCFullYear():a.getFullYear()),Sk.builtin.assk$((b?a.getUTCMonth():a.getMonth())+1),Sk.builtin.assk$(b?a.getUTCDate():a.getDate()),Sk.builtin.assk$(b?a.getUTCHours():a.getHours()),Sk.builtin.assk$(b?a.getUTCMinutes():a.getMinutes()),Sk.builtin.assk$(b?a.getUTCSeconds():a.getSeconds()),Sk.builtin.assk$(((b?a.getUTCDay():a.getDay())+6)%7),Sk.builtin.assk$(d(a,b)),Sk.builtin.assk$(b?0:f(a)?1:0)])}function i(a){Sk.builtin.pyCheckArgsLen(\"localtime\",arguments.length,0,1);var b=new Date;if(a){Sk.builtin.pyCheckType(\"secs\",\"number\",Sk.builtin.checkNumber(a));var c=Sk.builtin.asnum$(a);b.setTime(1e3*c)}return h(b)}function j(a){if(!a||Sk.builtin.checkNone(a)?a=i():!(a instanceof m)&&(a=new m(a)),a instanceof Sk.builtin.tuple&&9==a.v.length){var c=[o[Sk.builtin.asnum$(a.v[6])],n[Sk.builtin.asnum$(a.v[1])-1],b(Sk.builtin.asnum$(a.v[2]).toString(),2,\"0\"),b(Sk.builtin.asnum$(a.v[3]).toString(),2,\"0\")+\":\"+b(Sk.builtin.asnum$(a.v[4]).toString(),2,\"0\")+\":\"+b(Sk.builtin.asnum$(a.v[5]).toString(),2,\"0\"),b(Sk.builtin.asnum$(a.v[0]).toString(),4,\"0\")];return Sk.builtin.str(c.join(\" \"))}}function k(a){if(a instanceof Sk.builtin.tuple&&9==a.v.length){var b=new Date(Sk.builtin.asnum$(a.v[0]),Sk.builtin.asnum$(a.v[1])-1,Sk.builtin.asnum$(a.v[2]),Sk.builtin.asnum$(a.v[3]),Sk.builtin.asnum$(a.v[4]),Sk.builtin.asnum$(a.v[5]));return Sk.builtin.assk$(b.getTime()/1e3,void 0)}throw new Sk.builtin.TypeError(\"mktime() requires a struct_time or 9-tuple\")}var l={__file__:\"/src/lib/time/__init__.js\",__package__:Sk.builtin.none.none$},m=Sk.builtin.make_structseq(\"time\",\"struct_time\",{tm_year:\"year, for example, 1993\",tm_mon:\"month of year, range [1, 12]\",tm_mday:\"day of month, range [1, 31]\",tm_hour:\"hours, range [0, 23]\",tm_min:\"minutes, range [0, 59]\",tm_sec:\"seconds, range [0, 61]\",tm_wday:\"day of week, range [0, 6], Monday is 0\",tm_yday:\"day of year, range [1, 366]\",tm_isdst:\"1 if summer time is in effect, 0 if not, and -1 if unknown\"});l.struct_time=m,l.time=new Sk.builtin.func(function(){Sk.builtin.pyCheckArgsLen(\"time\",arguments.length,0,0);var a=Date.now();return this.performance&&this.performance.now&&(a+=performance.now()%1),Sk.builtin.assk$(a/1e3,void 0)}),l.sleep=new Sk.builtin.func(function(a){return Sk.builtin.pyCheckArgsLen(\"sleep\",arguments.length,1,1),Sk.builtin.pyCheckType(\"delay\",\"float\",Sk.builtin.checkNumber(a)),new Sk.misceval.promiseToSuspension(new Promise(function(b){Sk.setTimeout(function(){b(Sk.builtin.none.none$)},1e3*Sk.ffi.remapToJs(a))}))}),l.localtime=new Sk.builtin.func(i),l.gmtime=new Sk.builtin.func(function(a){Sk.builtin.pyCheckArgsLen(\"localtime\",arguments.length,0,1);var b=new Date;if(a){Sk.builtin.pyCheckType(\"secs\",\"number\",Sk.builtin.checkNumber(a));var c=Sk.builtin.asnum$(a);b.setTime(1e3*c)}return h(b,!0)});var n=[\"Jan\",\"Feb\",\"Mar\",\"Apr\",\"May\",\"Jun\",\"Jul\",\"Aug\",\"Sep\",\"Oct\",\"Nov\",\"Dec\"],o=[\"Mon\",\"Tue\",\"Wed\",\"Thu\",\"Fri\",\"Sat\",\"Sun\"];return l.asctime=new Sk.builtin.func(j),l.ctime=new Sk.builtin.func(function(a){return j(i(a))}),l.mktime=new Sk.builtin.func(k),l.timezone=new Sk.builtin.int_(60*e()),l.altzone=new Sk.builtin.int_(60*function(){var a=Math.min,b=new Date(2002,0,1),c=new Date(2002,6,1);return a(b.getTimezoneOffset(),c.getTimezoneOffset())}()),l.daylight=new Sk.builtin.int_(f(new Date)?1:0),l.tzname=Sk.builtin.tuple(function(){var a=new Date(2002,0,1),b=new Date(2002,6,1);return f(a)?[Sk.builtin.str(g(b)),Sk.builtin.str(g(a))]:[Sk.builtin.str(g(a)),Sk.builtin.str(g(b))]}()),l.accept2dyear=Sk.builtin.assk$(1,Sk.builtin.nmber.int$),l.clock=new Sk.builtin.func(function(){var a=0;return a=this.performance&&this.performance.now?performance.now()/1e3:new Date().getTime()/1e3,new Sk.builtin.float_(a)}),l.strftime=new Sk.builtin.func(function(b,c){var d;if(Sk.builtin.pyCheckArgsLen(\"strftime\",arguments.length,1,2),!Sk.builtin.checkString(b))throw new Sk.builtin.TypeError(\"format must be a string\");return c?!(c instanceof m)&&(c=new m(c)):c=i(),a(c),d=Sk.ffi.remapToJs(b),Sk.ffi.remapToPy(strftime(d,new Date(1e3*k(c).v)))}),l.tzset=new Sk.builtin.func(function(){throw new Sk.builtin.NotImplementedError(\"time.tzset() is not yet implemented\")}),l.strptime=new Sk.builtin.func(function(a,b){Sk.builtin.pyCheckArgsLen(\"strptime\",arguments.length,1,2),Sk.builtin.pyCheckType(\"string\",\"string\",Sk.builtin.checkString(a)),void 0===b?b=new Sk.builtin.str(\"%a %b %d %H:%M:%S %Y\"):Sk.builtin.pyCheckType(\"format\",\"string\",Sk.builtin.checkString(b));let c=h(strptime(Sk.ffi.remapToJs(a),Sk.ffi.remapToJs(b),!0));return c.v[8]=new Sk.builtin.int_(-1),c}),l};","src/lib/timeit.py":"raise NotImplementedError(\"timeit is not yet implemented in Skulpt\")\n","src/lib/toaiff.py":"raise NotImplementedError(\"toaiff is not yet implemented in Skulpt\")\n","src/lib/token.py":"raise NotImplementedError(\"token is not yet implemented in Skulpt\")\n","src/lib/tokenize.py":"raise NotImplementedError(\"tokenize is not yet implemented in Skulpt\")\n","src/lib/trace.py":"raise NotImplementedError(\"trace is not yet implemented in Skulpt\")\n","src/lib/traceback.py":"raise NotImplementedError(\"traceback is not yet implemented in Skulpt\")\n","src/lib/tty.py":"raise NotImplementedError(\"tty is not yet implemented in Skulpt\")\n","src/lib/turtle.js":"var $builtinmodule=function(){\"use strict\";var e=function(){var e,t;for(e=Sk.TurtleGraphics&&Sk.TurtleGraphics.target||\"turtle\",t=\"string\"==typeof e?document.getElementById(e):e;t.firstChild;)t.removeChild(t.firstChild);return t}();return e.turtleInstance?e.turtleInstance.reset():e.turtleInstance=function(e){var q=Math.round,G=Math.max,H=Math.sqrt,W=Math.min,V=Math.abs,K=Math.PI,j=Math.atan2,J=Math.sin,X=Math.cos;function t(e){var t=ee.assets,n=\"function\"==typeof t?t(e):t[e];return\"string\"==typeof n?new Promise(function(t,r){var a=new Image;a.onload=function(){ee.assets[e]=this,t(a)},a.onerror=function(){r(new Error(\"Missing asset: \"+n))},a.src=n}):new r(void 0,n)}function r(e,t){this.lastResult=t,this.lastError=e}function n(){this.reset()}function a(){return ce||(ce=new n),ce}function s(){var t=this;for(var r in this._target=_(),this._managers={},this._handlers={mousedown:function(r){t.onEvent(\"mousedown\",r)},mouseup:function(r){t.onEvent(\"mouseup\",r)},mousemove:function(r){t.onEvent(\"mousemove\",r)}},this._handlers)this._target.addEventListener(r,this._handlers[r])}function i(e,t){this._type=e,this._target=t,this._handlers=void 0,u().addManager(e,this)}function l(){a().addTurtle(this),this._screen=c(),this._managers={},this.reset()}function o(){var e,t;this._frames=1,this._delay=void 0,this._bgcolor=\"none\",this._mode=\"standard\",this._managers={},this._keyLogger={},e=(ee.worldWidth||ee.width||m())/2,t=(ee.worldHeight||ee.height||p())/2,this.setUpWorld(-e,-t,e,t)}function d(){return te||(te=Sk.misceval.callsimArray(ne.Turtle)),te.instance}function _(){return e}function c(){return Z||(Z=new o),Z}function u(){return re||(re=new s),re}function m(){return 0|(Z&&Z._width||ee.width||_().clientWidth||_e.width)}function p(){return 0|(Z&&Z._height||ee.height||_().clientHeight||_e.height)}function g(e,t){var r,n=document.createElement(\"canvas\"),a=m(),s=p(),i=_().firstChild?-s+\"px\":\"0\";return n.width=a,n.height=s,n.style.position=\"relative\",n.style.display=\"block\",n.style.setProperty(\"margin-top\",i),n.style.setProperty(\"z-index\",e),t&&(n.style.display=\"none\"),_().appendChild(n),r=n.getContext(\"2d\"),r.lineCap=\"round\",r.lineJoin=\"round\",y(c(),r),r}function f(){Y&&((window.cancelAnimationFrame||window.mozCancelAnimationFrame)(Y),Y=void 0),Q&&(window.clearTimeout(Q),Q=void 0)}function y(e,t){var r=e.llx,n=e.lly,a=e.urx,s=e.ury,i=e.xScale,l=e.yScale;t&&(w(t),t.restore(),t.save(),t.scale(1/i,1/l),0===n?t.translate(-r,n-(s-n)):0<n?t.translate(-r,2*-n):t.translate(-r,-s))}function h(e){var t,r,n;if(ee.allowUndo&&e._bufferSize){for(e._undoBuffer||(e._undoBuffer=[]);e._undoBuffer.length>e._bufferSize;)e._undoBuffer.shift();for(r={},t=[\"x\",\"y\",\"angle\",\"radians\",\"color\",\"fill\",\"down\",\"filling\",\"shown\",\"shape\",\"size\"],n=0;n<t.length;n++)r[t[n]]=e[\"_\"+t[n]];return e._undoBuffer.push(r),e.addUpdate(function(){r.fillBuffer=this.fillBuffer?this.fillBuffer.slice():void 0,e._paper&&e._paper.canvas&&(r.image=e._paper.canvas.toDataURL())},!1)}}function $(e){var t;if(e._bufferSize&&e._undoBuffer&&(t=e._undoBuffer.pop(),!!t)){for(var r in t)\"image\"!=r&&\"fillBuffer\"!=r&&(e[\"_\"+r]=t[r]);return e.addUpdate(function(){var e;t.image&&(ue.src=t.image,e=ue),w(this.context(),!1,ue),delete t.image},!0,t)}}function b(e){e&&e.canvas&&e.canvas.parentNode&&e.canvas.parentNode.removeChild(e.canvas)}function w(e,t,r){e&&(e.save(),e.setTransform(1,0,0,1,0,0),t?(e.fillStyle=t,e.fillRect(0,0,e.canvas.width,e.canvas.height)):e.clearRect(0,0,e.canvas.width,e.canvas.height),r&&e.drawImage(r,0,0),e.restore())}function v(e,t){var r,n,a,s=le[e.shape],l=c(),o=m(),d=p(),_=l.xScale,u=l.yScale;if(t){if(r=X(e.radians)/_,n=J(e.radians)/u,a=j(n,r)-K/2,t.save(),t.translate(e.x,e.y),t.scale(_,u),s.nodeName){t.rotate(a+K);var g=s.naturalWidth,f=s.naturalHeight;t.drawImage(s,0,0,g,f,-g/2,-f/2,g,f)}else{t.rotate(a),t.beginPath(),t.lineWidth=1,t.strokeStyle=e.color,t.fillStyle=e.fill,t.moveTo(s[0][0],s[0][1]);for(var h=1;h<s.length;h++)t.lineTo(s[h][0],s[h][1]);t.closePath(),t.fill(),t.stroke()}t.restore()}}function k(e,t){var r=this.context(),n=c(),a=n.xScale,s=n.yScale;r&&(r.beginPath(),r.moveTo(this.x,this.y),e*=W(V(a),V(s)),r.arc(this.x,this.y,e/2,0,l.RADIANS),r.closePath(),r.fillStyle=t||this.color,r.fill())}function x(e,t){return t&&(me.font=t),me.measureText(e).width}function T(e,t,r){var n=this.context();n&&(n.save(),r&&(n.font=r),t&&t.match(/^(left|right|center)$/)&&(n.textAlign=t),n.scale(1,-1),n.fillStyle=this.fill,n.fillText(e,this.x,-this.y),n.restore())}function A(e,t){var r=this.context();r&&(t&&(r.beginPath(),r.moveTo(this.x,this.y)),r.lineWidth=this.size*c().lineScale,r.strokeStyle=this.color,r.lineTo(e.x,e.y),r.stroke())}function L(){var e,t=this.context(),r=this.fillBuffer;if(t&&r&&r.length){for(t.save(),t.beginPath(),t.moveTo(r[0].x,r[0].y),e=1;e<r.length;e++)t.lineTo(r[e].x,r[e].y);for(t.closePath(),t.fillStyle=this.fill,t.fill(),e=1;e<r.length;e++)r[e].stroke&&(t.beginPath(),t.moveTo(r[e-1].x,r[e-1].y),t.lineWidth=r[e].size*c().lineScale,t.strokeStyle=r[e].color,t.lineTo(r[e].x,r[e].y),t.stroke());t.restore()}}function S(e,t,r,n,a){return function(){return e.addUpdate(function(e){this.down&&A.call(this,e,n)},a,{x:t,y:r},n)}}function C(e,t,n,s,l,o,d){var _,u=e._computed_speed,m=c(),p=V(m.xScale),g=V(m.yScale),f=t,h=n,$=H(s*s*p+l*l*g),b=u?q(G(1,$/u)):1,w=a().willRenderNext()?Promise.resolve():new r;for(e.addUpdate(function(){this.filling&&this.fillBuffer.push({x:this.x,y:this.y,stroke:this.down,color:this.color,size:this.size})},!1),_=0;_<b;_++)f=t+s/b*(_+1),h=n+l/b*(_+1),w=w.then(S(e,f,h,o,u||!d)),o=!1;return w.then(function(){return[t+s,n+l]})}function R(e,t,r,n){return function(){return e.addUpdate(void 0,n,{angle:t,radians:r})}}function U(e,t,n,s){var l,o=e._computed_speed,d=360*(n/e._fullCircle),_=o?q(G(1,V(d)/o)):1,c={},u=a().willRenderNext()?Promise.resolve():new r;for(l=0;l<_;l++)z(e,t+n/_*(l+1),c),u=u.then(R(e,c.angle,c.radians,o||!s));return u.then(function(){return z(e,t+n)})}function M(e,t){return void 0===t&&(t=e&&(e.y||e._y||e[1])||0,e=e&&(e.x||e._x||e[0])||0),{x:e,y:t}}function E(e){var t,r,n;return(t=/^rgba?\\((\\d+),(\\d+),(\\d+)(?:,([.\\d]+))?\\)$/.exec(e))?(n=[parseInt(t[1]),parseInt(t[2]),parseInt(t[3])],t[4]&&n.push(parseFloat(t[4]))):/^#?[a-f\\d]{3}|[a-f\\d]{6}$/i.exec(e)?(4===e.length&&(e=e.replace(/^#?([a-f\\d])([a-f\\d])([a-f\\d])$/i,function(e,t,r,n){return t+t+r+r+n+n})),r=/^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(e),n=[parseInt(r[1],16),parseInt(r[2],16),parseInt(r[3],16)]):n=e,n}function I(e,t,r,n,s){var a;if(\"number\"==typeof t&&(255<t||0>t)||\"number\"==typeof r&&(255<r||0>r)||\"number\"==typeof n&&(255<n||0>n))throw new Sk.builtin.TypeError(\"rgb \\u7684\\u6570\\u503C\\u8303\\u56F4\\u57280~255\\u4E4B\\u95F4\");if(void 0!==r&&(t=[t,r,n,s]),\"number\"==typeof t&&(255<t||0>t)||\"number\"==typeof r&&(255<r||0>r)||\"number\"==typeof n&&(255<n||0>n))throw new Sk.builtin.TypeError(\"rgb \\u7684\\u6570\\u503C\\u8303\\u56F4\\u57280~255\\u4E4B\\u95F4\");if(t.constructor===Array&&t.length){if(255===e){for(a=0;3>a;a++)if(\"number\"==typeof t[a])t[a]=G(0,W(255,parseInt(t[a])));else throw new Sk.builtin.ValueError(\"bad color sequence\");}else for(a=0;3>a;a++)if(\"number\"!=typeof t[a])throw new Sk.builtin.ValueError(\"bad color sequence\");else if(1>=t[a])t[a]=G(0,W(255,parseInt(255*t[a])));else throw new Sk.builtin.ValueError(\"bad color sequence\");\"number\"==typeof t[a]?(t[3]=G(0,W(1,t[a])),t=\"rgba(\"+t.join(\",\")+\")\"):t=\"rgb(\"+t.slice(0,3).join(\",\")+\")\"}else if(\"string\"==typeof t&&!t.match(/\\s*url\\s*\\(/i))t=t.replace(/\\s+/g,\"\");else return\"black\";return t}function z(e,t,r){var n=e._angle||0,a=e._radians||0;return r||(r={}),\"number\"==typeof t&&(e._isRadians?n=a=t%l.RADIANS:e._fullCircle?(n=t%e._fullCircle,a=n/e._fullCircle*l.RADIANS):n=a=0,0>n&&(n+=e._fullCircle,a+=l.RADIANS)),r.angle=n,r.radians=a,r}function B(e,t){return function(){var r=Array.prototype.slice.call(arguments),n=r.map(function(e){return Sk.ffi.remapToPy(e)});return\"undefined\"!=typeof t&&n.unshift(t),Sk.misceval.applyAsync(void 0,e,void 0,void 0,void 0,n).catch(Sk.uncaughtException)}}function O(e,t,n,a){var s,l=n.replace(/^\\$/,\"\"),o=l.replace(/_\\$[a-z]+\\$$/i,\"\"),d=e.prototype[n].length,_=e.prototype[n].minArgs,c=e.prototype[n].co_varnames||[],u=e.prototype[n].returnType,m=e.prototype[n].isSk;void 0===_&&(_=d),s=function(){var e,t,s,l,c,p=Array.prototype.slice.call(arguments,0),g=a?a():p.shift().instance;if(p.length<_||p.length>d)throw c=_===d?\"exactly \"+d:\"between \"+_+\" and \"+d,new Sk.builtin.TypeError(o+\"() takes \"+c+\" positional argument(s) (\"+p.length+\" given)\");for(e=p.length;0<=--e;)void 0!==p[e]&&(p[e]=p[e]instanceof Sk.builtin.func?B(p[e]):p[e]instanceof Sk.builtin.method?B(p[e].im_func,p[e].im_self):p[e]&&p[e].$d instanceof Sk.builtin.dict&&p[e].instance?p[e].instance:Sk.ffi.remapToJs(p[e]));var f=p.slice();for(p=[],e=f.length;0<=e;--e)null!==f[e]&&(p[e]=f[e]);try{t=g[n].apply(g,p)}catch(t){throw window&&window.console&&(window.console.log(\"wrapped method failed\"),window.console.log(t.stack)),t}return t instanceof r&&(t=t.lastResult),t instanceof Promise?(t=t.catch(function(t){throw window&&window.console&&(window.console.log(\"promise failed\"),window.console.log(t.stack)),t}),s=new Sk.misceval.Suspension,s.resume=function(){return void 0===l?Sk.builtin.none.none$:Sk.ffi.remapToPy(l)},s.data={type:\"Sk.promise\",promise:t.then(function(e){return l=e,e})},s):void 0===t?Sk.builtin.none.none$:m?t:\"function\"==typeof u?u(t):Sk.ffi.remapToPy(t)},s.co_varnames=c.slice(),s.$defaults=[];for(var p=_;p<c.length;p++)s.$defaults.push(Sk.builtin.none.none$);a||s.co_varnames.unshift(\"self\"),t[l]=new Sk.builtin.func(s)}function P(e,t){for(var r in t.__init__=new Sk.builtin.func(function(e){e.instance=new l,e.instance.skInstance=e}),l.prototype)/^\\$[a-z_]+/.test(r)&&O(l,t,r)}function N(e){return void 0!==e&&(se=!!e,se?_().focus():_().blur()),se}function F(){for(f(),c().reset(),a().reset();e.firstChild;)e.removeChild(e.firstChild);re&&re.reset(),ae=0,Z=void 0,te=void 0,re=void 0,oe=0}function D(){f(),re&&re.reset(),ae=0,Z=void 0,te=void 0,re=void 0,oe=0}var Y,Q,Z,ee,te,re,ne={},ae=0,se=!0,ie=1e3/30,le={},oe=0,de={},_e={target:\"turtle\",width:400,height:400,worldWidth:0,worldHeight:0,animate:!0,bufferSize:0,allowUndo:!0,assets:{}};e.hasAttribute(\"tabindex\")||e.setAttribute(\"tabindex\",0),de.FLOAT=function(e){return Sk.builtin.float_(e)},de.COLOR=function(e){if(\"string\"==typeof e)return new Sk.builtin.str(e);for(var t=0;3>t;t++)e[t]=Sk.builtin.assk$(e[t]);return 4===e.length&&(e[3]=Sk.builtin.float_(e[3])),new Sk.builtin.tuple(e)},de.TURTLE_LIST=function(e){for(var t=[],r=0;r<e.length;r++)t.push(e[r].skInstance);return new Sk.builtin.tuple(t)},le.arrow=[[-10,0],[10,0],[0,10]],le.square=[[10,-10],[10,10],[-10,10],[-10,-10]],le.triangle=[[10,-5.77],[0,11.55],[-10,-5.77]],le.classic=[[0,0],[-5,-9],[0,-7],[5,-9]],le.turtle=[[0,16],[-2,14],[-1,10],[-4,7],[-7,9],[-9,8],[-6,5],[-7,1],[-5,-3],[-8,-6],[-6,-8],[-4,-5],[0,-7],[4,-5],[6,-8],[8,-6],[5,-3],[7,1],[6,5],[9,8],[7,9],[4,7],[1,10],[2,14]],le.circle=[[10,0],[9.51,3.09],[8.09,5.88],[5.88,8.09],[3.09,9.51],[0,10],[-3.09,9.51],[-5.88,8.09],[-8.09,5.88],[-9.51,3.09],[-10,0],[-9.51,-3.09],[-8.09,-5.88],[-5.88,-8.09],[-3.09,-9.51],[-0,-10],[3.09,-9.51],[5.88,-8.09],[8.09,-5.88],[9.51,-3.09]],ee=function(){for(var e in Sk.TurtleGraphics||(Sk.TurtleGraphics={}),_e)Sk.TurtleGraphics.hasOwnProperty(e)||(Sk.TurtleGraphics[e]=_e[e]);return Sk.TurtleGraphics}(),r.prototype.then=function(e){if(this.lastError)return this;try{this.lastResult=e(this.lastResult)}catch(t){this.lastResult=void 0,this.lastError=t}return this.lastResult instanceof Promise?this.lastResult:this},r.prototype.catch=function(e){if(this.lastError)try{this.lastResult=e(this.lastError),this.lastError=void 0}catch(t){this.lastResult=void 0,this.lastError=t}return this.lastResult instanceof Promise?this.lastResult:this};var ce;(function(e){function t(e){return ee.animate?!e&&n?n:function(t){return Q=window.setTimeout(t,e||ie),Q}:function(e){e()}}var n;(function(e){e&&(n=function(t){return Y=e(t)})})(window.requestAnimationFrame||window.mozRequestAnimationFrame),e.willRenderNext=function(){return!!(this._buffer&&this._frameCount+1===this.frameBuffer())},e.turtles=function(){return this._turtles},e.addTurtle=function(e){this._turtles.push(e)},e.reset=function(){if(this._turtles)for(var e=this._turtles.length;0<=--e;)this._turtles[e].reset();this._turtles=[],this._frames=[],this._frameCount=0,this._buffer=1,this._rate=0,this._animationFrame=t()},e.addFrame=function(e,t){var n=!1;return t&&(this._frameCount+=1),this.frames().push(e),n=!ee.animate||this._buffer&&this._frameCount===this.frameBuffer(),n?this.update():new r},e.frames=function(){return this._frames},e.frameBuffer=function(e){return\"number\"==typeof e&&(this._buffer=0|e,e&&e<=this._frameCount)?this.update():this._buffer},e.refreshInterval=function(e){return\"number\"==typeof e&&(this._rate=0|e,this._animationFrame=t(e)),this._rate},e.update=function(){return this._frames&&this._frames.length?this.requestAnimationFrame():new r},e.requestAnimationFrame=function(){var e,t,r=this._frames,n=this._animationFrame,a=this._turtles,s=c().spriteLayer();return this._frames=[],this._frameCount=0,new Promise(function(i){n(function(){for(t=0;t<r.length;t++)r[t]&&r[t]();for(w(s),t=0;t<a.length;t++)e=a[t],e.getState().shown&&v(e.getState(),s);i()})})}})(n.prototype),function(e){e.onEvent=function(t,r){function e(){if(!u){var e=c(),t=e.spriteLayer().canvas.getBoundingClientRect();n=0|r.clientX-t.left,a=0|r.clientY-t.top,s=n*e.xScale+e.llx,l=a*e.yScale+e.ury,u=!0}}var n,a,s,l,o,d=this._managers[t],_=this._managers.mousemove,u=!1;if((\"mousedown\"===t||\"mouseup\"===t)&&_&&_.length)for(e(),o=_.length;0<=--o;)_[o].test(n,a,s,l)&&_[o].canMove(\"mousedown\"===t);if(d&&d.length)for(e(),o=d.length;0<=--o;)\"mousemove\"===t&&d[o].canMove()&&d[o].test(n,a,s,l)?d[o].trigger([s,l]):\"mousedown\"===t&&d[o].test(n,a,s,l)&&d[o].trigger([s,l])},e.reset=function(){this._managers={}},e.addManager=function(e,t){this._managers[e]||(this._managers[e]=[]),this._managers[e].push(t)}}(s.prototype),function(e){e.reset=function(){this._handlers=void 0},e.canMove=function(e){return!!(this._target&&this._target.hitTest)&&(void 0!==e&&(this._target.hitTest.hit=e),this._target.hitTest.hit)},e.test=function(e,t,r,n){return this._target&&this._target.hitTest?this._target.hitTest(e,t,r,n):!!this._target},e.trigger=function(e){var t,r=this._handlers;if(r&&r.length)for(t=0;t<r.length;t++)r[t].apply({},e)},e.addHandler=function(e,t){var r=this._handlers;if(!t&&r&&r.length)for(;r.shift(););return\"function\"==typeof e?void(!r&&(r=this._handlers=[]),r.push(e)):void(r&&!r.length&&this.reset())}}(i.prototype),l.RADIANS=2*K,function(e){function t(e,t,r){return function(){return e.addUpdate(void 0,!1,{angle:t,radians:r})}}function n(e,t,r,n,a,s){return function(){return e.translate(t,r,n,a,s,!0)}}e.hitTest=function(e,t){var r=c().hitTestLayer();w(r),v(this.getState(),r);var n=r.getImageData(e,t,1,1).data;return n[3]||n[0]||n[1]||n[2]},e.addUpdate=function(e,t,r){var n=this,s=this.getState(),i=Array.prototype.slice.call(arguments,r?2:3);return a().addFrame(function(){if(e&&e.apply(s,i),r)for(var t in r)s[t]=r[t]},t)},e.getState=function(){var e=this;return this._state||(this._state={x:this._x,y:this._y,angle:this._angle,radians:this._radians,shape:this._shape,color:this._color,fill:this._fill,filling:this._filling,size:this._size,speed:this._computed_speed,down:this._down,shown:this._shown,colorMode:this._colorMode,context:function(){return e.getPaper()}}),this._state},e.translate=function(e,t,r,n,a,s){var i=this;return C(this,e,t,r,n,a,s).then(function(e){i._x=e[0],i._y=e[1]})},e.rotate=function(e,t,r){var n=this;if(\"number\"==typeof t)return U(this,e,t,r).then(function(e){n._angle=e.angle,n._radians=e.radians});throw new Sk.builtin.TypeError(\"params must be integers, not \"+Sk.abstr.typeName(t))},e.queueMoveBy=function(e,t,r,n){if(\"number\"==typeof n){var a=X(r)*n,s=J(r)*n;return this.translate(e,t,a,s,!0)}throw new Sk.builtin.TypeError(\"params must be integers, not \"+Sk.abstr.typeName(n))},e.queueTurnTo=function(e,t){return t%=this._fullCircle,0>t&&(t+=this._fullCircle),this.rotate(e,t-e)},e.getManager=function(e){return this._managers[e]||(this._managers[e]=new i(e,this)),this._managers[e]},e.getPaper=function(){return this._paper||(this._paper=g(2))},e.reset=function(){for(var e in this._x=0,this._y=0,this._radians=0,this._angle=0,this._shown=!0,this._down=!0,this._color=\"black\",this._fill=\"black\",this._shape=\"classic\",this._size=1,this._filling=!1,this._undoBuffer=[],this._speed=3,this._computed_speed=5,this._colorMode=1,this._state=void 0,this._managers)this._managers[e].reset();this._isRadians=!1,this._fullCircle=360,this._bufferSize=\"number\"==typeof ee.bufferSize?ee.bufferSize:0,b(this._paper),this._paper=void 0},e.$degrees=function(e){return e=\"number\"==typeof e?V(e):360,this._isRadians=!1,this._angle=e&&this._fullCircle?this._angle/this._fullCircle*e:this._radians=0,this._fullCircle=e,this.addUpdate(void 0,!1,{angle:this._angle,radians:this._radians})},e.$degrees.minArgs=0,e.$degrees.co_varnames=[\"fullcircle\"],e.$degrees.returnType=de.FLOAT,e.$radians=function(){return this._isRadians||(this._isRadians=!0,this._angle=this._radians,this._fullCircle=l.RADIANS),this._angle},e.$radians.returnType=de.FLOAT,e.$position=e.$pos=function(){return[this.$xcor(),this.$ycor()]},e.$position.returnType=function(e){return new Sk.builtin.tuple([Sk.builtin.float_(e[0]),Sk.builtin.float_(e[1])])},e.$towards=function(e,t){var r=M(e,t),n=K+j(this._y-r.y,this._x-r.x),a=n*(this._fullCircle/l.RADIANS);return a},e.$towards.co_varnames=[\"x\",\"y\"],e.$towards.minArgs=1,e.$towards.returnType=de.FLOAT,e.$distance=function(e,t){var r=M(e,t),n=r.x-this._x,a=r.y-this._y;return H(n*n+a*a)},e.$distance.co_varnames=[\"x\",\"y\"],e.$distance.minArgs=1,e.$distance.returnType=de.FLOAT,e.$heading=function(){return 1e-13>V(this._angle)?0:this._angle},e.$heading.returnType=de.FLOAT,e.$xcor=function(){return 1e-13>V(this._x)?0:this._x},e.$xcor.returnType=de.FLOAT,e.$ycor=function(){return 1e-13>V(this._y)?0:this._y},e.$ycor.returnType=de.FLOAT,e.$forward=e.$fd=function(e){return h(this),this.queueMoveBy(this._x,this._y,this._radians,e)},e.$forward.co_varnames=e.$fd.co_varnames=[\"distance\"],e.$undo=function(){$(this)},e.$undobufferentries=function(){return this._undoBuffer.length},e.$setundobuffer=function(e){this._bufferSize=\"number\"==typeof e?W(V(e),1e3):0},e.$setundobuffer.co_varnames=[\"size\"],e.$backward=e.$back=e.$bk=function(e){return h(this),this.queueMoveBy(this._x,this._y,this._radians,-e)},e.$backward.co_varnames=e.$back.co_varnames=e.$bk.co_varnames=[\"distance\"],e.$goto_$rw$=e.$setpos=e.$setposition=function(e,t){var r=M(e,t);return h(this),this.translate(this._x,this._y,r.x-this._x,r.y-this._y,!0)},e.$goto_$rw$.co_varnames=e.$setpos.co_varnames=e.$setposition.co_varnames=[\"x\",\"y\"],e.$goto_$rw$.minArgs=e.$setpos.minArgs=e.$setposition.minArgs=1,e.$setx=function(e){return this.translate(this._x,this._y,e-this._x,0,!0)},e.$setx.co_varnames=[\"x\"],e.$sety=function(e){return this.translate(this._x,this._y,0,e-this._y,!0)},e.$sety.co_varnames=[\"y\"],e.$home=function(){var e=this,t=this._angle;return h(this),e.translate(this._x,this._y,-this._x,-this._y,!0).then(function(){return e.queueTurnTo(t,0)}).then(function(){})},e.$right=e.$rt=function(e){return h(this),this.rotate(this._angle,-e)},e.$right.co_varnames=e.$rt.co_varnames=[\"angle\"],e.$left=e.$lt=function(e){return h(this),this.rotate(this._angle,e)},e.$left.co_varnames=e.$lt.co_varnames=[\"angle\"],e.$setheading=e.$seth=function(e){return h(this),this.queueTurnTo(this._angle,e)},e.$setheading.co_varnames=e.$seth.co_varnames=[\"angle\"],e.$circle=function(e,s,o){var d,_,u,m,p,g,f,$,b,v=this,k=this._x,T=this._y,A=this._angle,L={},S=1/c().lineScale,C=!0;if(h(this),\"number\"!=typeof e)throw new Sk.builtin.TypeError(\"params must be integers, not \"+Sk.abstr.typeName(e));if(void 0===s)s=v._fullCircle;else if(\"number\"!=typeof s)throw new Sk.builtin.TypeError(\"params must be integers, not \"+Sk.abstr.typeName(s));if(void 0===o)_=V(s)/v._fullCircle,o=1+(0|W(11+V(e*S)/6,59)*_);else if(\"number\"!=typeof o)throw new Sk.builtin.TypeError(\"params must be integers, not \"+Sk.abstr.typeName(o));for(u=s/o,m=.5*u,p=2*e*J(u*K/v._fullCircle),0>e?(p=-p,u=-u,m=-m,d=A-s):d=A+s,b=a().willRenderNext()?Promise.resolve():new r,A+=m,g=0;g<o;g++)z(v,A+u*g,L),f=X(L.radians)*p,$=J(L.radians)*p,b=b.then(t(v,L.angle,L.radians)).then(n(v,k,T,f,$,C)),k+=f,T+=$,C=!1;return b=b.then(function(){return z(v,d,L),v._angle=L.angle,v._radians=L.radians,v.addUpdate(void 0,!0,L)}),b},e.$circle.co_varnames=[\"radius\",\"extent\",\"steps\"],e.$circle.minArgs=1,e.$penup=e.$up=e.$pu=function(){return this._down=!1,this.addUpdate(void 0,!1,{down:!1})},e.$pendown=e.$down=e.$pd=function(){return this._down=!0,this.addUpdate(void 0,!1,{down:!0})},e.$isdown=function(){return this._down},e.$speed=function(e){return void 0===e?this._speed:(this._speed=G(0,W(1e3,e)),this._computed_speed=G(0,2*e-1),this.addUpdate(void 0,!1,{speed:this._computed_speed}))},e.$speed.minArgs=0,e.$speed.co_varnames=[\"speed\"],e.$pencolor=function(e,t,r,n){return void 0===e?E(this._color):(this._color=I(this._colorMode,e,t,r,n),this.addUpdate(void 0,this._shown,{color:this._color}))},e.$pencolor.co_varnames=[\"r\",\"g\",\"b\",\"a\"],e.$pencolor.minArgs=0,e.$pencolor.returnType=de.COLOR,e.$fillcolor=function(e,t,r,n){return void 0===e?E(this._fill):(this._fill=I(this._colorMode,e,t,r,n),this.addUpdate(void 0,this._shown,{fill:this._fill}))},e.$fillcolor.co_varnames=[\"r\",\"g\",\"b\",\"a\"],e.$fillcolor.minArgs=0,e.$fillcolor.returnType=de.COLOR,e.$color=function(e,t,r,n){return void 0===e?[this.$pencolor(),this.$fillcolor()]:(void 0===t||void 0!==r?(this._color=I(this._colorMode,e,t,r,n),this._fill=this._color):(this._color=I(this._colorMode,e),this._fill=I(this._colorMode,t)),this.addUpdate(void 0,this._shown,{color:this._color,fill:this._fill}))},e.$color.minArgs=0,e.$color.co_varnames=[\"color\",\"fill\",\"b\",\"a\"],e.$color.returnType=function(e){return new Sk.builtin.tuple([de.COLOR(e[0]),de.COLOR(e[1])])},e.$fill=function(e){this;return void 0===e?this._filling:(e=!!e,e===this._filling)?void 0:(this._filling=e,e?(h(this),this.addUpdate(void 0,!1,{filling:!0,fillBuffer:[{x:this._x,y:this._y}]})):(h(this),this.addUpdate(function(){this.fillBuffer.push(this),L.call(this)},!0,{filling:!1,fillBuffer:void 0})))},e.$fill.co_varnames=[\"flag\"],e.$fill.minArgs=0,e.$begin_fill=function(){return this.$fill(!0)},e.$end_fill=function(){return this.$fill(!1)},e.$stamp=function(){return h(this),this.addUpdate(function(){v(this,this.context())},!0)},e.$dot=function(e,t,r,n,s){return h(this),e=Sk.builtin.asnum$(e),e=\"number\"==typeof e?G(1,0|V(e)):G(this._size+4,2*this._size),t=void 0===t?this._color:I(this._colorMode,t,r,n,s),this.addUpdate(k,!0,void 0,e,t)},e.$dot.co_varnames=[\"size\",\"color\",\"g\",\"b\",\"a\"],e.$write=function(e,t,r,n){var a,s,i,l,o,d=this;return h(this),e+=\"\",n&&n.constructor===Array&&(s=\"string\"==typeof n[0]?n[0]:\"Arial\",i=(n[1]||\"12pt\")+\"\",l=\"string\"==typeof n[2]?n[2]:\"normal\",/^\\d+$/.test(i)&&(i+=\"pt\"),n=[l,i,s].join(\" \")),r||(r=\"left\"),a=this.addUpdate(T,!0,void 0,e,r,n),t&&(\"left\"===r||\"center\"===r)&&(o=x(e,n),\"center\"===r&&(o/=2),a=a.then(function(){var e=d.getState();return d.translate(e.x,e.y,o,0,!0)})),a},e.$write.co_varnames=[\"message\",\"move\",\"align\",\"font\"],e.$write.minArgs=1,e.$pensize=e.$width=function(e){return void 0===e?this._size:(this._size=e,this.addUpdate(void 0,this._shown,{size:e}))},e.$pensize.minArgs=e.$width.minArgs=0,e.$pensize.co_varnames=e.$width.co_varnames=[\"width\"],e.$showturtle=e.$st=function(){return this._shown=!0,this.addUpdate(void 0,!0,{shown:!0})},e.$hideturtle=e.$ht=function(){return this._shown=!1,this.addUpdate(void 0,!0,{shown:!1})},e.$isvisible=function(){return this._shown},e.$shape=function(e){if(e&&le[e])return this._shape=e,this.addUpdate(void 0,this._shown,{shape:e});if(e&&!le[e])throw new Sk.builtin.TypeError(\"shape name options: arrow, turtle, circle, square, triangle, classic ,\"+Sk.abstr.typeName(e));return this._shape},e.$shape.minArgs=0,e.$shape.co_varnames=[\"name\"],e.$colormode=function(e){return void 0===e?this._colorMode:(this._colorMode=255===e?255:1,this.addUpdate(void 0,this._shown,{colorMode:this._colorMode}))},e.$colormode.minArgs=0,e.$colormode.co_varnames=[\"cmode\"],e.$colormode.returnType=function(e){return 255===e?Sk.builtin.int_(255):Sk.builtin.float_(1)},e.$window_width=function(){return this._screen.$window_width()},e.$window_height=function(){return this._screen.$window_height()},e.$tracer=function(e,t){return this._screen.$tracer(e,t)},e.$tracer.minArgs=0,e.$tracer.co_varnames=[\"n\",\"delay\"],e.$update=function(){return this._screen.$update()},e.$delay=function(e){return this._screen.$delay(e)},e.$delay.minArgs=0,e.$delay.co_varnames=[\"delay\"],e.$reset=function(){return this.reset(),this.$clear()},e.$mainloop=e.$done=function(){return this._screen.$mainloop()},e.$clear=function(){return this.addUpdate(function(){w(this.context())},!0)},e.$dot.minArgs=0,e.$onclick=function(e,t,r){this.getManager(\"mousedown\").addHandler(e,r)},e.$onclick.minArgs=1,e.$onclick.co_varnames=[\"method\",\"btn\",\"add\"],e.$onrelease=function(e,t,r){this.getManager(\"mouseup\").addHandler(e,r)},e.$onrelease.minArgs=1,e.$onrelease.co_varnames=[\"method\",\"btn\",\"add\"],e.$ondrag=function(e,t,r){this.getManager(\"mousemove\").addHandler(e,r)},e.$ondrag.minArgs=1,e.$ondrag.co_varnames=[\"method\",\"btn\",\"add\"],e.$getscreen=function(){return Sk.misceval.callsimArray(ne.Screen)},e.$getscreen.isSk=!0,e.$clone=function(){var e=Sk.misceval.callsimOrSuspendArray(ne.Turtle);return e.instance._x=this._x,e.instance._y=this._y,e.instance._angle=this._angle,e.instance._radians=this._radians,e.instance._shape=this._shape,e.instance._color=this._color,e.instance._fill=this._fill,e.instance._filling=this._filling,e.instance._size=this._size,e.instance._computed_speed=this._computed_speed,e.instance._down=this._down,e.instance._shown=this._shown,e.instance._colorMode=this._colorMode,e.instance._isRadians=this._isRadians,e.instance._fullCircle=this._fullCircle,e.instance._bufferSize=this._bufferSize,e.instance._undoBuffer=this._undoBuffer,e._clonedFrom=this,e},e.$clone.returnType=function(e){return e},e.$getturtle=e.$getpen=function(){return this.skInstance},e.$getturtle.isSk=!0}(l.prototype),function(e){e.spriteLayer=function(){return this._sprites||(this._sprites=g(3))},e.bgLayer=function(){return this._background||(this._background=g(1))},e.hitTestLayer=function(){return this._hitTest||(this._hitTest=g(0,!0))},e.getManager=function(e){return this._managers[e]||(this._managers[e]=new i(e,this)),this._managers[e]},e.reset=function(){for(var e in this._keyListeners=void 0,this._keyLogger)window.clearInterval(this._keyLogger[e]),window.clearTimeout(this._keyLogger[e]),delete this._keyLogger[e];for(e in this._keyDownListener&&(_().removeEventListener(\"keydown\",this._keyDownListener),this._keyDownListener=void 0),this._keyUpListener&&(_().removeEventListener(\"keyup\",this._keyUpListener),this._keyUpListener=void 0),this._timer&&(window.clearTimeout(this._timer),this._timer=void 0),this._managers)this._managers[e].reset();this._mode=\"standard\",b(this._sprites),this._sprites=void 0,b(this._background),this._background=void 0},e.setUpWorld=function(e,t,r,n){var a=this;a.llx=e,a.lly=t,a.urx=r,a.ury=n,a.xScale=(r-e)/m(),a.yScale=-1*(n-t)/p(),a.lineScale=W(V(a.xScale),V(a.yScale))},e.$setup=function(e,t,r,n){return isNaN(parseFloat(e))&&(e=m()),isNaN(parseFloat(t))&&(t=p()),1>=e&&(e=m()*e),1>=t&&(t=p()*t),this._width=e,this._height=t,this._xOffset=void 0===r||isNaN(parseInt(r))?0:parseInt(r),this._yOffset=void 0===n||isNaN(parseInt(n))?0:parseInt(n),\"world\"===this._mode?this._setworldcoordinates(this.llx,this.lly,this.urx,this.ury):this._setworldcoordinates(-e/2,-t/2,e/2,t/2)},e.$setup.minArgs=0,e.$setup.co_varnames=[\"width\",\"height\",\"startx\",\"starty\"],e.$register_shape=e.$addshape=function(e,r){return r?void(le[e]=r):t(e).then(function(t){le[e]=t})},e.$register_shape.minArgs=1,e.$getshapes=function(){return Object.keys(le)},e.$tracer=function(e,t){return void 0!==e||void 0!==t?(\"number\"==typeof t&&(this._delay=t,a().refreshInterval(t)),\"number\"==typeof e?(this._frames=e,a().frameBuffer(e)):void 0):this._frames},e.$tracer.co_varnames=[\"frames\",\"delay\"],e.$tracer.minArgs=0,e.$delay=function(e){return void 0===e?void 0===this._delay?ie:this._delay:this.$tracer(void 0,e)},e.$delay.co_varnames=[\"delay\"],e._setworldcoordinates=function(e,t,r,n){var s=this,i=a().turtles();return this.setUpWorld(e,t,r,n),this._sprites&&y(this,this._sprites),this._background&&y(this,this._background),this.$clear()},e.$setworldcoordinates=function(e,t,r,n){return this._mode=\"world\",this._setworldcoordinates(e,t,r,n)},e.$setworldcoordinates.co_varnames=[\"llx\",\"lly\",\"urx\",\"ury\"],e.minArgs=4,e.$clear=e.$clearscreen=function(){return this.reset(),this.$reset()},e.$update=function(){return a().update()},e.$reset=e.$resetscreen=function(){var e=this,t=a().turtles();return a().addFrame(function(){y(e,e._sprites),y(e,e._background);for(var r=0;r<t.length;r++)t[r].reset(),y(e,t[r]._paper)},!0)},e.$window_width=function(){return m()},e.$window_height=function(){return p()},e.$delay.minArgs=0,e.$turtles=function(){return a().turtles()},e.$turtles.returnType=de.TURTLE_LIST,e.$bgpic=function(e){var r;return e?(r=this,t(e).then(function(e){w(r.bgLayer(),void 0,e)})):this._bgpic},e.$bgpic.minArgs=0,e.$bgpic.co_varnames=[\"name\"],e.$bgcolor=function(e,t,r,n){return void 0===e?E(this._bgcolor):(this._bgcolor=I(this._colorMode,e,t,r,n),void w(this.bgLayer(),this._bgcolor))},e.$bgcolor.minArgs=0,e.$bgcolor.co_varnames=[\"color\",\"g\",\"b\",\"a\"],e.$bgcolor.returnType=de.COLOR,e.$mainloop=e.$done=function(){},e.$bye=function(){return Sk.TurtleGraphics.reset()},e.$exitonclick=function(){return this._exitOnClick=!0,this.getManager(\"mousedown\").addHandler(function(){F()},!1)},e.$onclick=function(e,t,r){this._exitOnClick||this.getManager(\"mousedown\").addHandler(e,r)},e.$onclick.minArgs=1,e.$onclick.co_varnames=[\"method\",\"btn\",\"add\"];var r={8:/^back(space)?$/i,9:/^tab$/i,13:/^(enter|return)$/i,16:/^shift$/i,17:/^(ctrl|control)$/i,18:/^alt$/i,27:/^esc(ape)?$/i,32:/^space$/i,33:/^page[\\s\\-]?up$/i,34:/^page[\\s\\-]?down$/i,35:/^end$/i,36:/^home$/i,37:/^left([\\s\\-]?arrow)?$/i,38:/^up([\\s\\-]?arrow)?$/i,39:/^right([\\s\\-]?arrow)?$/i,40:/^down([\\s\\-]?arrow)?$/i,45:/^insert$/i,46:/^del(ete)?$/i};e._createKeyRepeater=function(e,t){var r=this;r._keyLogger[t]=window.setTimeout(function(){r._keyListeners[e](),r._keyLogger[t]=window.setInterval(function(){r._keyListeners[e]()},50)},333)},e._createKeyDownListener=function(){var t=this;this._keyDownListener||(this._keyDownListener=function(n){var e=String.fromCharCode;if(N()){var a,s,i=n.charCode||n.keyCode,l=e(i).toLowerCase();if(!t._keyLogger[i])for(a in t._keyListeners)if(s=1<a.length&&r[i]&&r[i].test(a),a===l||s){t._keyListeners[a](),t._createKeyRepeater(a,i),n.preventDefault();break}}},_().addEventListener(\"keydown\",this._keyDownListener))},e._createKeyUpListener=function(){var t=this;this._keyUpListener||(this._keyUpListener=function(r){var e=t._keyLogger[r.charCode||r.keyCode];void 0!==e&&(r.preventDefault(),window.clearInterval(e),window.clearTimeout(e),delete t._keyLogger[r.charCode||r.keyCode])},_().addEventListener(\"keyup\",this._keyUpListener))},e.$listen=function(){this._createKeyUpListener(),this._createKeyDownListener()},e.$onkey=function(e,t){if(\"function\"==typeof t){var r=e;e=t,t=r}t=(t+\"\").toLowerCase(),e&&\"function\"==typeof e?(!this._keyListeners&&(this._keyListeners={}),this._keyListeners[t]=e):delete this._keyListeners[t]},e.$onkey.minArgs=2,e.$onkey.co_varnames=[\"method\",\"keyValue\"],e.$onscreenclick=function(e,t,r){this.getManager(\"mousedown\").addHandler(e,r)},e.$onscreenclick.minArgs=1,e.$onscreenclick.co_varnames=[\"method\",\"btn\",\"add\"],e.$ontimer=function(e,t){this._timer&&(window.clearTimeout(this._timer),this._timer=void 0),e&&\"number\"==typeof t&&(this._timer=window.setTimeout(e,G(0,0|t)))},e.$ontimer.minArgs=0,e.$textinput=function(e,t){return Sk.turtle_textinput(e,t)},e.$textinput.isSk=!0,e.$numinput=function(e,t,r,n,a){return Sk.turtle_numinput(e,t,r,n,a)},e.$numinput.minArgs=2,e.$numinput.keywordArgs=[\"defaultVal\",\"minval\",\"maxval\"],e.$numinput.isSk=!0,e.$ontimer.co_varnames=[\"method\",\"interval\"]}(o.prototype);var ue=new Image,me=document.createElement(\"canvas\").getContext(\"2d\");for(var pe in l.prototype)/^\\$[a-z_]+/.test(pe)&&O(l,ne,pe,d);return O(o,ne,\"$mainloop\",c),O(o,ne,\"$done\",c),O(o,ne,\"$bye\",c),O(o,ne,\"$tracer\",c),O(o,ne,\"$update\",c),O(o,ne,\"$delay\",c),O(o,ne,\"$window_width\",c),O(o,ne,\"$window_height\",c),O(o,ne,\"$textinput\",c),O(o,ne,\"$numinput\",c),ne.Pen=Sk.misceval.buildClass(ne,P,\"Pen\",[]),ne.Turtle=Sk.misceval.buildClass(ne,P,\"Turtle\",[]),ne.Screen=Sk.misceval.buildClass(ne,function(e,t){for(var r in t.__init__=new Sk.builtin.func(function(e){e.instance=c()}),o.prototype)/^\\$[a-z_]+/.test(r)&&O(o,t,r)},\"Screen\",[]),{skModule:ne,reset:F,stop:D,focus:N,Turtle:l,Screen:o,Pen:ne.Pen}}(e),Sk.TurtleGraphics.module=e.turtleInstance.skModule,Sk.TurtleGraphics.reset=e.turtleInstance.reset,Sk.TurtleGraphics.stop=e.turtleInstance.stop,Sk.TurtleGraphics.focus=e.turtleInstance.focus,Sk.TurtleGraphics.raw={Turtle:e.turtleInstance.Turtle,Screen:e.turtleInstance.Screen,Pen:e.turtleInstance.Pen},e.turtleInstance.skModule};","src/lib/types.py":"\"\"\"\nThis file was modified from CPython.\nCopyright (c) 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010,\n2011, 2012, 2013, 2014, 2015 Python Software Foundation; All Rights Reserved\n\"\"\"\n\"\"\"Define names for all type symbols known in the standard interpreter.\nTypes that are part of optional modules (e.g. array) are not listed.\n\"\"\"\nimport sys\n\n# Iterators in Python aren't a matter of type but of protocol.  A large\n# and changing number of builtin types implement *some* flavor of\n# iterator.  Don't check the type!  Use hasattr to check for both\n# \"__iter__\" and \"next\" attributes instead.\n\nNoneType = type(None)\nTypeType = type\nObjectType = object\nIntType = int\nLongType = long\nFloatType = float\nBooleanType = bool\ntry:\n    ComplexType = complex\nexcept NameError:\n    pass\nStringType = str\n\n# StringTypes is already outdated.  Instead of writing \"type(x) in\n# types.StringTypes\", you should use \"isinstance(x, basestring)\".  But\n# we keep around for compatibility with Python 2.2.\ntry:\n    UnicodeType = unicode\n    StringTypes = (StringType, UnicodeType)\nexcept NameError:\n    StringTypes = (StringType,)\n\nBufferType = buffer\n\nTupleType = tuple\nListType = list\nDictType = DictionaryType = dict\n\ndef _f(): pass\nFunctionType = type(_f)\nLambdaType = type(lambda: None)         # Same as FunctionType\n#CodeType = type(_f.func_code)\n\ndef _g():\n    yield 1\nGeneratorType = type(_g())\n\nclass _C:\n    def _m(self): pass\nClassType = type(_C)\nUnboundMethodType = type(_C._m)         # Same as MethodType\n_x = _C()\nInstanceType = type(_x)\nMethodType = type(_x._m)\nBuiltinFunctionType = type(len)\nBuiltinMethodType = type([].append)     # Same as BuiltinFunctionType\n\nModuleType = type(sys)\nFileType = file\nXRangeType = xrange\n\n# try:\n#     raise TypeError\n# except TypeError:\n#     tb = sys.exc_info()[2]\n#     TracebackType = type(tb)\n#     FrameType = type(tb.tb_frame)\n#     del tb\n\nSliceType = slice\n# EllipsisType = type(Ellipsis)\n\n# DictProxyType = type(TypeType.__dict__)\nNotImplementedType = type(NotImplemented)\n\n# For Jython, the following two types are identical\n# GetSetDescriptorType = type(FunctionType.func_code)\n# MemberDescriptorType = type(FunctionType.func_globals)\n\ndel sys, _f, _g, _C, _x                           # Not for export\n__all__ = list(n for n in globals() if n[:1] != '_')\n","src/lib/unittest/__init__.py":"__author__ = 'bmiller'\n'''\nThis is the start of something that behaves like\nthe unittest module from cpython.\n\n'''\n\nclass TestCase:\n    def __init__(self):\n        self.numPassed = 0\n        self.numFailed = 0\n        self.assertPassed = 0\n        self.assertFailed = 0\n        self.verbosity = 1\n        self.tlist = []\n        testNames = {}\n        for name in dir(self):\n            if name[:4] == 'test' and name not in testNames:\n                self.tlist.append(getattr(self,name))\n                testNames[name]=True\n\n    def setUp(self):\n        pass\n\n    def tearDown(self):\n        pass\n    \n    def cleanName(self,funcName):\n    # work around skulpts lack of an __name__\n        funcName = str(funcName)\n        funcName = funcName[13:]\n        funcName = funcName[:funcName.find('<')-3]\n        return funcName\n\n    def main(self):\n\n        for func in self.tlist:\n            if self.verbosity > 1:\n                print('Running %s' % self.cleanName(func))\n            try:\n                self.setUp()\n                self.assertPassed = 0\n                self.assertFailed = 0\n                func()\n                self.tearDown()\n                if self.assertFailed == 0:\n                    self.numPassed += 1\n                else:\n                    self.numFailed += 1\n                    print('Tests failed in %s ' % self.cleanName(func))\n            except Exception as e:\n                self.assertFailed += 1\n                self.numFailed += 1\n                print('Test threw exception in %s (%s)' % (self.cleanName(func), e))\n        self.showSummary()\n\n    def assertEqual(self, actual, expected, feedback=\"\"):\n        res = actual==expected\n        if not res and feedback == \"\":\n            feedback = \"Expected %s to equal %s\" % (str(actual),str(expected))\n        self.appendResult(res, actual ,expected, feedback)\n\n    def assertNotEqual(self, actual, expected, feedback=\"\"):\n        res = actual != expected\n        if not res and feedback == \"\":\n            feedback = \"Expected %s to not equal %s\" % (str(actual),str(expected))\n        self.appendResult(res, actual, expected, feedback)\n\n    def assertTrue(self,x, feedback=\"\"):\n        res = bool(x) is True\n        if not res and feedback == \"\":\n            feedback = \"Expected %s to be True\" % (str(x))\n        self.appendResult(res, x, True, feedback)\n\n    def assertFalse(self,x, feedback=\"\"):\n        res = not bool(x)\n        if not res and feedback == \"\":\n            feedback = \"Expected %s to be False\" % (str(x))\n        self.appendResult(res, x, False, feedback)\n\n    def assertIs(self,a,b, feedback=\"\"):\n        res = a is b\n        if not res and feedback == \"\":\n            feedback = \"Expected %s to be the same object as %s\" % (str(a),str(b))\n        self.appendResult(res, a, b, feedback)\n\n    def assertIsNot(self,a,b, feedback=\"\"):\n        res = a is not b\n        if not res and feedback == \"\":\n            feedback = \"Expected %s to not be the same object as %s\" % (str(a),str(b))\n        self.appendResult(res, a, b, feedback)\n\n    def assertIsNone(self,x, feedback=\"\"):\n        res = x is None\n        if not res and feedback == \"\":\n            feedback = \"Expected %s to be None\" % (str(x))\n        self.appendResult(res, x, None, feedback)\n\n    def assertIsNotNone(self,x, feedback=\"\"):\n        res = x is not None\n        if not res and feedback == \"\":\n            feedback = \"Expected %s to not be None\" % (str(x))\n        self.appendResult(res, x, None, feedback)\n\n    def assertIn(self, a, b, feedback=\"\"):\n        res = a in b\n        if not res and feedback == \"\":\n            feedback = \"Expected %s to be in %s\" % (str(a),str(b))\n        self.appendResult(res, a, b, feedback)\n\n    def assertNotIn(self, a, b, feedback=\"\"):\n        res = a not in b\n        if not res and feedback == \"\":\n            feedback = \"Expected %s to not be in %s\" % (str(a),str(b))\n        self.appendResult(res, a, b, feedback)\n\n    def assertIsInstance(self,a,b, feedback=\"\"):\n        res = isinstance(a,b)\n        if not res and feedback == \"\":\n            feedback = \"Expected %s to be an instance of %s\" % (str(a), str(b))\n        self.appendResult(res, a, b, feedback)\n\n    def assertNotIsInstance(self,a,b, feedback=\"\"):\n        res = not isinstance(a,b)\n        if not res and feedback == \"\":\n            feedback = \"Expected %s to not be an instance of %s\" % (str(a),str(b))\n        self.appendResult(res, a, b, feedback)\n\n    def assertAlmostEqual(self, a, b, places=7, feedback=\"\", delta=None):\n\n        if delta is not None:\n            res = abs(a-b) <= delta\n        else:\n            if places is None:\n                places = 7\n            res = round(a-b, places) == 0\n        \n        if not res and feedback == \"\":\n            feedback = \"Expected %s to equal %s\" % (str(a),str(b))\n        self.appendResult(res, a, b, feedback)\n\n    def assertNotAlmostEqual(self, a, b, places=7, feedback=\"\", delta=None):\n\n        if delta is not None:\n            res = not (a == b) and abs(a - b) > delta\n        else:\n            if places is None:\n                places = 7\n\n            res = round(a-b, places) != 0\n\n        if not res and feedback == \"\":\n            feedback = \"Expected %s to not equal %s\" % (str(a),str(b))\n        self.appendResult(res, a, b, feedback)\n\n    def assertGreater(self,a,b, feedback=\"\"):\n        res = a > b\n        if not res and feedback == \"\":\n            feedback = \"Expected %s to be greater than %s\" % (str(a),str(b))\n        self.appendResult(res, a, b, feedback)\n\n    def assertGreaterEqual(self,a,b, feedback=\"\"):\n        res = a >= b\n        if not res and feedback == \"\":\n            feedback = \"Expected %s to be >= %s\" % (str(a),str(b))\n        self.appendResult(res, a, b, feedback)\n\n    def assertLess(self, a, b, feedback=\"\"):\n        res = a < b\n        if not res and feedback == \"\":\n            feedback = \"Expected %s to be less than %s\" % (str(a),str(b))\n        self.appendResult(res, a, b, feedback)\n\n    def assertLessEqual(self,a,b, feedback=\"\"):\n        res = a <= b\n        if not res and feedback == \"\":\n            feedback = \"Expected %s to be <= %s\" % (str(a),str(b))\n        self.appendResult(res, a, b, feedback)\n\n    def appendResult(self,res,actual,expected,feedback):\n        if res:\n            msg = 'Pass'\n            self.assertPassed += 1\n        else:\n            msg = 'Fail: ' +  feedback\n            print(msg)\n            self.assertFailed += 1\n\n    def assertRaises(self, exception, callable=None, *args, **kwds):\n        # with is currently not supported hence we just try and catch\n        if callable is None:\n            raise NotImplementedError(\"assertRaises does currently not support assert contexts\")\n        if kwds:\n            raise NotImplementedError(\"assertRaises does currently not support **kwds\")\n\n        res = False\n        actualerror = str(exception())\n        try:\n            callable(*args)\n        except exception as ex:\n            res = True\n        except Exception as inst:\n            actualerror = str(inst)\n            print(\"ACT = \", actualerror, str(exception()))\n        else:\n            actualerror = \"No Error\"\n\n        self.appendResult(res, str(exception()), actualerror, \"\")\n\n    def fail(self, msg=None):\n        if msg is None:\n            msg = 'Fail'\n        else:\n            msg = 'Fail: ' + msg\n        print(msg)\n        self.assertFailed += 1\n\n    def showSummary(self):\n        pct = self.numPassed / (self.numPassed+self.numFailed) * 100\n        print(\"Ran %d tests, passed: %d failed: %d\\n\" % (self.numPassed+self.numFailed,\n                                               self.numPassed, self.numFailed))\n\n\n\ndef main(verbosity=1):\n    glob = globals() # globals() still needs work\n    for name in glob:\n        if type(glob[name]) == type and issubclass(glob[name], TestCase):\n            try:\n                tc = glob[name]()\n                tc.verbosity = verbosity\n                tc.main()\n            except:\n                print(\"Uncaught Error in: \", name)\n","src/lib/unittest/gui.py":"import document\nfrom unittest import TestCase\n\nclass TestCaseGui(TestCase):\n     def __init__(self):\n          TestCase.__init__(self)\n          self.divid = document.currentDiv()\n          self.mydiv = document.getElementById(self.divid)\n          res = document.getElementById(self.divid+'_unit_results')\n          if res:\n              self.resdiv = res\n              res.innerHTML = ''\n          else:\n              self.resdiv = document.createElement('div')\n              self.resdiv.setAttribute('id',self.divid+'_unit_results')\n              self.resdiv.setAttribute('class','unittest-results')\n              self.mydiv.appendChild(self.resdiv)\n\n\n     def main(self):\n         t = document.createElement('table')\n         self.resTable = t\n         self.resdiv.appendChild(self.resTable)\n\n         headers = ['Result','Actual Value','Expected Value','Notes']\n         row = document.createElement('tr')\n         for item in headers:\n             head = document.createElement('th')\n             head.setAttribute('class','ac-feedback')\n             head.innerHTML = item\n             head.setCSS('text-align','center')\n             row.appendChild(head)\n         self.resTable.appendChild(row)\n\n         for func in self.tlist:\n             try:\n                 self.setUp()\n                 func()\n                 self.tearDown()\n             except Exception as e:\n                 self.appendResult('Error', None, None, e)\n                 self.numFailed += 1\n                 self.showSummary()\n\n     def appendResult(self,res,actual,expected,param):\n         trimActual = False\n         if len(str(actual)) > 15:\n             trimActual = True\n             actualType = type(actual)\n         trimExpected = False\n         if len(str(expected)) > 15:\n             trimExpected = True\n             expectedType = type(expected)\n         row = document.createElement('tr')\n         err = False\n         if res == 'Error':\n             err = True\n             msg = 'Error: %s' % param\n             errorData = document.createElement('td')\n             errorData.setAttribute('class','ac-feedback')\n             errorData.innerHTML = 'ERROR'\n             errorData.setCSS('background-color','#de8e96')\n             errorData.setCSS('text-align','center')\n             row.appendChild(errorData)\n         elif res:\n             passed = document.createElement('td')\n             passed.setAttribute('class','ac-feedback')\n             passed.innerHTML = 'Pass'\n             passed.setCSS('background-color','#83d382')\n             passed.setCSS('text-align','center')\n             row.appendChild(passed)\n             self.numPassed += 1\n         else:\n             fail = document.createElement('td')\n             fail.setAttribute('class','ac-feedback')\n             fail.innerHTML = 'Fail'\n             fail.setCSS('background-color','#de8e96')\n             fail.setCSS('text-align','center')\n             row.appendChild(fail)\n             self.numFailed += 1\n\n\n         act = document.createElement('td')\n         act.setAttribute('class','ac-feedback')\n         if trimActual:\n             actHTML = str(actual)[:5] + \"...\" + str(actual)[-5:]\n             if actualType == str:\n                 actHTML = repr(actHTML)\n             act.innerHTML = actHTML\n         else:\n             act.innerHTML = repr(actual)\n         act.setCSS('text-align','center')\n         row.appendChild(act)\n\n         expect = document.createElement('td')\n         expect.setAttribute('class','ac-feedback')\n\n         if trimExpected:\n             expectedHTML = str(expected)[:5] + \"...\" + str(expected)[-5:]\n             if expectedType == str:\n                 expectedHTML = repr(expectedHTML)\n             expect.innerHTML = expectedHTML\n         else:\n             expect.innerHTML = repr(expected)\n         expect.setCSS('text-align','center')\n         row.appendChild(expect)\n         inp = document.createElement('td')\n         inp.setAttribute('class','ac-feedback')\n\n         if err:\n             inp.innerHTML = msg\n         else:\n             inp.innerHTML = param\n         inp.setCSS('text-align','center')\n         row.appendChild(inp)\n         self.resTable.appendChild(row)\n\n\n     def showSummary(self):\n         pct = self.numPassed / (self.numPassed+self.numFailed) * 100\n         pTag = document.createElement('p')\n         pTag.innerHTML = \"You passed: \" + str(pct) + \"% of the tests\"\n         self.resdiv.appendChild(pTag)\n","src/lib/urllib/__init__.js":"var $builtinmodule=function(){return{}};","src/lib/urllib/request/__init__.js":"var $builtinmodule=function(){var a={};return a.Response=Sk.misceval.buildClass(a,function(a,b){b.__init__=new Sk.builtin.func(function(a,b){a.data$=b.responseText,a.lineList=a.data$.split(\"\\n\"),a.lineList=a.lineList.slice(0,-1);for(var c=0;c<a.lineList.length;c++)a.lineList[c]+=\"\\n\";a.currentLine=0,a.pos$=0}),b.__str__=new Sk.builtin.func(function(){return Sk.ffi.remapToPy(\"<Response>\")}),b.__iter__=new Sk.builtin.func(function(a){var b=a.lineList;return Sk.builtin.makeGenerator(function(){return this.$index>=this.$lines.length?void 0:new Sk.builtin.str(this.$lines[this.$index++])},{$obj:a,$index:0,$lines:b})}),b.read=new Sk.builtin.func(function(a,b){if(a.closed)throw new Sk.builtin.ValueError(\"I/O operation on closed file\");var c=a.data$.length;void 0===b&&(b=c);var d=new Sk.builtin.str(a.data$.substr(a.pos$,b));return a.pos$+=b,a.pos$>=c&&(a.pos$=c),d}),b.readline=new Sk.builtin.func(function(a){var b=\"\";return a.currentLine<a.lineList.length&&(b=a.lineList[a.currentLine],a.currentLine++),new Sk.builtin.str(b)}),b.readlines=new Sk.builtin.func(function(a){for(var b=[],c=a.currentLine;c<a.lineList.length;c++)b.push(new Sk.builtin.str(a.lineList[c]));return new Sk.builtin.list(b)})},\"Response\",[]),a.urlopen=new Sk.builtin.func(function(b,c){var d=new Promise(function(d){var e=new XMLHttpRequest;e.addEventListener(\"loadend\",function(){d(Sk.misceval.callsimArray(a.Response,[e]))}),c?(e.open(\"POST\",b.v),e.setRequestHeader(\"Content-type\",\"application/x-www-form-urlencoded\"),e.setRequestHeader(\"Content-length\",c.v.length),e.send(c.v)):(e.open(\"GET\",b.v),e.send(null))}),e=new Sk.misceval.Suspension;return e.resume=function(){return resolution},e.data={type:\"Sk.promise\",promise:d.then(function(a){return resolution=a,a},function(a){return resolution=\"\",a})},e}),a};","src/lib/urllib2.py":"raise NotImplementedError(\"urllib2 is not yet implemented in Skulpt\")\n","src/lib/urlparse.py":"raise NotImplementedError(\"urlparse is not yet implemented in Skulpt\")\n","src/lib/user.py":"raise NotImplementedError(\"user is not yet implemented in Skulpt\")\n","src/lib/uu.py":"raise NotImplementedError(\"uu is not yet implemented in Skulpt\")\n","src/lib/uuid.py":"raise NotImplementedError(\"uuid is not yet implemented in Skulpt\")\n","src/lib/warnings.py":"raise NotImplementedError(\"warnings is not yet implemented in Skulpt\")\n","src/lib/wave.py":"raise NotImplementedError(\"wave is not yet implemented in Skulpt\")\n","src/lib/weakref.py":"raise NotImplementedError(\"weakref is not yet implemented in Skulpt\")\n","src/lib/webbrowser.py":"raise NotImplementedError(\"webbrowser is not yet implemented in Skulpt\")\n","src/lib/webgl/__init__.js":"var $builtinmodule=function(){var a={},c=function(a){return\"<table style=\\\"background-color: #8CE; width: 100%; height: 100%;\\\"><tr><td align=\\\"center\\\"><div style=\\\"display: table-cell; vertical-align: middle;\\\"><div style=\\\"\\\">\"+a+\"</div></div></td></tr></table>\"},d=\"This page requires a browser that supports WebGL.<br/><a href=\\\"http://get.webgl.org\\\">Click here to upgrade your browser.</a>\",e=function(a){for(var b=[\"webgl\",\"experimental-webgl\",\"webkit-3d\",\"moz-webgl\"],c=null,d=0;d<b.length;++d){try{c=a.getContext(b[d])}catch(a){}if(c)break}if(c){function b(){return!1}a.onselectstart=b,a.onmousedown=b}return c},f=function(a,f){var g=document.getElementById(a);if(f||(f=g.getElementsByTagName(\"canvas\")[0]),!f)return void(g.innerHTML=c(d));var h=e(f);if(!h){var i=navigator.userAgent.match(/(\\w+\\/.*? )/g),j={};try{for(var k=0;k<i.length;++k){for(var l=i[k].match(/(\\w+)/g),m=[],n=1;n<l.length;++n)m.push(parseInt(l[n]));j[l[0]]=m}}catch(a){}g.innerHTML=j.Chrome&&(7<j.Chrome[0]||7==j.Chrome[0]&&0<j.Chrome[1]||7==j.Chrome[0]&&0==j.Chrome[1]&&521<=j.Chrome[2])?c(\"It doesn't appear your computer can support WebGL.<br/><a href=\\\"http://get.webgl.org\\\">Click here for more information.</a>\"):c(d)}return h};return a.Context=Sk.misceval.buildClass(a,function(a,b){b.__init__=new Sk.builtin.func(function(a,b){var c=document.getElementById(b.v),d=f(b.v,c);if(!d)throw new Error(\"Your browser does not appear to support WebGL.\");for(var e in a.gl=d,d.__proto__)if(\"number\"==typeof d.__proto__[e])Sk.abstr.objectSetItem(a.$d,new Sk.builtin.str(e),d.__proto__[e]);else if(\"function\"==typeof d.__proto__[e])switch(e){case\"bufferData\":break;case\"clearColor\":break;case\"drawArrays\":break;case\"getAttribLocation\":break;case\"getUniformLocation\":break;case\"shaderSource\":break;case\"uniformMatrix4fv\":break;case\"vertexAttribPointer\":break;case\"viewport\":break;default:(function(b){Sk.abstr.objectSetItem(a.$d,new Sk.builtin.str(e),new Sk.builtin.func(function(){var a=d.__proto__[b];return a.apply(d,arguments)}))})(e);}d.clearColor(100/255,149/255,237/255,1),d.clear(d.COLOR_BUFFER_BIT)}),b.tp$getattr=Sk.builtin.object.prototype.GenericGetAttr,b.bufferData=new Sk.builtin.func(function(a,b,c,d){a.gl.bufferData(b,c.v,d)}),b.clearColor=new Sk.builtin.func(function(a,b,c,d,e){a.gl.clearColor(Sk.builtin.asnum$(b),Sk.builtin.asnum$(c),Sk.builtin.asnum$(d),Sk.builtin.asnum$(e))}),b.getAttribLocation=new Sk.builtin.func(function(a,b,c){return a.gl.getAttribLocation(b,c.v)}),b.getUniformLocation=new Sk.builtin.func(function(a,b,c){return a.gl.getUniformLocation(b,c.v)}),b.shaderSource=new Sk.builtin.func(function(a,b,c){a.gl.shaderSource(b,c.v)}),b.drawArrays=new Sk.builtin.func(function(a,b,c,d){a.gl.drawArrays(Sk.builtin.asnum$(b),Sk.builtin.asnum$(c),Sk.builtin.asnum$(d))}),b.vertexAttribPointer=new Sk.builtin.func(function(a,b,c,d,e,f,g){a.gl.vertexAttribPointer(b,Sk.builtin.asnum$(c),Sk.builtin.asnum$(d),e,Sk.builtin.asnum$(f),Sk.builtin.asnum$(g))}),b.viewport=new Sk.builtin.func(function(a,b,c,d,e){a.gl.viewport(Sk.builtin.asnum$(b),Sk.builtin.asnum$(c),Sk.builtin.asnum$(d),Sk.builtin.asnum$(e))}),b.uniformMatrix4fv=new Sk.builtin.func(function(a,b,c,d){a.gl.uniformMatrix4fv(Sk.builtin.asnum$(b),c,d.v)}),b.setDrawFunc=new Sk.builtin.func(function(a,b){var c=new Date().getTime(),d=setInterval(function(){Sk.misceval.callsimArray(b,[a,new Date().getTime()-c])},1e3/60)})},\"Context\",[]),a.Float32Array=Sk.misceval.buildClass(a,function(a,b){b.__init__=new Sk.builtin.func(function(a,b){a.v=\"number\"==typeof b?new Float32Array(b):new Float32Array(Sk.ffi.remapToJs(b))}),b.__repr__=new Sk.builtin.func(function(a){for(var b=[],c=0;c<a.v.length;++c)b.push(a.v[c]);return new Sk.builtin.str(\"[\"+b.join(\", \")+\"]\")})},\"Float32Array\",[]),a.Matrix4x4=Sk.misceval.buildClass(a,function(a,b){b.__init__=new Sk.builtin.func(function(a,b){a.v=new Float32Array(Sk.ffi.remapToJs(b))}),b.identity=new Sk.builtin.func(function(a){var b=a.v;b[0]=1,b[1]=0,b[2]=0,b[3]=0,b[4]=0,b[5]=1,b[6]=0,b[7]=0,b[8]=0,b[9]=0,b[10]=1,b[11]=0,b[12]=0,b[13]=0,b[14]=0,b[15]=1}),b.perspective=new Sk.builtin.func(function(b,c,d,e,g){var h=Math.tan,i=Math.PI,j=h(.5*i-.5*(Sk.builtin.asnum$(c)*i/180)),l=Sk.builtin.asnum$(d),a=Sk.builtin.asnum$(e),n=Sk.builtin.asnum$(g),f=1/(a-n),k=b.v;k[0]=j/l,k[1]=0,k[2]=0,k[3]=0,k[4]=0,k[5]=j,k[6]=0,k[7]=0,k[8]=0,k[9]=0,k[10]=(a+n)*f,k[11]=-1,k[12]=0,k[13]=0,k[14]=2*(a*n*f),k[15]=0}),b.translate=new Sk.builtin.func(function(a,b){var c=a.v,d=Sk.ffi.remapToJs(b);c[0]=1,c[1]=0,c[2]=0,c[3]=0,c[4]=0,c[5]=1,c[6]=0,c[7]=0,c[8]=0,c[9]=0,c[10]=1,c[11]=0,c[12]=d[0],c[13]=d[1],c[14]=d[2],c[15]=1}),b.__repr__=new Sk.builtin.func(function(a){for(var b=[],c=0;c<a.v.length;++c)b.push(a.v[c]);return new Sk.builtin.str(\"[\"+b.join(\", \")+\"]\")})},\"Matrix4x4\",[]),a};","src/lib/webgl/math.js":"var $builtinmodule=function(){var a={};return a.Mat44=Sk.misceval.buildClass(a,function(b,c){var d=Math.sqrt;c.__init__=new Sk.builtin.func(function(a){Sk.misceval.callsimArray(c.loadIdentity,[a]),a.stack=[]}),c.push=new Sk.builtin.func(function(a){a.stack.push(a.elements.slice(0))}),c.pop=new Sk.builtin.func(function(a){a.elements=a.stack.pop()}),c.loadIdentity=new Sk.builtin.func(function(a){a.elements=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]}),c.transform3=new Sk.builtin.func(function(b,c){var d=b.elements;return Sk.misceval.callsimArray(a.Vec3,[d[0]*c.x+d[4]*c.y+d[8]*c.z,d[1]*c.x+d[5]*c.y+d[9]*c.z,d[2]*c.x+d[6]*c.y+d[10]*c.z])}),c.scale=new Sk.builtin.func(function(a,b,c,d){return a.elements[0]*=b,a.elements[1]*=b,a.elements[2]*=b,a.elements[3]*=b,a.elements[4]*=c,a.elements[5]*=c,a.elements[6]*=c,a.elements[7]*=c,a.elements[8]*=d,a.elements[9]*=d,a.elements[10]*=d,a.elements[11]*=d,a}),c.translate=new Sk.builtin.func(function(a,b,c,d){return a.elements[12]+=a.elements[0]*b+a.elements[4]*c+a.elements[8]*d,a.elements[13]+=a.elements[1]*b+a.elements[5]*c+a.elements[9]*d,a.elements[14]+=a.elements[2]*b+a.elements[6]*c+a.elements[10]*d,a.elements[15]+=a.elements[3]*b+a.elements[7]*c+a.elements[11]*d,a}),c.rotate=new Sk.builtin.func(function(b,c,e,f,g){var h=Math.cos,i=Math.sin,j=Math.PI,k=d(e*e+f*f+g*g),l=i(c*j/180),m=h(c*j/180);if(0<k){var n,o,p,q,r,s,t,u,v,w,A;e/=k,f/=k,g/=k,n=e*e,o=f*f,p=g*g,q=e*f,r=f*g,s=g*e,t=e*l,u=f*l,v=g*l,w=1-m,A=Sk.misceval.callsimArray(a.Mat44),A.elements[0]=w*n+m,A.elements[1]=w*q-v,A.elements[2]=w*s+u,A.elements[3]=0,A.elements[4]=w*q+v,A.elements[5]=w*o+m,A.elements[6]=w*r-t,A.elements[7]=0,A.elements[8]=w*s-u,A.elements[9]=w*r+t,A.elements[10]=w*p+m,A.elements[11]=0,A.elements[12]=0,A.elements[13]=0,A.elements[14]=0,A.elements[15]=1,A=A.multiply(b),b.elements=A.elements}return b}),c.multiply=new Sk.builtin.func(function(b,c){for(var d=Sk.misceval.callsimArray(a.Mat44),e=0;4>e;e++)d.elements[4*e+0]=b.elements[4*e+0]*c.elements[0]+b.elements[4*e+1]*c.elements[4]+b.elements[4*e+2]*c.elements[8]+b.elements[4*e+3]*c.elements[12],d.elements[4*e+1]=b.elements[4*e+0]*c.elements[1]+b.elements[4*e+1]*c.elements[5]+b.elements[4*e+2]*c.elements[9]+b.elements[4*e+3]*c.elements[13],d.elements[4*e+2]=b.elements[4*e+0]*c.elements[2]+b.elements[4*e+1]*c.elements[6]+b.elements[4*e+2]*c.elements[10]+b.elements[4*e+3]*c.elements[14],d.elements[4*e+3]=b.elements[4*e+0]*c.elements[3]+b.elements[4*e+1]*c.elements[7]+b.elements[4*e+2]*c.elements[11]+b.elements[4*e+3]*c.elements[15];return b.elements=d.elements,b}),c.lookAt=new Sk.builtin.func(function(b,c,e,f,g,h,i,j,k,l){var m=[c-g,e-h,f-i],n=d(m[0]*m[0]+m[1]*m[1]+m[2]*m[2]);n&&(m[0]/=n,m[1]/=n,m[2]/=n);var o=[j,k,l],p=[];p[0]=o[1]*m[2]-o[2]*m[1],p[1]=-o[0]*m[2]+o[2]*m[0],p[2]=o[0]*m[1]-o[1]*m[0],o[0]=m[1]*p[2]-m[2]*p[1],o[1]=-m[0]*p[2]+m[2]*p[0],o[2]=m[0]*p[1]-m[1]*p[0],n=d(p[0]*p[0]+p[1]*p[1]+p[2]*p[2]),n&&(p[0]/=n,p[1]/=n,p[2]/=n),n=d(o[0]*o[0]+o[1]*o[1]+o[2]*o[2]),n&&(o[0]/=n,o[1]/=n,o[2]/=n);var q=Sk.misceval.callsimArray(a.Mat44);return q.elements[0]=p[0],q.elements[4]=p[1],q.elements[8]=p[2],q.elements[12]=0,q.elements[1]=o[0],q.elements[5]=o[1],q.elements[9]=o[2],q.elements[13]=0,q.elements[2]=m[0],q.elements[6]=m[1],q.elements[10]=m[2],q.elements[14]=0,q.elements[3]=0,q.elements[7]=0,q.elements[11]=0,q.elements[15]=1,q=q.multiply(b),b.elements=q.elements,b.translate(-c,-e,-f),b})},\"Mat44\",[]),a.Mat33=Sk.misceval.buildClass(a,function(a,b){b.__init__=new Sk.builtin.func(function(a){Sk.misceval.callsimArray(b.loadIdentity,[a])}),b.loadIdentity=new Sk.builtin.func(function(a){a.elements=[1,0,0,0,1,0,0,0,1]})},\"Mat33\",[]),a.Vec3=Sk.misceval.buildClass(a,function(b,c){c.__init__=new Sk.builtin.func(function(a,b,c,d){a.x=b,a.y=c,a.z=d}),c.__sub__=new Sk.builtin.func(function(b,c){return Sk.misceval.callsimArray(a.Vec3,[b.x-c.x,b.y-c.y,b.z-c.z])})},\"Vec3\",[]),a.cross=new Sk.builtin.func(function(b,c){return Sk.asserts.assert(b instanceof a.Vec3&&c instanceof a.Vec3),Sk.misceval.callsimArray(a.Vec3,[b.y*c.z-b.z*c.y,b.z*c.x-b.x*c.z,b.x*c.y-b.y*c.x])}),a};","src/lib/webgl/matrix4.js":"var $builtinmodule=function(){var a=Math.PI,b={},c=new Float32Array(3),d=new Float32Array(3),e=new Float32Array(3),f=new Float32Array(4),g=new Float32Array(4),h=new Float32Array(4),i=new Float32Array(16),j=new Float32Array(16),k=new Float32Array(16),l=function(b,c){for(var a=Math.sqrt,d=0,e=c.length,f=0;f<e;++f)d+=c[f]*c[f];if(d=a(d),1e-5<d)for(var f=0;f<e;++f)b[f]=c[f]/d;else for(var f=0;f<e;++f)b[f]=0;return b},m=function(c,d,a){return c[0]=d[1]*a[2]-d[2]*a[1],c[1]=d[2]*a[0]-d[0]*a[2],c[2]=d[0]*a[1]-d[1]*a[0],c},n=function(c,d,a){for(var b=d.length,e=0;e<b;++e)c[e]=d[e]-a[e];return c},o=function(c,a){return c[0]*a[0]+c[1]*a[1]+c[2]*a[2]};return b.lookAt=new Sk.builtin.func(function(a,b,f,g){var h=c,i=d,j=l(h,n(h,b.v,f.v)),k=l(i,m(i,g.v,j)),p=m(e,j,k),q=a.v;return q[0]=k[0],q[1]=p[0],q[2]=j[0],q[3]=0,q[4]=k[1],q[5]=p[1],q[6]=j[1],q[7]=0,q[8]=k[2],q[9]=p[2],q[10]=j[2],q[11]=0,q[12]=-o(k,b.v),q[13]=-o(p,b.v),q[14]=-o(j,b.v),q[15]=1,a}),b.perspective=new Sk.builtin.func(function(b,c,d,e,g){var h=Math.tan,i=h(.5*a-.5*(c*a/180)),f=1/(e-g),j=b.v;return j[0]=i/d,j[1]=0,j[2]=0,j[3]=0,j[4]=0,j[5]=i,j[6]=0,j[7]=0,j[8]=0,j[9]=0,j[10]=(e+g)*f,j[11]=-1,j[12]=0,j[13]=0,j[14]=2*(e*g*f),j[15]=0,b}),b.rotationY=new Sk.builtin.func(function(b,d){var e=Math.sin,f=Math.cos,g=b.v,h=f(d*a/180),c=e(d*a/180);return g[0]=h,g[1]=0,g[2]=-c,g[3]=0,g[4]=0,g[5]=1,g[6]=0,g[7]=0,g[8]=c,g[9]=0,g[10]=h,g[11]=0,g[12]=0,g[13]=0,g[14]=0,g[15]=1,b}),b.identity=new Sk.builtin.func(function(a){var b=a.v;return b[0]=1,b[1]=0,b[2]=0,b[3]=0,b[4]=0,b[5]=1,b[6]=0,b[7]=0,b[8]=0,b[9]=0,b[10]=1,b[11]=0,b[12]=0,b[13]=0,b[14]=0,b[15]=1,a}),b.mul=new Sk.builtin.func(function(c,d,e){var f=c.v,g=d.v,a=e.v,b=g[0],h=g[1],i=g[2],j=g[3],k=g[4],l=g[5],m=g[6],n=g[7],o=g[8],p=g[9],q=g[10],r=g[11],s=g[12],t=g[13],u=g[14],v=g[15],w=a[0],x=a[1],y=a[2],z=a[3],A=a[4],B=a[5],C=a[6],D=a[7],E=a[8],F=a[9],G=a[10],H=a[11],I=a[12],J=a[13],K=a[14],L=a[15];return f[0]=b*w+h*A+i*E+j*I,f[1]=b*x+h*B+i*F+j*J,f[2]=b*y+h*C+i*G+j*K,f[3]=b*z+h*D+i*H+j*L,f[4]=k*w+l*A+m*E+n*I,f[5]=k*x+l*B+m*F+n*J,f[6]=k*y+l*C+m*G+n*K,f[7]=k*z+l*D+m*H+n*L,f[8]=o*w+p*A+q*E+r*I,f[9]=o*x+p*B+q*F+r*J,f[10]=o*y+p*C+q*G+r*K,f[11]=o*z+p*D+q*H+r*L,f[12]=s*w+t*A+u*E+v*I,f[13]=s*x+t*B+u*F+v*J,f[14]=s*y+t*C+u*G+v*K,f[15]=s*z+t*D+u*H+v*L,c}),b.invert=new Sk.builtin.func(function(a,b){var c=a.v,e=b.v,f=e[0],g=e[1],h=e[2],i=e[3],j=e[4],k=e[5],l=e[6],m=e[7],n=e[8],o=e[9],p=e[10],q=e[11],r=e[12],s=e[13],t=e[14],u=e[15],v=p*u,w=t*q,x=l*u,y=t*m,z=l*q,A=p*m,B=h*u,C=t*i,D=h*q,E=p*i,F=h*m,G=l*i,H=n*s,I=r*o,J=j*s,K=r*k,L=j*o,M=n*k,N=f*s,O=r*g,P=f*o,Q=n*g,R=f*k,S=j*g,T=v*k+y*o+z*s-(w*k+x*o+A*s),U=w*g+B*o+E*s-(v*g+C*o+D*s),V=x*g+C*k+F*s-(y*g+B*k+G*s),W=A*g+D*k+G*o-(z*g+E*k+F*o),X=1/(f*T+j*U+n*V+r*W);return c[0]=X*T,c[1]=X*U,c[2]=X*V,c[3]=X*W,c[4]=X*(w*j+x*n+A*r-(v*j+y*n+z*r)),c[5]=X*(v*f+C*n+D*r-(w*f+B*n+E*r)),c[6]=X*(y*f+B*j+G*r-(x*f+C*j+F*r)),c[7]=X*(z*f+E*j+F*n-(A*f+D*j+G*n)),c[8]=X*(H*m+K*q+L*u-(I*m+J*q+M*u)),c[9]=X*(I*i+N*q+Q*u-(H*i+O*q+P*u)),c[10]=X*(J*i+O*m+R*u-(K*i+N*m+S*u)),c[11]=X*(M*i+P*m+S*q-(L*i+Q*m+R*q)),c[12]=X*(J*p+M*t+I*l-(L*t+H*l+K*p)),c[13]=X*(P*t+H*h+O*p-(N*p+Q*t+I*h)),c[14]=X*(N*l+S*t+K*h-(R*t+J*h+O*l)),c[15]=X*(R*p+L*h+Q*l-(P*l+S*p+M*h)),a}),b.transpose=new Sk.builtin.func(function(a,b){for(var c=a.v,d=b.v,e=0;4>e;++e)for(var f=0;4>f;++f)c[4*e+f]=d[4*f+e];return c}),b};","src/lib/webgl/models.js":"var $builtinmodule=function(a){var c={},d=function(a,c){var d=c||gl.ARRAY_BUFFER,e=gl.createBuffer();if(this.target=d,this.buf=e,this.set(a),this.numComponents_=a.numComponents,this.numElements_=a.numElements,this.totalComponents_=this.numComponents_*this.numElements_,a.buffer instanceof Float32Array)this.type_=gl.FLOAT;else if(a.buffer instanceof Uint8Array)this.type_=gl.UNSIGNED_BYTE;else if(a.buffer instanceof Int8Array)this.type_=gl._BYTE;else if(a.buffer instanceof Uint16Array)this.type_=gl.UNSIGNED_SHORT;else if(a.buffer instanceof Int16Array)this.type_=gl.SHORT;else throw\"unhandled type:\"+typeof a.buffer};return d.prototype.set=function(a){gl.bindBuffer(this.target,this.buf),gl.bufferData(this.target,a.buffer,gl.STATIC_DRAW)},d.prototype.type=function(){return this.type_},d.prototype.numComponents=function(){return this.numComponents_},d.prototype.numElements=function(){return this.numElements_},d.prototype.totalComponents=function(){return this.totalComponents_},d.prototype.buffer=function(){return this.buf},d.prototype.stride=function(){return 0},d.prototype.offset=function(){return 0},c.Model=Sk.misceval.buildClass(c,function(c,e){e.__init__=new Sk.builtin.func(function(c,e,f,g){c.buffers={};var h=function(a,e){var f=\"indices\"==a?gl.ELEMENT_ARRAY_BUFFER:gl.ARRAY_BUFFER;b=c.buffers[a],b?b.set(e):b=new d(e,f),c.buffers[a]=b};for(a in f)h(a,f[a]);var i={},j=0;for(var k in g)i[k]=j++;c.mode=gl.TRIANGLES,c.textures=g.v,c.textureUnits=i,c.shader=e}),e.drawPrep=new Sk.builtin.func(function(a,c){var d=a.shader,e=a.buffers,f=a.textures;for(var g in c=Sk.ffi.remapToJs(c),Sk.misceval.callsimArray(d.use,[d]),e){var h=e[g];if(\"indices\"==g)gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER,h.buffer());else{var i=d.attrib[g];i&&i(h)}}for(var j in f){var k=a.textureUnits[j];d.setUniform$impl(d,textuer,k),f[j].bindToUnit(k)}for(var l in c)d.setUniform$impl(d,l,c[l])}),e.draw=new Sk.builtin.func(function(a,c,d){var e=a.shader;for(uniform in c=Sk.ffi.remapToJs(c),c)e.setUniform$impl(e,uniform,c[uniform]);if(d)for(var f in d){var g=a.textureUnits[f];e.setUniform$impl(e,f,g),d[f].bindToUnit(g)}var h=a.buffers;gl.drawElements(a.mode,h.indices.totalComponents(),gl.UNSIGNED_SHORT,0)})},\"Model\",[]),c};","src/lib/webgl/primitives.js":"var $builtinmodule=function(){var a={},b=function(a,b,c){c=c||\"Float32Array\";var d=window[c];b.length?(this.buffer=new d(b),b=this.buffer.length/a,this.cursor=b):(this.buffer=new d(a*b),this.cursor=0),this.numComponents=a,this.numElements=b,this.type=c};return b.prototype.stride=function(){return 0},b.prototype.offset=function(){return 0},b.prototype.getElement=function(a){for(var b=a*this.numComponents,c=[],d=0;d<this.numComponents;++d)c.push(this.buffer[b+d]);return c},b.prototype.setElement=function(a,b){for(var c=a*this.numComponents,d=0;d<this.numComponents;++d)this.buffer[c+d]=b[d]},b.prototype.clone=function(){var a=new b(this.numComponents,this.numElements,this.type);return a.pushArray(this),a},b.prototype.push=function(a){this.setElement(this.cursor++,a)},b.prototype.pushArray=function(a){for(var b=0;b<a.numElements;++b)this.push(a.getElement(b))},b.prototype.pushArrayWithOffset=function(a,b){for(var c,d=0;d<a.numElements;++d){c=a.getElement(d);for(var e=0;e<b.length;++e)c[e]+=b[e];this.push(c)}},b.prototype.computeExtents=function(){for(var a=Math.max,b=Math.min,c,d=this.numElements,e=this.numComponents,f=this.getElement(0),g=this.getElement(0),h=1;h<d;++h){c=this.getElement(h);for(var i=0;i<e;++i)f[i]=b(f[i],c[i]),g[i]=a(g[i],c[i])}return{min:f,max:g}},a.createCube=new Sk.builtin.func(function(a){for(var c,d=[[3,7,5,1],[0,4,6,2],[6,7,3,2],[0,1,5,4],[5,7,6,4],[2,3,1,0]],e=a/2,g=[[-e,-e,-e],[+e,-e,-e],[-e,+e,-e],[+e,+e,-e],[-e,-e,+e],[+e,-e,+e],[-e,+e,+e],[+e,+e,+e]],h=[[1,0,0],[-1,0,0],[0,1,0],[0,-1,0],[0,0,1],[0,0,-1]],i=[[0,0],[1,0],[1,1],[0,1]],j=24,k=new b(3,j),l=new b(3,j),m=new b(2,j),n=new b(3,12,\"Uint16Array\"),o=0;6>o;++o){c=d[o];for(var p=0;4>p;++p){var q=g[c[p]],r=h[o],s=i[p];k.push(q),l.push(r),m.push(s)}var t=4*o;n.push([t+0,t+1,t+2]),n.push([t+0,t+2,t+3])}return{position:k,normal:l,texCoord:m,indices:n}}),a};","src/lib/whichdb.py":"raise NotImplementedError(\"whichdb is not yet implemented in Skulpt\")\n","src/lib/wsgiref/__init__.py":"raise NotImplementedError(\"wsgiref is not yet implemented in Skulpt\")\n","src/lib/xdrlib.py":"raise NotImplementedError(\"xdrlib is not yet implemented in Skulpt\")\n","src/lib/xml/__init__.py":"raise NotImplementedError(\"xml is not yet implemented in Skulpt\")\n","src/lib/xml/dom/__init__.py":"raise NotImplementedError(\"dom is not yet implemented in Skulpt\")\n","src/lib/xml/etree/__init__.py":"raise NotImplementedError(\"etree is not yet implemented in Skulpt\")\n","src/lib/xml/parsers/__init__.py":"raise NotImplementedError(\"parsers is not yet implemented in Skulpt\")\n","src/lib/xml/sax/__init__.py":"raise NotImplementedError(\"sax is not yet implemented in Skulpt\")\n","src/lib/xmllib.py":"raise NotImplementedError(\"xmllib is not yet implemented in Skulpt\")\n","src/lib/xmlrpclib.py":"raise NotImplementedError(\"xmlrpclib is not yet implemented in Skulpt\")\n","src/lib/zipfile.py":"raise NotImplementedError(\"zipfile is not yet implemented in Skulpt\")\n"}}